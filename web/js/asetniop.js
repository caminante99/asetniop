// Generated by CoffeeScript 1.4.0
(function() {
  var KeyNames, KeyToBit;

  KeyNames = {
    65: "a",
    81: "a",
    83: "s",
    87: "s",
    68: "e",
    69: "e",
    70: "t",
    82: "t",
    74: "n",
    85: "n",
    75: "i",
    73: "i",
    76: "o",
    79: "o",
    186: "p",
    80: "p",
    67: "shift",
    86: "shift",
    66: "number",
    78: "number",
    32: "space"
  };

  KeyToBit = {
    65: 1,
    81: 1,
    83: 2,
    87: 2,
    68: 4,
    69: 4,
    70: 8,
    82: 8,
    74: 16,
    85: 16,
    75: 32,
    73: 32,
    76: 64,
    79: 64,
    186: 128,
    80: 128,
    67: 256,
    86: 256,
    66: 1024,
    78: 1024,
    32: 512
  };

  $.get("../gestures.json", function(data) {
    var BitToKey, MaskToOutput, OutputToMask, getCaretPos, i, j, maskToKeys, reverseMap, setCaretPos, _i, _j, _ref, _ref1;
    MaskToOutput = JSON.parse(data);
    for (i = _i = 513; _i < 1024; i = ++_i) {
      if ((j = i - 512) in MaskToOutput && MaskToOutput[j].length < 3) {
        MaskToOutput[i] = MaskToOutput[j] + " ";
      }
    }
    for (i = _j = 1025, _ref = 1025 + 15; 1025 <= _ref ? _j <= _ref : _j >= _ref; i = 1025 <= _ref ? ++_j : --_j) {
      if ((_ref1 = MaskToOutput[i]) == null) {
        MaskToOutput[i] = "" + (i - 1024);
      }
    }
    reverseMap = function(map) {
      var k, ret, v;
      ret = Object.create(null);
      for (k in map) {
        v = map[k];
        if (!(v in ret)) {
          ret[v] = k;
        }
      }
      return ret;
    };
    BitToKey = reverseMap(KeyToBit);
    OutputToMask = reverseMap(MaskToOutput);
    maskToKeys = function(mask) {
      return ((function() {
        var _k, _len, _ref2, _results;
        _ref2 = [256, 1024, 1, 2, 4, 8, 16, 32, 64, 128, 512];
        _results = [];
        for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
          i = _ref2[_k];
          if ((mask & i) === i) {
            _results.push(KeyNames[BitToKey[i]]);
          }
        }
        return _results;
      })()).join("+");
    };
    getCaretPos = function(el) {
      var sel;
      el.focus();
      switch (true) {
        case 'selection' in document:
          sel = document.selection.createRange();
          sel.moveStart('character', el.value.length);
          return sel.text.length;
        case 'selectionStart' in el:
          return el.selectionStart;
        default:
          return el.value.length;
      }
    };
    setCaretPos = function(el, pos) {
      var range;
      switch (true) {
        case 'setSelectionRange' in this:
          el.focus();
          return el.setSelectionRange(pos, pos);
        case 'createTextRange' in this:
          range = el.createTextRange();
          range.collapse(true);
          range.moveEnd('character', pos);
          range.moveStart('character', pos);
          return range.select();
      }
    };
    $.asetniop = {
      init: function(selector) {
        return $(selector).log('binding ASETNIOP to:').each(function() {
          var gesture, hasNewKeys, lock, sticky, t;
          gesture = 0;
          sticky = 0;
          lock = 0;
          hasNewKeys = false;
          t = $(this);
          t.bind('keydown', function(evt) {
            var key;
            key = KeyToBit[evt.keyCode];
            if (evt.keyCode === 17) {
              lock = lock ^ 256;
            }
            if ((gesture & key) === key) {
              t.trigger('keyup', evt);
            }
            hasNewKeys = true;
            gesture = gesture | sticky | lock | key;
            return false;
          });
          return t.bind('keyup', function(evt) {
            var c, code, modified, value;
            value = MaskToOutput[gesture];
            modified = false;
            if (hasNewKeys) {
              if (/^<\w+>$/.test(value)) {
                switch (value) {
                  case "<Backspace>":
                    c = getCaretPos(this);
                    this.value = $.stringSplice(this.value, c - 1, c, '');
                    setCaretPos(this, c - 1);
                    modified = true;
                    break;
                  case "<Shift>":
                    sticky = sticky ^ 256;
                    break;
                  case "<Number>":
                    sticky = sticky ^ 1024;
                }
              } else if (value != null) {
                c = getCaretPos(this);
                this.value = $.stringSplice(this.value, c, c, value);
                setCaretPos(this, c + value.length);
                modified = true;
              }
            }
            code = KeyToBit[evt.keyCode];
            gesture = gesture ^ (gesture & code);
            if (modified) {
              gesture = gesture ^ (gesture & sticky);
              sticky = 0;
              hasNewKeys = false;
              t.trigger('change');
            }
            return false;
          });
        });
      },
      hint: function(output) {
        var a, b;
        switch (false) {
          case !(output in OutputToMask):
            return maskToKeys(OutputToMask[output]);
          case !(output.length > 1):
            j = output.length - 1;
            while (j >= 0 && output.slice(j, output.length) in OutputToMask) {
              --j;
            }
            ++j;
            a = output.slice(0, j);
            b = output.slice(j, output.length);
            return $.asetniop.hint(a) + ", " + $.asetniop.hint(b);
          default:
            return "";
        }
      }
    };
    return $(document).ready(function() {
      return $.asetniop.init(".asetniop");
    });
  });

}).call(this);
