// Generated by CoffeeScript 1.4.0
(function() {
  var BitToKey, KeyNames, KeyToBit, MaskToOutput, i, j, reverseMap, _i, _j, _ref;

  KeyNames = {
    65: "a",
    81: "a",
    83: "s",
    87: "s",
    68: "e",
    69: "e",
    70: "t",
    82: "t",
    74: "n",
    85: "n",
    75: "i",
    73: "i",
    76: "o",
    79: "o",
    186: "p",
    80: "p",
    67: "shift",
    86: "shift",
    66: "number",
    78: "number",
    32: "space"
  };

  KeyToBit = {
    65: 1,
    81: 1,
    83: 2,
    87: 2,
    68: 4,
    69: 4,
    70: 8,
    82: 8,
    74: 16,
    85: 16,
    75: 32,
    73: 32,
    76: 64,
    79: 64,
    186: 128,
    80: 128,
    67: 256,
    86: 256,
    66: 1024,
    78: 1024,
    32: 512
  };

  MaskToOutput = {
    0: "",
    1: "a",
    2: "s",
    3: "w",
    4: "e",
    5: "x",
    6: "d",
    7: "we",
    8: "t",
    9: "f",
    10: "c",
    11: "ac",
    12: "r",
    13: "ar",
    14: "est",
    15: "wr",
    16: "n",
    17: "q",
    18: "j",
    19: "wn",
    20: "y",
    21: "ay",
    22: "nd",
    23: "and",
    24: "b",
    25: "ab",
    27: "can",
    28: "be",
    32: "i",
    33: "!",
    34: "z",
    35: "wi",
    36: ",",
    37: "xi",
    38: "di",
    39: "said",
    40: "v",
    41: "fi",
    42: "ci",
    44: "ve",
    45: "five",
    46: "tried",
    48: "h",
    49: "ha",
    50: "sh",
    51: "wh",
    52: "he",
    54: "she",
    56: "th",
    57: "that",
    58: "ch",
    59: "with",
    60: "the",
    64: "o",
    65: "(",
    66: ".",
    67: "wo",
    68: "-",
    69: "xo",
    70: "do",
    72: "g",
    73: "fo",
    74: "co",
    75: "two",
    76: "or",
    77: "for",
    78: "dg",
    80: "u",
    81: "qu",
    82: "su",
    83: "now",
    84: "eu",
    86: "du",
    88: "but",
    89: "fu",
    90: "cu",
    92: "ru",
    96: "l",
    97: "al",
    98: "sl",
    100: "el",
    102: "dl",
    104: "gi",
    105: "fl",
    106: "cl",
    107: "class",
    108: "rl",
    116: "ly",
    120: "tion",
    128: "p",
    129: "?",
    130: ")",
    132: "'",
    133: "xp",
    134: "s",
    136: "<Backspace>",
    139: "past",
    140: "rp",
    141: "part",
    142: "step",
    144: "m",
    145: "am",
    146: "sm",
    148: "em",
    149: "may",
    150: "seem",
    152: "tm",
    156: "rm",
    160: "k",
    161: "ak",
    162: "sk",
    164: "ke",
    170: "ck",
    172: "rk",
    176: "mi",
    192: "\t",
    196: "->",
    208: "mo",
    216: "put",
    224: "lp",
    240: "lm",
    256: "<Shift>",
    257: "A",
    258: "S",
    259: "W",
    260: "E",
    261: "X",
    262: "D",
    264: "T",
    265: "F",
    266: "C",
    268: "R",
    272: "N",
    273: "Q",
    274: "J",
    276: "Y",
    280: "B",
    288: "I",
    289: "<Ctrl>",
    290: "Z",
    292: "<",
    296: "V",
    304: "H",
    316: "The",
    320: "O",
    321: "<Alt>",
    322: ">",
    324: "_",
    328: "G",
    336: "U",
    346: "constructor",
    352: "L",
    384: "P",
    385: "/",
    386: "<Esc>",
    388: '"',
    400: "M",
    416: "K",
    448: ":",
    512: " ",
    768: "\n",
    1024: "<Number>",
    1280: "0",
    1025: "1",
    1026: "2",
    1027: "3",
    1028: "4",
    1029: "5",
    1030: "6",
    1031: "7",
    1032: "8",
    1033: "9",
    1034: "10"
  };

  for (i = _i = 513; _i < 1024; i = ++_i) {
    if ((j = i - 512) in MaskToOutput && MaskToOutput[j].length < 3) {
      MaskToOutput[i] = MaskToOutput[j] + " ";
    }
  }

  for (i = _j = 1035; _j <= 1291; i = ++_j) {
    if ((_ref = MaskToOutput[i]) == null) {
      MaskToOutput[i] = "" + (i - 1024);
    }
  }

  reverseMap = function(map) {
    var k, ret, v;
    ret = Object.create(null);
    for (k in map) {
      v = map[k];
      if (!(v in ret)) {
        ret[v] = k;
      }
    }
    return ret;
  };

  BitToKey = reverseMap(KeyToBit);

  window.OutputToMask = reverseMap(MaskToOutput);

  window.maskToKeys = function(mask) {
    return ((function() {
      var _k, _len, _ref1, _results;
      _ref1 = [256, 1024, 1, 2, 4, 8, 16, 32, 64, 128, 512];
      _results = [];
      for (_k = 0, _len = _ref1.length; _k < _len; _k++) {
        i = _ref1[_k];
        if ((mask & i) === i) {
          _results.push(KeyNames[BitToKey[i]]);
        }
      }
      return _results;
    })()).join("+");
  };

  window.hint = function(output) {
    var a, b;
    switch (false) {
      case !(output in OutputToMask):
        return maskToKeys(OutputToMask[output]);
      case !(output.length > 1):
        j = output.length - 1;
        while (output.slice(j, output.length) in OutputToMask) {
          --j;
        }
        ++j;
        a = output.slice(0, j);
        b = output.slice(j, output.length);
        return hint(a) + ", " + hint(b);
      default:
        return "";
    }
  };

  $(document).ready(function() {
    return $(".asetniop").each(function() {
      var gesture, hasNewKeys, sticky, t,
        _this = this;
      gesture = 0;
      sticky = 0;
      hasNewKeys = false;
      $.defineProperty(this, 'caretPos', {
        get: function() {
          var sel;
          _this.focus();
          switch (true) {
            case 'selection' in document:
              sel = document.selection.createRange();
              sel.moveStart('character', _this.value.length);
              return sel.text.length;
            case 'selectionStart' in _this:
              return _this.selectionStart;
            default:
              return _this.value.length;
          }
        },
        set: function(pos) {
          var range;
          switch (true) {
            case 'setSelectionRange' in _this:
              _this.focus();
              return _this.setSelectionRange(pos, pos);
            case 'createTextRange' in _this:
              range = _this.createTextRange();
              range.collapse(true);
              range.moveEnd('character', pos);
              range.moveStart('character', pos);
              return range.select();
          }
        }
      });
      t = $(this);
      t.bind('keydown', function(evt) {
        var key;
        key = KeyToBit[evt.keyCode];
        if ((gesture & key) === key) {
          t.trigger('keyup', evt);
        }
        hasNewKeys = true;
        gesture = gesture | sticky | key;
        console.log(evt.type, "" + evt.keyCode + " -> " + KeyToBit[evt.keyCode] + " + " + sticky + " == " + gesture);
        return false;
      });
      return t.bind('keyup', function(evt) {
        var c, code, modified, value;
        value = MaskToOutput[gesture];
        console.log(evt.type, "" + evt.keyCode + " -> " + KeyToBit[evt.keyCode] + " + " + sticky + " == " + gesture + " (" + value + ")");
        modified = false;
        if (hasNewKeys) {
          if (/^<\w+>$/.test(value)) {
            switch (value) {
              case "<Backspace>":
                c = this.caretPos;
                this.value = $.stringSplice(this.value, c - 1, c, '');
                this.caretPos = c - 1;
                modified = true;
                break;
              case "<Shift>":
                if ((sticky & 256) === 256) {
                  sticky = sticky ^ (sticky & 256);
                } else {
                  sticky = sticky | 256;
                }
                break;
              case "<Number>":
                if ((sticky & 1024) === 1024) {
                  sticky = sticky ^ (sticky & 1024);
                } else {
                  sticky = sticky | 1024;
                }
            }
          } else if (value != null) {
            c = this.caretPos;
            this.value = $.stringSplice(this.value, c, c, value);
            this.caretPos = c + value.length;
            modified = true;
          }
        }
        code = KeyToBit[evt.keyCode];
        gesture = gesture ^ (gesture & code);
        if (modified) {
          gesture = gesture ^ (gesture & sticky);
          sticky = 0;
          hasNewKeys = false;
        }
        return false;
      });
    });
  });

}).call(this);
