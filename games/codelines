


KeyNames =
	A_KEY: "a"
	Q_KEY: "a"
	S_KEY: "s"
	W_KEY: "s"
	D_KEY: "e"
	E_KEY: "e"
	F_KEY: "t"
	R_KEY: "t"
	J_KEY: "n"
	U_KEY: "n"
	K_KEY: "i"
	I_KEY: "i"
	L_KEY: "o"
	O_KEY: "o"
	SEMICOLON_KEY: "p"
	P_KEY: "p"
	C_KEY: "shift"
	V_KEY: "shift"
	N_KEY: "number"
	M_KEY: "number"
	SPACE_KEY: "space"

KeyToBit =
	A_KEY: A_BIT
	Q_KEY: A_BIT
	S_KEY: S_BIT
	W_KEY: S_BIT
	D_KEY: E_BIT
	E_KEY: E_BIT
	F_KEY: T_BIT
	R_KEY: T_BIT
	J_KEY: N_BIT
	U_KEY: N_BIT
	K_KEY: I_BIT
	I_KEY: I_BIT
	L_KEY: O_BIT
	O_KEY: O_BIT
	SEMICOLON_KEY: P_BIT
	P_KEY: P_BIT
	C_KEY: SHIFT_BIT
	V_KEY: SHIFT_BIT
	N_KEY: NUMSH_BIT
	M_KEY: NUMSH_BIT
	SPACE_KEY: SPACE_BIT

MaskToOutput =
	346: "constructor"

for i in [513...1024] when (j = i - 512) of MaskToOutput and MaskToOutput[j].length < 3
	MaskToOutput[i] = MaskToOutput[j] + " "

for i in [1025..1291]

reverseMap = (map) ->
	ret = Object.create(null)
	for k,v of map
		unless v of ret
			ret[v] = k
	ret
BitToKey = reverseMap KeyToBit
OutputToMask = reverseMap MaskToOutput

maskToKeys = (mask) ->
	(KeyNames[BitToKey[i]] for i in [256, 1024, 1, 2, 4, 8, 16, 32, 64, 128, 512] when MASK_HAS(mask, i)).join "+"

$.asetniop =
	init: (selector) ->
		$(selector).log('binding ASETNIOP to:').each ->

			$.defineProperty @, 'caretPos',
				get: =>
					@focus()
					switch true
						when 'selection' of document
							sel = document.selection.createRange()
							sel.moveStart 'character', @value.length
							sel.text.length
						when 'selectionStart' of @
							@selectionStart
						else
							@value.length
				set: (pos) =>
					switch true
						when 'setSelectionRange' of @
							@focus()
							@setSelectionRange(pos,pos)
						when 'createTextRange' of @
							range = @createTextRange()
							range.collapse(true)
							range.moveEnd('character', pos)
							range.moveStart('character', pos)
							range.select()

			t = $(@)
			t.bind 'keydown', (evt) ->
				key = KeyToBit[evt.keyCode]
				if MASK_HAS(gesture, key)
				hasNewKeys = true
				false
			t.bind 'keyup', (evt) ->
				value = MaskToOutput[gesture]
				modified = false
				if hasNewKeys
					if /^<\w+>$/.test value
						switch value
							when "<Backspace>"
								c = @caretPos
								@value = $.stringSplice @value, c-1, c, ''
								@caretPos = c - 1
								modified = true
							when "<Shift>"
								MASK_TOGGLE(sticky, SHIFT_BIT)
							when "<Number>"
								MASK_TOGGLE(sticky, NUMSH_BIT)
					else if value?
						c = @caretPos
						@value = $.stringSplice @value, c, c, value
						@caretPos = c + value.length
						modified = true
				code = KeyToBit[evt.keyCode]
				MASK_OFF(gesture, code)
				if modified
					MASK_OFF(gesture, sticky)
					sticky = 0
					hasNewKeys = false
					t.trigger 'change'
				false
		
		switch
			when output of OutputToMask
				maskToKeys OutputToMask[output]
			when output.length > 1
				j = output.length - 1
				--j while output[j...output.length] of OutputToMask and j >= 0
				++j
				$.asetniop.hint(a) + ", " + $.asetniop.hint(b)
			else ""

$(document).ready -> $.asetniop.init(".asetniop")

class O extends $.EventEmitter
	tick: ->
	draw: ->

class FallingWord extends O
	constructor: (@word, range) ->
		super @
		@x = $.random.integer 0, range
		@y = 0
		@speed = .01
	tick: (dt) ->
		@y += @speed * dt
	draw: (ctx) ->
		ctx.fillText @x, @y, @word

class TimedScript extends O
	constructor: (@script) ->
		@elapsed = 0
		@cur = 0
	tick: (dt) ->
		@elapsed += dt
		while @cur < @script.length and @script[@cur][0] < @elapsed
			item = @script[@cur]
			switch item[1]
				when 'goto' then @elapsed = item[2] | 0
				else do item[1]

class Game extends Clock
	constructor: (selector) ->
		@canvas = $(selector).first()
		@ctx = @canvas.getContext('2d')
		@w = @canvas.getAttribute('width')
		@h = @canvas.getAttribute('height')
		@objects = []
	add: (obj) ->
		@objects.push obj
		obj.on 'die', =>
			if (i = @objects.indexOf obj) > -1
				@objects.splice i, 1

wordlist = ["one", "two", "three"]
game = new Game "canvas"
game.add new TimedScript [
	[ 0, -> game.add new FallingWord $.random.element(wordlist), game.w ],
	[ 1000, 'goto', 0 ]
]

class Clock extends $.EventEmitter
	requestInterval = window.requestAnimationFrame or
		window.mozRequestAnimationFrame or
		window.webkitRequestAnimationFrame or
		window.msRequestAnimationFrame or
		(f) -> window.setTimeout f, 1000/60

	cancelInterval = window.cancelAnimationFrame or
		window.mozCancelAnimationFrame or
		window.webkitCancelAnimationFrame or
		window.msCancelAnimationFrame or
		window.clearTimeout

	constructor: ->
		@interval = null
	start: ->
		return if @interval
		t = $.now
		do ticker = =>
			t += (dt = $.now - t)
			@emit 'tick', dt
			@interval = requestInterval ticker
		@
	stop: ->
		return unless @interval
		cancelInterval @interval
		@interval = null
		@
	toggle: ->
		if @interval then @stop() else @start()


class Game extends Clock
	constructor: (selector) ->
		@canvas = $(selector).first()
		@ctx = @canvas.getContext('2d')
		@w = @canvas.getAttribute('width')
		@h = @canvas.getAttribute('height')
		@objects = $()
		@dying = $()
		@on 'tick', (dt) =>
			obj.tick() for obj in @objects
			@remove(obj) for obj in @dying
			obj.draw() for obj in @objects
	add: (obj) ->
		obj.on? 'die', => @dying.push obj
		@objects.push obj
	remove: (obj) ->
		if (i = @objects.indexOf obj) > -1
			@objects.splice i, 1

	


window.game = new Game "canvas"
	"one",
	"two",
	"three"
]
window.words = {}
class RainingWord
	constructor: (@word, @w, @h) ->
		window.words[@word] = @
		@x = $.math.random 0, @w
		@y = 0
		@speed = .01
	tick: (dt) ->
		@y += @speed * dt
		if @y > @h
			@emit 'die'
	draw: (ctx) ->
		ctx.fillText @x, @y, @word

$.interval 1000, ->
	window.game.add new RainingWord(
		$.random.element(window.wordlist),
		window.game.w,
		window.game.h
	)




Object.keys or= (o) -> (k for k of o)

Object.values or= (o) -> (o[k] for k of o)

extend = (a, b) ->
	if b then a[k] = v for k,v of b when v?
	a






	constructor: (args...) ->
		return Bling.hook "bling-init", args

Bling.prototype = []
Bling.prototype.constructor = Bling
Bling.global = if window? then window else global





Bling.plugin = (opts, constructor) ->
	if not constructor
		constructor = opts
		opts = {}

	if "depends" of opts
		return @depends opts.depends, =>
			@plugin { provides: opts.provides }, constructor
	try
		if (plugin = constructor?.call @,@)
			extend @, plugin?.$
			['$','name'].forEach (k) -> delete plugin[k]
			extend @::, plugin
			for key of plugin then do (key) =>
				@[key] or= (a...) => (@::[key].apply Bling(a[0]), a[1...])
			if opts.provides? then @provide opts.provides
	catch error
	@


do ->
	dep =
		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)

	Bling.depends = (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else
			dep.q.push (need) ->
				(needs.splice i, 1) if (i = needs.indexOf need) > -1
				return (needs.length is 0 and f)
		f

	Bling.provide = (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data


$ = Bling
Object.keys or= (o) -> (k for k of o)
Object.values or= (o) -> (o[k] for k of o)
extend = (a, b) ->
	if b then a[k] = v for k,v of b when v?
	a
	constructor: (args...) ->
		return Bling.hook "bling-init", args
Bling.prototype = []
Bling.prototype.constructor = Bling
Bling.global = if window? then window else global
Bling.plugin = (opts, constructor) ->
	if not constructor
		constructor = opts
		opts = {}
	if "depends" of opts
		return @depends opts.depends, =>
			@plugin { provides: opts.provides }, constructor
	try
		if (plugin = constructor?.call @,@)
			extend @, plugin?.$
			['$','name'].forEach (k) -> delete plugin[k]
			extend @::, plugin
			for key of plugin then do (key) =>
				@[key] or= (a...) => (@::[key].apply Bling(a[0]), a[1...])
			if opts.provides? then @provide opts.provides
	catch error
	@
do ->
	dep =
		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)
	Bling.depends = (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else
			dep.q.push (need) ->
				(needs.splice i, 1) if (i = needs.indexOf need) > -1
				return (needs.length is 0 and f)
		f
	Bling.provide = (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data
$ = Bling
$.plugin
	provides: "cartesian"
, ->
	$:
		cartesian: (sets...) ->
			n = sets.length
			ret = []
			helper = (cur, i) ->
				(return ret.push cur) if ++i >= n
				for x in sets[i]
					helper (cur.concat x), i
				null
			helper [], -1
			return $(ret)
$.plugin ->
	String::trimLeft or= -> @replace(/^\s+/, "")
	String::split or= (sep) ->
		a = []; i = 0
		while (j = @indexOf sep,i) > -1
			a.push @substring(i,j)
			i = j + 1
		a
	String::lastIndexOf or= (s, c, i = -1) ->
		j = -1
		j = i while (i = s.indexOf c, i+1) > -1
		j
	Array::join or= (sep = '') ->
		n = @length
		return "" if n is 0
		s = @[n-1]
		while --n > 0
			s = @[n-1] + sep + s
		s
	if Event?
		Event::preventAll = () ->
			@preventDefault()
			@stopPropagation()
			@cancelBubble = true
	if Element?
		Element::matchesSelector = Element::webkitMatchesSelector or
			Element::mozMatchesSelector or
			Element::matchesSelector
		if Element::cloneNode.length is 0
			oldClone = Element::cloneNode
			Element::cloneNode = (deep = false) ->
				n = oldClone.call(@)
				if deep
					for i in @childNodes
						n.appendChild i.cloneNode true
				return n
	return { }
$.plugin
	provides: 'config'
	depends: 'type'
, ->
	get = (name, def) -> process.env[name] ? def
	$: config: $.extend(get, get: get)
$.plugin
	provides: "core"
	depends: "string"
, ->
	$.defineProperty $, "now",
		get: -> +new Date
	index = (i, o) ->
		i += o.length while i < 0
		Math.min i, o.length
	baseTime = $.now
	return {
		$:
			log: $.extend((a...) ->
				if prefix.length > $.log.prefixSize + 2
				if a.length and $.is "string", a[0]
				else
					a.unshift prefix
				console.log a...
				return a[a.length-1] if a.length
			, prefixSize: 5)
			coalesce: (a...) -> $(a).coalesce()
			keysOf: (o) -> $(k for k of o)
			valuesOf: (o) -> $.keysOf(o).map (k)->
				return try o[k] catch err then err
		eq: (i) -> $([@[index i, @]])
		each: (f) -> (f.call(t,t) for t in @); @
		map: (f) ->
			b = $()
			for t in @
				b.push f.call t,t
			b
		filterMap: (f) ->
			b = $()
			for t in @
				v = f.call t,t
				if v?
					b.push v
			b
		replaceWith: (array) ->
			for i in [0...array.length] by 1
				@[i] = array[i]
		reduce: (f, a) ->
			i = 0; n = @length
			a = @[i++] if not a?
			(a = f.call @[x], a, @[x]) for x in [i...n] by 1
			return a
		union: (other, strict = true) ->
			ret = $()
			ret.push(x) for x in @ when not ret.contains(x, strict)
			ret.push(x) for x in other when not ret.contains(x, strict)
			ret
		distinct: (strict = true) -> @union @, strict
		contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
		count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
		coalesce: ->
			for i in @
				if $.is('array',i) or $.is('bling',i) then i = $(i).coalesce()
				if i? then return i
			null
		swap: (i,j) ->
			i = index i, @
			j = index j, @
			if i isnt j
				[@[i],@[j]] = [@[j],@[i]]
			@
		shuffle: ->
			i = @length-1
			while i >= 0
				@swap --i, Math.floor(Math.random() * i)
			@
		select: (->
			getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
			select = (p) ->
				if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
				else @map(getter p)
		)()
		or: (x) -> @[i] or= x for i in [0...@length]; @
		zap: (p, v) ->
			i = p.lastIndexOf "."
			if i > 0
				head = p.substr 0,i
				tail = p.substr i+1
				@select(head).zap tail, v
				return @
			switch $.type(v)
				when "array","bling" then @each -> @[p] = v[++i % v.length]
				when "function" then @zap p, @select(p).map(v)
				else @each -> @[p] = v
			@
		clean: (prop) -> @each -> delete @[prop]
		take: (n = 1) ->
			end = Math.min n, @length
			$( @[i] for i in [0...end] by 1 )
		skip: (n = 0) ->
			start = Math.max 0, n|0
			$( @[i] for i in [start...@length] by 1 )
		first: (n = 1) -> if n is 1 then @[0] else @take(n)
		last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)
		slice: (start=0, end=@length) ->
			start = index start, @
			end = index end, @
			$( @[i] for i in [start...end] )
		extend: (b) -> @.push(i) for i in b; @
		push: (b) -> Array::push.call(@, b); @
		filter: (f) ->
			g = switch $.type f
				when "string" then (x) -> x.matchesSelector(f)
				when "regexp" then (x) -> f.test(x)
				when "function" then f
			$( it for it in @ when g.call(it,it) )
		matches: (expr) ->
			switch $.type expr
				when "string" then @select('matchesSelector').call(expr)
				when "regexp" then @map (x) -> expr.test x
		querySelectorAll: (expr) ->
			@filter("*")
			.reduce (a, i) ->
				a.extend i.querySelectorAll expr
			, $()
		weave: (b) ->
			c = $()
			for i in [@length-1..0] by -1
				c[(i*2)+1] = @[i]
			for i in [0...b.length] by 1
				c[i*2] = b[i]
			c
		fold: (f) ->
			n = @length
			b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
			if (n%2) is 1
				b.push( f.call @, @[n-1], undefined )
			b
		flatten: ->
			b = $()
			(b.push(j) for j in i) for i in @
			b
		call: -> @apply(null, arguments)
		apply: (context, args) ->
			@filterMap ->
				if $.is 'function', @ then @apply(context, args)
				else null
		log: (label) ->
			if label
				$.log(label, @toString(), @length + " items")
			else
				$.log(@toString(), @length + " items")
			@
		toArray: ->
			@__proto__ = Array::
	}
$.plugin
	provides: 'date'
	depends: 'type'
, ->
	[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]
	units = {
		ms, s, m, h, d,
		sec: s
		second: s
		seconds: s
		min: m
		minute: m
		minutes: m
		hr: h
		hour: h
		hours: h
		day: d
		days: d
	}
	formats =
		yyyy: Date::getUTCFullYear
		mm: -> @getUTCMonth() + 1
		dd: Date::getUTCDate
		HH: Date::getUTCHours
		MM: Date::getUTCMinutes
		SS: Date::getUTCSeconds
		MS: Date::getUTCMilliseconds
	format_keys = Object.keys(formats).sort().reverse()
	parsers =
		yyyy: Date::setUTCFullYear
		mm: (x) -> @setUTCMonth(x - 1)
		dd: Date::setUTCDate
		HH: Date::setUTCHours
		MM: Date::setUTCMinutes
		SS: Date::setUTCSeconds
		MS: Date::setUTCMilliseconds
	parser_keys = Object.keys(parsers).sort().reverse()
	floor = Math.floor
	$.type.register "date",
		match: (o) -> $.isType Date, o
		array: (o) -> [o]
		string: (o, fmt, unit) -> $.date.format o, fmt, unit
		number: (o, unit) -> $.date.stamp o, unit
	$.type.extend 'string', date: (o, fmt = $.date.defaultFormat) -> new Date $.date.parse o, fmt, "ms"
	$.type.extend 'number', date: (o, unit) -> $.date.unstamp o, unit
	adder = (key) ->
		(stamp, delta, stamp_unit = $.date.defaultUnit) ->
			date = $.date.unstamp(stamp, stamp_unit)
			parsers[key].call date, (formats[key].call date) + delta
			$.date.stamp date, stamp_unit
	$:
		date:
			defaultUnit: "s"
			defaultFormat: "yyyy-mm-dd HH:MM:SS"
			stamp: (date = new Date, unit = $.date.defaultUnit) ->
				floor (date / units[unit])
			unstamp: (stamp, unit = $.date.defaultUnit) ->
				new Date floor(stamp * units[unit])
			convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
				(floor stamp * units[from] / units[to])
			midnight: (stamp, unit = $.date.defaultUnit) ->
				$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
			format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
				date = $.date.unstamp stamp, unit
				for k in format_keys
					fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
				fmt
			parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
				date = new Date(0)
				for i in [0...fmt.length] by 1
					for k in parser_keys
						if fmt.indexOf(k, i) is i
							try
								parsers[k].call date,
									parseInt dateString[i...i+k.length], 10
							catch err
				$.date.stamp date, to
			addMilliseconds: adder("MS")
			addSeconds: adder("SS")
			addMinutes: adder("MM")
			addHours: adder("HH")
			addDays: adder("dd")
			addMonths: adder("mm")
			addYears: adder("yyyy")
			range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
				add = adder(interval_unit)
				ret = [from]
				while (cur = ret[ret.length-1]) < to
					ret.push add(cur, interval, stamp_unit)
				ret
	midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
	unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
	stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
	dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
	dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)
$.plugin
	provides: "delay"
	depends: "function"
, ->
	$:
		delay: (->
			timeoutQueue = $.extend [], (->
				next = (a) -> -> a.shift()() if a.length
				add: (f, n) ->
					f.order = n + $.now
					for i in [0..@length] by 1
						if i is @length or @[i].order > f.order
							@splice i,0,f
							break
					setTimeout next(@), n
					@
				cancel: (f) ->
					for i in [0...@length] by 1
						if @[i] == f
							@splice i, 1
							break
					@
			)()
			(n, f) ->
				if $.is("function",f) then timeoutQueue.add(f, n)
				cancel: -> timeoutQueue.cancel(f)
		)()
	delay: (n, f, c=@) ->
		$.delay n, $.bound(c, f)
		@
	interval: (n, f, c=@) ->
		g = $.bound c, f
		h = -> g(); $.delay n, h
		$.delay n, h
		@
if $.global.document?
	$.plugin
		depends: "function,type"
		provides: "dom"
	, ->
		$.type.register "nodelist",
			match:  (o) -> o? and $.isType "NodeList", o
			hash:   (o) -> $($.hash(i) for i in x).sum()
			array:  $.identity
			string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
			node:   (o) -> $(o).toFragment()
		$.type.register "node",
			match:  (o) -> o?.nodeType > 0
			hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "fragment",
			match:  (o) -> o?.nodeType is 11
			hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "html",
			match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
			node:   (h) ->
				(node = document.createElement('div')).innerHTML = h
				if n = (childNodes = node.childNodes).length is 1
					return node.removeChild(childNodes[0])
				df = document.createDocumentFragment()
				df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
				df
			array:  (o) -> $.type.lookup(h = Bling.HTML.parse o).array h
			repr:   (o) -> '"' + o + '"'
		$.type.extend
			unknown:  { node: -> null }
			bling:    { node: (o) -> o.toFragment() }
			node:     { html: (n) ->
				d = document.createElement "div"
				d.appendChild (n = n.cloneNode true)
				ret = d.innerHTML
				ret
			}
			string:
				node:  (o) -> $(o).toFragment()
				array: (o) -> document.querySelectorAll? o
			function: { node: (o) -> $(o.toString()).toFragment() }
		toFrag = (a) ->
			if not a.parentNode?
				df = document.createDocumentFragment()
				df.appendChild a
			a
		before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
		after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
		toNode = (x) -> $.type.lookup(x).node x
		escaper = false
		parser = false
		computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue k
		getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select p
		selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )
		return {
			$:
				HTML:
					parse: (h) -> $.type.lookup(h).node h
					stringify: (n) -> $.type.lookup(n).html n
					escape: (h) ->
						escaper or= $("<div>&nbsp;</div>").child 0
						ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
						escaper.zap('data', '')
						ret
			html: (h) ->
				return switch $.type h
					when "undefined","null" then @select 'innerHTML'
					when "string","html" then @zap 'innerHTML', h
					when "bling" then @html h.toFragment()
					when "node"
							@replaceChild @childNodes[0], h
							while @childNodes.length > 1
								@removeChild @childNodes[1]
				@each -> @appendChild x.cloneNode true
				clones = @map( -> @cloneNode true)
				i = 0
				$(x).each -> @appendChild clones[i++]
				clones
				if x?
					x = toNode x
					@take(1).each ->
						before @childNodes[0], x
					@skip(1).each ->
						before @childNodes[0], x.cloneNode true
				@
				if x?
					$(x).prepend(@)
				@
				if x?
					x = toNode x
					@take(1).each -> before @, x
					@skip(1).each -> before @, x.cloneNode true
				@
				if x?
					x = toNode x
					@take(1).each -> after @, x
					@skip(1).each -> after @, x.cloneNode true
				@
				parent = toNode parent
				if $.is "fragment", parent
					throw new Error("cannot call .wrap() with a fragment as the parent")
				@each (child) ->
					if ($.is "fragment", child) or not child.parentNode
						return parent.appendChild child
					grandpa = child.parentNode
					marker = document.createElement "dummy"
					parent.appendChild grandpa.replaceChild marker, child
					grandpa.replaceChild parent, marker
				@each ->
					if @parentNode and @parentNode.parentNode
						@parentNode.parentNode.replaceChild(@, @parentNode)
					else if @parentNode
						@parentNode.removeChild(@)
				n = toNode n
				clones = @map(-> n.cloneNode true)
				for i in [0...clones.length] by 1
					@[i].parentNode?.replaceChild clones[i], @[i]
				clones
				return switch v
					when undefined then @select("getAttribute").call(a, v)
					when null then @select("removeAttribute").call(a, v)
					else
						@select("setAttribute").call(a, v)
						@
				notempty = (y) -> y isnt ""
				@removeClass(x).each ->
					c = @className.split(" ").filter notempty
					c.push x
					@className = c.join " "
				notx = (y) -> y != x
				@each ->
					c = @className.split(" ").filter(notx).join(" ")
					if c.length is 0
						@removeAttribute('class')
				notx = (y) -> y isnt x
				@each ->
					cls = @className.split(" ")
					filter = $.not $.isEmpty
					if( cls.indexOf(x) > -1 )
						filter = $.and notx, filter
					else
						cls.push x
					c = cls.filter(filter).join(" ")
					@className = c
					if c.length is 0
						@removeAttribute('class')
				@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1
				return @zap('textContent', t) if t?
				return @select('textContent')
				return @zap('value', v) if v?
				return @select('value')
			css: (k,v) ->
				if v? or $.is "object", k
					setter = @select 'style.setProperty'
					if $.is "object", k then setter.call i, k[i], "" for i of k
					else if $.is "string", v then setter.call k, v, ""
					else if $.is "array", v
						setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
					return @
				else
					cv = @map computeCSSProperty k
					ov = @select('style').select k
					ov.weave(cv).fold (x,y) -> x or y
			defaultCss: (k, v) ->
				sel = @selector
				style = ""
				if $.is "string", k
					if $.is "string", v
					else throw Error("defaultCss requires a value with a string key")
				else if $.is "object", k
					"} "
				$("<style></style>").text(style).appendTo("head")
				@
			rect: -> @select('getBoundingClientRect').call()
			width: getOrSetRect("width")
			height: getOrSetRect("height")
			top: getOrSetRect("top")
			left: getOrSetRect("left")
			bottom: getOrSetRect("bottom")
			right: getOrSetRect("right")
			position: (left, top) ->
				switch true
					when not left? then @rect()
					when not top? then @css("left", $.px(left))
					else @css({top: $.px(top), left: $.px(left)})
			scrollToCenter: ->
				document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
				@
			child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]
			parents: selectChain('parentNode')
			prev: selectChain('previousSibling')
			next: selectChain('nextSibling')
			remove: -> @each -> @parentNode?.removeChild(@)
			find: (css) ->
				@filter("*")
					.map( -> $(css, @) )
					.flatten()
			clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @
			toFragment: ->
				if @length > 1
					df = document.createDocumentFragment()
					(@map toNode).map $.bound df, df.appendChild
					return df
				return toNode @[0]
		}
$.plugin
	provides: "EventEmitter"
	depends: "type,hook"
, ->
	$: EventEmitter: $.hook("bling-init").append (obj = Object.create(null)) ->
		listeners = {}
		list = (e) -> (listeners[e] or= [])
		$.inherit {
			emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
			addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
			on:                 (e, h) -> @addListener e, h
			removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
			removeAllListeners: (e) -> listeners[e] = []
			listeners:          (e) -> list(e).slice 0
		}, obj
$.plugin
	depends: "dom,function,core"
	provides: "event"
, ->
	EVENTSEP_RE = /,* +/
	events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
		'load','unload','reset','submit','keyup','keydown','change',
		'abort','cut','copy','paste','selection','drag','drop','orientationchange',
		'touchstart','touchmove','touchend','touchcancel',
		'gesturestart','gestureend','gesturecancel',
		'hashchange'
	]
	binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)
	register_live = (selector, context, evt, f, h) ->
		$(context).bind(evt, h)
			.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h
	unregister_live = (selector, context, e, f) ->
		$c = $(context)
		$c.each ->
			a = (@__alive__ or= {})
			b = (a[selector] or= {})
			c = (b[e] or= {})
			$c.unbind(e, c[f])
			delete c[f]
	triggerReady = $.once ->
		$(document).trigger("ready").unbind("ready")
		document.removeEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.removeEventListener?("load", triggerReady, false)
	bindReady = $.once ->
		document.addEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.addEventListener?("load", triggerReady, false)
	bindReady()
	ret = {
		bind: (e, f) ->
			c = (e or "").split(EVENTSEP_RE)
			h = (evt) ->
				ret = f.apply @, arguments
				if ret is false
					evt.preventAll()
				ret
			@each -> (@addEventListener i, h, false) for i in c
		unbind: (e, f) ->
			c = (e or "").split EVENTSEP_RE
			@each -> (@removeEventListener i, f, null) for i in c
		trigger: (evt, args = {}) ->
			args = $.extend
				bubbles: true
				cancelable: true
			, args
			for evt_i in (evt or "").split(EVENTSEP_RE)
					e = document.createEvent "MouseEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						button: 0,
						relatedTarget: null
					, args
					e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.button, args.relatedTarget
					e = document.createEvent "UIEvents"
					e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1
					e = document.createEvent "TouchEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						touches: [],
						targetTouches: [],
						changedTouches: [],
						scale: 1.0,
						rotation: 0.0
					, args
					e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)
					e = document.createEvent "GestureEvents"
					args = $.extend {
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						target: null,
						scale: 1.0,
						rotation: 0.0
					}, args
					e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.target, args.scale, args.rotation
				else
					e = document.createEvent "Events"
					e.initEvent evt_i, args.bubbles, args.cancelable
					try
						e = $.extend e, args
					catch err
				if not e
					continue
				else
					try
						@each -> @dispatchEvent e
					catch err
						$.log "dispatchEvent error:", err
			@
		live: (e, f) ->
			selector = @selector
			context = @context
			handler = (evt) ->
				$(selector, context)
					.intersect($(evt.target).parents().first().union($(evt.target)))
					.each -> f.call(evt.target = @, evt)
			register_live selector, context, e, f, handler
			@
		die: (e, f) ->
			$(@context).unbind e, unregister_live(@selector, @context, e, f)
			@
		click: (f = {}) ->
			if @css("cursor") in ["auto",""]
				@css "cursor", "pointer"
			if $.is "function", f then @bind 'click', f
			else @trigger 'click', f
			@
		ready: (f) ->
			return (f.call @) if triggerReady.exhausted
			@bind "ready", f
	}
	events.forEach (x) -> ret[x] = binder(x)
	return ret
$.plugin
	provides: "function"
	depends: "hash"
, ->
	$:
		identity: (o) -> o
		not: (f) -> -> not f.apply @, arguments
		compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
		and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
		once: (f, n=1) ->
			$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
				"exhausted",
					get: -> n <= 0
		cycle: (f...) ->
			i = -1
			-> f[i = ++i % f.length].apply @, arguments
		bound: (t, f, args = []) ->
			if $.is "function", f.bind
				args.splice 0, 0, t
				r = f.bind.apply f, args
			else
				r = (a...) -> f.apply t, (args if args.length else a)
		memoize: (f) ->
			cache = {}
		E: (callback) -> (f) -> (err, data) ->
			return f(data) unless err
			callback err, data
$.plugin
	provides: "groupBy"
, ->
	groupBy: (key) ->
		groups = {}
		switch $.type key
			when 'array','bling'
				@each ->
					c = (@[k] for k in key).join ","
					(groups[c] or= $()).push @
			else @each -> (groups[@[key]] or= $()).push @
		return $.valuesOf groups
$.plugin
	provides: "hash"
	depends: "type"
, ->
	$.type.extend
		unknown: { hash: (o) -> $.checksum $.toString o }
		object:  { hash: (o) ->
			$.hash(Object) +
				$($.hash(o[k]) for k of o).sum() +
				$.hash Object.keys o
		}
		array:   { hash: (o) ->
			$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
				(a*a)+(x|0)
			, 1
		}
		bool:    { hash: (o) -> parseInt(1 if o) }
	return {
		$:
			hash: (x) -> $.type.lookup(x).hash(x)
		hash: -> $.hash @
	}
$.plugin ->
	$:
		histogram: (data, bucket_width=1, output_width=80) ->
			buckets = $()
			len = 0
			for x in data
				i = Math.floor( x / bucket_width )
				buckets[i] ?= 0
				buckets[i] += 1
				len = Math.max(len, i+1)
			buckets.length = len
			max = buckets.max()
			buckets = buckets.map((x) -> x or 0)
				.scale(1/max)
				.scale(output_width)
			sum = buckets.sum()
			ret = ""
			pct_sum = 0
			for n in [0...len] by 1
				end = (n+1) * bucket_width
				pct = (buckets[n]*100/sum)
				pct_sum += pct
			ret
	histogram: -> $.histogram @
$.plugin
	provides: "hook"
	depends: "type"
, ->
	hooks = {}
	hook = (name, args) ->
		p = (hooks[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args
	hook("bling-init").prepend (args) ->
		if args.length is 1
			args = $.type.lookup(args[0]).array(args[0])
		$.inherit Bling, args
	$: hook: hook
$.plugin
	depends: "dom"
	provides: "http"
, ->
	$.type.register "http",
		match: (o) -> $.isType 'XMLHttpRequest', o
		array: (o) -> [o]
	return {
		$:
			http: (url, opts = {}) ->
				xhr = new XMLHttpRequest()
				if $.is "function", opts
					opts = success: $.bound(xhr, opts)
				opts = $.extend {
					method: "GET"
					data: null
					async: true
					asBlob: false
					followRedirects: false
					withCredentials: false
				}, opts
				opts.state = $.bound(xhr, opts.state)
				opts.success = $.bound(xhr, opts.success)
				opts.error = $.bound(xhr, opts.error)
				if opts.data and opts.method is "GET"
					url += "?" + formencode(opts.data)
				else if opts.data and opts.method is "POST"
					opts.data = formencode(opts.data)
				xhr.open(opts.method, url, opts.async)
				xhr = $.extend xhr,
					asBlob: opts.asBlob
					timeout: opts.timeout
					followRedirects: opts.followRedirects
					withCredentials: opts.withCredentials
					onreadystatechange: ->
						opts.state?()
						if xhr.readyState is 4
							if xhr.status is 200
								opts.success xhr.responseText
							else
								opts.error xhr.status, xhr.statusText
				xhr.send opts.data
				return $(xhr)
			post: (url, opts = {}) ->
				if $.is("function",opts)
					opts = success: opts
				opts.method = "POST"
				$.http(url, opts)
			get: (url, opts = {}) ->
				if( $.is("function",opts) )
					opts = success: opts
				opts.method = "GET"
				$.http(url, opts)
	}
$.depends 'hook', ->
	$.hook('bling-init').append (obj) ->
		map = Object.create(null)
		keyMakers = []
		$.inherit {
			index: (keyFunc) ->
				if keyMakers.indexOf(keyFunc) is -1
					keyMakers.push keyFunc
					map[keyFunc] = Object.create(null)
				@each (x) ->
					map[keyFunc][keyFunc(x)] = x
			query: (criteria) ->
				for keyMaker in keyMakers
					key = keyMaker(criteria)
					return map[keyMaker][key] if key of map[keyMaker]
				null
		}, obj
$.plugin
	depends: "dom"
	provides: "lazy"
, ->
	lazy_load = (elementName, props) ->
		$("head").append $.extend document.createElement(elementName), props
	$:
		script: (src) ->
			lazy_load "script", { src: src }
		style: (src) ->
			lazy_load "link", { href: src, rel: "stylesheet" }
$.plugin
	provides: "math"
	depends: "core"
, ->
	$.type.extend
		bool: { number: (o) -> if o then 1 else 0 }
		number: { bool: (o) -> not not o }
	_By = (cmp) ->
		(field) ->
			valueOf = switch $.type field
				when "string" then (o) -> o[field]
				when "function" then field
				else throw new Error ".maxBy first argument should be a string or function"
			x = @first()
			@skip(1).each ->
				if cmp valueOf(@), valueOf(x)
					x = @
			return x
	$:
		range: (start, end, step = 1) ->
			if not end? then (end = start; start = 0)
			$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
		zeros: (n) -> $( 0 for i in [0...n] )
		ones: (n) -> $( 1 for i in [0...n] )
		deg2rad: (n) -> n * Math.PI / 180
		rad2deg: (n) -> n * 180 / Math.PI
	floats: -> @map parseFloat
	ints: -> @map -> parseInt @, 10
	px: (delta) -> @ints().map -> $.px @,delta
	min: -> @filter( isFinite ).reduce Math.min
	max: -> @filter( isFinite ).reduce Math.max
	maxBy: _By (a,b) -> a > b
	minBy: _By (a,b) -> a < b
	mean: mean = -> if not @length then 0 else @sum() / @length
	avg: mean
	sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
	product: -> @filter( isFinite ).reduce (a) -> a * @
	squares: -> @pow(2)
	pow: (n) -> @map -> Math.pow @, n
	magnitude: -> Math.sqrt @floats().squares().sum()
	scale: (r) -> @map -> r * @
	add: add = (d) -> switch $.type(d)
		when "number" then @map -> d + @
		when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
	plus: add
	dot: (b) ->
		$.sum( @[i]*b[i] for i in [0...Math.min(@length,b.length)] )
	vecAdd: (v) ->
		d = $()
		for i in [0...@length] by 1
			d[i] = @[i] + v[i]
		d
	normalize: -> @scale 1 / @magnitude()
	deg2rad: -> @filter( isFinite ).map -> @ * Math.PI / 180
	rad2deg: -> @filter( isFinite ).map -> @ * 180 / Math.PI
$.plugin
	provides: "pubsub"
, ->
	$:
		publish: (e, args...) ->
			f.apply null, args for f in (subscribers[e] or= [])
			args
		publisher: (e, func) ->
			(args...) ->
				$.publish e, func.apply @, args
		subscribe: (e, func) ->
			(subscribers[e] or= []).push func
			func
		unsubscribe: (e, func) ->
			if not func?
				subscribers[e] = []
			else
				a = (subscribers[e] or= [])
				if (i = a.indexOf func)  > -1
					a.splice(i,i)
$.plugin
	provides: 'random'
	depends: 'type'
, ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""
		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615
		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)
			index = (index + 1) % 624
			(y + a) / b
		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()
		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
$.plugin
	provides: "sendgrid"
	depends: "config"
, ->
	try
		nodemailer = require 'nodemailer'
	catch err
		`return`
	transport = nodemailer.createTransport 'SMTP',
		service: 'SendGrid'
		auth:
			user: $.config.get 'SENDGRID_USERNAME'
	$:
		sendMail: (mail, callback) ->
			mail.transport ?= transport
			mail.from ?= $.config.get 'EMAILS_FROM'
			mail.bcc ?= $.config.get 'EMAILS_BCC'
			if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
				nodemailer.sendMail mail, callback
			else
$.plugin
	provides: "sortBy,sortedIndex"
, ->
	$:
		sortedIndex: (array, item, iterator) ->
			cmp = switch $.type iterator
				when "string" then (a,b) -> a[iterator] - b[iterator]
				when "function" then (a,b) -> iterator(a) - iterator(b)
				else (a,b) -> a - b
			hi = array.length
			lo = 0
			while lo < hi
				mid = (hi + lo)>>>1
				if cmp(array[mid], item) < 0
					lo = mid + 1
				else
					hi = mid
			return lo
	sortBy: (iterator) ->
		a = $()
		for item in @
			n = $.sortedIndex a, item, iterator
			a.splice n, 0, item
		a
	sortedInsert: (item, iterator) ->
		@splice ($.sortedIndex @, item, iterator), 0, item
		@
		
$.plugin
	provides: "string"
	depends: "function"
, ->
	safer = (f) ->
		(a...) ->
			try return f(a...)
	$.type.extend
		unknown:
			string: safer (o) -> o.toString?() ? String(o)
			repr: safer (o) -> $.type.lookup(o).string(o)
			number: safer (o) -> parseFloat String o
		null: { string: -> "null" }
		undefined: { string: -> "undefined" }
		string:
			number: safer parseFloat
		array:  { string: safer (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
		object: { string: safer (o) ->
			ret = []
			for k of o
				try
					v = o[k]
				catch err
			"{" + ret.join(', ') + "}"
		}
		function:
			string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
		number:
			repr:   (n) -> String(n)
			string: safer (n) ->
				switch true
					when n.precision? then n.toPrecision(n.precision)
					when n.fixed? then n.toFixed(n.fixed)
					else String(n)
	return {
		$:
			toString: (x) ->
				if not x? then "function Bling(selector, context) { [ ... ] }"
				else
					try
						$.type.lookup(x).string(x)
					catch err
			toRepr: (x) -> $.type.lookup(x).repr(x)
			px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"
			capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")
			dashize: (name) ->
				ret = ""
				for i in [0...(name?.length|0)]
					c = name.charCodeAt i
					if 91 > c > 64
						c += 32
						ret += '-'
					ret += String.fromCharCode(c)
				ret
			camelize: (name) ->
				name.split('-')
				while (i = name?.indexOf('-')) > -1
					name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
				name
			padLeft: (s, n, c = " ") ->
				while s.length < n
					s = c + s
				s
			padRight: (s, n, c = " ") ->
				while s.length < n
					s = s + c
				s
			stringTruncate: (s, n, c = "...") ->
				s = s.split(' ')
				r = []
				while n > 0
					x = s.shift()
					n -= x.length
					if n >= 0
						r.push x
				r.join('') + c
			stringCount: (s, x, i = 0, n = 0) ->
				if (j = s.indexOf x,i) > i-1
					$.stringCount s, x, j+1, n+1
				else n
			stringSplice: (s, i, j, n) ->
				nn = s.length
				end = j
				if end < 0
					end += nn
				start = i
				if start < 0
					start += nn
				s.substring(0,start) + n + s.substring(end)
			checksum: (s) ->
				a = 1; b = 0
				for i in [0...s.length]
					a = (a + s.charCodeAt(i)) % 65521
					b = (b + a) % 65521
				(b << 16) | a
			repeat: (x, n=2) ->
				switch true
					when n is 1 then x
					when n < 1 then ""
					when $.is "string", x then x + $.repeat(x, n-1)
					else $(x).extend $.repeat(x, n-1)
			stringBuilder: ->
				if $.is("global", @) then return new $.stringBuilder()
				items = []
				@length   = 0
				@append   = (s) => items.push s; @length += s?.toString().length|0
				@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
				@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
				@toString = ( ) => items.join("")
				@
		toString: -> $.toString @
		toRepr: -> $.toRepr @
	}
$.plugin
	provides: "symbol"
	depends: "type"
, ->
	symbol = null
	cache = {}
	g = $.global
	g.Bling = Bling
	if module?
		module.exports = Bling
	$.defineProperty $, "symbol",
		set: (v) ->
			g[symbol] = cache[symbol]
			cache[symbol = v] = g[v]
			g[v] = Bling
		get: -> symbol
	return $:
		symbol: "$"
		noConflict: ->
			Bling.symbol = "Bling"
			Bling
$.plugin
	provides: "StateMachine"
, ->
	$: StateMachine: class StateMachine
		constructor: (stateTable) ->
			@debug = false
			@reset()
			@table = stateTable
			Object.defineProperty @, "modeline",
				get: -> @table[@_mode]
			Object.defineProperty @, "mode",
				set: (m) ->
					@_lastMode = @_mode
					@_mode = m
					if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
						ret = @modeline['enter'].call @
						while $.is("function",ret)
							ret = ret.call @
					m
				get: -> @_mode
		reset: ->
			@_mode = null
			@_lastMode = null
		GO: (m) -> -> @mode = m
		@GO: (m) -> -> @mode = m
		
		tick: (c) ->
			row = @modeline
			if not row?
				ret = null
			else if c of row
				ret = row[c]
			else if 'def' of row
				ret = row['def']
			while $.is "function",ret
				ret = ret.call @, c
			ret
		run: (inputs) ->
			@mode = 0
			for c in inputs
				ret = @tick(c)
			if $.is "function",@modeline?.eof
				ret = @modeline.eof.call @
			while $.is "function",ret
				ret = ret.call @
			@reset()
			return @
$.plugin
	provides: "synth"
	depends: "StateMachine, type"
, ->
	class SynthMachine extends $.StateMachine
		basic =
			".": @GO 3
			"[": @GO 4
			'"': @GO 6
			"'": @GO 7
			" ": @GO 8
			",": @GO 10
			"+": @GO 11
			eof: @GO 13
		@STATE_TABLE = [
				enter: ->
					@tag = @id = @cls = @attr = @val = @text = ""
					@attrs = {}
					@GO 1
			},
				def: (c) -> @tag += c
			}, basic),
				def: (c) -> @id += c
			}, basic),
				enter: -> @cls += " " if @cls.length > 0
				def: (c) -> @cls += c
			}, basic),
				"=": @GO 5
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @attr += c
				eof: @GO 12
			},
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @val += c
				eof: @GO 12
			},
				'"': @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				"'": @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = null
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = @cursor?.parentNode
					@GO 0
			},
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
			}
		]
		constructor: ->
			super(SynthMachine.STATE_TABLE)
			@fragment = @cursor = document.createDocumentFragment()
		emitNode: ->
			if @tag
				node = document.createElement @tag
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@cursor.appendChild node
				@cursor = node
		emitText: ->
			@cursor.appendChild $.type.lookup("<html>").node(@text)
			@text = ""
	return {
		$:
			synth: (expr) ->
				s = new SynthMachine()
				s.run(expr)
				if s.fragment.childNodes.length == 1
					$(s.fragment.childNodes[0])
				else
					$(s.fragment)
	}
do ($ = Bling) ->
		current_engine = null
		engines = {}
		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine
		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()
		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop] by 1
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1
	$.template.register_engine 'pythonic', (() ->
		chunk_re = /%[\(\/]/
		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n] by 1
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}
			if not cache?
			n = cache.length
			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""
		return render
	)()
		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
$.plugin
	provides: "throttle"
	depends: "core"
, ->
	$:
		throttle: (ms, f) ->
			last = 0
			(a...) ->
				gap = $.now - last
				if gap > ms
					last += gap
					return f.apply @,a
				null
		debounce: (ms, f) ->
			last = 0
			(a...) ->
				last += (gap = $.now - last)
				return f.apply @,a if gap > ms else null
	parseOne = (data) ->
		i = data.indexOf ":"
		if i > 0
			len = parseInt data[0...i], 10
			item = data[i+1...i+1+len]
			type = data[i+1+len]
			extra = data[i+len+2...]
			item = switch type
				when "'" then String(item)
				when "!" then (item is "true")
				when "~" then null
				when "]" then parseArray(item)
				when "}" then parseObject(item)
			return [item, extra]
		return undefined
	parseArray = (x) ->
		data = []
		while x.length > 0
			[one, x] = parseOne(x)
			data.push(one)
		data
	parseObject = (x) ->
		data = {}
		while x.length > 0
			[key, x] = parseOne(x)
			[value, x] = parseOne(x)
			data[key] = value
		data
	$:
		TNET:
			stringify: (x) ->
				[data, type] = switch $.type x
					when "string" then [x, "'"]
					when "function" then [String(x), "'"]
					when "boolean" then [String(not not x), "!"]
					when "null" then ["", "~"]
					when "undefined" then ["", "~"]
					when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
					when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
				return (data.length|0) + ":" + data + type
			parse: (x) ->
				parseOne(x)?[0]
$.plugin
	provides: "trace"
	depends: "function,type"
, ->
	$.type.extend
		unknown: { trace: $.identity }
		function:
			trace: (label, f, tracer) ->
				label or= f.name
				r = (a...) ->
					f.apply @, a
				r
	return $: trace: (label, o, tracer) ->
		if not $.is "string", label
			[tracer, o] = [o, label]
		tracer or= $.log
		label or= ""
		$.type.lookup(o).trace(label, o, tracer)
$.plugin
	depends: "dom"
, ->
	COMMASEP = ", "
		"slow": 700
		"medium": 500
		"normal": 300
		"fast": 100
		"instant": 0
		"now": 0
	accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
	testStyle = document.createElement("div").style
	transformProperty = "transform"
	transitionProperty = "transition-property"
	transitionDuration = "transition-duration"
	transitionTiming = "transition-timing-function"
	if "WebkitTransform" of testStyle
		transformProperty = "-webkit-transform"
		transitionProperty = "-webkit-transition-property"
		transitionDuration = "-webkit-transition-duration"
		transitionTiming = "-webkit-transition-timing-function"
	else if "MozTransform" of testStyle
		transformProperty = "-moz-transform"
		transitionProperty = "-moz-transition-property"
		transitionDuration = "-moz-transition-duration"
		transitionTiming = "-moz-transition-timing-function"
	else if "OTransform" of testStyle
		transformProperty = "-o-transform"
		transitionProperty = "-o-transition-property"
		transitionDuration = "-o-transition-duration"
		transitionTiming = "-o-transition-timing-function"
	return {
		$:
			duration: (speed) ->
				d = speeds[speed]
				return d if d?
				return parseFloat speed
		transform: (end_css, speed, easing, callback) ->
			if $.is("function",speed)
				callback = speed
				speed = easing = null
			else if $.is("function",easing)
				callback = easing
				easing = null
			speed ?= "normal"
			easing or= "ease"
			duration = $.duration(speed) + "ms"
			props = []
			trans = ""
			css = {}
			for i of end_css
				if accel_props_re.test(i)
					ii = end_css[i]
					if ii.join
						ii = $(ii).px().join COMMASEP
					else if ii.toString
						ii = ii.toString()
					trans += " " + i + "(" + ii + ")"
				else css[i] = end_css[i]
			(props.push i) for i of css
			if trans
				props.push transformProperty
			css[transitionProperty] = props.join COMMASEP
			css[transitionDuration] = props.map(-> duration).join COMMASEP
			css[transitionTiming] = props.map(-> easing).join COMMASEP
			if trans
				css[transformProperty] = trans
			@css css
			@delay duration, callback
			@each ->
				if @style
					if @style.display is not "none"
						@_display = @syle.display
					@style.display = "none"
			.trigger "hide"
			.delay updateDelay, callback
			@each ->
				if @style
					@style.display = @_display
					delete @_display
			.trigger "show"
			.delay updateDelay, callback
			@weave(@css("display"))
				.fold (display, node) ->
					if display is "none"
						node.style.display = node._display or ""
						delete node._display
						$(node).trigger "show"
					else
						node._display = display
						node.style.display = "none"
						$(node).trigger "hide"
					node
				.delay(updateDelay, callback)
			@.css('opacity','0.0')
				.show ->
					@transform {
						opacity:"1.0",
						translate3d: [0,0,0]
					}, speed, callback
			@transform {
				opacity:"0.0",
				translate3d:[x,y,0.0]
			}, speed, -> @hide(callback)
		fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
		fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
		fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
		fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
	}
$.plugin
	provides: "type"
, ->
	isType = (T, o) ->
		if not o? then T in [o,"null","undefined"]
		else o.constructor is T or
			o.constructor.name is T or
	inherit = (parent, obj) ->
		if typeof parent is "function"
			parent = parent.prototype
		if parent.__proto__ is Object.prototype
			parent.__proto__ = obj.__proto__
		obj.__proto__ = parent
		obj
	_type = do ->
		cache = {}
		base =
			name: 'unknown'
			match: (o) -> true
		order = []
		register = (name, data) ->
			order.unshift name if not (name of cache)
			cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
			cache[name][name] = (o) -> o
		_extend = (name, data) ->
			if typeof name is "string"
				cache[name] ?= register name, {}
				cache[name] = extend cache[name], data
			else if typeof name is "object"
				(_extend k, name[k]) for k of name
		lookup = (obj) ->
			for name in order
				if cache[name]?.match.call obj, obj
					return cache[name]
		register "unknown",   base
		register "object",    match: -> typeof @ is "object"
		register "error",     match: -> isType 'Error', @
		register "regexp",    match: -> isType 'RegExp', @
		register "string",    match: -> typeof @ is "string" or isType String, @
		register "number",    match: -> (isType Number, @) and @ isnt NaN
		register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
		register "array",     match: -> Array.isArray?(@) or isType Array, @
		register "function",  match: -> typeof @ is "function"
		register "undefined", match: (x) -> x is undefined
		register "null",      match: (x) -> x is null
		return extend ((o) -> lookup(o).name),
			register: register
			lookup: lookup
			extend: _extend
			is: (t, o) -> cache[t]?.match.call o, o
			as: (t, o, rest...) -> lookup(o)[t]?(o, rest...)
	_type.extend
		unknown:   { array: (o) -> [o] }
		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }
	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) -> o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"
	$:
		inherit: inherit
		extend: extend
		defineProperty: (o, name, opts) ->
			Object.defineProperty o, name, extend({ configurable: true, enumerable: true }, opts)
			o
		isType: isType
		type: _type
		is: _type.is
		as: _type.as
		isSimple: (o) -> _type(o) in ["string", "number", "bool"]
		isEmpty: (o) -> o in ["", null, undefined] or o.length is 0 or (typeof o is "object" and Object.keys(o).length is 0)
	defineProperty: (name, opts) -> @each -> $.defineProperty @, name, opts
$.plugin
	provides: "unittest"
	depends: "core,function"
, ->
	testCount = passCount = failCount = 0
	failed = []
	invokeTest = (group, name, func) ->
		return if not $.is "function", func
		shouldFail = name.toLowerCase().indexOf("fail") isnt -1
		done = $.once (err) ->
			testCount--
			if (!!err isnt shouldFail)
				failCount++
				failed.push name
			else
				_log "pass"
				passCount++
				$.provide name
		f = (done) ->
			try func(done)
			catch err then done(err)
			finally
				if name.toLowerCase().indexOf("async") is -1 then done()
		testCount++
		try f(done)
		catch err then done(err)
	testReport = $.once ->
		if failCount > 0
			try process.exit(failCount)
	$:
		approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
		assertEqual: (a, b, label) ->
			if a isnt b
		assertArrayEqual: (a, b, label) ->
			for i in [0...a.length] by 1
				try
					$.assertEqual(a[i], b[i], label)
				catch err
		testGroup: (name, funcs) ->
			interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
			for k,func of funcs
				invokeTest(name, k, func)
	assertEqual: (args...) ->
				if $.is "function", x then x.call(@,@) else x
			a = args[0]
			for i in [1...args.length]
				$.assertEqual a, args[i]
		return @
$.plugin
	provides: "cartesian"
, ->
	$:
		cartesian: (sets...) ->
			n = sets.length
			ret = []
			helper = (cur, i) ->
				(return ret.push cur) if ++i >= n
				for x in sets[i]
					helper (cur.concat x), i
				null
			helper [], -1
			return $(ret)
$.plugin ->
	String::trimLeft or= -> @replace(/^\s+/, "")
	String::split or= (sep) ->
		a = []; i = 0
		while (j = @indexOf sep,i) > -1
			a.push @substring(i,j)
			i = j + 1
		a
	String::lastIndexOf or= (s, c, i = -1) ->
		j = -1
		j = i while (i = s.indexOf c, i+1) > -1
		j

	Array::join or= (sep = '') ->
		n = @length
		return "" if n is 0
		s = @[n-1]
		while --n > 0
			s = @[n-1] + sep + s
		s

	if Event?
		Event::preventAll = () ->
			@preventDefault()
			@stopPropagation()
			@cancelBubble = true

	if Element?
		Element::matchesSelector = Element::webkitMatchesSelector or
			Element::mozMatchesSelector or
			Element::matchesSelector
		if Element::cloneNode.length is 0
			oldClone = Element::cloneNode
			Element::cloneNode = (deep = false) ->
				n = oldClone.call(@)
				if deep
					for i in @childNodes
						n.appendChild i.cloneNode true
				return n

	return { }
$.plugin
	provides: 'config'
	depends: 'type'
, ->
	get = (name, def) -> process.env[name] ? def
	$: config: $.extend(get, get: get)

$.plugin
	provides: "core"
	depends: "string"
, ->

	$.defineProperty $, "now",
		get: -> +new Date

	index = (i, o) ->
		i += o.length while i < 0
		Math.min i, o.length

	baseTime = $.now
	return {
		$:
			log: $.extend((a...) ->
				if prefix.length > $.log.prefixSize + 2
				if a.length and $.is "string", a[0]
				else
					a.unshift prefix
				console.log a...
				return a[a.length-1] if a.length
			, prefixSize: 5)
			coalesce: (a...) -> $(a).coalesce()
			keysOf: (o) -> $(k for k of o)
			valuesOf: (o) -> $.keysOf(o).map (k)->
				return try o[k] catch err then err

		eq: (i) -> $([@[index i, @]])

		each: (f) -> (f.call(t,t) for t in @); @

		map: (f) ->
			b = $()
			for t in @
				b.push f.call t,t
			b

		filterMap: (f) ->
			b = $()
			for t in @
				v = f.call t,t
				if v?
					b.push v
			b

		replaceWith: (array) ->
			for i in [0...array.length] by 1
				@[i] = array[i]

		reduce: (f, a) ->
			i = 0; n = @length
			a = @[i++] if not a?
			(a = f.call @[x], a, @[x]) for x in [i...n] by 1
			return a
		union: (other, strict = true) ->
			ret = $()
			ret.push(x) for x in @ when not ret.contains(x, strict)
			ret.push(x) for x in other when not ret.contains(x, strict)
			ret
		distinct: (strict = true) -> @union @, strict
		contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
		count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
		coalesce: ->
			for i in @
				if $.is('array',i) or $.is('bling',i) then i = $(i).coalesce()
				if i? then return i
			null
		swap: (i,j) ->
			i = index i, @
			j = index j, @
			if i isnt j
				[@[i],@[j]] = [@[j],@[i]]
			@
		shuffle: ->
			i = @length-1
			while i >= 0
				@swap --i, Math.floor(Math.random() * i)
			@

		select: (->
			getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
			select = (p) ->
				if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
				else @map(getter p)
		)()

		or: (x) -> @[i] or= x for i in [0...@length]; @

		zap: (p, v) ->

			i = p.lastIndexOf "."

			if i > 0
				head = p.substr 0,i
				tail = p.substr i+1
				@select(head).zap tail, v
				return @

			switch $.type(v)
				when "array","bling" then @each -> @[p] = v[++i % v.length]
				when "function" then @zap p, @select(p).map(v)
				else @each -> @[p] = v
			@

		clean: (prop) -> @each -> delete @[prop]

		take: (n = 1) ->
			end = Math.min n, @length
			$( @[i] for i in [0...end] by 1 )

		skip: (n = 0) ->
			start = Math.max 0, n|0
			$( @[i] for i in [start...@length] by 1 )

		first: (n = 1) -> if n is 1 then @[0] else @take(n)

		last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)

		slice: (start=0, end=@length) ->
			start = index start, @
			end = index end, @
			$( @[i] for i in [start...end] )

		extend: (b) -> @.push(i) for i in b; @

		push: (b) -> Array::push.call(@, b); @

		filter: (f) ->
			g = switch $.type f
				when "string" then (x) -> x.matchesSelector(f)
				when "regexp" then (x) -> f.test(x)
				when "function" then f
			$( it for it in @ when g.call(it,it) )

		matches: (expr) ->
			switch $.type expr
				when "string" then @select('matchesSelector').call(expr)
				when "regexp" then @map (x) -> expr.test x

		querySelectorAll: (expr) ->
			@filter("*")
			.reduce (a, i) ->
				a.extend i.querySelectorAll expr
			, $()

		weave: (b) ->
			c = $()
			for i in [@length-1..0] by -1
				c[(i*2)+1] = @[i]
			for i in [0...b.length] by 1
				c[i*2] = b[i]
			c

		fold: (f) ->
			n = @length
			b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
			if (n%2) is 1
				b.push( f.call @, @[n-1], undefined )
			b

		flatten: ->
			b = $()
			(b.push(j) for j in i) for i in @
			b

		call: -> @apply(null, arguments)

		apply: (context, args) ->
			@filterMap ->
				if $.is 'function', @ then @apply(context, args)
				else null

		log: (label) ->
			if label
				$.log(label, @toString(), @length + " items")
			else
				$.log(@toString(), @length + " items")
			@

		toArray: ->
			@__proto__ = Array::
	}
$.plugin
	provides: 'date'
	depends: 'type'
, ->
	[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]

	units = {
		ms, s, m, h, d,
		sec: s
		second: s
		seconds: s
		min: m
		minute: m
		minutes: m
		hr: h
		hour: h
		hours: h
		day: d
		days: d
	}

	formats =
		yyyy: Date::getUTCFullYear
		mm: -> @getUTCMonth() + 1
		dd: Date::getUTCDate
		HH: Date::getUTCHours
		MM: Date::getUTCMinutes
		SS: Date::getUTCSeconds
		MS: Date::getUTCMilliseconds
	format_keys = Object.keys(formats).sort().reverse()

	parsers =
		yyyy: Date::setUTCFullYear
		mm: (x) -> @setUTCMonth(x - 1)
		dd: Date::setUTCDate
		HH: Date::setUTCHours
		MM: Date::setUTCMinutes
		SS: Date::setUTCSeconds
		MS: Date::setUTCMilliseconds
	parser_keys = Object.keys(parsers).sort().reverse()

	floor = Math.floor

	$.type.register "date",
		match: (o) -> $.isType Date, o
		array: (o) -> [o]
		string: (o, fmt, unit) -> $.date.format o, fmt, unit
		number: (o, unit) -> $.date.stamp o, unit

	$.type.extend 'string', date: (o, fmt = $.date.defaultFormat) -> new Date $.date.parse o, fmt, "ms"
	$.type.extend 'number', date: (o, unit) -> $.date.unstamp o, unit

	adder = (key) ->
		(stamp, delta, stamp_unit = $.date.defaultUnit) ->
			date = $.date.unstamp(stamp, stamp_unit)
			parsers[key].call date, (formats[key].call date) + delta
			$.date.stamp date, stamp_unit

	$:
		date:
			defaultUnit: "s"
			defaultFormat: "yyyy-mm-dd HH:MM:SS"
			stamp: (date = new Date, unit = $.date.defaultUnit) ->
				floor (date / units[unit])
			unstamp: (stamp, unit = $.date.defaultUnit) ->
				new Date floor(stamp * units[unit])
			convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
				(floor stamp * units[from] / units[to])
			midnight: (stamp, unit = $.date.defaultUnit) ->
				$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
			format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
				date = $.date.unstamp stamp, unit
				for k in format_keys
					fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
				fmt
			parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
				date = new Date(0)
				for i in [0...fmt.length] by 1
					for k in parser_keys
						if fmt.indexOf(k, i) is i
							try
								parsers[k].call date,
									parseInt dateString[i...i+k.length], 10
							catch err
				$.date.stamp date, to
			addMilliseconds: adder("MS")
			addSeconds: adder("SS")
			addMinutes: adder("MM")
			addHours: adder("HH")
			addDays: adder("dd")
			addMonths: adder("mm")
			addYears: adder("yyyy")
			range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
				add = adder(interval_unit)
				ret = [from]
				while (cur = ret[ret.length-1]) < to
					ret.push add(cur, interval, stamp_unit)
				ret

	midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
	unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
	stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
	dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
	dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)


$.plugin
	provides: "delay"
	depends: "function"
, ->
	$:
		delay: (->
			timeoutQueue = $.extend [], (->
				next = (a) -> -> a.shift()() if a.length
				add: (f, n) ->
					f.order = n + $.now
					for i in [0..@length] by 1
						if i is @length or @[i].order > f.order
							@splice i,0,f
							break
					setTimeout next(@), n
					@
				cancel: (f) ->
					for i in [0...@length] by 1
						if @[i] == f
							@splice i, 1
							break
					@
			)()

			(n, f) ->
				if $.is("function",f) then timeoutQueue.add(f, n)
				cancel: -> timeoutQueue.cancel(f)

		)()

	delay: (n, f, c=@) ->
		$.delay n, $.bound(c, f)
		@
	interval: (n, f, c=@) ->
		g = $.bound c, f
		h = -> g(); $.delay n, h
		$.delay n, h
		@
if $.global.document?
	$.plugin
		depends: "function,type"
		provides: "dom"
	, ->
		$.type.register "nodelist",
			match:  (o) -> o? and $.isType "NodeList", o
			hash:   (o) -> $($.hash(i) for i in x).sum()
			array:  $.identity
			string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
			node:   (o) -> $(o).toFragment()
		$.type.register "node",
			match:  (o) -> o?.nodeType > 0
			hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "fragment",
			match:  (o) -> o?.nodeType is 11
			hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "html",
			match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
			node:   (h) ->
				(node = document.createElement('div')).innerHTML = h
				if n = (childNodes = node.childNodes).length is 1
					return node.removeChild(childNodes[0])
				df = document.createDocumentFragment()
				df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
				df
			array:  (o) -> $.type.lookup(h = Bling.HTML.parse o).array h
			repr:   (o) -> '"' + o + '"'
		$.type.extend
			unknown:  { node: -> null }
			bling:    { node: (o) -> o.toFragment() }
			node:     { html: (n) ->
				d = document.createElement "div"
				d.appendChild (n = n.cloneNode true)
				ret = d.innerHTML
				ret
			}
			string:
				node:  (o) -> $(o).toFragment()
				array: (o) -> document.querySelectorAll? o
			function: { node: (o) -> $(o.toString()).toFragment() }

		toFrag = (a) ->
			if not a.parentNode?
				df = document.createDocumentFragment()
				df.appendChild a
			a
		before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
		after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
		toNode = (x) -> $.type.lookup(x).node x
		escaper = false
		parser = false

		computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue k

		getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select p

		selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )

		return {
			$:

				HTML:
					parse: (h) -> $.type.lookup(h).node h
					stringify: (n) -> $.type.lookup(n).html n
					escape: (h) ->
						escaper or= $("<div>&nbsp;</div>").child 0
						ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
						escaper.zap('data', '')
						ret

			html: (h) ->
				return switch $.type h
					when "undefined","null" then @select 'innerHTML'
					when "string","html" then @zap 'innerHTML', h
					when "bling" then @html h.toFragment()
					when "node"
							@replaceChild @childNodes[0], h
							while @childNodes.length > 1
								@removeChild @childNodes[1]

				@each -> @appendChild x.cloneNode true

				clones = @map( -> @cloneNode true)
				i = 0
				$(x).each -> @appendChild clones[i++]
				clones

				if x?
					x = toNode x
					@take(1).each ->
						before @childNodes[0], x
					@skip(1).each ->
						before @childNodes[0], x.cloneNode true
				@

				if x?
					$(x).prepend(@)
				@

				if x?
					x = toNode x
					@take(1).each -> before @, x
					@skip(1).each -> before @, x.cloneNode true
				@

				if x?
					x = toNode x
					@take(1).each -> after @, x
					@skip(1).each -> after @, x.cloneNode true
				@

				parent = toNode parent
				if $.is "fragment", parent
					throw new Error("cannot call .wrap() with a fragment as the parent")
				@each (child) ->
					if ($.is "fragment", child) or not child.parentNode
						return parent.appendChild child
					grandpa = child.parentNode
					marker = document.createElement "dummy"
					parent.appendChild grandpa.replaceChild marker, child
					grandpa.replaceChild parent, marker

				@each ->
					if @parentNode and @parentNode.parentNode
						@parentNode.parentNode.replaceChild(@, @parentNode)
					else if @parentNode
						@parentNode.removeChild(@)

				n = toNode n
				clones = @map(-> n.cloneNode true)
				for i in [0...clones.length] by 1
					@[i].parentNode?.replaceChild clones[i], @[i]
				clones

				return switch v
					when undefined then @select("getAttribute").call(a, v)
					when null then @select("removeAttribute").call(a, v)
					else
						@select("setAttribute").call(a, v)
						@


				notempty = (y) -> y isnt ""
				@removeClass(x).each ->
					c = @className.split(" ").filter notempty
					c.push x
					@className = c.join " "

				notx = (y) -> y != x
				@each ->
					c = @className.split(" ").filter(notx).join(" ")
					if c.length is 0
						@removeAttribute('class')

				notx = (y) -> y isnt x
				@each ->
					cls = @className.split(" ")
					filter = $.not $.isEmpty
					if( cls.indexOf(x) > -1 )
						filter = $.and notx, filter
					else
						cls.push x
					c = cls.filter(filter).join(" ")
					@className = c
					if c.length is 0
						@removeAttribute('class')

				@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1

				return @zap('textContent', t) if t?
				return @select('textContent')

				return @zap('value', v) if v?
				return @select('value')

			css: (k,v) ->
				if v? or $.is "object", k
					setter = @select 'style.setProperty'
					if $.is "object", k then setter.call i, k[i], "" for i of k
					else if $.is "string", v then setter.call k, v, ""
					else if $.is "array", v
						setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
					return @
				else
					cv = @map computeCSSProperty k
					ov = @select('style').select k
					ov.weave(cv).fold (x,y) -> x or y

			defaultCss: (k, v) ->
				sel = @selector
				style = ""
				if $.is "string", k
					if $.is "string", v
					else throw Error("defaultCss requires a value with a string key")
				else if $.is "object", k
					"} "
				$("<style></style>").text(style).appendTo("head")
				@

			rect: -> @select('getBoundingClientRect').call()

			width: getOrSetRect("width")

			height: getOrSetRect("height")

			top: getOrSetRect("top")

			left: getOrSetRect("left")

			bottom: getOrSetRect("bottom")

			right: getOrSetRect("right")

			position: (left, top) ->
				switch true
					when not left? then @rect()
					when not top? then @css("left", $.px(left))
					else @css({top: $.px(top), left: $.px(left)})

			scrollToCenter: ->
				document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
				@

			child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]

			parents: selectChain('parentNode')

			prev: selectChain('previousSibling')

			next: selectChain('nextSibling')

			remove: -> @each -> @parentNode?.removeChild(@)

			find: (css) ->
				@filter("*")
					.map( -> $(css, @) )
					.flatten()

			clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @

			toFragment: ->
				if @length > 1
					df = document.createDocumentFragment()
					(@map toNode).map $.bound df, df.appendChild
					return df
				return toNode @[0]
		}
$.plugin
	provides: "EventEmitter"
	depends: "type,hook"
, ->
	$: EventEmitter: $.hook("bling-init").append (obj = Object.create(null)) ->
		listeners = {}
		list = (e) -> (listeners[e] or= [])
		$.inherit {
			emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
			addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
			on:                 (e, h) -> @addListener e, h
			removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
			removeAllListeners: (e) -> listeners[e] = []
			listeners:          (e) -> list(e).slice 0
		}, obj
$.plugin
	depends: "dom,function,core"
	provides: "event"
, ->
	EVENTSEP_RE = /,* +/
	events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
		'load','unload','reset','submit','keyup','keydown','change',
		'abort','cut','copy','paste','selection','drag','drop','orientationchange',
		'touchstart','touchmove','touchend','touchcancel',
		'gesturestart','gestureend','gesturecancel',
		'hashchange'
	]

	binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)

	register_live = (selector, context, evt, f, h) ->
		$(context).bind(evt, h)
			.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h

	unregister_live = (selector, context, e, f) ->
		$c = $(context)
		$c.each ->
			a = (@__alive__ or= {})
			b = (a[selector] or= {})
			c = (b[e] or= {})
			$c.unbind(e, c[f])
			delete c[f]

	triggerReady = $.once ->
		$(document).trigger("ready").unbind("ready")
		document.removeEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.removeEventListener?("load", triggerReady, false)
	bindReady = $.once ->
		document.addEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.addEventListener?("load", triggerReady, false)
	bindReady()

	ret = {
		bind: (e, f) ->
			c = (e or "").split(EVENTSEP_RE)
			h = (evt) ->
				ret = f.apply @, arguments
				if ret is false
					evt.preventAll()
				ret
			@each -> (@addEventListener i, h, false) for i in c

		unbind: (e, f) ->
			c = (e or "").split EVENTSEP_RE
			@each -> (@removeEventListener i, f, null) for i in c

		trigger: (evt, args = {}) ->
			args = $.extend
				bubbles: true
				cancelable: true
			, args

			for evt_i in (evt or "").split(EVENTSEP_RE)
					e = document.createEvent "MouseEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						button: 0,
						relatedTarget: null
					, args
					e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.button, args.relatedTarget

					e = document.createEvent "UIEvents"
					e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1

					e = document.createEvent "TouchEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						touches: [],
						targetTouches: [],
						changedTouches: [],
						scale: 1.0,
						rotation: 0.0
					, args
					e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)

					e = document.createEvent "GestureEvents"
					args = $.extend {
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						target: null,
						scale: 1.0,
						rotation: 0.0
					}, args
					e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.target, args.scale, args.rotation

				else
					e = document.createEvent "Events"
					e.initEvent evt_i, args.bubbles, args.cancelable
					try
						e = $.extend e, args
					catch err

				if not e
					continue
				else
					try
						@each -> @dispatchEvent e
					catch err
						$.log "dispatchEvent error:", err
			@

		live: (e, f) ->
			selector = @selector
			context = @context
			handler = (evt) ->
				$(selector, context)
					.intersect($(evt.target).parents().first().union($(evt.target)))
					.each -> f.call(evt.target = @, evt)
			register_live selector, context, e, f, handler
			@

		die: (e, f) ->
			$(@context).unbind e, unregister_live(@selector, @context, e, f)
			@

		click: (f = {}) ->
			if @css("cursor") in ["auto",""]
				@css "cursor", "pointer"
			if $.is "function", f then @bind 'click', f
			else @trigger 'click', f
			@

		ready: (f) ->
			return (f.call @) if triggerReady.exhausted
			@bind "ready", f
	}

	events.forEach (x) -> ret[x] = binder(x)
	return ret

(($) ->
	$.plugin
		depends: "experimental"
	, ->
		pruners = {}
		register = (type, f) -> (pruners[type] = f)
		lookup = (obj) -> pruners[obj.t or obj.type]
		stack = []

		$.type.extend null,        { compact: (o) -> $.toString(o) }
		$.type.extend "undefined", { compact: (o) -> "" }
		$.type.extend "null",      { compact: (o) -> "" }
		$.type.extend "string",    { compact: $.identity }
		$.type.extend "array",     { compact: (o) -> (Object.Compact(x) for x in o).join("") }
		$.type.extend "bling",     { compact: (o) -> o.map(Object.Compact).join("") }
		$.type.extend "object",    { compact: (o) -> Object.Compact(lookup(o)?.call o, o) }

		Object.Compact = (o) ->
			stack.push(o)
			$.type.lookup(o)?.compact(o)
			stack.pop()
		$.extend Object.Compact,
			register: register
			lookup: lookup

		register 'page', -> [
			"<!DOCTYPE html><html><head>",
				@head,
			"</head><body>",
				@body,
			"</body></html>"
		]
		register 'text', -> @EN
		register 'link', ->
			a = $(["<a"])
			a.extend(" ",k,"='",@[k],"'") for k in ["href","name","target"] when k of @
			a.extend(">",node.content,"</a>")

		$.assert(Object.Compact({ t: "page", head: [], body: {type: "text", EN: "Hello World"} }) is
			"<!DOCTYPE html><html><head></head><body>Hello World</body></html>")

		return { name: "Compact" }
)(Bling)

(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'ClientRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts

				post: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "POST"
					$.http url, opts

				get: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "GET"
					$.http url, opts
		}
)(Bling)
(($) ->
		operatorHtml = "<span class='opr'>$&</span>"
		keywords = /\b[Ff]unction\b|\bvar\b|\.prototype\b|\.__proto__\b|\bString\b|\bArray\b|\bNumber\b|\bObject\b|\bbreak\b|\bcase\b|\bcontinue\b|\bdelete\b|\bdo\b|\bif\b|\belse\b|\bfinally\b|\binstanceof\b|\breturn\b|\bthrow\b|\btry\b|\btypeof\b|\btrue\b|\bfalse\b/g
		keywordHtml = "<span class='kwd'>$&</span>"
		allNumbers = /\d+\.*\d*/g
		numberHtml = "<span class='num'>$&</span>"
		blingSymbol = /\$(\(|\.)/g
		blingHtml = "<span class='bln'>$$</span>$1"
		tabs = /\t/g
		tabHtml = "&nbsp;&nbsp;"
		singlelineComment = /\/\/.*?(?:\n|$)/
		multilineComment = /\/\*(?:.|\n)*?\*\//
		commentHtml = (comment) ->
		quotedHtml = (quoted) ->

			a = s.indexOf('"', i)
			b = s.indexOf("'", i)
			a = s.length if a is -1
			b = s.length if b is -1
			return [null, -1] if a is b
			return ['"', a] if a < b
			return ["'", b]
			r = s.indexOf(q, i)
			while( s.charAt(r-1) is "\\" and 0 < r < s.length)
				r = s.indexOf(q, r+1)
			r
			i = 0
			n = s.length
			ret = []
			if not Object.IsString(s)
				if not Object.IsFunction(s.toString)
					throw TypeError("invalid string argument to split_quoted")
				else
					s = s.toString()
					n = s.length
			while( i < n )
				q = firstQuote(s, i)
				j = q[1]
				if( j is -1 )
					ret.push(s.substring(i))
					break
				ret.push(s.substring(i,j))
				k = closingQuote(s, j+1, q[0])
				if( k is -1 )
					throw Error("unclosed quote: "+q[0]+" starting at "+j)
				ret.push(s.substring(j, k+1))
				i = k+1
			ret

		firstComment = (s) ->
			a = s.match(singlelineComment)
			b = s.match(multilineComment)
			return [-1, null] if a is b
			return [b.index, b[0]] if a == null and b != null
			return [a.index, a[0]] if a != null && b == null
			return [b.index, b[0]] if b.index < a.index
			return [a.index, a[0]]

		splitComments = (s) ->
			ret = []
			i = 0
			n = s.length
			while( i < n )
				ss = s.substring(i)
				q = firstComment(ss)
				j = q[0]
				if( j > -1 )
					ret.push(ss.substring(0,j))
					ret.push(q[1])
					i += j + q[1].length
				else
					ret.push(ss)
					break
			ret

		foldCodeAndQuoted = (code, quoted) ->
			code.replace(operators, operatorHtml).replace(allNumbers, numberHtml).replace(keywords, keywordHtml).replace(blingSymbol, blingHtml).replace(tabs, tabHtml) + quotedHtml(quoted)

		foldTextAndComments = (text, comment) ->
			$(splitQuoted(text)).fold(foldCodeAndQuoted).join('') + commentHtml(comment)

		return {
			name: "PrettyPrint"
			$:
				prettyPrint: (js, colors) ->
					js = js.toString() if Object.IsFunction(js)
					if not Object.IsString(js)
						throw TypeError("prettyPrint requires a function or string to format, not '"+Object.Type(js)+"'")
						css = "code.pp .bln { font-size: 17px; } "
						colors = Object.Extend(
						, colors)
						for cls of colors
							.text(css)
							.appendTo("head")
					ret = "<code class='pp'>" + ($(splitComments(js)).fold(foldTextAndComments).join('')) + "</code>"
		}

)(Bling)
require "../../dist/bling"

do ($ = Bling) ->

	$.plugin
		provides: "text-analysis"
	, ->
		indices = $.memoize (str, substr) ->
			switch substr.length
				when 0 then $.range 0, str.length
				when 1
					i = -1
					i while (i = str.indexOf substr, i+1) > -1
				else
					subsub = substr[0...substr.length-1]
					indices(str, subsub).filter (x) -> str.indexOf(substr,x) is x

		ld = $.memoize (s, t) ->
			switch true
				when not s then t.length
				when not t then s.length
				when s is t then 0
				when s[0] is t[0] then ld s[1..],t[1..]
				else 1 + Math.min(
					ld(s, t[1..]),
					ld(s[1..], t),
					ld(s[1..], t[1..])
				)

		commonSubstrings = (a,b,min_length=1,limit=1) ->
			a = a.toLowerCase()
			b = b.toLowerCase()
			ret = {}
			for i in [0...b.length]
				for j in [0...b.length]
					if (j - i) < min_length-1 then continue
					c = b[i..j]
					if (indices a,c).length > 0
							ret[c] = 1
			$(Object.keys ret)
				.sort((x,y) -> y.length - x.length)
				.take(limit)

		$:
			stringDistance: ld
			stringsInCommon: commonSubstrings

(($) ->

	$.plugin () ->

		Dialog = (selector, opts) ->
			opts = $.extend({
				autoOpen: false
				draggable: true
			}, opts)
			dialog = $(selector)
				.addClass("dialog")
			if opts.draggable
				dialog.draggable()
			if opts.autoOpen
				dialog.show().center()
			dialog
				.find("button.close, .close-button")
				.bind "click touchstart", () ->
					dialog.hide()
					false
			dialog
		
		Draggable = (selector, opts) ->
			opts = $.extend({
				handleCSS: {}
			}, opts)

			opts.handleCSS = $.extend({
				position: "absolute"
				top: "0px"
				left: "0px"
				width: "100%"
				height: "6px"
			}, opts.handleCSS)

			dragObject = $(selector)
			moving = false
			oX = oY = 0
			handle = $
				.synth("div.handle")
				.defaultCss({
					height: "6px"
					"border-radius": "3px"
					cursor: "move"
				})
				.css(opts.handleCSS)
				.bind 'mousedown, touchstart', (evt) ->
					moving = true
					oX or= evt.pageX
					oY or= evt.pageY
					false
			$(document)
			.bind 'mousemove, touchmove', (evt) ->
				if moving
					dX = (evt.pageX - oX)
					dY = (evt.pageY - oY)
					dragObject.transform({
						translate: [ dX, dY ]
					}, 0)
					.trigger 'drag', {
						dragObject: dragObject
					}
					false
			.bind 'mouseup, touchend', (evt) ->
				if moving
					moving = false
					pos = handle.position()[0]
					$(document.elementFromPoint(pos.left, pos.top - 1))
					.trigger 'drop',
						dropObject: dragObject

			dragObject
				.addClass("draggable")
				.css {
					position: "relative"
					"padding-top": dragObject.css("padding-top")
						.map(Number.AtLeast(parseInt(opts.handleCSS.height,10)))
						.px().first()
				}
				.append(handle)

		ProgressBar = (selector, opts) ->
			opts = $.extend({
				change: null
				barColor: "rgba(0,128,0,0.5)"
				textColor: "white"
				reset: false
			}, opts)

			node = $(selector)
				.addClass('progress-bar')
				_bg = node.css("background").first()
				_color = node.css("color").first()

			node.zap 'updateProgress', (pct) ->
				while pct < 1.0
					pct *= 100.0
					node.css
						background: _bg
						color: _color
				else
					node.css
						background:"""
						"""
						color: opts.textColor
				if $.is "function", opts.change
					opts.change pct

		Accordion = (selector, opts) ->
			opts = $.extend({
				exclusive: false
				sticky: false
			}, opts)
			node = $(selector).addClass("accordion")
			selectedChild = null

			initRow = (n) ->
				t = $(n).children().first().filter("*")
				if( t.len() isnt 2 )
				title = t.eq(0).addClass("title")
				body = t.eq(1).addClass("body").hide()
				bodyVisible = false
				title.click () ->
					if opts.exclusive
						node.find(".body").hide()
					if bodyVisible
						if not opts.sticky
							body.hide().removeClass("visible")
							title.removeClass("selected").trigger("deselect")
							bodyVisible = false
						else
							body.show().addClass("visible")
							title.addClass("selected").trigger("select")
							bodyVisible = true
					else
						body.show().addClass("visible")
						title.addClass("selected").trigger("select")
						bodyVisible = true

			node.bind "DOMNodeInserted", (evt) ->
				directChildren = node.children().first().filter("*")
				parentsOfInserted = $(evt.target).parents().first()
				initRow(parentsOfInserted.intersect(directChildren))

			node.children().first()
				.map(initRow)

			return node

		ViewStack = (selector, opts) ->
			items = $(selector)
				.css {
					position: "relative"
					top: "0px"
					left: "0px"
				}
				.hide()
				.map($)
			active = 0
			items[active].show()
			items.next = () ->
				items[active].hide()
				active = (++active % items.length)
				items[active].show()
			items.activate = (k) ->
				items[active].hide()
				active = k
				items[k].show()
			for j in [0...items.len()]
				items[j]
				.zap("_viewIndex", j)
				.zap "activate", ->
					items.activate(this._viewIndex)
			items

		Tabs = (selector, views) ->
			tabs = $(selector)
			views = $(views).viewStack()
			nn = tabs.len()
			tabs._tabIndex = i for i in [0..nn]
			$(tabs[0]).addClass("active")
			tabs.click () ->
				tabs.removeClass("active")
				views.activate(this._tabIndex)
				$(this).addClass("active")

		return {
			$:
				UI:
					Draggable: Draggable
					ProgressBar: ProgressBar
					ViewStack: ViewStack
					Tabs: Tabs
					Accordion: Accordion

			dialog: (opts) -> Dialog(this, opts)
			progressBar: (opts) -> ProgressBar(this, opts)
			viewStack: (opts) -> ViewStack(this, opts)
			tabs: (views) -> Tabs(this, views)
			accordion: (opts) -> Accordion(this, opts)
			draggable: (opts) -> Draggable(this, opts)
		}

)(Bling)


	units = ["px","pt","pc","em","%","in","cm","mm","ex",""]
	UNIT_RE = /(\d+\.*\d*)(px|pt|pc|em|%|in|cm|mm|ex)/

	parseUnits = (s) -> UNIT_RE.exec(s)[2] if UNIT_RE.test(s) else ""

	conv = (a,b) -> conv[a][b]()
	for a in units
		for b in units
			(conv[a] or= {})[b] = trick +(a is b or a is "" or b is "")
	conv.in.pt = -> 72
	conv.in.px = -> 96
	conv.in.cm = -> 2.54
	conv.pc.pt = -> 12
	conv.cm.mm = -> 10
	conv.em.px = ->
		x = $("<span style='font-size:1em;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.px = ->
		x = $("<span style='font-size:1ex;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.em = -> 2
	fillIn = ->
		for a in units
			for b in units
				if not conv(a,b) and conv(b,a)
					conv[a][b] = trick 1.0/conv(b,a)
				for c in units
					if not conv(a,c) and conv(a,b) and conv(b,c)
						conv[a][c] = trick conv(a,b) * conv(b,c)
	fillIn(); fillIn()
	
	convertUnits = (number, unit) -> parseFloat(number) * conv[parseUnits(number)][unit]() + unit

	$.assert(convertUnits("300px", "cm") == "10cm")

	convertAll = (to, a) ->
		for i in [0...a.length]
			a[i] = convertTo(to, a[i])

	Object.Type.register "units",
		match: (x) -> UNIT_RE.test(x)

	unit_scalar = (f) ->
		(a...) ->
			convertAll( unit = parseUnits(@[0]), @)
			(f.apply @, a) + unit
	unit_vector = (f) ->
		(a...) ->
			u = @map parseUnits
			f.apply(@floats(), a).map ->

	{
		min: unit_scalar -> @reduce (a) -> Math.min parseFloat(@), a
		max: unit_scalar -> @reduce (a) -> Math.max parseFloat(@), a
		sum: unit_scalar -> @reduce (a) -> parseFloat(@) + a
		mean: unit_scalar -> parseFloat(@sum()) / @length
		magnitude: unit_scalar -> Math.sqrt @floats().squares().sum()
		squares: -> @map -> (x=parseFloat(@)) * x
		scale: (n) -> @map -> n * parseFloat(@)
		add: (d) -> @map -> d + @
		normalize: -> @scale(1/@magnitude())
	}


	EOF = -> "EOF"

	BackgroundQueue = (opts) ->
		opts = extend {
			item: -> EOF
			action: Function.Identity
			latency: 10
		}, opts

		return extend new $.EventEmitter(), {
			run: ->
				r = () =>
					if (item = opts.action(opts.item())) isnt EOF
						@emit("data", item)
						setTimeout r, opts.latency
				setTimeout r, opts.latency
		}

	data = x for x in [0...1000]
	i = 0
	BackgroundQueue
		item: ->
			return data[i++] if i < data.length else EOF
		action: (item) -> (item*item) - 1
		latency: 10
	.on "data", (x) -> console.log "data:", x
	.on "error", (x) -> console.log "error:", x
	
$.plugin
	provides: "function"
	depends: "hash"
, ->
	$:
		identity: (o) -> o
		not: (f) -> -> not f.apply @, arguments
		compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
		and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
		once: (f, n=1) ->
			$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
				"exhausted",
					get: -> n <= 0
		cycle: (f...) ->
			i = -1
			-> f[i = ++i % f.length].apply @, arguments
		bound: (t, f, args = []) ->
			if $.is "function", f.bind
				args.splice 0, 0, t
				r = f.bind.apply f, args
			else
				r = (a...) -> f.apply t, (args if args.length else a)
		memoize: (f) ->
			cache = {}
		E: (callback) -> (f) -> (err, data) ->
			return f(data) unless err
			callback err, data

$.plugin
	provides: "groupBy"
, ->
	groupBy: (key) ->
		groups = {}
		switch $.type key
			when 'array','bling'
				@each ->
					c = (@[k] for k in key).join ","
					(groups[c] or= $()).push @
			else @each -> (groups[@[key]] or= $()).push @
		return $.valuesOf groups
$.plugin
	provides: "hash"
	depends: "type"
, ->
	$.type.extend
		unknown: { hash: (o) -> $.checksum $.toString o }
		object:  { hash: (o) ->
			$.hash(Object) +
				$($.hash(o[k]) for k of o).sum() +
				$.hash Object.keys o
		}
		array:   { hash: (o) ->
			$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
				(a*a)+(x|0)
			, 1
		}
		bool:    { hash: (o) -> parseInt(1 if o) }
	return {
		$:
			hash: (x) -> $.type.lookup(x).hash(x)
		hash: -> $.hash @
	}
$.plugin ->
	$:
		histogram: (data, bucket_width=1, output_width=80) ->
			buckets = $()
			len = 0
			for x in data
				i = Math.floor( x / bucket_width )
				buckets[i] ?= 0
				buckets[i] += 1
				len = Math.max(len, i+1)
			buckets.length = len

			max = buckets.max()
			buckets = buckets.map((x) -> x or 0)
				.scale(1/max)
				.scale(output_width)
			sum = buckets.sum()

			ret = ""
			pct_sum = 0
			for n in [0...len] by 1
				end = (n+1) * bucket_width
				pct = (buckets[n]*100/sum)
				pct_sum += pct
			ret
	histogram: -> $.histogram @
$.plugin
	provides: "hook"
	depends: "type"
, ->





	hooks = {}
	hook = (name, args) ->
		p = (hooks[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args

	hook("bling-init").prepend (args) ->
		if args.length is 1
			args = $.type.lookup(args[0]).array(args[0])
		$.inherit Bling, args

	$: hook: hook

$.plugin
	depends: "dom"
	provides: "http"
, ->

	$.type.register "http",
		match: (o) -> $.isType 'XMLHttpRequest', o
		array: (o) -> [o]

	return {
		$:
			http: (url, opts = {}) ->
				xhr = new XMLHttpRequest()
				if $.is "function", opts
					opts = success: $.bound(xhr, opts)
				opts = $.extend {
					method: "GET"
					data: null
					async: true
					asBlob: false
					followRedirects: false
					withCredentials: false
				}, opts
				opts.state = $.bound(xhr, opts.state)
				opts.success = $.bound(xhr, opts.success)
				opts.error = $.bound(xhr, opts.error)
				if opts.data and opts.method is "GET"
					url += "?" + formencode(opts.data)
				else if opts.data and opts.method is "POST"
					opts.data = formencode(opts.data)
				xhr.open(opts.method, url, opts.async)
				xhr = $.extend xhr,
					asBlob: opts.asBlob
					timeout: opts.timeout
					followRedirects: opts.followRedirects
					withCredentials: opts.withCredentials
					onreadystatechange: ->
						opts.state?()
						if xhr.readyState is 4
							if xhr.status is 200
								opts.success xhr.responseText
							else
								opts.error xhr.status, xhr.statusText
				xhr.send opts.data
				return $(xhr)

			post: (url, opts = {}) ->
				if $.is("function",opts)
					opts = success: opts
				opts.method = "POST"
				$.http(url, opts)

			get: (url, opts = {}) ->
				if( $.is("function",opts) )
					opts = success: opts
				opts.method = "GET"
				$.http(url, opts)
	}
$.depends 'hook', ->
	$.hook('bling-init').append (obj) ->
		map = Object.create(null)
		keyMakers = []
		$.inherit {
			index: (keyFunc) ->
				if keyMakers.indexOf(keyFunc) is -1
					keyMakers.push keyFunc
					map[keyFunc] = Object.create(null)
				@each (x) ->
					map[keyFunc][keyFunc(x)] = x
			query: (criteria) ->
				for keyMaker in keyMakers
					key = keyMaker(criteria)
					return map[keyMaker][key] if key of map[keyMaker]
				null
		}, obj

$.plugin
	depends: "dom"
	provides: "lazy"
, ->
	lazy_load = (elementName, props) ->
		$("head").append $.extend document.createElement(elementName), props
	$:
		script: (src) ->
			lazy_load "script", { src: src }
		style: (src) ->
			lazy_load "link", { href: src, rel: "stylesheet" }

$.plugin
	provides: "math"
	depends: "core"
, ->
	$.type.extend
		bool: { number: (o) -> if o then 1 else 0 }
		number: { bool: (o) -> not not o }

	_By = (cmp) ->
		(field) ->
			valueOf = switch $.type field
				when "string" then (o) -> o[field]
				when "function" then field
				else throw new Error ".maxBy first argument should be a string or function"
			x = @first()
			@skip(1).each ->
				if cmp valueOf(@), valueOf(x)
					x = @
			return x

	$:
		range: (start, end, step = 1) ->
			if not end? then (end = start; start = 0)
			$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
		zeros: (n) -> $( 0 for i in [0...n] )
		ones: (n) -> $( 1 for i in [0...n] )
		deg2rad: (n) -> n * Math.PI / 180
		rad2deg: (n) -> n * 180 / Math.PI
	floats: -> @map parseFloat
	ints: -> @map -> parseInt @, 10
	px: (delta) -> @ints().map -> $.px @,delta
	min: -> @filter( isFinite ).reduce Math.min
	max: -> @filter( isFinite ).reduce Math.max
	maxBy: _By (a,b) -> a > b
	minBy: _By (a,b) -> a < b
	mean: mean = -> if not @length then 0 else @sum() / @length
	avg: mean
	sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
	product: -> @filter( isFinite ).reduce (a) -> a * @
	squares: -> @pow(2)
	pow: (n) -> @map -> Math.pow @, n
	magnitude: -> Math.sqrt @floats().squares().sum()
	scale: (r) -> @map -> r * @
	add: add = (d) -> switch $.type(d)
		when "number" then @map -> d + @
		when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
	plus: add
	dot: (b) ->
		$.sum( @[i]*b[i] for i in [0...Math.min(@length,b.length)] )
	vecAdd: (v) ->
		d = $()
		for i in [0...@length] by 1
			d[i] = @[i] + v[i]
		d
	normalize: -> @scale 1 / @magnitude()
	deg2rad: -> @filter( isFinite ).map -> @ * Math.PI / 180
	rad2deg: -> @filter( isFinite ).map -> @ * 180 / Math.PI
$.plugin
	provides: "pubsub"
, ->
	$:
		publish: (e, args...) ->
			f.apply null, args for f in (subscribers[e] or= [])
			args
		publisher: (e, func) ->
			(args...) ->
				$.publish e, func.apply @, args
		subscribe: (e, func) ->
			(subscribers[e] or= []).push func
			func
		unsubscribe: (e, func) ->
			if not func?
				subscribers[e] = []
			else
				a = (subscribers[e] or= [])
				if (i = a.indexOf func)  > -1
					a.splice(i,i)
$.plugin
	provides: 'random'
	depends: 'type'
, ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""

		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615

		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)

			index = (index + 1) % 624
			(y + a) / b

		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()

		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u

$.plugin
	provides: "sendgrid"
	depends: "config"
, ->
	try
		nodemailer = require 'nodemailer'
	catch err
		`return`
	transport = nodemailer.createTransport 'SMTP',
		service: 'SendGrid'
		auth:
			user: $.config.get 'SENDGRID_USERNAME'

	$:
		sendMail: (mail, callback) ->
			mail.transport ?= transport
			mail.from ?= $.config.get 'EMAILS_FROM'
			mail.bcc ?= $.config.get 'EMAILS_BCC'

			if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
				nodemailer.sendMail mail, callback
			else
$.plugin
	provides: "sortBy,sortedIndex"
, ->
	$:
		sortedIndex: (array, item, iterator) ->
			cmp = switch $.type iterator
				when "string" then (a,b) -> a[iterator] - b[iterator]
				when "function" then (a,b) -> iterator(a) - iterator(b)
				else (a,b) -> a - b
			hi = array.length
			lo = 0
			while lo < hi
				mid = (hi + lo)>>>1
				if cmp(array[mid], item) < 0
					lo = mid + 1
				else
					hi = mid
			return lo
	sortBy: (iterator) ->
		a = $()
		for item in @
			n = $.sortedIndex a, item, iterator
			a.splice n, 0, item
		a
	sortedInsert: (item, iterator) ->
		@splice ($.sortedIndex @, item, iterator), 0, item
		@

		
$.plugin
	provides: "string"
	depends: "function"
, ->
	safer = (f) ->
		(a...) ->
			try return f(a...)
	$.type.extend
		unknown:
			string: safer (o) -> o.toString?() ? String(o)
			repr: safer (o) -> $.type.lookup(o).string(o)
			number: safer (o) -> parseFloat String o
		null: { string: -> "null" }
		undefined: { string: -> "undefined" }
		string:
			number: safer parseFloat
		array:  { string: safer (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
		object: { string: safer (o) ->
			ret = []
			for k of o
				try
					v = o[k]
				catch err
			"{" + ret.join(', ') + "}"
		}
		function:
			string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
		number:
			repr:   (n) -> String(n)
			string: safer (n) ->
				switch true
					when n.precision? then n.toPrecision(n.precision)
					when n.fixed? then n.toFixed(n.fixed)
					else String(n)

	return {
		$:
			toString: (x) ->
				if not x? then "function Bling(selector, context) { [ ... ] }"
				else
					try
						$.type.lookup(x).string(x)
					catch err

			toRepr: (x) -> $.type.lookup(x).repr(x)

			px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"



			capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")

			dashize: (name) ->
				ret = ""
				for i in [0...(name?.length|0)]
					c = name.charCodeAt i
					if 91 > c > 64
						c += 32
						ret += '-'
					ret += String.fromCharCode(c)
				ret

			camelize: (name) ->
				name.split('-')
				while (i = name?.indexOf('-')) > -1
					name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
				name

			padLeft: (s, n, c = " ") ->
				while s.length < n
					s = c + s
				s

			padRight: (s, n, c = " ") ->
				while s.length < n
					s = s + c
				s

			stringTruncate: (s, n, c = "...") ->
				s = s.split(' ')
				r = []
				while n > 0
					x = s.shift()
					n -= x.length
					if n >= 0
						r.push x
				r.join('') + c


			stringCount: (s, x, i = 0, n = 0) ->
				if (j = s.indexOf x,i) > i-1
					$.stringCount s, x, j+1, n+1
				else n

			stringSplice: (s, i, j, n) ->
				nn = s.length
				end = j
				if end < 0
					end += nn
				start = i
				if start < 0
					start += nn
				s.substring(0,start) + n + s.substring(end)

			checksum: (s) ->
				a = 1; b = 0
				for i in [0...s.length]
					a = (a + s.charCodeAt(i)) % 65521
					b = (b + a) % 65521
				(b << 16) | a

			repeat: (x, n=2) ->
				switch true
					when n is 1 then x
					when n < 1 then ""
					when $.is "string", x then x + $.repeat(x, n-1)
					else $(x).extend $.repeat(x, n-1)

			stringBuilder: ->
				if $.is("global", @) then return new $.stringBuilder()
				items = []
				@length   = 0
				@append   = (s) => items.push s; @length += s?.toString().length|0
				@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
				@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
				@toString = ( ) => items.join("")
				@
		toString: -> $.toString @
		toRepr: -> $.toRepr @
	}


$.plugin
	provides: "symbol"
	depends: "type"
, ->
	symbol = null
	cache = {}
	g = $.global
	g.Bling = Bling
	if module?
		module.exports = Bling
	$.defineProperty $, "symbol",
		set: (v) ->
			g[symbol] = cache[symbol]
			cache[symbol = v] = g[v]
			g[v] = Bling
		get: -> symbol
	return $:
		symbol: "$"
		noConflict: ->
			Bling.symbol = "Bling"
			Bling
$.plugin
	provides: "StateMachine"
, ->
	$: StateMachine: class StateMachine
		constructor: (stateTable) ->
			@debug = false
			@reset()
			@table = stateTable
			Object.defineProperty @, "modeline",
				get: -> @table[@_mode]
			Object.defineProperty @, "mode",
				set: (m) ->
					@_lastMode = @_mode
					@_mode = m
					if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
						ret = @modeline['enter'].call @
						while $.is("function",ret)
							ret = ret.call @
					m
				get: -> @_mode

		reset: ->
			@_mode = null
			@_lastMode = null

		GO: (m) -> -> @mode = m
		@GO: (m) -> -> @mode = m
		
		tick: (c) ->
			row = @modeline
			if not row?
				ret = null
			else if c of row
				ret = row[c]
			else if 'def' of row
				ret = row['def']
			while $.is "function",ret
				ret = ret.call @, c
			ret

		run: (inputs) ->
			@mode = 0
			for c in inputs
				ret = @tick(c)
			if $.is "function",@modeline?.eof
				ret = @modeline.eof.call @
			while $.is "function",ret
				ret = ret.call @
			@reset()
			return @

$.plugin
	provides: "synth"
	depends: "StateMachine, type"
, ->
	class SynthMachine extends $.StateMachine
		basic =
			".": @GO 3
			"[": @GO 4
			'"': @GO 6
			"'": @GO 7
			" ": @GO 8
			",": @GO 10
			"+": @GO 11
			eof: @GO 13

		@STATE_TABLE = [
				enter: ->
					@tag = @id = @cls = @attr = @val = @text = ""
					@attrs = {}
					@GO 1
			},
				def: (c) -> @tag += c
			}, basic),
				def: (c) -> @id += c
			}, basic),
				enter: -> @cls += " " if @cls.length > 0
				def: (c) -> @cls += c
			}, basic),
				"=": @GO 5
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @attr += c
				eof: @GO 12
			},
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @val += c
				eof: @GO 12
			},
				'"': @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				"'": @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = null
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = @cursor?.parentNode
					@GO 0
			},
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
			}
		]
		constructor: ->
			super(SynthMachine.STATE_TABLE)
			@fragment = @cursor = document.createDocumentFragment()
		emitNode: ->
			if @tag
				node = document.createElement @tag
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@cursor.appendChild node
				@cursor = node
		emitText: ->
			@cursor.appendChild $.type.lookup("<html>").node(@text)
			@text = ""

	return {
		$:
			synth: (expr) ->
				s = new SynthMachine()
				s.run(expr)
				if s.fragment.childNodes.length == 1
					$(s.fragment.childNodes[0])
				else
					$(s.fragment)
	}
do ($ = Bling) ->

		current_engine = null
		engines = {}

		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine

		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()

		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop] by 1
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1

	$.template.register_engine 'pythonic', (() ->

		chunk_re = /%[\(\/]/

		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n] by 1
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}

			if not cache?
			n = cache.length

			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""

		return render
	)()

		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
$.plugin
	provides: "throttle"
	depends: "core"
, ->
	$:
		throttle: (ms, f) ->
			last = 0
			(a...) ->
				gap = $.now - last
				if gap > ms
					last += gap
					return f.apply @,a
				null
		debounce: (ms, f) ->
			last = 0
			(a...) ->
				last += (gap = $.now - last)
				return f.apply @,a if gap > ms else null
	parseOne = (data) ->
		i = data.indexOf ":"
		if i > 0
			len = parseInt data[0...i], 10
			item = data[i+1...i+1+len]
			type = data[i+1+len]
			extra = data[i+len+2...]
			item = switch type
				when "'" then String(item)
				when "!" then (item is "true")
				when "~" then null
				when "]" then parseArray(item)
				when "}" then parseObject(item)
			return [item, extra]
		return undefined
	parseArray = (x) ->
		data = []
		while x.length > 0
			[one, x] = parseOne(x)
			data.push(one)
		data
	parseObject = (x) ->
		data = {}
		while x.length > 0
			[key, x] = parseOne(x)
			[value, x] = parseOne(x)
			data[key] = value
		data
	$:
		TNET:
			stringify: (x) ->
				[data, type] = switch $.type x
					when "string" then [x, "'"]
					when "function" then [String(x), "'"]
					when "boolean" then [String(not not x), "!"]
					when "null" then ["", "~"]
					when "undefined" then ["", "~"]
					when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
					when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
				return (data.length|0) + ":" + data + type
			parse: (x) ->
				parseOne(x)?[0]
$.plugin
	provides: "trace"
	depends: "function,type"
, ->
	$.type.extend
		unknown: { trace: $.identity }
		function:
			trace: (label, f, tracer) ->
				label or= f.name
				r = (a...) ->
					f.apply @, a
				r
	return $: trace: (label, o, tracer) ->
		if not $.is "string", label
			[tracer, o] = [o, label]
		tracer or= $.log
		label or= ""
		$.type.lookup(o).trace(label, o, tracer)
$.plugin
	depends: "dom"
, ->
	COMMASEP = ", "
		"slow": 700
		"medium": 500
		"normal": 300
		"fast": 100
		"instant": 0
		"now": 0
	accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
	testStyle = document.createElement("div").style

	transformProperty = "transform"
	transitionProperty = "transition-property"
	transitionDuration = "transition-duration"
	transitionTiming = "transition-timing-function"

	if "WebkitTransform" of testStyle
		transformProperty = "-webkit-transform"
		transitionProperty = "-webkit-transition-property"
		transitionDuration = "-webkit-transition-duration"
		transitionTiming = "-webkit-transition-timing-function"
	else if "MozTransform" of testStyle
		transformProperty = "-moz-transform"
		transitionProperty = "-moz-transition-property"
		transitionDuration = "-moz-transition-duration"
		transitionTiming = "-moz-transition-timing-function"
	else if "OTransform" of testStyle
		transformProperty = "-o-transform"
		transitionProperty = "-o-transition-property"
		transitionDuration = "-o-transition-duration"
		transitionTiming = "-o-transition-timing-function"

	return {
		$:
			duration: (speed) ->
				d = speeds[speed]
				return d if d?
				return parseFloat speed

		transform: (end_css, speed, easing, callback) ->

			if $.is("function",speed)
				callback = speed
				speed = easing = null
			else if $.is("function",easing)
				callback = easing
				easing = null
			speed ?= "normal"
			easing or= "ease"
			duration = $.duration(speed) + "ms"
			props = []
			trans = ""
			css = {}
			for i of end_css
				if accel_props_re.test(i)
					ii = end_css[i]
					if ii.join
						ii = $(ii).px().join COMMASEP
					else if ii.toString
						ii = ii.toString()
					trans += " " + i + "(" + ii + ")"
				else css[i] = end_css[i]
			(props.push i) for i of css
			if trans
				props.push transformProperty

			css[transitionProperty] = props.join COMMASEP
			css[transitionDuration] = props.map(-> duration).join COMMASEP
			css[transitionTiming] = props.map(-> easing).join COMMASEP

			if trans
				css[transformProperty] = trans
			@css css
			@delay duration, callback

			@each ->
				if @style
					if @style.display is not "none"
						@_display = @syle.display
					@style.display = "none"
			.trigger "hide"
			.delay updateDelay, callback

			@each ->
				if @style
					@style.display = @_display
					delete @_display
			.trigger "show"
			.delay updateDelay, callback

			@weave(@css("display"))
				.fold (display, node) ->
					if display is "none"
						node.style.display = node._display or ""
						delete node._display
						$(node).trigger "show"
					else
						node._display = display
						node.style.display = "none"
						$(node).trigger "hide"
					node
				.delay(updateDelay, callback)

			@.css('opacity','0.0')
				.show ->
					@transform {
						opacity:"1.0",
						translate3d: [0,0,0]
					}, speed, callback
			@transform {
				opacity:"0.0",
				translate3d:[x,y,0.0]
			}, speed, -> @hide(callback)
		fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
		fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
		fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
		fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
	}
$.plugin
	provides: "type"
, ->


	isType = (T, o) ->
		if not o? then T in [o,"null","undefined"]
		else o.constructor is T or
			o.constructor.name is T or

	inherit = (parent, obj) ->
		if typeof parent is "function"
			parent = parent.prototype
		if parent.__proto__ is Object.prototype
			parent.__proto__ = obj.__proto__
		obj.__proto__ = parent
		obj

	_type = do ->

		cache = {}

		base =
			name: 'unknown'
			match: (o) -> true

		order = []

		register = (name, data) ->
			order.unshift name if not (name of cache)
			cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
			cache[name][name] = (o) -> o

		_extend = (name, data) ->
			if typeof name is "string"
				cache[name] ?= register name, {}
				cache[name] = extend cache[name], data
			else if typeof name is "object"
				(_extend k, name[k]) for k of name

		lookup = (obj) ->
			for name in order
				if cache[name]?.match.call obj, obj
					return cache[name]

		register "unknown",   base
		register "object",    match: -> typeof @ is "object"
		register "error",     match: -> isType 'Error', @
		register "regexp",    match: -> isType 'RegExp', @
		register "string",    match: -> typeof @ is "string" or isType String, @
		register "number",    match: -> (isType Number, @) and @ isnt NaN
		register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
		register "array",     match: -> Array.isArray?(@) or isType Array, @
		register "function",  match: -> typeof @ is "function"
		register "undefined", match: (x) -> x is undefined
		register "null",      match: (x) -> x is null

		return extend ((o) -> lookup(o).name),
			register: register
			lookup: lookup
			extend: _extend
			is: (t, o) -> cache[t]?.match.call o, o
			as: (t, o, rest...) -> lookup(o)[t]?(o, rest...)



	_type.extend
		unknown:   { array: (o) -> [o] }

		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }

	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) -> o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"

	$:
		inherit: inherit
		extend: extend
		defineProperty: (o, name, opts) ->
			Object.defineProperty o, name, extend({ configurable: true, enumerable: true }, opts)
			o
		isType: isType
		type: _type
		is: _type.is
		as: _type.as
		isSimple: (o) -> _type(o) in ["string", "number", "bool"]
		isEmpty: (o) -> o in ["", null, undefined] or o.length is 0 or (typeof o is "object" and Object.keys(o).length is 0)
	defineProperty: (name, opts) -> @each -> $.defineProperty @, name, opts
$.plugin
	provides: "unittest"
	depends: "core,function"
, ->
	testCount = passCount = failCount = 0
	failed = []
	invokeTest = (group, name, func) ->
		return if not $.is "function", func
		shouldFail = name.toLowerCase().indexOf("fail") isnt -1
		done = $.once (err) ->
			testCount--
			if (!!err isnt shouldFail)
				failCount++
				failed.push name
			else
				_log "pass"
				passCount++
				$.provide name
		f = (done) ->
			try func(done)
			catch err then done(err)
			finally
				if name.toLowerCase().indexOf("async") is -1 then done()
		testCount++
		try f(done)
		catch err then done(err)

	testReport = $.once ->
		if failCount > 0
			try process.exit(failCount)

	$:
		approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
		assertEqual: (a, b, label) ->
			if a isnt b
		assertArrayEqual: (a, b, label) ->
			for i in [0...a.length] by 1
				try
					$.assertEqual(a[i], b[i], label)
				catch err
		testGroup: (name, funcs) ->
			interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
			for k,func of funcs
				invokeTest(name, k, func)
	assertEqual: (args...) ->
				if $.is "function", x then x.call(@,@) else x
			a = args[0]
			for i in [1...args.length]
				$.assertEqual a, args[i]
		return @
dom = require("jldom")
dom.registerGlobals(global)
global.document = dom.createDocument()
global.window = global
require "../dist/bling.js"
assert = require 'assert'
document.body.innerHTML = """
	<table>
		<tr><td>1,1</td><td>1,2</td></tr>
		<tr><td>2,1</td><td>2,2</td></tr>
		<tr><td>3,1</td><td class='d'>3,2</td></tr>
		<tr><td>4,1</td><td>4,2</td></tr>
	</table>
	<div class='c'>C</div>
	<p><span>foobar</span></p>
"""

describe "Object", ->
	it "should have a keys method", ->
		assert typeof Object.keys is "function"
	it "should have a values method", ->
		assert typeof Object.values is "function"
	describe ".keys()", ->
		it "should return the list of keys", ->
			assert.deepEqual Object.keys( "a": 1, b: 2 ), ['a', 'b']
	describe ".values()", ->
		it "should return the list of values", ->
			assert.deepEqual Object.values( "a": 1, b: 2 ), [1, 2]

describe "Bling", ->
	it "should have a symbol with side effects", ->
		assert Bling?
		assert.equal Bling.symbol, "$"
		assert.equal global.$, Bling
		Bling.symbol = "_"
		assert.equal global._, Bling
		global.$ = "before"
		Bling.symbol = "$"
		assert.equal global.$, Bling
		Bling.symbol = "_"
		assert.equal global.$, "before"
		Bling.symbol = "$"
		assert.equal global.$, Bling
	it "should be constructable by call (python style)", ->
		b = Bling([1,2,3])
		assert.equal b[0], 1
		assert.equal b[1], 2
		assert.equal b[2], 3
	it "should have have the right constructor name", ->
		assert.equal Bling([1,2]).constructor.name, "Bling"
	it "should correct the length value", ->
		assert.equal(Array(10).length,10)
		assert.equal(Bling(10).length, 0)

	it "can be created from an array", ->
		assert.deepEqual $([1,2,3]), [1,2,3]
	it "can be created from multiple arguments", ->
		assert.deepEqual $(1,2,3), [1,2,3]
	it "can be created from CSS selector", ->
		assert.equal $("td").length, 8

	describe ".type()", ->
		describe "should classify", ->
			it "'string'", -> assert.equal $.type(''), 'string'
			it "'number'", -> assert.equal $.type(42), 'number'
			it "'undefined'", -> assert.equal $.type(), "undefined"
			it "'null'", -> assert.equal $.type(null), "null"
			it "'array'", -> assert.equal $.type([]), "array"
			it "'function'", -> assert.equal $.type(->), "function"
			it "'bool'", -> assert.equal $.type(true), "bool"
			it "'regexp'", -> assert.equal $.type(//), "regexp"
			it "'window'", -> assert.equal $.type(window), "global"

	describe ".is()", ->
		describe "should identify", ->
			it "'array'", -> assert $.is "array", []
			it "'function'", -> assert $.is "function", ->

	describe ".inherit(a,b)", ->
		a = a: 1
		b = b: 2
		$.inherit a, b
		it "should set b's __proto__ to a", ->
			assert.equal b.__proto__, a
		it "b should inherit properties from a", ->
			assert.equal b.a, 1
		it "but b should not own those properties", ->
			assert not b.hasOwnProperty "a"

	describe ".extend(a,b)", ->
		a = a: 1
		b = b: 2
		c = $.extend a, b
		it "should return the modified a", -> assert.equal c, a
		it "should give a properties from b", -> assert.equal a.b, 2
		it "should copy those properties", ->
			a.b = 3
			assert.equal b.b, 2

	describe ".defineProperty()", ->
		describe "getters", ->
			a = {}
			$.defineProperty a, "getter",
				get: -> 2
			it "should be readable", ->
				assert.equal a.getter, 2
			it "should not be settable", ->
				a.getter = 3
				assert.equal a.getter, 2
			it "should be enumerable", ->
				assert.notEqual -1, Object.keys(a).indexOf("getter")
			it "should be configurable"
		describe "setters", ->
			a = {}
			$.defineProperty a, "setter",
				set: (v) ->
			it "should be settable", ->
				a.setter = 10
			it "should not be gettable", ->
				assert.equal a.setter, undefined
			it "should be enumerable", ->
				assert.notEqual -1, Object.keys(a).indexOf("setter")

	describe ".isType()", ->
		it "should compare against actual types", ->
			assert $.isType Array, []
		it "or against names of constructors", ->
			assert( $.isType('Array', []) )
		it "should work on non-builtin types", ->
			class Foo
			f = new Foo()
			assert $.isType Foo, f

	describe ".isSimple()", ->
		describe "should accept", ->
			it "strings", -> assert $.isSimple ""
			it "numbers", -> assert $.isSimple 42.0
			it "bools", -> assert( $.isSimple false )
		describe "should reject", ->
			it "objects", -> assert not $.isSimple {}
			it "arrays", -> assert not $.isSimple []

	describe ".isEmpty()", ->
		describe "should accept", ->
			it "empty strings", -> assert $.isEmpty ""
			it "nulls", -> assert $.isEmpty null
			it "undefineds", -> assert $.isEmpty undefined
			it "empty arrays", -> assert $.isEmpty []
			it "empty objects", -> assert $.isEmpty {}
		describe "should reject", ->
			it "full strings", -> assert not $.isEmpty "abc"
			it "arrays with items", -> assert not $.isEmpty [1,2,3]
			it "objects with keys", -> assert not $.isEmpty a:1

	describe ".toArray()", ->
		a = $([1,2,3])
		b = a.toArray()
		it "should produce an Array", ->
			assert.equal b.constructor.name, "Array"
		it "should preserve data", ->
			assert.equal b[1], 2
		it "should preserve length", ->
			assert.equal b.length, 3
		it "should not preserve bling functions", ->
			assert not b.zap

	describe ".as()", ->
		describe "should convert", ->
			it "strings to numbers", -> assert.equal ($.as "number", "1234"), 1234

	describe ".identity", ->
		it "should be a function", -> assert $.is "function", $.identity
		it "should echo anything", -> assert.equal $.identity(a = {}), a

	describe ".bound", ->
		f = -> @value
		a = value:'a'
		b = value:'b'
		it "binding to a should return a's value", ->
			assert.equal do $.bound(a, f), 'a'
		it "binding to b should return b's value", ->
			assert.equal do $.bound(b, f), 'b'

	describe ".trace", ->
		f = -> 42
		h = $.trace "label", f, (a...) ->
			g.push a.join ''
		it "should not trace the original function", ->
			f()
		it "should trace the returned function", ->
			assert.deepEqual g, [ "global.label('one','two')" ]

	describe ".px()", ->
		describe "converts ... to pixel strings", ->
			it "integers", -> assert.equal $.px(100), "100px"
			it "floats", -> assert.equal $.px(-100.0), "-100px"
			it "negatives", -> assert.equal $.px(-100.0), "-100px"
			it "pixel strings", -> assert.equal $.px("100.0px"), "100px"

	describe ".padLeft()", ->
		it "adds padding when needed", ->
			assert.equal $.padLeft("foo", 5), "  foo"
		it "does not add padding when not needed", ->
			assert.equal $.padLeft("foo", 2), "foo"
		it "does not add padding when barely not needed", ->
			assert.equal $.padLeft("foo", 3), "foo"
		it "can pad with non-default character", ->
			assert.equal $.padLeft("foo", 5, "X"), "XXfoo"

	describe ".padRight()", ->
		it "adds padding when needed", -> assert.equal $.padRight("foo", 5), "foo  "
		it "doesnt when not", -> assert.equal $.padRight("foo", 2), "foo"
		it "doesnt when not", -> assert.equal $.padRight("foo", 3), "foo"
		it "can pad with non-default character", -> assert.equal $.padRight("foo", 5, "X"), "fooXX"

	describe ".stringSplice()", ->
		it "should insert text", ->
			assert.equal $.stringSplice("foobar",3,3,"baz"), "foobazbar"
		it "should partially replace text", ->
			assert.equal $.stringSplice("foobar",1,5,"baz"), "fbazr"
		it "should completely replace text", ->
			assert.equal $.stringSplice("foobar",0,6,"baz"), "baz"
		it "should prepend text", ->
			assert.equal $.stringSplice("foobar",0,0,"baz"), "bazfoobar"

	describe ".checkSum()", ->
		it "should compute the same hash as adler32", ->
			assert.equal $.checksum("foobar"), 145425018
		it "should not just hash the one thing", ->
			assert.equal $.checksum("foobarbaz"), 310051767

	describe ".toString()", ->
		describe "should output", ->
			it "blings", ->
				assert.equal $([2,3,4]).toString(), "$([2, 3, 4])"
			it "functions", ->
				assert.equal $.toString(-> $.log), "function () { ... }"
			it "objects", ->assert.equal $.toString({a:{b:1}}), "{a:{b:1}}"
		it "should not fail", ->
			obj = a: 1
			$.defineProperty obj, 'xxx',
				get: -> throw new Error "forbidden"
			assert.equal $.toString(obj), "{a:1, xxx:[Error: forbidden]}"

	describe ".stringTruncate()", ->
		it "should truncate long strings and add ellipses", ->
			assert.equal ($.stringTruncate "long string", 6), "long..."

	describe ".plugin()", ->
		describe "creating new plugins", ->
			$.plugin ->
				$:
					testGlobal: -> 9
				testOp: -> 42
			it "should define new globals", ->
				assert.equal $.testGlobal?(), 9
			it "should define new instance methods", ->
				assert.equal $().testOp?(), 42
			it "should provide a default global wrapper", ->
				assert.equal $.testOp?(), 42

	describe ".avg()", ->
		it "average of an empty set is 0", ->
			assert.equal $([]).avg(), 0
		it "should compute the average", ->
			assert.equal $([1,2,3,4]).avg(), 2.5
		it "should be aliased as .mean()", ->
			assert.equal $.prototype.avg, $.prototype.mean

	describe ".sum()", ->
		it "should add an empty set as 0", ->
			assert.equal $([]).sum(), 0
		it "should compute the sum", ->
			assert.equal $([1,2,3,4,5]).sum(), 15
		it "should ignore non-numbers", ->
			assert.equal($([1,2,NaN,3]).sum(), 6)

	describe ".range(start,end)", ->
		it "should produce a sequence of ints from start to end", ->
			assert.equal($.range(1,6).toRepr(), '$([1, 2, 3, 4, 5])')
		it "start is optional, defaults to 0", ->
			assert.equal($.range(5).toRepr(), '$([0, 1, 2, 3, 4])')

	describe ".zeros()", ->
		it "should produce a set", ->
			assert $.is 'bling', $.zeros 10
		it "should produce all zeros", ->
			assert.equal 0, $.zeros(10).sum()

	describe ".ones()", ->
		it "should produce a set of ones", ->
			assert.equal $.ones(10).sum(), 10

	describe ".floats()", ->
		it "should convert everything to floats", ->
			assert.equal $(["12.1","29.9"]).floats().sum(), 42

	describe ".ints()", ->
		it "should convert everything to ints", ->
			assert.equal $(["12.1","29.9px"]).ints().sum(), 41

	describe ".px()", ->
		it "should convert everything to -px strings (for CSS)", ->
			assert.equal $(["12.1", "29.9"]).px(2).toRepr(), "$(['14px', '31px'])"

	describe ".min()", ->
		it "should return the smallest item", ->
			assert.equal $([12.1, 29.9]).min(), 12.1
		it "should ignore non-numbers", ->
			assert.equal( $([12.1, NaN, 29.9]).min(), 12.1)
		it "should return 0 for an empty set?"

	describe ".max()", ->
		it "should return the largest item", -> assert.equal( $([12.1, 29.9]).max(), 29.9)
		it "should ignore non-numbers", -> assert.equal( $([12.1, NaN, 29.9]).max(), 29.9)
		it "should return Infinity for an empty set?"
	
	describe ".dot()", ->
		it "computes the dot-product", ->
			assert.equal( $([1,2,3]).dot([4,5,6]), 4 + 10 + 18)

	describe ".maxBy()", ->
		it "should return the largest item", ->
			assert.deepEqual $( {a:1}, {a:3}, {a:2} ).maxBy('a'), a:3
		it "accepts a value function", ->
			assert.deepEqual $( {a:1}, {a:3}, {a:2} ).maxBy((o) -> Math.pow(o.a,2)), a:3
	
	describe ".minBy()", ->
		it "should return the smallest item", ->
			assert.deepEqual $( {a:3}, {a:1}, {a:2} ).minBy('a'), a:1
		it "accepts a value function", ->
			assert.deepEqual $( {a:1}, {a:3}, {a:2} ).minBy((o) -> Math.pow(o.a,2)), a:1
	
	describe ".product()", ->
		it "computes the product of everything (like .sum() with *)", ->
			assert.equal $(2,4,6).product(), 48
	
	describe ".squares()", ->
		it "squares everything", -> assert.deepEqual $(2,4,6).squares(), [4, 16, 36]
	
	describe ".pow(n)", ->
		it "maps Math.pow", -> assert.deepEqual $(2,4,6).pow(3), [8,64,6*6*6]
	
	describe ".magnitude()", ->
		it "computes the vector length", -> assert.equal $(2,4,6).magnitude(), 7.483314773547883
	
	describe ".scale(r)", ->
		it "mulitiplies everything by a constant factor", -> assert.deepEqual $(2,4,6).scale(3), [6,12,18]
	
	describe ".add(n)", ->
		it "does vector addition (with a scalar)", ->
			assert.deepEqual $(2,4,6).add(2), [4,6,8]
		it "adds two vectors", ->
			assert.deepEqual $(2,4,6).add([3,5,9]), [5,9,15]
		it "truncates the longer vector if mis-sized", ->
			assert.deepEqual $(2,4,6,8).add([3,5,9]), [5,9,15]
	
	describe ".normalize()", ->
		it "scales so that .magnitude() is 1", -> assert.equal $(2,4,6).normalize().magnitude(), 1
	
	describe ".deg2rad()", ->
		it "works as a global", -> assert.equal $.deg2rad(180), Math.PI
		it "works on a set", -> assert.deepEqual $(0,180).deg2rad(), [0, Math.PI]
	describe ".rad2deg()", ->
		it "works as a global", -> assert.equal $.rad2deg(Math.PI), 180
		it "works on a set", -> assert.deepEqual $(0,Math.PI).rad2deg(), [0, 180]

	describe ".random()", ->
		assert 0.0 < $.random() < 1.0
		describe ".real()", ->
			r = $.random.real 10,100
			it "should produce a number", ->
				assert $.is 'number', r
			it "is in the range", ->
				assert 10.0 < r < 100.0
		describe ".integer()", ->
			r = $.random.integer(3,9)
			it "should be an integer", ->
				assert.equal Math.floor(r), r
			it "is in the range", ->
				assert 3 <= r <= 9
		describe ".string()", ->
			s = $.random.string(16)
			it "is a string", ->
				assert $.is 'string', s
			it "has the right length", ->
				assert.equal s.length, 16
		describe ".seed()", ->
			$.random.seed = 42
			r = $.random.string(16)
			$.random.seed = 43
			s = $.random.string(16)
			$.random.seed = 42
			t = $.random.string(16)
			it "should produce same output for the same seed", ->
				assert.equal r, t
			it "should produce different output for a new seed", ->
				assert.notEqual r, s

	describe ".hash()", ->
		describe "hashes any type of object", ->
			it "number", -> assert $.hash(42) isnt $.hash(43)
			it "string", -> assert $.hash("foo") isnt $.hash("bar")
			it "array", -> assert $.hash("poop") isnt $.hash(["poop"])
			it "object", -> assert ($.hash a:1) isnt ($.hash a:2)
			it "bling", -> assert ($.hash $)?
		describe "always produces finite hashes", ->
			it "for objects", -> assert isFinite $.hash a:1
			it "for empty objects", -> assert isFinite $.hash {}
		describe "the order of elements matters", ->
			it "in arrays", -> assert.notEqual $.hash(["a","b"]), $.hash(["b","a"])
			it "in objects", -> assert.notEqual $.hash({}), $.hash []
			it "in blings", -> assert.notEqual $.hash($(["a","b"])), $.hash $(["b","a"])

	describe ".hook()", ->
		it "is a function", ->
			assert $.is 'function', $.hook
		it "returns a hook with append/prepend", ->
			p = $.hook('unit-test')
			assert $.is 'function', p.append
			assert $.is 'function', p.prepend
		it "computes values when called", ->
			$.hook('unit-test').append (x) -> x += 2
			$.hook('unit-test').prepend (x) -> x *= 2
			assert.equal $.hook('unit-test', 4), 10

	describe ".eq()", ->
		it "selects a new set with only one element", ->
			assert.equal $([1,2,3]).eq(1)[0], 2

	describe ".each(f)", ->
		it "repeats f for each element", ->
			check = 0
			$([1,2,3]).each -> check += 1
			assert.equal check, 3

	describe ".map(f)", ->
		it "returns a new set", ->
			a = $([1,2,3])
			b = a.map (->)
			assert.notEqual a,b
		it "containing the results of f(each item)", ->
			assert.deepEqual $([1,2,3]).map(->@*@), [1,4,9]
	
	describe ".filterMap(f)", ->
		it "works like map, but can omit some results", ->
			assert.deepEqual $(1,2,3,4).filterMap(->
				if @ % 2 then @*@
				else null
			), [1, 9]
	
	describe ".replaceWith", ->
		it "copies values from array to this", ->
			assert.deepEqual $(1,2,3,4).replaceWith([5,6,7,8]), [5,6,7,8]
		it "does not create a new Bling", ->
			d = $(1,2,3,4)
			e = d.replaceWith([5,6,7])
			assert.deepEqual d, [5,6,7,4]

	describe ".coalesce()", ->
		it "should return the first non-null item", ->
			assert.equal $.coalesce(null, 42, 22), 42
		it "should accept an array as argument", ->
			assert.equal($.coalesce([null, 14, 42]), 14)
		it "should descend arrays if nested", ->
			assert.equal($.coalesce([null, [null, 14], 42]), 14)
		it "should span arrays if given multiple", ->
			assert.equal $.coalesce([null, null], [null, [null, 14], 42]), 14

	describe ".reduce()", ->
		it "applies a combiner to accumulate a single result", ->
			assert.equal $([1,2,3,4]).reduce( (a,x) -> a + x ), 10

	describe ".union()", ->
		it "combines two sets, eliminating duplicates", ->
			assert.deepEqual $([1,2,3,4]).union([2,3,4,5]), [1,2,3,4,5]

	describe ".intersect()", ->
		it "combines two sets, leaving only the duplicates", ->
			assert.deepEqual($([1,2,3,4]).intersect([2,3,4,5]), [2,3,4])

	describe ".distinct()", ->
		it "removes duplicates from a single set", ->
			assert.deepEqual($([1,2,2,3,4,3]).distinct(), [1,2,3,4])

	describe ".contains()", ->
		it "returns true if an item is found in the set", ->
			assert $([1,2,3]).contains 3
		it "returns false if an item is not found", ->
			assert not $([1,2,3]).contains 4

	describe ".count()", ->
		it "returns the number of matching items, if given an item", ->
			assert.equal $([1,2,2,3,4,3]).count(3), 2
		it "returns the total count if no item is given", ->
			assert.equal $([1,2,2,3,4,3]).count(), 6

	describe ".select()", ->
		it "extracts values from properties of items in a set", ->
			assert.deepEqual $([ {id:1}, {id:2}, {id:3} ]).select('id'), [1,2,3]
		it "supports nested property names", ->
			assert.deepEqual $([
				{a:{b:2}},
				{a:{b:4}},
				{a:{b:6}}
			]).select("a.b"), [2,4,6]
		it "supports nesting into arrays", ->
			assert.deepEqual $([
				{a:[{b:3}]},
				{a:[{b:6}]},
				{a:[{b:9}]}
			]).select("a.0.b"), [3,6,9]

	describe ".zap()", ->
		it "assigns values to properties of items in a set", ->
			assert.deepEqual $([ {id:1}, {id:2}, {id:3} ]).zap('id', 13).select('id'), [13,13,13]
		it "supports using a function to compute the assigned values", ->
			assert.deepEqual $([ {id:1}, {id:2}, {id:3} ]).zap('id', -> @ * 2).select('id'), [2,4,6]
		it "supports nested property names", ->
			assert.deepEqual $([ {sub:{id:1}}, {sub:{id:2}}, {sub:{id:3}} ]).zap('sub.id', -> @*2).select('sub.id'), [2,4,6]

	describe ".take()", ->
		it "take0", -> assert.deepEqual $([1,2,3,4]).take(0), []
		it "take1", -> assert.deepEqual $([1,2,3,4]).take(1), [1]
		it "take2", -> assert.deepEqual $([1,2,3,4]).take(2), [1,2]
		it "take3", -> assert.deepEqual $([1,2,3,4]).take(3), [1,2,3]
		it "take4", -> assert.deepEqual $([1,2,3,4]).take(4), [1,2,3,4]
		it "take5", -> assert.deepEqual $([1,2,3,4]).take(5), [1,2,3,4]

	describe ".skip()", ->
		it "skip0", -> assert.deepEqual $([1,2,3,4]).skip(0), [1,2,3,4]
		it "skip1", -> assert.deepEqual $([1,2,3,4]).skip(1), [2,3,4]
		it "skip2", -> assert.deepEqual $([1,2,3,4]).skip(2), [3,4]
		it "skip3", -> assert.deepEqual $([1,2,3,4]).skip(3), [4]
		it "skip4", -> assert.deepEqual $([1,2,3,4]).skip(4), []
		it "skip5", -> assert.deepEqual $([1,2,3,4]).skip(5), []

	describe ".first()", ->
		a = $([1,2,3,4])
		it "returns a single element", -> assert.equal a.first(), 1
		it "acts like take", -> assert.deepEqual a.first(5), [1,2,3,4]
		it "acts like take", -> assert.deepEqual a.first(2), [1,2]
		it "acts like take", -> assert.deepEqual a.first(0), []

	describe ".last()", ->
		a = $([1,2,3,4])
		it "returns last element", -> assert.equal a.last(), 4
		it "returns multiple if asked", -> assert.deepEqual a.last(5), [1,2,3,4]
		it "returns multiple if asked", -> assert.deepEqual a.last(2), [3,4]
		it "returns multiple if asked", -> assert.deepEqual a.last(0), []

	describe ".slice()", ->
		a = $([1,2,3,4,5])
		it "slice1", -> assert.deepEqual $([1,2,3,4,5]).slice(0,5), [1,2,3,4,5]
		it "slice2", -> assert.deepEqual $([1,2,3,4,5]).slice(1,5), [2,3,4,5]
		it "slice3", -> assert.deepEqual $([1,2,3,4,5]).slice(2,5), [3,4,5]
		it "slice4", -> assert.deepEqual $([1,2,3,4,5]).slice(3,5), [4,5]
		it "slice5", -> assert.deepEqual $([1,2,3,4,5]).slice(4,5), [5]
		it "slice6", -> assert.deepEqual $([1,2,3,4,5]).slice(1,-2), [2,3]
		it "slice7", -> assert.deepEqual $([1,2,3,4,5]).slice(-1,-3), [5,4]
		it "slice8", -> assert.deepEqual $([1,2,3,4,5]).slice(-1,-4), [5,4,3]

	describe ".push()", ->
		it "appends to the set", ->
			assert.deepEqual $([1,2]).push(3), [1,2,3]
		it "overrides Array::push()", ->
			assert.notEqual Array::push, Bling::push
		it "returns the resulting set", ->
			assert $.is 'bling', $([1,2]).push(3)

	describe ".filter()", ->
		it "filters by a function", -> assert.deepEqual $([1,2,3,4,5]).filter((x) -> x % 2), [1,3,5]
		it "supports regular expressions", -> assert.deepEqual $(["foo","bar","baz"]).filter(/^ba/), ["bar","baz"]
		it "can chain DOM filters", -> assert.equal $("*").filter("td").filter(".d").length, 1
		it "filters might remove all nodes", -> assert.equal $("*").filter("td").filter(".none").length, 0
		it "filters DOM nodes by CSS selector", -> assert.deepEqual $("*").filter("td").length, 8

	describe ".matches()", ->
		describe "supports", ->
			it "CSS selectors", ->
				assert.deepEqual $("td").matches(".d"), [false,false,false,false,false,true,false,false]
			it "regular expressions", ->
				assert.deepEqual $(["one","two","three"]).matches(/o/), [true, true, false]

	describe ".weave()", ->
		it "interleaves items from two sets", ->
			assert.deepEqual($([1,1,1]).weave([2,2,2]), [2,1,2,1,2,1])
		it "supports blinged arguments", ->
			assert.deepEqual($([1,1,1]).weave($([2,2,2])), [2,1,2,1,2,1])

	describe ".querySelectorAll()", ->
		it "queries children for DOM nodes", ->
			assert.deepEqual($("tr").querySelectorAll("td.d")[0].className, "d")

	describe ".fold()", ->
		it "is like a partial reduce", ->
			assert.deepEqual $([1,1,1]).weave([2,2,2]).fold( (a,b) -> a+b ), [3,3,3]
		it "returns half the items", ->
			assert.deepEqual $([1,2,3,4,5,6]).fold( (a,b) -> a+b ).length, 3

	describe ".flatten()", ->
		it "combines subsets", ->
			assert.deepEqual $([[1,2],[3,4]]).flatten(), [1,2,3,4]
		it "allows duplicates (unlike union)", ->
			assert.deepEqual $([[1,2],[1,2]]).flatten(), [1,2,1,2]

	describe ".call()", ->
		it "calls every function in the set", ->
			assert.deepEqual $([((x) -> x*2), ((x) -> x*x)]).call(4), [8, 16]
		it "skips non-functions", ->
			assert.deepEqual $([((x) -> x*2), NaN, ((x) -> x*x)]).call(4), [8, 16]

	describe ".apply()", ->
		it "calls every function in the set, with a specific context", ->
			assert.deepEqual($([((x) -> @+x), ((x) -> @*x)]).apply(4,[2]), [6, 8])

	describe ".keysOf()", ->
		it "is like Object.keys", ->
			assert.deepEqual $.keysOf(a:1), ['a']
		it "returns a bling", ->
			assert $.is 'bling', $.keysOf(a:1)
		it "includes any enumerable property", ->
			a = a: 1
			$.defineProperty a, "b", get: -> 2
			assert.deepEqual $.keysOf(a), ["a", "b"]

	describe ".valuesOf()", ->
		it "returns a bling", ->
			assert $.is 'bling', $.valuesOf(a:1)
		it "returns the set of values", ->
			assert.deepEqual $.valuesOf(a:1), [1]
		it "includes any enumerable properties", ->
			a = a: 1
			$.defineProperty a, "b", get: -> 2
			assert.deepEqual $.valuesOf(a), [1, 2]

	describe "EventEmitter", ->
		it "works", ->
			a = $.EventEmitter a:1
			v = false
			a.on "event", -> v = true
			a.emit "event"
			assert v
		it "works on new blings automatically", ->
			b = $()
			v = false
			b.on "event", -> v = true
			b.emit "event"
			assert v
		it "provides (almost) the same API as node's EventEmitter", ->
			b = $()
			["addListener", "emit", "listeners", "on", "removeAllListeners", "removeListener", "setMaxListeners"].forEach (k) ->
				assert $.is 'function', b[k]
		it "can bless an object in-place", ->
			a = a:1
			b = $.EventEmitter(a)
			assert $.is 'function', a.emit
			assert $.is 'function', b.emit
		it "does not leak listeners", ->
			a = $.EventEmitter a:1
			a.on "smoke", -> "fire"
			a.on "smoke", -> "flee"
			assert.equal a.listeners("smoke").length, 2
			a.listeners("smoke").push("water")
			assert.equal a.listeners("smoke").length, 2
		describe "class extends support", ->
			class Foo extends $.EventEmitter
				constructor: ->
					super @
					@x = 1
				method: ->
			f = new Foo()
			it "gives new instances the EE interface", ->
				assert.equal $.type(f.on), "function"
			it "does not clobber instance methods", ->
				assert.equal $.type(f.method), "function"
			it "does not clobber instance properties", ->
				assert.equal $.type(f.x), "number"
			it "works", ->
				flag = false
				f.on 'event', -> flag = true
				f.emit 'event'
				assert.equal flag, true
			describe "inheritance chain", ->
				class A extends $.EventEmitter
					A: ->
				class B extends A
					B: ->
				class C extends B
					constructor: ->
						super(@)
				a = new A()
				b = new B()
				c = new C()
				it "goes through one level", ->
					assert.equal $.type(a.on), "function"
				it "goes through two levels", ->
					assert.equal $.type(b.on), "function"
				it "goes through three levels", ->
					assert.equal $.type(c.on), "function"


	describe ".date", ->
		it "adds the 'date' type", ->
			assert $.is 'date', new Date(0)
		describe 'converts', ->
			it "date to string", ->
				assert.equal ($.as "string", new Date 1,2,3,4,5,6), "1901-03-03 09:05:06"
			it "string to date", ->
				assert.equal ($.as "date", "1901-03-03 09:05:06").toString(), new Date(1,2,3,4,5,6).toString()
			it "date to number", ->
				assert.equal ($.as "number", new Date 1,2,3,4,5,6), -2172149694
			it "number to date", ->
				assert.equal ($.as "date", -2172149694).toString(), (new Date 1,2,3,4,5,6).toString()
		describe ".stamp()", ->
			describe "converts date objects to numbers (with units)", ->
				it "ms", -> assert $.date.stamp(new Date(1000000), "ms") is 1000000
				it "seconds", -> assert $.date.stamp(new Date(1000000), "s") is 1000
		describe ".unstamp()", ->
			it "converts a number to a real date", ->
				assert $.is 'date', $.date.unstamp 0
			it "is the reverse of stamp", ->
				d1 = new Date(1000000)
				d2 = $.date.unstamp $.date.stamp d1
				assert d1.toString() is d2.toString()
			it "supports chaining as .unstamp()", ->
				assert $.is 'date', $([1000000]).unstamp().first()
		describe ".convert()", ->
			assert $.date.convert(1000000, "ms", "s") is 1000
		describe ".midnight()", ->
			it "returns a stamp", ->
				assert $.is 'number', $.date.midnight new Date 0
			it "shifts a date to midnight of that day", ->
				assert.notEqual -1, $.date.unstamp($.date.midnight new Date 1000000000).toUTCString().indexOf("00:00:00 GMT")
			it "supports chaining", ->
				assert.equal $($.date.range 1000, 1000000, 3)
					.midnight()
					.dateFormat("HHMMSS")
					.ints().sum(), 0
		describe ".format()", ->
			d1 = new Date(1000000000)
			describe "supports fields", ->
				it "yyyy", -> assert.equal $.date.format(d1, "yyyy"), "1970"
				it "mm", -> assert.equal $.date.format(d1, "mm"), "01"
				it "dd", -> assert.equal $.date.format(d1, "dd"), "12"
				it "HH", -> assert.equal $.date.format(d1, "HH"), "13"
				it "MM", -> assert.equal $.date.format(d1, "MM"), "46"
				it "SS", -> assert.equal $.date.format(d1, "SS"), "40"
			it "supports spacing and punctuation", ->
				assert.equal $.date.format(d1, "yyyy-mm-dd HH:MM:SS"), "1970-01-12 13:46:40"
			it "supports chaining as .dateFormat()", ->
				assert.equal $($.date.range 1000, 1000000, 3)
					.dateFormat("dd")
					.ints().sum(), 35
		describe ".parse()", ->
			it "supports the same formats as .format()", ->
				assert $.date.parse("1970-01-12 13:46:40", "yyyy-mm-dd HH:MM:SS", "ms") is 1000000000
			it "supports chaining as .dateParse()", ->
				assert $(["1970-01-12 13:46:40"]).dateParse("yyyy-mm-dd HH:MM:SS", "ms").first() is 1000000000
		describe ".range()", ->
			it "generates a range of date stamps", ->
				assert.equal $($.date.range(1000, 1000000, 3))
					.unstamp()
					.select("getUTCDate").call()

	describe ".TNET", ->
		describe ".parse()", ->
			it "parses TNET format strings into objects", ->
		describe ".stringify()", ->
			it "creates TNET strings from objects", ->

	describe ".StateMachine", ->
		it "allows subclassing to define machines", ->
			class T extends $.StateMachine
			t = new T
			assert $.is 'function', t.run
		describe ".run()", ->
			it "reads input and rules from @STATE_TABLE", ->
				class Capper extends $.StateMachine
					@STATE_TABLE = [
						{
							enter: ->
								@output = "<<"
								@GO 1
						}
						{
							def: (c) -> @output += c.toUpperCase()
							eof: @GO 2
						}
						{
							enter: -> @output += ">>"
						}
					]
					constructor: ->
						super(Capper.STATE_TABLE)

				assert.equal new Capper().run("hello").output, "<<HELLO>>"

	describe ".synth()", ->
		it "creates DOM nodes", ->
			assert $.is 'node', $.synth('div').first()
		it "uses CSS-like selectors", ->
		describe "supports CSS selectors:", ->
			it "class", -> assert.equal $.synth('div.cls').first().className, "cls"
			it "attributes", -> assert.equal $.synth('div[foo=bar]').first().attributes.foo, "bar"
			it "attributes (multiple)", -> assert.deepEqual $.synth('div[a=b][c=d]').first().attributes, {a:'b',c:'d'}
			it "text (single quotes)", -> assert.equal $.synth("div 'text'").first().toString(), "<div>text</div>"
			it "text (double quotes)", -> assert.equal $.synth('div "text"').first().toString(), "<div>text</div>"
			it "entity escaped", -> assert.equal $.synth('div "text&amp;stuff"').first().toString(), "<div>text&amp;stuff</div>"
			it "entity un-escaped", -> assert.equal $.synth('div "text&stuff"').first().toString(), "<div>text&stuff</div>"

	describe ".delay(ms, f)", ->
		it "runs f after a delay of ms", (done) ->
			t = $.now
			$.delay 100, ->
				delta = Math.abs(($.now - t) - 100)
				assert delta < 25
				done()

	describe ".config(name, def)", ->
		it "gets config from the environment", ->
			try
				process.env.UNIT_TEST_MAGIC = "magic"
				assert.equal $.config.get("UNIT_TEST_MAGIC"), "magic"
			finally
				delete process.env.UNIT_TEST_MAGIC
		it "supports a default value", ->
			assert.equal $.config.get("NOT_FOUND", "default"), "default"
		it "can be called directly", ->
			assert.equal $.config("NOT_FOUND", "default"), "default"

	describe ".index(keyMaker)", ->
		keyMaker = (obj) -> obj.a
		it "creates a private index", ->
			$([{a:1,b:2}, {a:2,b:3}]).index keyMaker
		it "cannot query until index has been built", ->
			assert.equal $([1,2,3]).query(a:1), null
		it "can .query() after indexing", ->
			a = $([{a:1,b:'b'},{a:2},{a:3}]).index keyMaker
			assert.equal a.query(a:1).b, 'b'
		it "can use compound keys", ->
			compoundKeyMaker = (obj) -> obj.a + "-" + obj.b
			a = $([{a:1,b:'b'},{a:2,b:1},{a:3,b:2,c:'c'}]).index compoundKeyMaker
			assert.equal a.query(a:3,b:2).c, 'c'
		describe "using more than one key maker", ->
			keyMakerOne = (obj) -> obj.a
			keyMakerTwo = (obj) -> obj.b
			keyMakerThree = (obj) -> obj.a + '-' + obj.b
			a = $([{a:1,b:'b'},{a:2,b:1},{a:3,b:2,c:'c'}])
			it "wont hurt if you re-index by the same keyMaker", ->
				a.index keyMakerOne
				a.index keyMakerOne
				assert.equal a.query(a:3).b, 2
			it "will allow querying against a second keyMaker", ->
				a.index keyMakerTwo
				assert.equal a.query(a:3).b, 2
				assert.equal a.query(b:2).a, 3
			it "will allow querying against N keyMakers", ->
				a.index keyMakerOne
				a.index keyMakerTwo
				a.index keyMakerThree
				assert.equal a.query(a:3).b, 2
				assert.equal a.query(b:'b').a, 1
				assert.equal a.query({a:3,b:2}).c, 'c'
	
	describe ".groupBy(key)", ->
		objs = $([
			{name: "a", k: 1, val: 1},
			{name: "a", k: 1, val: 2},
			{name: "a", k: 2, val: 3},
			{name: "b", k: 1, val: 4},
			{name: "c", k: 1, val: 5},
			{ val: 6 }

		])
		it "groups objects by the key", ->
			assert.deepEqual objs.groupBy('name'), [
				[ {name: "a", k:1, val: 1},
					{name: "a", k:1, val: 2},
					{name: "a", k:2, val: 3} ],
				[ {name: "b", k:1, val: 4} ],
				[ {name: "c", k:1, val: 5} ],
				[ { val: 6 } ]
			]
		it "can group by multiple keys", ->
			assert.deepEqual objs.groupBy(['name','k']), [
				[ {name: "a", k:1, val: 1},
					{name: "a", k:1, val: 2}
				],
				[ {name: "b", k:1, val: 4} ],
				[ {name: "c", k:1, val: 5} ],
				[ { val: 6 } ]
			]

		it "is mappable", ->
			assert.deepEqual objs.groupBy('name').map(-> @select('val').sum()),
				[ 6, 4, 5, 6 ]

		it "is mappable to a new object", ->
			assert.deepEqual objs.groupBy(['name','k']).map(->
				name: @select('name').first()
				sum: @select('val').sum()
				k: @select('k').first()
			),
				[ { name: "a", sum: 3, k:1 },
					{ name: "a", sum: 3, k:2 },
				  { name: "b", sum: 4, k:1 },
					{ name: "c", sum: 5, k:1 }
					{ name: undefined, sum: 6, k:undefined }
				]
	
	describe "$.sortedIndex()", ->
		it "returns the index to insert at", ->
			assert.equal $.sortedIndex([1,2,4], 3), 2
		it "will insert at end", ->
			assert.equal $.sortedIndex([1,2,3], 4), 3
		it "will insert at beginning", ->
			assert.equal $.sortedIndex([2,3,4], 1), 0
		it "can use a field for comparison", ->
			assert.equal $.sortedIndex([{a:1},{a:2},{a:4}], {a:3}, 'a'), 2
		it "can use a comparison function", ->
			assert.equal $.sortedIndex([1,2,4], 3, null, (x)->Math.pow(x,2)), 2

	describe ".sortBy(field,cmp)", ->
		it "can sort", ->
			assert.deepEqual $(3,1,2).sortBy(), [1,2,3]
		it "can sort by a field", ->
			assert.deepEqual $( {a:2}, {a:1}, {a:3} ).sortBy('a').select('a'), [1,2,3]
		it "does NOT sort in-place", ->
			a = $(2,3,1)
			b = a.sortBy()
			assert.deepEqual b, [1,2,3]
			assert a isnt b
	
	describe ".sortedInsert(item,iterator)", ->
		it "inserts in sorted order", ->
			assert.deepEqual $(1,2,4).sortedInsert(3), [1,2,3,4]
		it "can be chained", ->
			assert.deepEqual $().sortedInsert(3).sortedInsert(1).sortedInsert(2), [1,2,3]
		it "works on fields", ->
			assert.deepEqual $().sortedInsert({x:1,y:2}, 'y').sortedInsert({x:2,y:1}, 'y'), [{x:2,y:1},{x:1,y:2}]


describe "DOM", ->
	it "parse", ->
		d = $.HTML.parse "<div><a></a><b></b><c></c></div>"
		assert.equal $.type(d), "node"
		assert.equal d.nodeName, "DIV"
	it "stringify", -> assert.equal $.HTML.stringify($.HTML.parse(h = "<div><a/><b/><c/></div>")), h
	it "select_childNodes", -> assert.equal( $("<div><a></a><b></b><c></c></div>").select("childNodes").flatten().map($.type).toRepr(), "$(['node', 'node', 'node'])" )
	it "child", -> i = 0; d = $("<div><a></a><b></b><c></c></div>"); assert.equal( d.select('childNodes').flatten().map( () -> d.child(i++) ).toRepr(), "$([$([<a/>]), $([<b/>]), $([<c/>])])")
	it "child2", -> assert.equal($("tr").child(0).select('nodeName').toRepr(), "$(['TD', 'TD', 'TD', 'TD'])")
	it "textData", ->
		d = $("<div>&nbsp;</div>")
		assert.equal d.toRepr(), "$([<div>&nbsp;</div>])"
		t = d.child 0
		assert.equal t.toRepr(), "$([&nbsp;])"
		t.zap 'data', '<p>'
		assert.equal d.select('innerHTML').first(), '&lt;p&gt;'
	it "escape", -> assert.equal $.HTML.escape("<p>"), "&lt;p&gt;"
	it "dashName1", -> assert.equal $.dashize("fooBar"), "foo-bar"
	it "dashName2", -> assert.equal $.dashize("FooBar"), "-foo-bar"
	it "html1", -> assert.equal $("tr").html().first(), "<td>1,1</td><td>1,2</td>"
	it "html2", -> assert.equal $("div").html("<span>C</span>").html().first(), "<span>C</span>"
	it "append", ->
		try
			assert.equal($("tr td.d").append("<span>Hi</span>").html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	it "appendTo1", -> assert.equal($("<span>Hi</span>").toRepr(), "$([<span>Hi</span>])")
	it "appendTo2", ->
		try
			assert.equal($("<span>Hi</span>").appendTo("tr td.d").toRepr(), "$([<span>Hi</span>])")
		finally
			$("tr td.d span").remove()
	it "appendTo3", ->
		try
			assert.equal($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').toRepr(), '$([<td class="d">3,2<span>Hi</span></td>])')
		finally
			$("tr td.d span").remove()
	it "appendTo4", ->
		try
			assert.equal($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	it "prepend", ->
		try
			assert.equal($("tr td.d").prepend("<span>Hi</span>").html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	it "prependTo", ->
		try
			assert.equal($("<span>Hi</span>").prependTo("tr td.d").select('parentNode').html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	it "before", -> assert.equal($("<a><b></b></a>").find("b").before("<c></c>").select('parentNode').toRepr(), "$([<a><c/><b/></a>])")
	it "after1", -> assert.equal($("<a><b></b></a>").find("b").after("<c></c>").select('parentNode').toRepr(), "$([<a><b/><c/></a>])")
	it "after2", -> assert.equal($("<b></b>").after("<c></c>").select('parentNode').toRepr(), "$([<b/><c/>])")
	it "wrap", -> assert.equal($("<b></b>").wrap("<a></a>").select('parentNode').toRepr(), "$([<a><b/></a>])")
	it "unwrap", -> assert.equal($("<a><b/></a>").find("b").unwrap().first().parentNode, null)
	it "replace", -> assert.equal($("<a><b/><c/><b/></a>").find("b").replace("<p/>").eq(0).select('parentNode').toRepr(), "$([<a><p/><c/><p/></a>])")
	it "removeClass", -> assert.equal($("<a class='test'></a>").removeClass('test').toRepr(), "$([<a/>])")
	it "removeClass2", -> assert.equal($("<a></a>").removeClass('test').toRepr(), "$([<a/>])")
	it "addClass", -> assert.equal($("<a></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	it "addClass2", -> assert.equal($("<a class='test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	it "addClass3", -> assert.equal($("<a class='test test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	it "toggleClass", -> assert.equal($("<a class='on'></a>").toggleClass("on").toRepr(), "$([<a/>])")
	it "toggleClass2", -> assert.equal($("<a class='off'></a>").toggleClass("on").toRepr(), '$([<a class="off on"/>])')
	it "toggleClass3", -> assert.equal($("<a class=''></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	it "toggleClass4", -> assert.equal($("<a></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	it "hasClass", -> assert.equal($("<a class='foo'></a>").hasClass("foo").first(), true)
	it "hasClass2", -> assert.equal($("<a class='bar'></a>").hasClass("foo").first(), false)
	it "text1", -> assert.equal($("<a>Hello<b>World</b></a>").select('innerText').toRepr(), "$(['HelloWorld'])")
	it "text3", -> assert.equal($("<a>Hello<b>World</b></a>").text().toRepr(), "$(['HelloWorld'])")
	it "text2", -> assert.equal($("<a>Hello<b>World</b></a>").text("Goodbye").toRepr(), "$([<a>Goodbye</a>])")
	it "value1", -> assert.equal($("<input type='text' value='foo'/>").val().toRepr(), "$(['foo'])")
	it "value2", -> assert.equal($("<input />").val().toRepr(), "$([''])")
	it "value3", -> assert.equal($("<input type='checkbox' checked />").val().toRepr(), "$(['on'])")
	it "parents", -> assert.equal($("td.d").parents().first().select('nodeName').toRepr(), "$(['TR', 'TABLE', 'BODY', 'HTML'])")
	it "remove", ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
		b = a.find(".x")
			.assert.equal(2, -> @length)
			.assert.equal("$(['B', 'C'])", -> @select('nodeName').toRepr())
			.remove()
			.assert.equal("$([null, null])", -> @select('parentNode').toRepr() )
		assert.equal a.toRepr(), '$([<a><d/></a>])'
	it "find", ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
			.find(".x")
			.assert.equal(2, -> @length)
			.assert.equal("$(['B', 'C'])", -> @select('nodeName').toRepr())
	it "clone", ->
		c = $("div.c").clone()[0]
		d = $("div.c")[0]
		c.a = "magic"
		assert.equal( typeof d.a, "undefined")
		assert.equal( typeof c.a, "string")
	it "toFragment", ->
		assert.equal($("td").clone().toFragment().childNodes.length, 8)




KeyNames =
	A_KEY: "a"
	Q_KEY: "a"
	S_KEY: "s"
	W_KEY: "s"
	D_KEY: "e"
	E_KEY: "e"
	F_KEY: "t"
	R_KEY: "t"
	J_KEY: "n"
	U_KEY: "n"
	K_KEY: "i"
	I_KEY: "i"
	L_KEY: "o"
	O_KEY: "o"
	SEMICOLON_KEY: "p"
	P_KEY: "p"
	C_KEY: "shift"
	V_KEY: "shift"
	N_KEY: "number"
	M_KEY: "number"
	SPACE_KEY: "space"

KeyToBit =
	A_KEY: A_BIT
	Q_KEY: A_BIT
	S_KEY: S_BIT
	W_KEY: S_BIT
	D_KEY: E_BIT
	E_KEY: E_BIT
	F_KEY: T_BIT
	R_KEY: T_BIT
	J_KEY: N_BIT
	U_KEY: N_BIT
	K_KEY: I_BIT
	I_KEY: I_BIT
	L_KEY: O_BIT
	O_KEY: O_BIT
	SEMICOLON_KEY: P_BIT
	P_KEY: P_BIT
	C_KEY: SHIFT_BIT
	V_KEY: SHIFT_BIT
	N_KEY: NUMSH_BIT
	M_KEY: NUMSH_BIT
	SPACE_KEY: SPACE_BIT

MaskToOutput =
	346: "constructor"

for i in [513...1024] when (j = i - 512) of MaskToOutput and MaskToOutput[j].length < 3
	MaskToOutput[i] = MaskToOutput[j] + " "

for i in [1025..1291]

reverseMap = (map) ->
	ret = Object.create(null)
	for k,v of map
		unless v of ret
			ret[v] = k
	ret
BitToKey = reverseMap KeyToBit
OutputToMask = reverseMap MaskToOutput

maskToKeys = (mask) ->
	(KeyNames[BitToKey[i]] for i in [256, 1024, 1, 2, 4, 8, 16, 32, 64, 128, 512] when MASK_HAS(mask, i)).join "+"

$.asetniop =
	init: (selector) ->
		$(selector).log('binding ASETNIOP to:').each ->

			$.defineProperty @, 'caretPos',
				get: =>
					@focus()
					switch true
						when 'selection' of document
							sel = document.selection.createRange()
							sel.moveStart 'character', @value.length
							sel.text.length
						when 'selectionStart' of @
							@selectionStart
						else
							@value.length
				set: (pos) =>
					switch true
						when 'setSelectionRange' of @
							@focus()
							@setSelectionRange(pos,pos)
						when 'createTextRange' of @
							range = @createTextRange()
							range.collapse(true)
							range.moveEnd('character', pos)
							range.moveStart('character', pos)
							range.select()

			t = $(@)
			t.bind 'keydown', (evt) ->
				key = KeyToBit[evt.keyCode]
				if MASK_HAS(gesture, key)
				hasNewKeys = true
				false
			t.bind 'keyup', (evt) ->
				value = MaskToOutput[gesture]
				modified = false
				if hasNewKeys
					if /^<\w+>$/.test value
						switch value
							when "<Backspace>"
								c = @caretPos
								@value = $.stringSplice @value, c-1, c, ''
								@caretPos = c - 1
								modified = true
							when "<Shift>"
								MASK_TOGGLE(sticky, SHIFT_BIT)
							when "<Number>"
								MASK_TOGGLE(sticky, NUMSH_BIT)
					else if value?
						c = @caretPos
						@value = $.stringSplice @value, c, c, value
						@caretPos = c + value.length
						modified = true
				code = KeyToBit[evt.keyCode]
				MASK_OFF(gesture, code)
				if modified
					MASK_OFF(gesture, sticky)
					sticky = 0
					hasNewKeys = false
					t.trigger 'change'
				false
		
		switch
			when output of OutputToMask
				maskToKeys OutputToMask[output]
			when output.length > 1
				j = output.length - 1
				--j while output[j...output.length] of OutputToMask and j >= 0
				++j
				$.asetniop.hint(a) + ", " + $.asetniop.hint(b)
			else ""

$(document).ready -> $.asetniop.init(".asetniop")

class O extends $.EventEmitter
	tick: ->
	draw: ->

class FallingWord extends O
	constructor: (@word, range) ->
		super @
		@x = $.random.integer 0, range
		@y = 0
		@speed = .01
	tick: (dt) ->
		@y += @speed * dt
	draw: (ctx) ->
		ctx.fillText @x, @y, @word

class TimedScript extends O
	constructor: (@script) ->
		@elapsed = 0
		@cur = 0
	tick: (dt) ->
		@elapsed += dt
		while @cur < @script.length and @script[@cur][0] < @elapsed
			item = @script[@cur]
			switch item[1]
				when 'goto' then @elapsed = item[2] | 0
				else do item[1]

class Game extends Clock
	constructor: (selector) ->
		@canvas = $(selector).first()
		@ctx = @canvas.getContext('2d')
		@w = @canvas.getAttribute('width')
		@h = @canvas.getAttribute('height')
		@objects = []
	add: (obj) ->
		@objects.push obj
		obj.on 'die', =>
			if (i = @objects.indexOf obj) > -1
				@objects.splice i, 1

wordlist = ["one", "two", "three"]
game = new Game "canvas"
game.add new TimedScript [
	[ 0, -> game.add new FallingWord $.random.element(wordlist), game.w ],
	[ 1000, 'goto', 0 ]
]



Object.keys or= (o) -> (k for k of o)

Object.values or= (o) -> (o[k] for k of o)

extend = (a, b) ->
	if b then a[k] = v for k,v of b when v?
	a






	constructor: (args...) ->
		return Bling.hook "bling-init", args

Bling.prototype = []
Bling.prototype.constructor = Bling
Bling.global = if window? then window else global





Bling.plugin = (opts, constructor) ->
	if not constructor
		constructor = opts
		opts = {}

	if "depends" of opts
		return @depends opts.depends, =>
			@plugin { provides: opts.provides }, constructor
	try
		if (plugin = constructor?.call @,@)
			extend @, plugin?.$
			['$','name'].forEach (k) -> delete plugin[k]
			extend @::, plugin
			for key of plugin then do (key) =>
				@[key] or= (a...) => (@::[key].apply Bling(a[0]), a[1...])
			if opts.provides? then @provide opts.provides
	catch error
	@


do ->
	dep =
		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)

	Bling.depends = (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else
			dep.q.push (need) ->
				(needs.splice i, 1) if (i = needs.indexOf need) > -1
				return (needs.length is 0 and f)
		f

	Bling.provide = (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data


$ = Bling
Object.keys or= (o) -> (k for k of o)
Object.values or= (o) -> (o[k] for k of o)
extend = (a, b) ->
	if b then a[k] = v for k,v of b when v?
	a
	constructor: (args...) ->
		return Bling.hook "bling-init", args
Bling.prototype = []
Bling.prototype.constructor = Bling
Bling.global = if window? then window else global
Bling.plugin = (opts, constructor) ->
	if not constructor
		constructor = opts
		opts = {}
	if "depends" of opts
		return @depends opts.depends, =>
			@plugin { provides: opts.provides }, constructor
	try
		if (plugin = constructor?.call @,@)
			extend @, plugin?.$
			['$','name'].forEach (k) -> delete plugin[k]
			extend @::, plugin
			for key of plugin then do (key) =>
				@[key] or= (a...) => (@::[key].apply Bling(a[0]), a[1...])
			if opts.provides? then @provide opts.provides
	catch error
	@
do ->
	dep =
		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)
	Bling.depends = (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else
			dep.q.push (need) ->
				(needs.splice i, 1) if (i = needs.indexOf need) > -1
				return (needs.length is 0 and f)
		f
	Bling.provide = (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data
$ = Bling
$.plugin
	provides: "EventEmitter"
	depends: "type,hook"
, ->
	$: EventEmitter: $.hook("bling-init").append (obj = Object.create(null)) ->
		listeners = {}
		list = (e) -> (listeners[e] or= [])
		$.inherit {
			emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
			addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
			on:                 (e, h) -> @addListener e, h
			removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
			removeAllListeners: (e) -> listeners[e] = []
			listeners:          (e) -> list(e).slice 0
		}, obj
$.plugin
	provides: "cartesian"
, ->
	$:
		cartesian: (sets...) ->
			n = sets.length
			ret = []
			helper = (cur, i) ->
				(return ret.push cur) if ++i >= n
				for x in sets[i]
					helper (cur.concat x), i
				null
			helper [], -1
			return $(ret)
$.plugin ->
	String::trimLeft or= -> @replace(/^\s+/, "")
	String::split or= (sep) ->
		a = []; i = 0
		while (j = @indexOf sep,i) > -1
			a.push @substring(i,j)
			i = j + 1
		a
	String::lastIndexOf or= (s, c, i = -1) ->
		j = -1
		j = i while (i = s.indexOf c, i+1) > -1
		j
	Array::join or= (sep = '') ->
		n = @length
		return "" if n is 0
		s = @[n-1]
		while --n > 0
			s = @[n-1] + sep + s
		s
	if Event?
		Event::preventAll = () ->
			@preventDefault()
			@stopPropagation()
			@cancelBubble = true
	if Element?
		Element::matchesSelector = Element::webkitMatchesSelector or
			Element::mozMatchesSelector or
			Element::matchesSelector
		if Element::cloneNode.length is 0
			oldClone = Element::cloneNode
			Element::cloneNode = (deep = false) ->
				n = oldClone.call(@)
				if deep
					for i in @childNodes
						n.appendChild i.cloneNode true
				return n
	return { }
$.plugin
	provides: 'config'
	depends: 'type'
, ->
	get = (name, def) -> process.env[name] ? def
	$: config: $.extend(get, get: get)
$.plugin
	provides: "core"
	depends: "string"
, ->
	$.defineProperty $, "now",
		get: -> +new Date
	index = (i, o) ->
		i += o.length while i < 0
		Math.min i, o.length
	baseTime = $.now
	return {
		$:
			log: $.extend((a...) ->
				if prefix.length > $.log.prefixSize + 2
				if a.length and $.is "string", a[0]
				else
					a.unshift prefix
				console.log a...
				return a[a.length-1] if a.length
			, prefixSize: 5)
			coalesce: (a...) -> $(a).coalesce()
			keysOf: (o) -> $(k for k of o)
			valuesOf: (o) -> $.keysOf(o).map (k)->
				return try o[k] catch err then err
		eq: (i) -> $([@[index i, @]])
		each: (f) -> (f.call(t,t) for t in @); @
		map: (f) ->
			b = $()
			for t in @
				b.push f.call t,t
			b
		filterMap: (f) ->
			b = $()
			for t in @
				v = f.call t,t
				if v?
					b.push v
			b
		replaceWith: (array) ->
			for i in [0...array.length] by 1
				@[i] = array[i]
		reduce: (f, a) ->
			i = 0; n = @length
			a = @[i++] if not a?
			(a = f.call @[x], a, @[x]) for x in [i...n] by 1
			return a
		union: (other, strict = true) ->
			ret = $()
			ret.push(x) for x in @ when not ret.contains(x, strict)
			ret.push(x) for x in other when not ret.contains(x, strict)
			ret
		distinct: (strict = true) -> @union @, strict
		contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
		count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
		coalesce: ->
			for i in @
				if $.is('array',i) or $.is('bling',i) then i = $(i).coalesce()
				if i? then return i
			null
		swap: (i,j) ->
			i = index i, @
			j = index j, @
			if i isnt j
				[@[i],@[j]] = [@[j],@[i]]
			@
		shuffle: ->
			i = @length-1
			while i >= 0
				@swap --i, Math.floor(Math.random() * i)
			@
		select: (->
			getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
			select = (p) ->
				if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
				else @map(getter p)
		)()
		or: (x) -> @[i] or= x for i in [0...@length]; @
		zap: (p, v) ->
			i = p.lastIndexOf "."
			if i > 0
				head = p.substr 0,i
				tail = p.substr i+1
				@select(head).zap tail, v
				return @
			switch $.type(v)
				when "array","bling" then @each -> @[p] = v[++i % v.length]
				when "function" then @zap p, @select(p).map(v)
				else @each -> @[p] = v
			@
		clean: (prop) -> @each -> delete @[prop]
		take: (n = 1) ->
			end = Math.min n, @length
			$( @[i] for i in [0...end] by 1 )
		skip: (n = 0) ->
			start = Math.max 0, n|0
			$( @[i] for i in [start...@length] by 1 )
		first: (n = 1) -> if n is 1 then @[0] else @take(n)
		last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)
		slice: (start=0, end=@length) ->
			start = index start, @
			end = index end, @
			$( @[i] for i in [start...end] )
		extend: (b) -> @.push(i) for i in b; @
		push: (b) -> Array::push.call(@, b); @
		filter: (f) ->
			g = switch $.type f
				when "string" then (x) -> x.matchesSelector(f)
				when "regexp" then (x) -> f.test(x)
				when "function" then f
			$( it for it in @ when g.call(it,it) )
		matches: (expr) ->
			switch $.type expr
				when "string" then @select('matchesSelector').call(expr)
				when "regexp" then @map (x) -> expr.test x
		querySelectorAll: (expr) ->
			@filter("*")
			.reduce (a, i) ->
				a.extend i.querySelectorAll expr
			, $()
		weave: (b) ->
			c = $()
			for i in [@length-1..0] by -1
				c[(i*2)+1] = @[i]
			for i in [0...b.length] by 1
				c[i*2] = b[i]
			c
		fold: (f) ->
			n = @length
			b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
			if (n%2) is 1
				b.push( f.call @, @[n-1], undefined )
			b
		flatten: ->
			b = $()
			(b.push(j) for j in i) for i in @
			b
		call: -> @apply(null, arguments)
		apply: (context, args) ->
			@filterMap ->
				if $.is 'function', @ then @apply(context, args)
				else null
		log: (label) ->
			if label
				$.log(label, @toString(), @length + " items")
			else
				$.log(@toString(), @length + " items")
			@
		toArray: ->
			@__proto__ = Array::
	}
$.plugin
	provides: 'date'
	depends: 'type'
, ->
	[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]
	units = {
		ms, s, m, h, d,
		sec: s
		second: s
		seconds: s
		min: m
		minute: m
		minutes: m
		hr: h
		hour: h
		hours: h
		day: d
		days: d
	}
	formats =
		yyyy: Date::getUTCFullYear
		mm: -> @getUTCMonth() + 1
		dd: Date::getUTCDate
		HH: Date::getUTCHours
		MM: Date::getUTCMinutes
		SS: Date::getUTCSeconds
		MS: Date::getUTCMilliseconds
	format_keys = Object.keys(formats).sort().reverse()
	parsers =
		yyyy: Date::setUTCFullYear
		mm: (x) -> @setUTCMonth(x - 1)
		dd: Date::setUTCDate
		HH: Date::setUTCHours
		MM: Date::setUTCMinutes
		SS: Date::setUTCSeconds
		MS: Date::setUTCMilliseconds
	parser_keys = Object.keys(parsers).sort().reverse()
	floor = Math.floor
	$.type.register "date",
		match: (o) -> $.isType Date, o
		array: (o) -> [o]
		string: (o, fmt, unit) -> $.date.format o, fmt, unit
		number: (o, unit) -> $.date.stamp o, unit
	$.type.extend 'string', date: (o, fmt = $.date.defaultFormat) -> new Date $.date.parse o, fmt, "ms"
	$.type.extend 'number', date: (o, unit) -> $.date.unstamp o, unit
	adder = (key) ->
		(stamp, delta, stamp_unit = $.date.defaultUnit) ->
			date = $.date.unstamp(stamp, stamp_unit)
			parsers[key].call date, (formats[key].call date) + delta
			$.date.stamp date, stamp_unit
	$:
		date:
			defaultUnit: "s"
			defaultFormat: "yyyy-mm-dd HH:MM:SS"
			stamp: (date = new Date, unit = $.date.defaultUnit) ->
				floor (date / units[unit])
			unstamp: (stamp, unit = $.date.defaultUnit) ->
				new Date floor(stamp * units[unit])
			convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
				(floor stamp * units[from] / units[to])
			midnight: (stamp, unit = $.date.defaultUnit) ->
				$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
			format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
				date = $.date.unstamp stamp, unit
				for k in format_keys
					fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
				fmt
			parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
				date = new Date(0)
				for i in [0...fmt.length] by 1
					for k in parser_keys
						if fmt.indexOf(k, i) is i
							try
								parsers[k].call date,
									parseInt dateString[i...i+k.length], 10
							catch err
				$.date.stamp date, to
			addMilliseconds: adder("MS")
			addSeconds: adder("SS")
			addMinutes: adder("MM")
			addHours: adder("HH")
			addDays: adder("dd")
			addMonths: adder("mm")
			addYears: adder("yyyy")
			range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
				add = adder(interval_unit)
				ret = [from]
				while (cur = ret[ret.length-1]) < to
					ret.push add(cur, interval, stamp_unit)
				ret
	midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
	unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
	stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
	dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
	dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)
$.plugin
	provides: "delay"
	depends: "function"
, ->
	$:
		delay: (->
			timeoutQueue = $.extend [], (->
				next = (a) -> -> a.shift()() if a.length
				add: (f, n) ->
					f.order = n + $.now
					for i in [0..@length] by 1
						if i is @length or @[i].order > f.order
							@splice i,0,f
							break
					setTimeout next(@), n
					@
				cancel: (f) ->
					for i in [0...@length] by 1
						if @[i] == f
							@splice i, 1
							break
					@
			)()
			(n, f) ->
				if $.is("function",f) then timeoutQueue.add(f, n)
				cancel: -> timeoutQueue.cancel(f)
		)()
	delay: (n, f, c=@) ->
		$.delay n, $.bound(c, f)
		@
	interval: (n, f, c=@) ->
		g = $.bound c, f
		h = -> g(); $.delay n, h
		$.delay n, h
		@
if $.global.document?
	$.plugin
		depends: "function,type"
		provides: "dom"
	, ->
		$.type.register "nodelist",
			match:  (o) -> o? and $.isType "NodeList", o
			hash:   (o) -> $($.hash(i) for i in x).sum()
			array:  $.identity
			string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
			node:   (o) -> $(o).toFragment()
		$.type.register "node",
			match:  (o) -> o?.nodeType > 0
			hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "fragment",
			match:  (o) -> o?.nodeType is 11
			hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "html",
			match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
			node:   (h) ->
				(node = document.createElement('div')).innerHTML = h
				if n = (childNodes = node.childNodes).length is 1
					return node.removeChild(childNodes[0])
				df = document.createDocumentFragment()
				df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
				df
			array:  (o) -> $.type.lookup(h = Bling.HTML.parse o).array h
			repr:   (o) -> '"' + o + '"'
		$.type.extend
			unknown:  { node: -> null }
			bling:    { node: (o) -> o.toFragment() }
			node:     { html: (n) ->
				d = document.createElement "div"
				d.appendChild (n = n.cloneNode true)
				ret = d.innerHTML
				ret
			}
			string:
				node:  (o) -> $(o).toFragment()
				array: (o) -> document.querySelectorAll? o
			function: { node: (o) -> $(o.toString()).toFragment() }
		toFrag = (a) ->
			if not a.parentNode?
				df = document.createDocumentFragment()
				df.appendChild a
			a
		before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
		after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
		toNode = (x) -> $.type.lookup(x).node x
		escaper = false
		parser = false
		computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue k
		getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select p
		selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )
		return {
			$:
				HTML:
					parse: (h) -> $.type.lookup(h).node h
					stringify: (n) -> $.type.lookup(n).html n
					escape: (h) ->
						escaper or= $("<div>&nbsp;</div>").child 0
						ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
						escaper.zap('data', '')
						ret
			html: (h) ->
				return switch $.type h
					when "undefined","null" then @select 'innerHTML'
					when "string","html" then @zap 'innerHTML', h
					when "bling" then @html h.toFragment()
					when "node"
							@replaceChild @childNodes[0], h
							while @childNodes.length > 1
								@removeChild @childNodes[1]
				@each -> @appendChild x.cloneNode true
				clones = @map( -> @cloneNode true)
				i = 0
				$(x).each -> @appendChild clones[i++]
				clones
				if x?
					x = toNode x
					@take(1).each ->
						before @childNodes[0], x
					@skip(1).each ->
						before @childNodes[0], x.cloneNode true
				@
				if x?
					$(x).prepend(@)
				@
				if x?
					x = toNode x
					@take(1).each -> before @, x
					@skip(1).each -> before @, x.cloneNode true
				@
				if x?
					x = toNode x
					@take(1).each -> after @, x
					@skip(1).each -> after @, x.cloneNode true
				@
				parent = toNode parent
				if $.is "fragment", parent
					throw new Error("cannot call .wrap() with a fragment as the parent")
				@each (child) ->
					if ($.is "fragment", child) or not child.parentNode
						return parent.appendChild child
					grandpa = child.parentNode
					marker = document.createElement "dummy"
					parent.appendChild grandpa.replaceChild marker, child
					grandpa.replaceChild parent, marker
				@each ->
					if @parentNode and @parentNode.parentNode
						@parentNode.parentNode.replaceChild(@, @parentNode)
					else if @parentNode
						@parentNode.removeChild(@)
				n = toNode n
				clones = @map(-> n.cloneNode true)
				for i in [0...clones.length] by 1
					@[i].parentNode?.replaceChild clones[i], @[i]
				clones
				return switch v
					when undefined then @select("getAttribute").call(a, v)
					when null then @select("removeAttribute").call(a, v)
					else
						@select("setAttribute").call(a, v)
						@
				notempty = (y) -> y isnt ""
				@removeClass(x).each ->
					c = @className.split(" ").filter notempty
					c.push x
					@className = c.join " "
				notx = (y) -> y != x
				@each ->
					c = @className.split(" ").filter(notx).join(" ")
					if c.length is 0
						@removeAttribute('class')
				notx = (y) -> y isnt x
				@each ->
					cls = @className.split(" ")
					filter = $.not $.isEmpty
					if( cls.indexOf(x) > -1 )
						filter = $.and notx, filter
					else
						cls.push x
					c = cls.filter(filter).join(" ")
					@className = c
					if c.length is 0
						@removeAttribute('class')
				@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1
				return @zap('textContent', t) if t?
				return @select('textContent')
				return @zap('value', v) if v?
				return @select('value')
			css: (k,v) ->
				if v? or $.is "object", k
					setter = @select 'style.setProperty'
					if $.is "object", k then setter.call i, k[i], "" for i of k
					else if $.is "string", v then setter.call k, v, ""
					else if $.is "array", v
						setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
					return @
				else
					cv = @map computeCSSProperty k
					ov = @select('style').select k
					ov.weave(cv).fold (x,y) -> x or y
			defaultCss: (k, v) ->
				sel = @selector
				style = ""
				if $.is "string", k
					if $.is "string", v
					else throw Error("defaultCss requires a value with a string key")
				else if $.is "object", k
					"} "
				$("<style></style>").text(style).appendTo("head")
				@
			rect: -> @select('getBoundingClientRect').call()
			width: getOrSetRect("width")
			height: getOrSetRect("height")
			top: getOrSetRect("top")
			left: getOrSetRect("left")
			bottom: getOrSetRect("bottom")
			right: getOrSetRect("right")
			position: (left, top) ->
				switch true
					when not left? then @rect()
					when not top? then @css("left", $.px(left))
					else @css({top: $.px(top), left: $.px(left)})
			scrollToCenter: ->
				document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
				@
			child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]
			parents: selectChain('parentNode')
			prev: selectChain('previousSibling')
			next: selectChain('nextSibling')
			remove: -> @each -> @parentNode?.removeChild(@)
			find: (css) ->
				@filter("*")
					.map( -> $(css, @) )
					.flatten()
			clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @
			toFragment: ->
				if @length > 1
					df = document.createDocumentFragment()
					(@map toNode).map $.bound df, df.appendChild
					return df
				return toNode @[0]
		}
$.plugin
	depends: "dom,function,core"
	provides: "event"
, ->
	EVENTSEP_RE = /,* +/
	events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
		'load','unload','reset','submit','keyup','keydown','change',
		'abort','cut','copy','paste','selection','drag','drop','orientationchange',
		'touchstart','touchmove','touchend','touchcancel',
		'gesturestart','gestureend','gesturecancel',
		'hashchange'
	]
	binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)
	register_live = (selector, context, evt, f, h) ->
		$(context).bind(evt, h)
			.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h
	unregister_live = (selector, context, e, f) ->
		$c = $(context)
		$c.each ->
			a = (@__alive__ or= {})
			b = (a[selector] or= {})
			c = (b[e] or= {})
			$c.unbind(e, c[f])
			delete c[f]
	triggerReady = $.once ->
		$(document).trigger("ready").unbind("ready")
		document.removeEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.removeEventListener?("load", triggerReady, false)
	bindReady = $.once ->
		document.addEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.addEventListener?("load", triggerReady, false)
	bindReady()
	ret = {
		bind: (e, f) ->
			c = (e or "").split(EVENTSEP_RE)
			h = (evt) ->
				ret = f.apply @, arguments
				if ret is false
					evt.preventAll()
				ret
			@each -> (@addEventListener i, h, false) for i in c
		unbind: (e, f) ->
			c = (e or "").split EVENTSEP_RE
			@each -> (@removeEventListener i, f, null) for i in c
		trigger: (evt, args = {}) ->
			args = $.extend
				bubbles: true
				cancelable: true
			, args
			for evt_i in (evt or "").split(EVENTSEP_RE)
					e = document.createEvent "MouseEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						button: 0,
						relatedTarget: null
					, args
					e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.button, args.relatedTarget
					e = document.createEvent "UIEvents"
					e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1
					e = document.createEvent "TouchEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						touches: [],
						targetTouches: [],
						changedTouches: [],
						scale: 1.0,
						rotation: 0.0
					, args
					e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)
					e = document.createEvent "GestureEvents"
					args = $.extend {
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						target: null,
						scale: 1.0,
						rotation: 0.0
					}, args
					e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.target, args.scale, args.rotation
				else
					e = document.createEvent "Events"
					e.initEvent evt_i, args.bubbles, args.cancelable
					try
						e = $.extend e, args
					catch err
				if not e
					continue
				else
					try
						@each -> @dispatchEvent e
					catch err
						$.log "dispatchEvent error:", err
			@
		live: (e, f) ->
			selector = @selector
			context = @context
			handler = (evt) ->
				$(selector, context)
					.intersect($(evt.target).parents().first().union($(evt.target)))
					.each -> f.call(evt.target = @, evt)
			register_live selector, context, e, f, handler
			@
		die: (e, f) ->
			$(@context).unbind e, unregister_live(@selector, @context, e, f)
			@
		click: (f = {}) ->
			if @css("cursor") in ["auto",""]
				@css "cursor", "pointer"
			if $.is "function", f then @bind 'click', f
			else @trigger 'click', f
			@
		ready: (f) ->
			return (f.call @) if triggerReady.exhausted
			@bind "ready", f
	}
	events.forEach (x) -> ret[x] = binder(x)
	return ret
$.plugin
	provides: "function"
	depends: "hash"
, ->
	$:
		identity: (o) -> o
		not: (f) -> -> not f.apply @, arguments
		compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
		and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
		once: (f, n=1) ->
			$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
				"exhausted",
					get: -> n <= 0
		cycle: (f...) ->
			i = -1
			-> f[i = ++i % f.length].apply @, arguments
		bound: (t, f, args = []) ->
			if $.is "function", f.bind
				args.splice 0, 0, t
				r = f.bind.apply f, args
			else
				r = (a...) -> f.apply t, (args if args.length else a)
		memoize: (f) ->
			cache = {}
		E: (callback) -> (f) -> (err, data) ->
			return f(data) unless err
			callback err, data
$.plugin
	provides: "groupBy"
, ->
	groupBy: (key) ->
		groups = {}
		switch $.type key
			when 'array','bling'
				@each ->
					c = (@[k] for k in key).join ","
					(groups[c] or= $()).push @
			else @each -> (groups[@[key]] or= $()).push @
		return $.valuesOf groups
$.plugin
	provides: "hash"
	depends: "type"
, ->
	$.type.extend
		unknown: { hash: (o) -> $.checksum $.toString o }
		object:  { hash: (o) ->
			$.hash(Object) +
				$($.hash(o[k]) for k of o).sum() +
				$.hash Object.keys o
		}
		array:   { hash: (o) ->
			$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
				(a*a)+(x|0)
			, 1
		}
		bool:    { hash: (o) -> parseInt(1 if o) }
	return {
		$:
			hash: (x) -> $.type.lookup(x).hash(x)
		hash: -> $.hash @
	}
$.plugin ->
	$:
		histogram: (data, bucket_width=1, output_width=80) ->
			buckets = $()
			len = 0
			for x in data
				i = Math.floor( x / bucket_width )
				buckets[i] ?= 0
				buckets[i] += 1
				len = Math.max(len, i+1)
			buckets.length = len
			max = buckets.max()
			buckets = buckets.map((x) -> x or 0)
				.scale(1/max)
				.scale(output_width)
			sum = buckets.sum()
			ret = ""
			pct_sum = 0
			for n in [0...len] by 1
				end = (n+1) * bucket_width
				pct = (buckets[n]*100/sum)
				pct_sum += pct
			ret
	histogram: -> $.histogram @
$.plugin
	provides: "hook"
	depends: "type"
, ->
	hooks = {}
	hook = (name, args) ->
		p = (hooks[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args
	hook("bling-init").prepend (args) ->
		if args.length is 1
			args = $.type.lookup(args[0]).array(args[0])
		$.inherit Bling, args
	$: hook: hook
$.plugin
	depends: "dom"
	provides: "http"
, ->
	$.type.register "http",
		match: (o) -> $.isType 'XMLHttpRequest', o
		array: (o) -> [o]
	return {
		$:
			http: (url, opts = {}) ->
				xhr = new XMLHttpRequest()
				if $.is "function", opts
					opts = success: $.bound(xhr, opts)
				opts = $.extend {
					method: "GET"
					data: null
					async: true
					asBlob: false
					followRedirects: false
					withCredentials: false
				}, opts
				opts.state = $.bound(xhr, opts.state)
				opts.success = $.bound(xhr, opts.success)
				opts.error = $.bound(xhr, opts.error)
				if opts.data and opts.method is "GET"
					url += "?" + formencode(opts.data)
				else if opts.data and opts.method is "POST"
					opts.data = formencode(opts.data)
				xhr.open(opts.method, url, opts.async)
				xhr = $.extend xhr,
					asBlob: opts.asBlob
					timeout: opts.timeout
					followRedirects: opts.followRedirects
					withCredentials: opts.withCredentials
					onreadystatechange: ->
						opts.state?()
						if xhr.readyState is 4
							if xhr.status is 200
								opts.success xhr.responseText
							else
								opts.error xhr.status, xhr.statusText
				xhr.send opts.data
				return $(xhr)
			post: (url, opts = {}) ->
				if $.is("function",opts)
					opts = success: opts
				opts.method = "POST"
				$.http(url, opts)
			get: (url, opts = {}) ->
				if( $.is("function",opts) )
					opts = success: opts
				opts.method = "GET"
				$.http(url, opts)
	}
$.depends 'hook', ->
	$.hook('bling-init').append (obj) ->
		map = Object.create(null)
		keyMakers = []
		$.inherit {
			index: (keyFunc) ->
				if keyMakers.indexOf(keyFunc) is -1
					keyMakers.push keyFunc
					map[keyFunc] = Object.create(null)
				@each (x) ->
					map[keyFunc][keyFunc(x)] = x
			query: (criteria) ->
				for keyMaker in keyMakers
					key = keyMaker(criteria)
					return map[keyMaker][key] if key of map[keyMaker]
				null
		}, obj
$.plugin
	depends: "dom"
	provides: "lazy"
, ->
	lazy_load = (elementName, props) ->
		$("head").append $.extend document.createElement(elementName), props
	$:
		script: (src) ->
			lazy_load "script", { src: src }
		style: (src) ->
			lazy_load "link", { href: src, rel: "stylesheet" }
$.plugin
	provides: "math"
	depends: "core"
, ->
	$.type.extend
		bool: { number: (o) -> if o then 1 else 0 }
		number: { bool: (o) -> not not o }
	_By = (cmp) ->
		(field) ->
			valueOf = switch $.type field
				when "string" then (o) -> o[field]
				when "function" then field
				else throw new Error ".maxBy first argument should be a string or function"
			x = @first()
			@skip(1).each ->
				if cmp valueOf(@), valueOf(x)
					x = @
			return x
	$:
		range: (start, end, step = 1) ->
			if not end? then (end = start; start = 0)
			$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
		zeros: (n) -> $( 0 for i in [0...n] )
		ones: (n) -> $( 1 for i in [0...n] )
		deg2rad: (n) -> n * Math.PI / 180
		rad2deg: (n) -> n * 180 / Math.PI
	floats: -> @map parseFloat
	ints: -> @map -> parseInt @, 10
	px: (delta) -> @ints().map -> $.px @,delta
	min: -> @filter( isFinite ).reduce Math.min
	max: -> @filter( isFinite ).reduce Math.max
	maxBy: _By (a,b) -> a > b
	minBy: _By (a,b) -> a < b
	mean: mean = -> if not @length then 0 else @sum() / @length
	avg: mean
	sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
	product: -> @filter( isFinite ).reduce (a) -> a * @
	squares: -> @pow(2)
	pow: (n) -> @map -> Math.pow @, n
	magnitude: -> Math.sqrt @floats().squares().sum()
	scale: (r) -> @map -> r * @
	add: add = (d) -> switch $.type(d)
		when "number" then @map -> d + @
		when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
	plus: add
	vecAdd: (v) ->
		d = $()
		for i in [0...@length] by 1
			d[i] = @[i] + v[i]
		d
	normalize: -> @scale 1 / @magnitude()
	deg2rad: -> @filter( isFinite ).map -> @ * Math.PI / 180
	rad2deg: -> @filter( isFinite ).map -> @ * 180 / Math.PI
$.plugin
	provides: "pubsub"
, ->
	$:
		publish: (e, args...) ->
			f.apply null, args for f in (subscribers[e] or= [])
			args
		publisher: (e, func) ->
			(args...) ->
				$.publish e, func.apply @, args
		subscribe: (e, func) ->
			(subscribers[e] or= []).push func
			func
		unsubscribe: (e, func) ->
			if not func?
				subscribers[e] = []
			else
				a = (subscribers[e] or= [])
				if (i = a.indexOf func)  > -1
					a.splice(i,i)
$.plugin
	provides: 'random'
	depends: 'type'
, ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""
		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615
		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)
			index = (index + 1) % 624
			(y + a) / b
		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()
		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
$.plugin
	provides: "sendgrid"
	depends: "config"
, ->
	try
		nodemailer = require 'nodemailer'
	catch err
		`return`
	transport = nodemailer.createTransport 'SMTP',
		service: 'SendGrid'
		auth:
			user: $.config.get 'SENDGRID_USERNAME'
	$:
		sendMail: (mail, callback) ->
			mail.transport ?= transport
			mail.from ?= $.config.get 'EMAILS_FROM'
			mail.bcc ?= $.config.get 'EMAILS_BCC'
			if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
				nodemailer.sendMail mail, callback
			else
$.plugin
	provides: "sortBy,sortedIndex"
, ->
	$:
		sortedIndex: (array, item, iterator) ->
			cmp = switch $.type iterator
				when "string" then (a,b) -> a[iterator] - b[iterator]
				when "function" then (a,b) -> iterator(a) - iterator(b)
				else (a,b) -> a - b
				if cmp(array[i], item) > 0
					return i
			return array.length
	sortBy: (iterator) ->
		a = $()
		for item in @
			n = $.sortedIndex a, item, iterator
			a.splice n, 0, item
		a
		
$.plugin
	provides: "string"
	depends: "function"
, ->
	safer = (f) ->
		(a...) ->
			try return f(a...)
	$.type.extend
		unknown:
			string: safer (o) -> o.toString?() ? String(o)
			repr: safer (o) -> $.type.lookup(o).string(o)
			number: safer (o) -> parseFloat String o
		null: { string: -> "null" }
		undefined: { string: -> "undefined" }
		string:
			number: safer parseFloat
		array:  { string: safer (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
		object: { string: safer (o) ->
			ret = []
			for k of o
				try
					v = o[k]
				catch err
			"{" + ret.join(', ') + "}"
		}
		function:
			string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
		number:
			repr:   (n) -> String(n)
			string: safer (n) ->
				switch true
					when n.precision? then n.toPrecision(n.precision)
					when n.fixed? then n.toFixed(n.fixed)
					else String(n)
	return {
		$:
			toString: (x) ->
				if not x? then "function Bling(selector, context) { [ ... ] }"
				else
					try
						$.type.lookup(x).string(x)
					catch err
			toRepr: (x) -> $.type.lookup(x).repr(x)
			px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"
			capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")
			dashize: (name) ->
				ret = ""
				for i in [0...(name?.length|0)]
					c = name.charCodeAt i
					if 91 > c > 64
						c += 32
						ret += '-'
					ret += String.fromCharCode(c)
				ret
			camelize: (name) ->
				name.split('-')
				while (i = name?.indexOf('-')) > -1
					name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
				name
			padLeft: (s, n, c = " ") ->
				while s.length < n
					s = c + s
				s
			padRight: (s, n, c = " ") ->
				while s.length < n
					s = s + c
				s
			stringTruncate: (s, n, c = "...") ->
				s = s.split(' ')
				r = []
				while n > 0
					x = s.shift()
					n -= x.length
					if n >= 0
						r.push x
				r.join('') + c
			stringCount: (s, x, i = 0, n = 0) ->
				if (j = s.indexOf x,i) > i-1
					$.stringCount s, x, j+1, n+1
				else n
			stringSplice: (s, i, j, n) ->
				nn = s.length
				end = j
				if end < 0
					end += nn
				start = i
				if start < 0
					start += nn
				s.substring(0,start) + n + s.substring(end)
			checksum: (s) ->
				a = 1; b = 0
				for i in [0...s.length]
					a = (a + s.charCodeAt(i)) % 65521
					b = (b + a) % 65521
				(b << 16) | a
			repeat: (x, n=2) ->
				switch true
					when n is 1 then x
					when n < 1 then ""
					when $.is "string", x then x + $.repeat(x, n-1)
					else $(x).extend $.repeat(x, n-1)
			stringBuilder: ->
				if $.is("global", @) then return new $.stringBuilder()
				items = []
				@length   = 0
				@append   = (s) => items.push s; @length += s?.toString().length|0
				@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
				@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
				@toString = ( ) => items.join("")
				@
		toString: -> $.toString @
		toRepr: -> $.toRepr @
	}
$.plugin
	provides: "symbol"
	depends: "type"
, ->
	symbol = null
	cache = {}
	g = $.global
	g.Bling = Bling
	if module?
		module.exports = Bling
	$.defineProperty $, "symbol",
		set: (v) ->
			g[symbol] = cache[symbol]
			cache[symbol = v] = g[v]
			g[v] = Bling
		get: -> symbol
	return $:
		symbol: "$"
		noConflict: ->
			Bling.symbol = "Bling"
			Bling
$.plugin
	provides: "StateMachine"
, ->
	$: StateMachine: class StateMachine
		constructor: (stateTable) ->
			@debug = false
			@reset()
			@table = stateTable
			Object.defineProperty @, "modeline",
				get: -> @table[@_mode]
			Object.defineProperty @, "mode",
				set: (m) ->
					@_lastMode = @_mode
					@_mode = m
					if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
						ret = @modeline['enter'].call @
						while $.is("function",ret)
							ret = ret.call @
					m
				get: -> @_mode
		reset: ->
			@_mode = null
			@_lastMode = null
		GO: (m) -> -> @mode = m
		@GO: (m) -> -> @mode = m
		
		tick: (c) ->
			row = @modeline
			if not row?
				ret = null
			else if c of row
				ret = row[c]
			else if 'def' of row
				ret = row['def']
			while $.is "function",ret
				ret = ret.call @, c
			ret
		run: (inputs) ->
			@mode = 0
			for c in inputs
				ret = @tick(c)
			if $.is "function",@modeline?.eof
				ret = @modeline.eof.call @
			while $.is "function",ret
				ret = ret.call @
			@reset()
			return @
$.plugin
	provides: "synth"
	depends: "StateMachine, type"
, ->
	class SynthMachine extends $.StateMachine
		basic =
			".": @GO 3
			"[": @GO 4
			'"': @GO 6
			"'": @GO 7
			" ": @GO 8
			",": @GO 10
			"+": @GO 11
			eof: @GO 13
		@STATE_TABLE = [
				enter: ->
					@tag = @id = @cls = @attr = @val = @text = ""
					@attrs = {}
					@GO 1
			},
				def: (c) -> @tag += c
			}, basic),
				def: (c) -> @id += c
			}, basic),
				enter: -> @cls += " " if @cls.length > 0
				def: (c) -> @cls += c
			}, basic),
				"=": @GO 5
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @attr += c
				eof: @GO 12
			},
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @val += c
				eof: @GO 12
			},
				'"': @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				"'": @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = null
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = @cursor?.parentNode
					@GO 0
			},
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
			}
		]
		constructor: ->
			super(SynthMachine.STATE_TABLE)
			@fragment = @cursor = document.createDocumentFragment()
		emitNode: ->
			if @tag
				node = document.createElement @tag
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@cursor.appendChild node
				@cursor = node
		emitText: ->
			@cursor.appendChild $.type.lookup("<html>").node(@text)
			@text = ""
	return {
		$:
			synth: (expr) ->
				s = new SynthMachine()
				s.run(expr)
				if s.fragment.childNodes.length == 1
					$(s.fragment.childNodes[0])
				else
					$(s.fragment)
	}
do ($ = Bling) ->
		current_engine = null
		engines = {}
		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine
		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()
		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop] by 1
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1
	$.template.register_engine 'pythonic', (() ->
		chunk_re = /%[\(\/]/
		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n] by 1
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}
			if not cache?
			n = cache.length
			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""
		return render
	)()
		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
$.plugin
	provides: "throttle"
	depends: "core"
, ->
	$:
		throttle: (ms, f) ->
			last = 0
			(a...) ->
				gap = $.now - last
				if gap > ms
					last += gap
					return f.apply @,a
				null
		debounce: (ms, f) ->
			last = 0
			(a...) ->
				last += (gap = $.now - last)
				return f.apply @,a if gap > ms else null
	parseOne = (data) ->
		i = data.indexOf ":"
		if i > 0
			len = parseInt data[0...i], 10
			item = data[i+1...i+1+len]
			type = data[i+1+len]
			extra = data[i+len+2...]
			item = switch type
				when "'" then String(item)
				when "!" then (item is "true")
				when "~" then null
				when "]" then parseArray(item)
				when "}" then parseObject(item)
			return [item, extra]
		return undefined
	parseArray = (x) ->
		data = []
		while x.length > 0
			[one, x] = parseOne(x)
			data.push(one)
		data
	parseObject = (x) ->
		data = {}
		while x.length > 0
			[key, x] = parseOne(x)
			[value, x] = parseOne(x)
			data[key] = value
		data
	$:
		TNET:
			stringify: (x) ->
				[data, type] = switch $.type x
					when "string" then [x, "'"]
					when "function" then [String(x), "'"]
					when "boolean" then [String(not not x), "!"]
					when "null" then ["", "~"]
					when "undefined" then ["", "~"]
					when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
					when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
				return (data.length|0) + ":" + data + type
			parse: (x) ->
				parseOne(x)?[0]
$.plugin
	provides: "trace"
	depends: "function,type"
, ->
	$.type.extend
		unknown: { trace: $.identity }
		function:
			trace: (label, f, tracer) ->
				label or= f.name
				r = (a...) ->
					f.apply @, a
				r
	return $: trace: (label, o, tracer) ->
		if not $.is "string", label
			[tracer, o] = [o, label]
		tracer or= $.log
		label or= ""
		$.type.lookup(o).trace(label, o, tracer)
$.plugin
	depends: "dom"
, ->
	COMMASEP = ", "
		"slow": 700
		"medium": 500
		"normal": 300
		"fast": 100
		"instant": 0
		"now": 0
	accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
	testStyle = document.createElement("div").style
	transformProperty = "transform"
	transitionProperty = "transition-property"
	transitionDuration = "transition-duration"
	transitionTiming = "transition-timing-function"
	if "WebkitTransform" of testStyle
		transformProperty = "-webkit-transform"
		transitionProperty = "-webkit-transition-property"
		transitionDuration = "-webkit-transition-duration"
		transitionTiming = "-webkit-transition-timing-function"
	else if "MozTransform" of testStyle
		transformProperty = "-moz-transform"
		transitionProperty = "-moz-transition-property"
		transitionDuration = "-moz-transition-duration"
		transitionTiming = "-moz-transition-timing-function"
	else if "OTransform" of testStyle
		transformProperty = "-o-transform"
		transitionProperty = "-o-transition-property"
		transitionDuration = "-o-transition-duration"
		transitionTiming = "-o-transition-timing-function"
	return {
		$:
			duration: (speed) ->
				d = speeds[speed]
				return d if d?
				return parseFloat speed
		transform: (end_css, speed, easing, callback) ->
			if $.is("function",speed)
				callback = speed
				speed = easing = null
			else if $.is("function",easing)
				callback = easing
				easing = null
			speed ?= "normal"
			easing or= "ease"
			duration = $.duration(speed) + "ms"
			props = []
			trans = ""
			css = {}
			for i of end_css
				if accel_props_re.test(i)
					ii = end_css[i]
					if ii.join
						ii = $(ii).px().join COMMASEP
					else if ii.toString
						ii = ii.toString()
					trans += " " + i + "(" + ii + ")"
				else css[i] = end_css[i]
			(props.push i) for i of css
			if trans
				props.push transformProperty
			css[transitionProperty] = props.join COMMASEP
			css[transitionDuration] = props.map(-> duration).join COMMASEP
			css[transitionTiming] = props.map(-> easing).join COMMASEP
			if trans
				css[transformProperty] = trans
			@css css
			@delay duration, callback
			@each ->
				if @style
					if @style.display is not "none"
						@_display = @syle.display
					@style.display = "none"
			.trigger "hide"
			.delay updateDelay, callback
			@each ->
				if @style
					@style.display = @_display
					delete @_display
			.trigger "show"
			.delay updateDelay, callback
			@weave(@css("display"))
				.fold (display, node) ->
					if display is "none"
						node.style.display = node._display or ""
						delete node._display
						$(node).trigger "show"
					else
						node._display = display
						node.style.display = "none"
						$(node).trigger "hide"
					node
				.delay(updateDelay, callback)
			@.css('opacity','0.0')
				.show ->
					@transform {
						opacity:"1.0",
						translate3d: [0,0,0]
					}, speed, callback
			@transform {
				opacity:"0.0",
				translate3d:[x,y,0.0]
			}, speed, -> @hide(callback)
		fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
		fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
		fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
		fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
	}
$.plugin
	provides: "type"
, ->
	isType = (T, o) ->
		if not o? then T in [o,"null","undefined"]
		else o.constructor is T or
			o.constructor.name is T or
	inherit = (parent, obj) ->
		if typeof parent is "function"
			parent = parent.prototype
		if parent.__proto__ is Object.prototype
			parent.__proto__ = obj.__proto__
		obj.__proto__ = parent
		obj
	_type = do ->
		cache = {}
		base =
			name: 'unknown'
			match: (o) -> true
		order = []
		register = (name, data) ->
			order.unshift name if not (name of cache)
			cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
			cache[name][name] = (o) -> o
		_extend = (name, data) ->
			if typeof name is "string"
				cache[name] ?= register name, {}
				cache[name] = extend cache[name], data
			else if typeof name is "object"
				(_extend k, name[k]) for k of name
		lookup = (obj) ->
			for name in order
				if cache[name]?.match.call obj, obj
					return cache[name]
		register "unknown",   base
		register "object",    match: -> typeof @ is "object"
		register "error",     match: -> isType 'Error', @
		register "regexp",    match: -> isType 'RegExp', @
		register "string",    match: -> typeof @ is "string" or isType String, @
		register "number",    match: -> (isType Number, @) and @ isnt NaN
		register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
		register "array",     match: -> Array.isArray?(@) or isType Array, @
		register "function",  match: -> typeof @ is "function"
		register "undefined", match: (x) -> x is undefined
		register "null",      match: (x) -> x is null
		return extend ((o) -> lookup(o).name),
			register: register
			lookup: lookup
			extend: _extend
			is: (t, o) -> cache[t]?.match.call o, o
			as: (t, o, rest...) -> lookup(o)[t]?(o, rest...)
	_type.extend
		unknown:   { array: (o) -> [o] }
		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }
	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) -> o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"
	$:
		inherit: inherit
		extend: extend
		defineProperty: (o, name, opts) ->
			Object.defineProperty o, name, extend({ configurable: true, enumerable: true }, opts)
			o
		isType: isType
		type: _type
		is: _type.is
		as: _type.as
		isSimple: (o) -> _type(o) in ["string", "number", "bool"]
		isEmpty: (o) -> o in ["", null, undefined] or o.length is 0 or (typeof o is "object" and Object.keys(o).length is 0)
	defineProperty: (name, opts) -> @each -> $.defineProperty @, name, opts
$.plugin
	provides: "unittest"
	depends: "core,function"
, ->
	testCount = passCount = failCount = 0
	failed = []
	invokeTest = (group, name, func) ->
		return if not $.is "function", func
		shouldFail = name.toLowerCase().indexOf("fail") isnt -1
		done = $.once (err) ->
			testCount--
			if (!!err isnt shouldFail)
				failCount++
				failed.push name
			else
				_log "pass"
				passCount++
				$.provide name
		f = (done) ->
			try func(done)
			catch err then done(err)
			finally
				if name.toLowerCase().indexOf("async") is -1 then done()
		testCount++
		try f(done)
		catch err then done(err)
	testReport = $.once ->
		if failCount > 0
			try process.exit(failCount)
	$:
		approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
		assertEqual: (a, b, label) ->
			if a isnt b
		assertArrayEqual: (a, b, label) ->
			for i in [0...a.length] by 1
				try
					$.assertEqual(a[i], b[i], label)
				catch err
		testGroup: (name, funcs) ->
			interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
			for k,func of funcs
				invokeTest(name, k, func)
	assertEqual: (args...) ->
				if $.is "function", x then x.call(@,@) else x
			a = args[0]
			for i in [1...args.length]
				$.assertEqual a, args[i]
		return @


generateDocumentation = (source, config, callback) ->
  fs.readFile source, (error, buffer) ->
    throw error if error
    code = buffer.toString()
    sections = parse source, code
    highlight source, sections, ->
      generateHtml source, sections, config
      callback()

parse = (source, code) ->
  lines    = code.split '\n'
  sections = []
  language = getLanguage source
  hasCode  = docsText = codeText = ''

  save = (docsText, codeText) ->
    sections.push {docsText, codeText}

  for line in lines
    if line.match(language.commentMatcher) and not line.match(language.commentFilter)
      if hasCode
        save docsText, codeText
        hasCode = docsText = codeText = ''
      docsText += line.replace(language.commentMatcher, '') + '\n'
    else
      hasCode = yes
      codeText += line + '\n'
  save docsText, codeText
  sections

highlight = (source, sections, callback) ->
  language = getLanguage source
  pygments = spawn 'pygmentize', [
    '-l', language.name,
    '-f', 'html',
    '-O', 'encoding=utf-8,tabsize=2'
  ]
  output   = ''
  
  pygments.stderr.on 'data',  (error)  ->
    console.error error.toString() if error
    
  pygments.stdin.on 'error',  (error)  ->
    console.error 'Could not use Pygments to highlight the source.'
    process.exit 1
    
  pygments.stdout.on 'data', (result) ->
    output += result if result
    
  pygments.on 'exit', ->
    output = output.replace(highlightStart, '').replace(highlightEnd, '')
    fragments = output.split language.dividerHtml
    for section, i in sections
      section.codeHtml = highlightStart + fragments[i] + highlightEnd
      section.docsHtml = showdown.makeHtml section.docsText
    callback()
    
  if pygments.stdin.writable
    text = (section.codeText for section in sections)
    pygments.stdin.write text.join language.dividerText
    pygments.stdin.end()
  
generateHtml = (source, sections, config) ->
  destination = (filepath) ->
    path.join(config.output, path.basename(filepath, path.extname(filepath)) + '.html')   
  title = path.basename source
  dest  = destination source
  html  = config.doccoTemplate {
    title      : title, 
    sections   : sections, 
    sources    : config.sources, 
    path       : path, 
    destination: destination
    css        : path.basename(config.css)
  }
  fs.writeFileSync dest, html


fs       = require 'fs'
path     = require 'path'
showdown = require('./../vendor/showdown').Showdown
{spawn, exec} = require 'child_process'
commander = require 'commander'

getResource = (name) ->
  fullPath = path.join __dirname, '..', 'resources', name
  fs.readFileSync(fullPath).toString()

languages = JSON.parse getResource 'languages.json'

for ext, l of languages





getLanguage = (source) -> languages[path.extname(source)]

ensureDirectory = (dir, callback) ->

template = (str) ->
  new Function 'obj',
    'var p=[],print=function(){p.push.apply(p,arguments);};' +
    'with(obj){p.push(\'' +
    str.replace(/[\r\t\n]/g, " ")
       .replace(/'(?=[^<]*%>)/g,"\t")
       .split("'").join("\\'")
       .split("\t").join("'")
       .replace(/<%=(.+?)%>/g, "',$1,'")
       .split('<%').join("');")
       .split('%>').join("p.push('") +
       "');}return p.join('');"

highlightStart = '<div class="highlight"><pre>'

highlightEnd   = '</pre></div>'


defaults =
  output  : "docs/"


  
run = (args=process.argv) ->
  commander.version(version)
    .usage("[options] <filePattern ...>")
    .option("-c, --css [file]","use a custom css file",defaults.css)
    .option("-o, --output [path]","use a custom output path",defaults.output)
    .option("-t, --template [file]","use a custom .jst template",defaults.template)
    .parse(args)
    .name = "docco"
  if commander.args.length
    document(commander.args.slice(),commander)
  else
    console.log commander.helpInformation()


document = (sources, options = {}, callback = null) ->
  config = {}
  config[key] = defaults[key] for key,value of defaults
  config[key] = value for key,value of options if key of defaults

  resolved = []
  resolved = resolved.concat(resolveSource(src)) for src in sources
  config.sources = resolved.filter((source) -> getLanguage source).sort()
  
  config.doccoTemplate = template fs.readFileSync(config.template).toString()
  doccoStyles = fs.readFileSync(config.css).toString()

  ensureDirectory config.output, ->
    fs.writeFileSync path.join(config.output,path.basename(config.css)), doccoStyles
    files = config.sources.slice()
    nextFile = -> 
      callback() if callback? and not files.length
      generateDocumentation files.shift(), config, nextFile if files.length
    nextFile()


resolveSource = (source) ->
  return source if not source.match(/([\*\?])/)
  regex_str = path.basename(source)
    .replace(/\./g, "\\$&")
    .replace(/\*/,".*")
    .replace(/\?/,".")
  regex = new RegExp('^(' + regex_str + ')$')
  file_path = path.dirname(source)
  files = fs.readdirSync file_path
  return (path.join(file_path,file) for file in files when file.match regex)


exports[key] = value for key, value of {
  run           : run
  document      : document
  parse         : parse
  resolveSource : resolveSource
  version       : version
  defaults      : defaults
  languages     : languages
}
world = "World!"


This file will report 3 comments when parsed because the 
and end of the block comment.

As a result, all of this text will be considered code. It's 
not a good situation, but that's how `docco` works.
  

console.log "// Comment"


{spawn, exec} = require 'child_process'
path          = require 'path'
fs            = require 'fs'

testPath      = path.dirname fs.realpathSync(__filename)
dataPath      = path.join testPath, "data"
resourcesPath = path.normalize path.join(testPath,"/../resources")

testDoccoRun = (testName,sources,options=null,callback=null) ->
  destPath = path.join dataPath, testName
  cleanup ->
    options?.output = destPath
    Docco.document sources, options, ->
      files       = []
      files       = files.concat(Docco.resolveSource(src)) for src in sources
      expected    = files.length + 1
      found       = fs.readdirSync(destPath).length
      callback() if callback?

test "custom JST template file", ->
  testDoccoRun "custom_jst", 

test "custom CSS file", ->
  testDoccoRun "custom_css", 

test "single line comment parsing", ->
  commentsPath = path.join testPath, "comments"
  languageKeys = (ext for ext,l of Docco.languages)

  testNextLanguage = (keys,callback) ->
    return callback?() if not keys.length

    extension       = keys.shift()
    language        = Docco.languages[extension]
    languagePath    = path.join dataPath, languageTest

    return testNextLanguage(keys, callback) if not path.existsSync languageExample   
   
    testDoccoRun languageTest, [languageExample], options, ->

      content = fs.readFileSync(languageOutput).toString()
      comments = (c.trim() for c in content.split(',') when c.trim() != '') 

      eq true, comments.length >= 1, 'expect at least the descriptor comment'

      expected = parseInt(comments[0])    
      
      eq comments.length, expected, [
        ""
        "------------------------"
      ].join '\n'
      
      testNextLanguage keys, callback
      
  testNextLanguage languageKeys.slice()
     
dom = require('../dom')

assign_and_output = () ->
	document = dom.createDocument()
	document.body.innerHTML = "<div class='content' id='content'>Hello World.</div>"
	return document.toString()

output = () ->
	node = (name, attrs = {}, children) ->
		attrs = (' '+k+'="'+attrs[k]+'"' for k of attrs).join('')
		if children.join
			children = children.join('')
	html = (children = []) -> node('html', {}, children)
	head = (attrs = {}, children = []) -> node('head', attrs, children)
	body = (attrs = {}, children = []) -> node('body', attrs, children)
	div = (attrs = {}, children = []) -> node('div', attrs, children)
	p = (attrs = {}, children = []) -> node('p', attrs, children)
	span = (attrs = {}, children = []) -> node('span', attrs, children)

	html([head(), body(null, div({id:'content','class':'content'}, "Hello World."))])

measure = (f, n) ->
	start = Date.now()
	for i in [0..n]
		f()
	return (Date.now() - start)

run = (f, n, interval) ->
	sum = 0
	sum_n = 0
	for i in [0...n] by interval
		ms = measure(f, interval)
		rps = interval * 1000 / ms
		sum += rps
		sum_n += 1
	console.log "Avg. requests per sec:", (sum/sum_n)

console.log "Using domjs"
console.log assign_and_output()
run assign_and_output, 1000,200

console.log "Using a raw tree"
console.log output()
run output, 100000, 20000

tag = (name, attrs = {}, children) ->
	attrs = (' '+k+'="'+attrs[k]+'"' for k of attrs).join('')
	if children.join
		children = children.join('')
a = (attrs = {}, children = []) -> tag('a', attrs, children)
area = (attrs = {}, children = []) -> tag('area', attrs, children)
audio = (attrs = {}, children = []) -> tag('audio', attrs, children)
base = (attrs = {}, children = []) -> tag('base', attrs, children)
blockquote = (attrs = {}, children = []) -> tag('blockquote', attrs, children)
body = (attrs = {}, children = []) -> tag('body', attrs, children)
br = (attrs = {}, children = []) -> tag('br', attrs, children)
button = (attrs = {}, children = []) -> tag('button', attrs, children)
canvas = (attrs = {}, children = []) -> tag('canvas', attrs, children)
caption = (attrs = {}, children = []) -> tag('caption', attrs, children)
col = (attrs = {}, children = []) -> tag('col', attrs, children)
colgroup = (attrs = {}, children = []) -> tag('colgroup', attrs, children)
del = (attrs = {}, children = []) -> tag('del', attrs, children)
details = (attrs = {}, children = []) -> tag('details', attrs, children)
div = (attrs = {}, children = []) -> tag('div', attrs, children)
dl = (attrs = {}, children = []) -> tag('dl', attrs, children)
embed = (attrs = {}, children = []) -> tag('embed', attrs, children)
fieldSet = (attrs = {}, children = []) -> tag('fieldSet', attrs, children)
form = (attrs = {}, children = []) -> tag('form', attrs, children)
h1 = (attrs = {}, children = []) -> tag('h1', attrs, children)
h2 = (attrs = {}, children = []) -> tag('h2', attrs, children)
h3 = (attrs = {}, children = []) -> tag('h3', attrs, children)
h4 = (attrs = {}, children = []) -> tag('h4', attrs, children)
h5 = (attrs = {}, children = []) -> tag('h5', attrs, children)
h6 = (attrs = {}, children = []) -> tag('h6', attrs, children)
head = (attrs = {}, children = []) -> tag('head', attrs, children)
hr = (attrs = {}, children = []) -> tag('hr', attrs, children)
html = (attrs = {}, children = []) -> tag('html', attrs, children)
iframe = (attrs = {}, children = []) -> tag('iframe', attrs, children)
image = (attrs = {}, children = []) -> tag('image', attrs, children)
input = (attrs = {}, children = []) -> tag('input', attrs, children)
ins = (attrs = {}, children = []) -> tag('ins', attrs, children)
keygen = (attrs = {}, children = []) -> tag('keygen', attrs, children)
label = (attrs = {}, children = []) -> tag('label', attrs, children)
legend = (attrs = {}, children = []) -> tag('legend', attrs, children)
li = (attrs = {}, children = []) -> tag('li', attrs, children)
link = (attrs = {}, children = []) -> tag('link', attrs, children)
map = (attrs = {}, children = []) -> tag('map', attrs, children)
menu = (attrs = {}, children = []) -> tag('menu', attrs, children)
meta = (attrs = {}, children = []) -> tag('meta', attrs, children)
meter = (attrs = {}, children = []) -> tag('meter', attrs, children)
object = (attrs = {}, children = []) -> tag('object', attrs, children)
ol = (attrs = {}, children = []) -> tag('ol', attrs, children)
optgroup = (attrs = {}, children = []) -> tag('optgroup', attrs, children)
option = (attrs = {}, children = []) -> tag('option', attrs, children)
output = (attrs = {}, children = []) -> tag('output', attrs, children)
p = (attrs = {}, children = []) -> tag('p', attrs, children)
param = (attrs = {}, children = []) -> tag('param', attrs, children)
pre = (attrs = {}, children = []) -> tag('pre', attrs, children)
progress = (attrs = {}, children = []) -> tag('progress', attrs, children)
quote = (attrs = {}, children = []) -> tag('quote', attrs, children)
script = (attrs = {}, children = []) -> tag('script', attrs, children)
select = (attrs = {}, children = []) -> tag('select', attrs, children)
source = (attrs = {}, children = []) -> tag('source', attrs, children)
style = (attrs = {}, children = []) -> tag('style', attrs, children)
table = (attrs = {}, children = []) -> tag('table', attrs, children)
thead = (attrs = {}, children = []) -> tag('thead', attrs, children)
tbody = (attrs = {}, children = []) -> tag('tbody', attrs, children)
tfoot = (attrs = {}, children = []) -> tag('tfoot', attrs, children)
td = (attrs = {}, children = []) -> tag('td', attrs, children)
th = (attrs = {}, children = []) -> tag('th', attrs, children)
tr = (attrs = {}, children = []) -> tag('tr', attrs, children)
textarea = (attrs = {}, children = []) -> tag('textarea', attrs, children)
title = (attrs = {}, children = []) -> tag('title', attrs, children)
ul = (attrs = {}, children = []) -> tag('ul', attrs, children)
video = (attrs = {}, children = []) -> tag('video', attrs, children)
Copyright (c) 2011 Jesse Dailey <jesse.dailey@gmail.com>
License: MIT License - http://www.opensource.org/licenses/mit-license.php
parser = require("./html/parser")
htmlparse = parser.parse
htmlescape = parser.escape
htmlunescape = parser.unescape
matcher = require("./css/nwmatcher")

NotSupported = ->
	throw Error "NOT_SUPPORTED"

repeat = (s, n) ->
	n = Math.max(0, n)
	switch n
		when 0 then ""
		when 1 then s
		else s + repeat(s, n-1)

extend = (o, p) ->
	o or= {}
	for k of p
		o[k] = p[k]
	return o

property = (o, k, props) ->
	Object.defineProperty o, k, extend({
		enumerable: true
		configurable: true
	}, props)

class Event
	@CAPTURING_PHASE = 1
	@AT_TARGET = 2
	@BUBBLING_PHASE = 3
	constructor: ->
		@type = null
		@target = null
		@currentTarget = null
		@eventPhase = 0
		@bubbles = false
		@cancelable = true
		@timeStamp = 0
	stopPropagation: ->
	preventDefault: ->
	initEvent: (type, canBubble, cancelable) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@timeStamp = new Date().getTime()

class MutationEvent extends Event
	@MODIFICATION = 1
	@ADDITION = 2
	@REMOVAL = 3
	constructor: ->
		@relatedNode = null
		@prevValue = null
		@newValue = null
		@attrName = null
		@attrChange = 0
	initMutationEvent: (type, canBubble, cancelable, relatedNode, prevValue, newValue, attrName, attrChange) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@relatedNode = relatedNode
		@prevValue = prevValue
		@newValue = newValue
		@attrName = attrName
		@attrChange = attrChange

class Node
	@ELEMENT_NODE = 1
	@ATTRIBUTE_NODE = 2
	@TEXT_NODE = 3
	@CDATA_SECTION_NODE = 4
	@ENTITY_REFERENCE_NODE = 5
	@ENTITY_NODE = 6
	@PROCESSING_INSTRUCTION_NODE = 7
	@COMMENT_NODE = 8
	@DOCUMENT_NODE = 9
	@DOCUMENT_TYPE_NODE = 10
	@DOCUMENT_FRAGMENT_NODE = 11
	@NOTATION_NODE = 12

	@DOCUMENT_POSITION_DISCONNECTED = 1
	@DOCUMENT_POSITION_PRECEDING = 2
	@DOCUMENT_POSITION_FOLLOWING = 4
	@DOCUMENT_POSITION_CONTAINS = 8
	@DOCUMENT_POSITION_CONTAINED_BY = 16
	@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32

	constructor: (name, value = null, type = 1, ownerDocument = null) ->
		@_private =
			nodeName: null
			parentNode: null
			childIndex: -1
			classes: []
		@nodeName = name
		@nodeValue = value
		@nodeType = type
		@ownerDocument = ownerDocument
		@childNodes = []
		@attributes = { }
		@listeners =
			true: {}
			false: {}

	addEventListener: (type, listener, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		if not listener in list
			list.push listener
	removeEventListener: (type, listener = null, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		i = list.indexOf listener
		list.splice(i,1)
	dispatchEvent: (evt) ->
		prevented = false
		stopped = false
		evt.preventDefault = ->
			if evt.cancelable
				prevented = true
		evt.stopPropagation = ->
			stopped = true
		evt.target = @
		evt.eventPhase = Event.CAPTURING_PHASE
		chain = [@]
		while chain[0].parentNode isnt @ownerDocument
			chain.unshift chain[0].parentNode
		chain.unshift @ownerDocument
		for ancestor in chain
			evt.currentTarget = ancestor
			list = ancestor.listeners[true][evt.type]
			handler(evt) for handler in list if list
			break if stopped

		evt.eventPhase = Event.AT_TARGET
		evt.currentTarget = evt.target
		list = @listeners[true][evt.type]
		handler(evt) for handler in list if list
		list = @listeners[false][evt.type]
		handler(evt) for handler in list if list

		if evt.bubbles
			for ancestor in chain.reverse()
				evt.currentTarget = ancestor
				list = ancestor.listeners[false][evt.type]
				handler(evt) for handler in list if list


	cloneNode: (deep = false) ->
		ret = switch @.constructor
			when Text,Comment,CData then new @constructor @nodeValue, @ownerDocument
			when Attr then new @constructor @nodeName, @nodeValue
			else new @constructor(@nodeName, @nodeValue, @nodeType, @ownerDocument)
		for a of @_private
			ret._private[a] = @_private[a]
		for a of @attributes
			ret.attributes[a] = @attributes[a]
		if deep
			for c in @childNodes
				ret.childNodes.push c.cloneNode(true)
		ret
	hasAttributes: ->
		for a of @attributes
			return true
		return false
	isSameNode: (node) ->
		node is @
	hasChildNodes: ->
		@childNodes.length > 0
	insertBefore: (newNode, refNode) ->
		if not refNode?
			return @appendChild(newNode)
		if refNode.parentNode isnt @
			throw Error "Cannot insertBefore a non-child."
		if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in newNode.childNodes
				@insertBefore(c, refNode)
		else
			i = refNode._private.childIndex
			if i > -1
				@childNodes.splice(i, 0, newNode)
				newNode._private.childIndex = i
				newNode._private.parentNode = @
				refNode._private.childIndex = i + 1
				i = 0
				for c in @childNodes
					c._private.childIndex = i++
		newNode
	appendChild: (node) ->
		if not node?
			return
		if node.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in node.childNodes
				@appendChild(c)
		else
			node._private.parentNode = @
			node._private.childIndex = @childNodes.length
			@childNodes.push node
	removeChild: (node) ->
		if( typeof node is "number" )
			node = @childNodes[node]
		i = node._private.childIndex
		if i > -1 and node.parentNode is @
			node._private.parentNode = null
			node._private.childIndex = -1
			@childNodes.splice(i, 1)
			i = 0
				c._private.childIndex = i++
		else
			throw Error "Cannot removeChild a non-child."
		node
	replaceChild: (newNode, oldNode) ->
		if oldNode.parentNode isnt @
			throw Error "Cannot replaceChild a non-child."
		i = oldNode._private.childIndex
		if i < 0
			throw Error "DOM tree corruption, childIndex is < 0"
		if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in @childNodes
				@insertBefore(c, oldNode)
			return @removeChild(oldNode)
		newNode._private.parentNode = @
		newNode._private.childIndex = i
		oldNode._private.parentNode = null
		oldNode._private.childIndex = -1
		@childNodes.splice(i, 1, newNode)
		oldNode
	toString: (pretty=false,deep=true,indentLevel=0) ->
		if pretty
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		switch @nodeType
			when Node.TEXT_NODE
			when Node.ELEMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.ATTRIBUTE_NODE
				if @nodeValue isnt ""
			when Node.CDATA_SECTION_NODE
			when Node.COMMENT_NODE
				body = ""
					body = '>'+newline+(c.toString(pretty, deep, indentLevel+1) for c in @childNodes).join('')
					body += indent+"<![endif]"
			when Node.DOCUMENT_TYPE_NODE
			when Node.DOCUMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.DOCUMENT_FRAGMENT_NODE

property Node::, 'nodeName',
	get: -> @_private.nodeName
	set: (v) -> @_private.nodeName = v?.toUpperCase()
property Node::, 'previousSibling',
	get: -> @parentNode?.childNodes[@_private.childIndex-1]
property Node::, 'nextSibling',
	get: -> @parentNode?.childNodes[@_private.childIndex+1]
property Node::, 'parentNode',
	get: -> @_private.parentNode
	set: (v) ->
		if v isnt null
			throw Error "Must use one of appendChild, insertBefore, etc. to give a Node a new parent."
		@_private.parentNode?.removeChild @
		@_private.parentNode = null
		@_private.childIndex = -1
property Node::, 'firstChild',
	get: -> @childNodes[0]
property Node::, 'lastChild',
	get: -> @childNodes[@childNodes.length-1]

class Entity extends Node
	constructor: (a...) ->
		a[2] ?= Node.ENTITY_NODE
		super a...

class Element extends Node
	constructor: (a...) ->
		a[2] ?= Node.ELEMENT_NODE
		super a...
		@style = {}
	getElementsByClassName: (name) ->
		ret = []
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if name is "*" or name in c._private.classes
					ret.push c
				for i in c.getElementsByClassName(name)
					ret.push i
		return ret
	getElementsByTagName: (name) ->
		ret = []
		uname = name.toUpperCase()
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if uname in ["*", c.tagName]
					ret.push c
				for i in c.getElementsByTagName(uname)
					ret.push i
		return ret
	getAttribute: (name) ->
		@attributes[name] or ""
	getAttributeNode: (name) ->
		n = new Attr(name, @getAttribute(name))
		n.ownerElement = @
		n.ownerDocument = @.ownerDocument
		n
	hasAttribute: (name) ->
		name of @attributes
	setAttribute: (name, value) ->
		if not value?
			@removeAttribute(name)
			when "class"
				@className = value
			when "id"
				@id = value
			else
				@attributes[name] = value
	removeAttribute: (name) ->
		delete @attributes[name]
		switch name
			when "class"
				@_private.classes = []
			when "id"
				delete @ownerDocument?._private.idMap[@id]
	matchesSelector: (selector) ->
		@ownerDocument?._private.matcher.match(@, selector)
	querySelector: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)[0]
	querySelectorAll: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)
	scrollByLines: NotSupported
	scrollByPages: NotSupported
	scrollIntoView: NotSupported
	scrollIntoViewIfNeeded: NotSupported
	getBoundingClientRect: NotSupported
	getClientRects: NotSupported
	focus: NotSupported
	blur: NotSupported
	toString: (pretty=false, deep=true, indentLevel = 0) ->
		name = @nodeName?.toLowerCase()
		if pretty and deep
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		len = @childNodes.length
		end = switch len
			when 0 then "/"
			else ""
		r = 1
		if deep
			for c in @childNodes
				ret[r++] = c.toString pretty, deep, indentLevel + 1
		else if len > 0
		if len > 0
		ret.join('')

	_: class HTMLElement extends Element
		constructor: (a...) ->
			super a...
	a: class HTMLAnchorElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "A"
			super a...
	area: class HTMLAreaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "AREA"
			super a...
	audio: class HTMLAudioElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "AUDIO"
			super a...
	base: class HTMLBaseElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BASE"
			super a...
	blockquote: class HTMLBlockquoteElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BLOCKQUOTE"
			super a...
	body: class HTMLBodyElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BODY"
			super a...
	br: class HTMLBRElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BR"
			super a...
	button: class HTMLButtonElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BUTTON"
			super a...
	canvas: class HTMLCanvasElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "CANVAS"
			super a...
	caption: class HTMLTableCaptionElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "CAPTION"
			super a...
	col: class HTMLTableColElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "COL"
			super a...
	colgroup: class HTMLTableColElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "COLGROUP"
			super a...
	del: class HTMLDelElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DEL"
			super a...
	details: class HTMLDetailsElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DETAILS"
			super a...
	div: class HTMLDivElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DIV"
			super a...
	dl: class HTMLDListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DL"
			super a...
	embed: class HTMLEmbedElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "EMBED"
			super a...
	fieldSet: class HTMLFieldSetElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "FIELDSET"
			super a...
	form: class HTMLFormElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "FORM"
			super a...
	h1: class HTMLHeadingElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h2: class HTMLHeading2Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h3: class HTMLHeading3Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h4: class HTMLHeading4Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h5: class HTMLHeading5Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h6: class HTMLHeading6Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H6"
			super a...
	head: class HTMLHeadElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HEAD"
			super a...
	hr: class HTMLHRElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HR"
			super a...
	html: class HTMLHtmlElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HTML"
			super a...
	iframe: class HTMLIFrameElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "IFRAME"
			super a...
	image: class HTMLImageElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "IMAGE"
			super a...
	input: class HTMLInputElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "INPUT"
			super a...
	ins: class HTMLInsElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "INS"
			super a...
	keygen: class HTMLKeygenElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "KEYGEN"
			super a...
	label: class HTMLLabelElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LABEL"
			super a...
	legend: class HTMLLegendElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LEGEND"
			super a...
	li: class HTMLLIElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LI"
			super a...
	link: class HTMLLinkElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LINK"
			super a...
	map: class HTMLMapElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "MAP"
			super a...
	menu: class HTMLMenuElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "MENU"
			super a...
	meta: class HTMLMetaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "META"
			super a...
	meter: class HTMLMeterElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "METER"
			super a...
	object: class HTMLObjectElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OBJECT"
			super a...
	ol: class HTMLOListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OL"
			super a...
	optgroup: class HTMLOptGroupElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OPTGROUP"
			super a...
	option: class HTMLOptionElement extends HTMLInputElement
		constructor: (a...) ->
			a[0] = "OPTION"
			super a...
	output: class HTMLOutputElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OUTPUT"
			super a...
	p: class HTMLParagraphElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "P"
			super a...
	param: class HTMLParamElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PARAM"
			super a...
	pre: class HTMLPreElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PRE"
			super a...
	progress: class HTMLProgressElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PROGRESS"
			super a...
	quote: class HTMLQuoteElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "QUOTE"
			super a...
	script: class HTMLScriptElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "SCRIPT"
			super a...
	select: class HTMLSelectElement extends HTMLInputElement
		constructor: (a...) ->
			a[0] = "SELECT"
			super a...
	source: class HTMLSourceElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "SOURCE"
			super a...
	style: class HTMLStyleElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "STYLE"
			super a...
	table: class HTMLTableElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TABLE"
			super a...
	thead: class HTMLTableHeadElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "THEAD"
			super a...
	tbody: class HTMLTableBodyElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TBODY"
			super a...
	tfoot: class HTMLTableFootElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TFOOT"
			super a...
	td: class HTMLTableCellElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TD"
			super a...
	th: class HTMLTableHeadElement extends HTMLTableCellElement
		constructor: (a...) ->
			a[0] = "TH"
			super a...
	tr: class HTMLTableRowElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TR"
			super a...
	textarea: class HTMLTextAreaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TEXTAREA"
			super a...
	title: class HTMLTitleElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TITLE"
			super a...
	ul: class HTMLUListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "UL"
			super a...
	video: class HTMLVideoElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "VIDEO"
			super a...
}

property Element::, 'tagName',
	get: -> @nodeName
property Element::, 'innerHTML',
	get: ->
		h = []
		for c in @childNodes
			h.push c.toString()
		return h.join('')
	set: (v) ->
		fragment = htmlparse(v, @ownerDocument)
		for c in @childNodes
			c._private.parentNode = null
			c._private.childIndex = -1
		@childNodes.length = 0
		@appendChild fragment

getInnerText = ->
	t = []
	for c in @childNodes
		if c.nodeType in [Node.TEXT_NODE, Node.CDATA_SECTION_NODE]
			t.push c.toString(false, false)
		else if c.nodeType isnt Node.COMMENT_NODE
			t.push getInnerText.apply c
	return t.join ''
setInnerText = (text) ->
	while @hasChildNodes()
		@removeChild(0)
	@appendChild(new Text(text, @))

property Element::, 'innerText',
	get: getInnerText
	set: setInnerText
property Element::, 'textContent',
	get: getInnerText
	set: setInnerText
property Element::, 'id',
	get: -> @attributes['id']
	set: (value) ->
		o = @ownerDocument?
		if o
			if @attributes.id?
				delete @ownerDocument._private.idMap[@attributes.id]
		if value in [null, undefined, "undefined"]
			delete @attributes.id
		else
			if o
				@ownerDocument._private.idMap[value] = @
			@attributes.id = value
property Element::, 'className',
	get: -> @attributes['class'] or ""
	set: (value) ->
		if value in [null, undefined, "undefined"]
			delete @attributes.class
			@_private.classes.length = 0
		else
			@attributes['class'] = value
			@_private.classes = value.split(' ')

property HTMLInputElement::, 'value',
	get: -> @attributes.value or (if @attributes.type in ['checkbox','radio'] then "on") or ""
	set: (v) -> @setAttribute('value',v)

property HTMLInputElement::, 'checked',
	get: -> @hasAttribute('checked')
	set: (v) ->
		if v? then @setAttribute('checked','checked')
		else @removeAttribute('checked')

property HTMLInputElement::, 'selected',
	get: -> @hasAttribute('selected')
	set: (v) ->
		if v? then @setAttribute('selected','selected')
		else @removeAttribute('selected')

property HTMLSelectElement::, 'selectedIndex',
	get: ->
		if not (@_private.selectedIndex? and @_private.selectedIndex < @childNodes.length)
			for index in [0...@childNodes.length]
				if @childNodes[index].hasAttribute 'selected'
					@_private.selectedIndex = index
		return @_private.selectedIndex or 0
	set: (v) ->
		if v < @childNodes.length
			for index in [0...@childNodes.length]
				if index is v
					@childNodes[index].setAttribute('selected','selected')
				else
					@childNodes[index].removeAttribute('selected')
			@_private.selectedIndex = v
		return @_private.selectedIndex or 0

property HTMLOptionElement::, 'value',
	get: -> if @hasAttribute('value') then @getAttribute('value') else @innerText
	set: (v) -> @setAttribute('value',v)

property HTMLSelectElement::, 'value',
	get: -> @childNodes[@selectedIndex]?.value
	set: (v) ->
		for index in [0...@childNodes.length]
			child = @childNodes[index]
			if child.value is v
				@selectedIndex = index

class Attr extends Node
	constructor: (name, value) ->
		super name, value, Node.ATTRIBUTE_NODE, null
		@name = @nodeName
		@value = @nodeValue
		@ownerElement = null

class CData extends Node
	constructor: (value, owner) ->

class Comment extends Node
	constructor: (value, owner) ->

class CComment extends Node
	constructor: (value, owner) ->

class Text extends Node
	constructor: (value, owner) ->
property Text::, 'data',
	set: (v) -> @nodeValue = htmlescape(v)

class DocumentFragment extends Node
	constructor: (owner) ->
	toString: (pretty=false, deep=true) ->
		ret = []; r = 0
		for c in @childNodes
			ret[r++] = c.toString pretty, deep
		return ret.join('')

property DocumentFragment::, 'parentNode',
	set: (v) -> throw Error "DocumentFragment cannot have a parentNode"

class Document extends Element
	constructor: (a...) ->
		a[2] = Node.DOCUMENT_NODE
		super a...
		@documentElement = @
		@documentURI = null
		@_private = extend @_private, {
			idMap: {}
		}
	createCDATASection: (value) -> new CData(value, @)
	createComment: (value) -> new Comment(value, @)
	createCComment: (value) -> new CComment(value, @)
	createDocumentFragment: -> new DocumentFragment(@)
	createElement: (name) ->
		nodeClass = ELEMENT_MAP[name?.toLowerCase()]
		if not nodeClass?
			new ELEMENT_MAP['_'](name.toUpperCase())
		else
			new nodeClass(name.toUpperCase(),null,null,@)
	createEntityReference: NotSupported
	createEvent: (type) ->
		switch type
			when "MutationEvents" then new MutationEvent()
			else new Event()
	createTextNode: (text) -> new Text(text, @)
	getElementById: (id) -> @_private.idMap[id]

class HTMLDocument extends Document
	constructor: ->
		super "HTML", null, Node.DOCUMENT_NODE, @
		Document::appendChild.call @,@createElement('head')
		Document::appendChild.call @,@createElement('body')
		@head = @childNodes[0]
		@body = @childNodes[1]
		@_private = extend @_private, {
			matcher: matcher.init(global, @)
		}
	hasChildNodes: -> true
	insertBefore: NotSupported
	appendChild: NotSupported
	removeChild: NotSupported
	replaceChild: NotSupported
	write: NotSupported
	writeln: NotSupported

exports.createDocument = ->
	new HTMLDocument()

exports.registerGlobals = (g) ->
	g.Element = Element
	g.Node = Node
	g.Document = Document
	g.DocumentFragment = DocumentFragment
	g.Event = Event
	for tagName of ELEMENT_MAP
		c = ELEMENT_MAP[tagName]
		g[c.name] = c


clear = (a...) ->
	for i in a
		i.length = 0
get = (a) -> a.join("")
void_elements = [ "AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"]
parse = (input, document) ->
	i = 0
	mode = 0
	fragment = document.createDocumentFragment()
	cursor = fragment
	tagName = []
	attrName = []
	attrVal = []
	text = []
	attributes = {}
	closeNode = () ->
		t = get(tagName).toUpperCase()
		clear(tagName)
		if t in void_elements
			return
		cursor = cursor.parentNode
	emitNode = (closing) -> () ->
		if tagName.length > 0
			node = document.createElement(get(tagName))
			for a of attributes
				node.setAttribute(a, attributes[a])
			cursor.appendChild(node)
			cursor = node
			clear(text, tagName, attrName, attrVal)
			for a of attributes
				delete attributes[a]
			if closing or node.nodeName in void_elements
				closeNode()
	emitAttr = () ->
		k = get(attrName)
		v = get(attrVal)
		if k?
			k = k.replace(/^\s+/,'')
		if k isnt ""
			attributes[k] = v or ""
		clear(attrName, attrVal)
	emitText = () ->
		if text.length > 0
			cursor.appendChild(document.createTextNode(get(text)))
			clear(text)
	emitComment = () ->
		if text.length > 0
			cursor.appendChild(document.createComment(get(text)))
			clear(text)
	states = [
			"<": [emitText, 1]
			"": [text, 0]
			" ": [3]
			"/": [8]
			">": [emitNode(false), 0]
			"": [tagName]
			"=": [4]
			" ": [emitAttr, 3]
			"/": [emitAttr, 8]
			">": [emitAttr, emitNode(false), 0]
			"": [attrName]
			'"': [5]
			"'": [6]
			"": [attrVal, 7]
			'"': [emitAttr, 2]
			"": [attrVal]
			"'": [emitAttr, 2]
			"": [attrVal]
			" ": [emitAttr, 2]
			">": [emitAttr, emitNode(false), 0]
			"/": [emitAttr, 8]
			"": [attrVal]
			">": [emitNode(true), 0]
			"": [parseError("state 8: failed to properly close a /> tag"), 0]
			">": [closeNode, 0]
			"": [tagName]
			"": [parseError("state 11: unknown <! tag"), 0]
			"-": [12]
			"": [parseError("state 12: invalid <!-- tag"), 0]
			"-": [ 13 ]
			"": [text, 12]
		}
	]
	while c = input[i++]
		m = states[mode]
		result = m[c] or m[""] or []
		for x in result
			if x.call
				x()
				mode = x
			else if x.push
				x.push c
	emitText()
	emitNode()
	return cursor

entity_table =
	"€": "&euro;"
	" ": "&nbsp;"
	'"': "&quot;"
	"<": "&lt;"
	">": "&gt;"
	"¡": "&iexcl;"
	"¢": "&cent;"
	"£": "&pound;"
	"¤": "&curren;"
	"¥": "&yen;"
	"¦": "&brvbar;"
	"§": "&sect;"
	"¨": "&uml;"
	"©": "&copy;"
	"ª": "&ordf;"
	"«": "&laquo;"
	"¬": "&not;"
	"¯": "&shy;"
	"®": "&reg;"
	"°": "&deg;"
	"±": "&plusmn;"
	"²": "&sup2;"
	"³": "&sup3;"
	"´": "&acute;"
	"µ": "&micro;"
	"¶": "&para;"
	"·": "&middot;"
	"¸": "&cedil;"
	"¹": "&sup1;"
	"º": "&ordm;"
	"»": "&raquo;"
	"¼": "&frac14;"
	"½": "&frac12;"
	"¾": "&frac34;"
	"¿": "&iquest;"
	"À": "&Agrave;"
	"Á": "&Aacute;"
	"Â": "&Acirc;"
	"Ã": "&Atilde;"
	"Ä": "&Auml;"
	"Å": "&Aring;"
	"Æ": "&AElig;"
	"Ç": "&Ccedil;"
	"È": "&Egrave;"
	"É": "&Eacute;"
	"Ê": "&Ecirc;"
	"Ë": "&Euml;"
	"Ì": "&Igrave;"
	"Í": "&Iacute;"
	"Î": "&Icirc;"
	"Ï": "&Iuml;"
	"Ð": "&ETH;"
	"Ñ": "&Ntilde;"
	"Ò": "&Ograve;"
	"Ó": "&Oacute;"
	"Ô": "&Ocirc;"
	"Õ": "&Otilde;"
	"Ö": "&Ouml;"
	"×": "&times;"
	"Ø": "&Oslash;"
	"Ù": "&Ugrave;"
	"Ú": "&Uacute;"
	"Û": "&Ucirc;"
	"Ü": "&Uuml;"
	"Ý": "&Yacute;"
	"Þ": "&THORN;"
	"ß": "&szlig;"
	"à": "&agrave;"
	"á": "&aacute;"
	"â": "&acirc;"
	"ã": "&atilde;"
	"ä": "&auml;"
	"å": "&aring;"
	"æ": "&aelig;"
	"ç": "&ccedil;"
	"è": "&egrave;"
	"é": "&eacute;"
	"ê": "&ecirc;"
	"ë": "&euml;"
	"ì": "&igrave;"
	"í": "&iacute;"
	"î": "&icirc;"
	"ï": "&iuml;"
	"ð": "&eth;"
	"ñ": "&ntilde;"
	"ò": "&ograve;"
	"ó": "&oacute;"
	"ô": "&ocirc;"
	"õ": "&otilde;"
	"ö": "&ouml;"
	"÷": "&divide;"
	"ø": "&oslash;"
	"ù": "&ugrave;"
	"ú": "&uacute;"
	"û": "&ucirc;"
	"ü": "&uuml;"
	"ý": "&yacute;"
	"þ": "&thorn;"

escape = (input) ->
	input = unescape input
	for c of entity_table
		input = input.replace(c, entity_table[c])
	input

unescape = (input) ->
	for c of entity_table
		input = input.replace entity_table[c], c
	input

if exports
	exports.parse = parse
	exports.escape = escape
	exports.unescape = unescape

assert = require 'assert'
dom = require "../lib/dom.js"
dom.registerGlobals global
global.document = dom.createDocument()
global.window = global

testSelector = (s, output) ->
	x = document.querySelectorAll(s)
	assert.equal x.toString(), output, s

describe 'document', ->
	it "should exist", ->
		assert document?
	it "has a head", ->
		assert document.head?
	it "has a body", ->
		assert document.body?
	it "has DOCUMENT_ELEMENT node type", ->
		assert.equal document.nodeType, 9, "document.nodeType"
	describe 'creating a new element', ->
		div = document.createElement('div')
		it 'has node type', ->
			assert.equal div.nodeType, 1
		it 'has node name', ->
			assert.equal div.nodeName, "DIV"
		it 'has a style object', ->
			assert div.style
		describe 'appending new element to document', ->
			it 'appears in parent.childNodes', ->
				document.body.innerHTML = ""
				document.body.appendChild div
				assert.equal document.body.childNodes.length, 1
			it 'can be removed', ->
				document.body.innerHTML = ""
				document.body.appendChild div
				document.body.removeChild div
				assert.equal document.body.childNodes.length, 0

	describe '.getElementsByTagName()', ->
		it "should find a single element", ->
			document.body.innerHTML = "<div/>"
			assert.equal document.body.getElementsByTagName('DIV').length, 1
		it "should find nested elements", ->
			document.body.innerHTML = "<p><div><div/></div></p>"
			assert.equal document.body.getElementsByTagName('DIV').length, 2
		it "is not case sensitive", ->
			document.body.innerHTML = "<p><div><div/></div></p>"
			assert.equal document.body.getElementsByTagName('div').length, 2
	
	describe '.getElementById()', ->
		it 'finds a single element', ->
			div = document.createElement("div")
			div.id = "getElemId"
			document.body.appendChild(div)
			assert.equal document.getElementById("getElemId"), div

	describe ".attributes", ->
		it "is read/write", ->
			div = document.createElement 'div'
			div.attributes.foo = 'bar'
			assert.equal div.attributes.foo, 'bar'
		it "appears in a .toString()", ->
			div = document.createElement 'div'
			div.attributes.foo = 'bar'
			assert.equal div.toString(), '<div foo="bar"/>'
		it "treats .id as a special attribute", ->
			div = document.createElement 'div'
			div.id = 'testId'
			assert.equal div.attributes.id, div.id
		it "treats .className special", ->
			div = document.createElement 'div'
			div.className = 'foo'
			assert.equal div.attributes.class, 'foo'
		describe ".get/setAttribute()", ->
			it "reads/writes the .attributes map", ->
				div = document.createElement("div")
				div.setAttribute("name", "foo")
				assert.equal div.getAttribute("name"), "foo"
		describe ".hasAttribute()", ->
			it "is true if attr exists", ->
				div = document.createElement("div")
				div.setAttribute("name", "")
				assert.equal div.hasAttribute("name"), true
			it "is false if attr does not exist", ->
				div = document.createElement("div")
				assert.equal div.hasAttribute("name"), false
		describe ".getAttributeNode()", ->
			it "returns an attribute node with value and nodeValue", ->
				div = document.createElement("div")
				div.setAttribute("name", "foo")
				attr = div.getAttributeNode("name")
				assert.equal attr.value, "foo"
				assert.equal attr.nodeValue, "foo"
	
	describe ".childNodes", ->
		it "every node should have .childNodes", ->
			div = document.createElement("div")
			div.id = "subChildren_parent"
			document.body.appendChild(div)
			span = document.createElement("span")
			div.appendChild(span)
			assert.equal div.childNodes.length, 1
			nodesByTagName = div.getElementsByTagName("span")
			assert.equal nodesByTagName.length, 1
			assert.equal nodesByTagName[0], span
	describe ".getElementsByClassName()", ->
		it "should find elements by class name", ->
			div = document.createElement("div")
			div.id = "getElemClass_parent"
			document.body.appendChild(div)
			p = document.createElement("p")
			p.id = 'classTest'
			p.className = "alpha beta"
			div.appendChild(p)
			alphaNodes = div.getElementsByClassName("alpha")
			betaNodes = div.getElementsByClassName("beta")
			assert.equal alphaNodes.length, 1, "alphaNodes.length"
			assert.equal betaNodes.length, 1, "betaNodes.length"
			assert.equal alphaNodes[0], p, "alphaNodes[0]"
			assert.equal betaNodes[0], p, "betaNodes[0]"
	describe "fragments",  ->
		fragment_doc = fragment = null
		it "can be created", ->
			fragment_doc = global.dom.createDocument()
			fragment = fragment_doc.createDocumentFragment()
		it "can have children", ->
			fragment.appendChild(fragment_doc.createElement("div"))
			fragment.appendChild(fragment_doc.createElement("p"))
			assert.equal fragment.childNodes.length, 2, "fragment.childNodes.length"
		it "can render toString", ->
			assert.equal fragment.toString(), "<div/><p/>", "fragment.toString()"
		it "can be appended to a node and disappear", ->
			div = fragment_doc.createElement("div")
			div.id = "fragment_test"
			fragment_doc.body.appendChild(div)
			div.appendChild(fragment)
			assert.equal fragment_doc.toString(), '<html><head/><body><div id="fragment_test"><div/><p/></div></body></html>'
	describe "text nodes", ->
		it "can be created", ->
			text = document.createTextNode("&nbsp;")
		it "has nodeValue",  ->
			text = document.createTextNode("Harro!")
			assert.equal(text.nodeValue, "Harro!", "text.nodeValue")
		it "can set .data property",  ->
			text = document.createTextNode("Harro!")
			text.data = "BB"
			assert.equal(text.nodeValue, "BB", "text.nodeValue")
		it "can put html in .data",  ->
			text = document.createTextNode("Harro!")
			text.data = "<p>"
			assert.equal(text.nodeValue, "&lt;p&gt;", "text.nodeValue")
		it "can read .data back from .innerHTML (escaped)",  ->
			text = document.createTextNode("Harro!")
			text.data = "<p>"
			div = document.createElement("div")
			div.appendChild(text)
			assert.equal(div.innerHTML, "&lt;p&gt;")
			text.data = "Goodbye!"
			assert.equal(div.innerHTML, "Goodbye!")
		describe ".innerText", ->
			text = div = null
			it "includes direct text nodes", ->
				text = document.createTextNode("&nbsp;")
				div = document.createElement("div")
				div.appendChild(text)
				assert.equal div.innerHTML, "&nbsp;"
				assert.equal div.innerText, "&nbsp;"
			it "also includes deeply nested text nodes", ->
				span = document.createElement "span"
				text2 = document.createTextNode "hello"
				span.appendChild text2
				assert.equal span.innerText, "hello"
				div.appendChild(span)
				assert.equal(div.innerText, "&nbsp;hello")
	describe "input nodes", ->
		it "treats .value as an attribute-property", ->
			input = document.createElement("input")
			input.value = 'bar'
			input.setAttribute('value', 'foo')
			assert.equal input.value, 'foo', 'input.value'
			assert.equal input.value, input.getAttribute('value'), 'input.getAttribute("value")'
		describe "<select/option>", ->
			select = optionA = optionB = null
			it "can be created", ->
				select = document.createElement("select")
				optionA = document.createElement("option")
				optionB = document.createElement("option")
				assert.equal optionA.constructor.name, "HTMLOptionElement"
				assert.equal optionA.constructor.__super__.constructor.name, "HTMLInputElement"
			it "<option> can have value", ->
				optionA.value = '1'
				optionA.innerText = 'A'
				optionB.innerText = 'B'
				assert.equal optionA.value, '1', 'optionA.value'
				assert.equal optionB.value, 'B', 'optionB.value'
			it "<select> can have <option> children", ->
				select.appendChild(optionA)
				select.appendChild(optionB)
			it ".selectedIndex is populated", ->
				assert.equal select.selectedIndex, 0, 'select.selectedIndex'
			it ".value is populated", ->
				assert.equal select.value, '1', 'select.value'
			it ".selectedIndex is settable and updates .value", ->
				select.selectedIndex = 1
				assert.equal select.selectedIndex, 1, 'select.selectedIndex * 2'
				assert.equal select.value, 'B', 'select.value'
	it "input_radio",  ->
		test_doc = global.dom.createDocument()
		test_doc.body.innerHTML = "<input type='radio' selected>"
		input = test_doc.body.childNodes[0]
		assert.equal input.constructor.name, "HTMLInputElement"
		assert.equal input.hasAttribute('selected'), true, 'input.hasAttr'
		assert.equal input.getAttribute('selected'), ''
		assert.equal input.selected, true, 'input.selected'
		input.removeAttribute('selected')
		assert.equal input.selected, false, 'input.selected'
		assert.equal input.value, "on"
	it "input_checkbox",  ->
		test_doc = global.dom.createDocument()
		test_doc.body.innerHTML = "<input type='checkbox' checked >"
		input = test_doc.body.childNodes[0]
		assert.equal input.checked, true, 'input.checked'
		assert.equal input.value, "on"
	it "can create/render comments",  ->
		comment_doc = global.dom.createDocument()
		comment = comment_doc.createComment("comment text")
		assert.equal comment.nodeValue, "comment text"
		comment_doc.body.appendChild(comment)
		assert.equal comment_doc.body.toString(), '<body><!--comment text--></body>'
	it "can create/render conditional comments",  ->
		doc = global.dom.createDocument()
		comment = doc.createCComment("if lt IE 9")
		script = doc.createElement('script')
		script.setAttribute('src', 'ie.js')
		comment.appendChild script
		doc.body.appendChild(comment)
		assert.equal doc.body.toString(), '<body><!--[if lt IE 9]><script src="ie.js"/><![endif]--></body>'
	describe ".querySelectorAll()", ->
		it "id",  ->
			document.body.innerHTML = '<div><span/><p id="classTest" class="alpha beta"/></div>'
		it "class",  ->
			document.body.innerHTML = '<div><span/><p id="classTest" class="alpha beta"/></div>'
			testSelector "p.alpha.beta", '<p id="classTest" class="alpha beta"/>'
		it "tag",  ->
			document.body.innerHTML = '<div><span/><p id="classTest" class="alpha beta"/></div>'
			testSelector "p", '<p id="classTest" class="alpha beta"/>'
		it "star",  ->
			document.body.innerHTML = '<div><span/><p id="classTest" class="alpha beta"/></div>'
			testSelector "div *", '<span/>,<p id="classTest" class="alpha beta"/>'

	test_parse = (input, output, debug = false) ->
		html = require('../html/parser')
		message = ""
		try
			result = html.parse(input, document, debug).toString(false, true)
			output ?= input
		catch err
			throw err
		if result isnt output
			throw Error result+" !== "+output
	
	describe ".innerHTML can parse", ->
		cases = [
			["text", "text"],
			["<p>","<p/>"],
			["<div/>"],
			["<div />", "<div/>"],
			["<div>Harro?</div>"],
			["<div>foo</div>"],
			["<div>1,2</div>"],
			["<div><p>Hi.</p></div>"],
			["<div><p><span>Bye.</span></p></div>"],
			["<div><p/></div>"],
			["<div><p /></div>", "<div><p/></div>"],
			["<div><p  /></div>", "<div><p/></div>"],
			["<div key='val'></div>", '<div key="val"/>'],
			["<div key='val' ></div>", '<div key="val"/>'],
			["<div key='val'/>", '<div key="val"/>'],
			["<div key='val' />", '<div key="val"/>'],
			["<div id='test_parse'></div>", '<div id="test_parse"/>'],
			["<input checked/>"],
			["<eval>CurrencyFormat(Application.User.balance)</eval>"],
			['<body><!-- comment --><span>foo</span></body>'],
			['<a>Hello<b>World</b></a>'],
			['<head><meta charset="utf-8"><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'],
			['<head><meta charset="utf-8"/><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'],
			['<head><meta charset="utf-8"></meta><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'],
		]
		for c in cases
			it c[0], -> test_parse c...

	test_escape = (input, output) ->
		html = require('../html/parser')
		result = html.escape(input)
		if result isnt output
			throw Error result+" !== "+output
	
	describe ".innerHTML does escape", ->
		it '<p>', -> test_escape '<p>', '&lt;p&gt;'
		it '&amp;', -> test_escape '&amp;', '&amp;'
		it '?input=foo&amp;bar&key=value', -> test_escape '?input=foo&amp;bar&key=value', '?input=foo&amp;bar&key=value',

	describe 'nwmatcher', ->
		nw_doc = global.dom.createDocument()
		nw_doc.body.innerHTML = "<div><p id='pId' class='c'><span class='c'>C</span></p><input name='foo' /></div>"
		nw = require("../css/nwmatcher")
		matcher = nw.init(global, nw_doc)

		describe '.byId', ->
			it 'find DOM nodes', ->
				assert.equal matcher.byId('pId').constructor.name, "HTMLParagraphElement"

		describe '.byClass()', ->
			c = matcher.byClass('c')
			it "is an Array", -> assert.equal c.constructor.name, "Array"
			it "finds the right elements", ->
				assert.equal c.length, 2
				assert matcher.match(c[0], '.c')
				assert matcher.match(c[1], '.c')
				assert !matcher.match(c[1], 'c')

		describe '.byName()', ->
			f = matcher.byName('foo')
			it "is an Array", -> assert.equal f.constructor.name, "Array"
			it "find the right elements", -> assert.equal f.length, 1

		describe '.byTag()', ->
			s = matcher.byTag('span')
			it "is an Array", -> assert.equal s.constructor.name, "Array"
			it "finds the right elements", -> assert.equal s.length, 1

		describe '.select()', ->
			it "supports the '+' selector", ->
				x = matcher.select('p + input')
				assert.equal x.constructor.name, "Array"
				assert.equal x.length, 1
			it "supports the '*' selector", ->
				a = matcher.select('*')
				assert.equal a.constructor.name, "Array"
				assert.equal a.length, 6

$.plugin
	provides: "cartesian"
, ->
	$:
		cartesian: (sets...) ->
			n = sets.length
			ret = []
			helper = (cur, i) ->
				(return ret.push cur) if ++i >= n
				for x in sets[i]
					helper (cur.concat x), i
				null
			helper [], -1
			return $(ret)
$.plugin ->
	String::trimLeft or= -> @replace(/^\s+/, "")
	String::split or= (sep) ->
		a = []; i = 0
		while (j = @indexOf sep,i) > -1
			a.push @substring(i,j)
			i = j + 1
		a
	String::lastIndexOf or= (s, c, i = -1) ->
		j = -1
		j = i while (i = s.indexOf c, i+1) > -1
		j

	Array::join or= (sep = '') ->
		n = @length
		return "" if n is 0
		s = @[n-1]
		while --n > 0
			s = @[n-1] + sep + s
		s

	if Event?
		Event::preventAll = () ->
			@preventDefault()
			@stopPropagation()
			@cancelBubble = true

	if Element?
		Element::matchesSelector = Element::webkitMatchesSelector or
			Element::mozMatchesSelector or
			Element::matchesSelector
		if Element::cloneNode.length is 0
			oldClone = Element::cloneNode
			Element::cloneNode = (deep = false) ->
				n = oldClone.call(@)
				if deep
					for i in @childNodes
						n.appendChild i.cloneNode true
				return n

	return { }
$.plugin
	provides: 'config'
	depends: 'type'
, ->
	get = (name, def) -> process.env[name] ? def
	$: config: $.extend(get, get: get)

$.plugin
	provides: "core"
	depends: "string"
, ->

	$.defineProperty $, "now",
		get: -> +new Date

	index = (i, o) ->
		i += o.length while i < 0
		Math.min i, o.length

	baseTime = $.now
	return {
		$:
			log: $.extend((a...) ->
				if prefix.length > $.log.prefixSize + 2
				if a.length and $.is "string", a[0]
				else
					a.unshift prefix
				console.log a...
				return a[a.length-1] if a.length
			, prefixSize: 5)
			coalesce: (a...) -> $(a).coalesce()
			keysOf: (o) -> $(k for k of o)
			valuesOf: (o) -> $.keysOf(o).map (k)->
				return try o[k] catch err then err

		eq: (i) -> $([@[index i, @]])

		each: (f) -> (f.call(t,t) for t in @); @

		map: (f) ->
			b = $()
			for t in @
				b.push f.call t,t
			b

		filterMap: (f) ->
			b = $()
			for t in @
				v = f.call t,t
				if v?
					b.push v
			b

		replaceWith: (array) ->
			for i in [0...array.length] by 1
				@[i] = array[i]

		reduce: (f, a) ->
			i = 0; n = @length
			a = @[i++] if not a?
			(a = f.call @[x], a, @[x]) for x in [i...n] by 1
			return a
		union: (other, strict = true) ->
			ret = $()
			ret.push(x) for x in @ when not ret.contains(x, strict)
			ret.push(x) for x in other when not ret.contains(x, strict)
			ret
		distinct: (strict = true) -> @union @, strict
		contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
		count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
		coalesce: ->
			for i in @
				if $.is('array',i) or $.is('bling',i) then i = $(i).coalesce()
				if i? then return i
			null
		swap: (i,j) ->
			i = index i, @
			j = index j, @
			if i isnt j
				[@[i],@[j]] = [@[j],@[i]]
			@
		shuffle: ->
			i = @length-1
			while i >= 0
				@swap --i, Math.floor(Math.random() * i)
			@

		select: (->
			getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
			select = (p) ->
				if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
				else @map(getter p)
		)()

		or: (x) -> @[i] or= x for i in [0...@length]; @

		zap: (p, v) ->

			i = p.lastIndexOf "."

			if i > 0
				head = p.substr 0,i
				tail = p.substr i+1
				@select(head).zap tail, v
				return @

			switch $.type(v)
				when "array","bling" then @each -> @[p] = v[++i % v.length]
				when "function" then @zap p, @select(p).map(v)
				else @each -> @[p] = v
			@

		clean: (prop) -> @each -> delete @[prop]

		take: (n = 1) ->
			end = Math.min n, @length
			$( @[i] for i in [0...end] by 1 )

		skip: (n = 0) ->
			start = Math.max 0, n|0
			$( @[i] for i in [start...@length] by 1 )

		first: (n = 1) -> if n is 1 then @[0] else @take(n)

		last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)

		slice: (start=0, end=@length) ->
			start = index start, @
			end = index end, @
			$( @[i] for i in [start...end] )

		extend: (b) -> @.push(i) for i in b; @

		push: (b) -> Array::push.call(@, b); @

		filter: (f) ->
			g = switch $.type f
				when "string" then (x) -> x.matchesSelector(f)
				when "regexp" then (x) -> f.test(x)
				when "function" then f
			$( it for it in @ when g.call(it,it) )

		matches: (expr) ->
			switch $.type expr
				when "string" then @select('matchesSelector').call(expr)
				when "regexp" then @map (x) -> expr.test x

		querySelectorAll: (expr) ->
			@filter("*")
			.reduce (a, i) ->
				a.extend i.querySelectorAll expr
			, $()

		weave: (b) ->
			c = $()
			for i in [@length-1..0] by -1
				c[(i*2)+1] = @[i]
			for i in [0...b.length] by 1
				c[i*2] = b[i]
			c

		fold: (f) ->
			n = @length
			b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
			if (n%2) is 1
				b.push( f.call @, @[n-1], undefined )
			b

		flatten: ->
			b = $()
			(b.push(j) for j in i) for i in @
			b

		call: -> @apply(null, arguments)

		apply: (context, args) ->
			@filterMap ->
				if $.is 'function', @ then @apply(context, args)
				else null

		log: (label) ->
			if label
				$.log(label, @toString(), @length + " items")
			else
				$.log(@toString(), @length + " items")
			@

		toArray: ->
			@__proto__ = Array::
	}
$.plugin
	provides: 'date'
	depends: 'type'
, ->
	[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]

	units = {
		ms, s, m, h, d,
		sec: s
		second: s
		seconds: s
		min: m
		minute: m
		minutes: m
		hr: h
		hour: h
		hours: h
		day: d
		days: d
	}

	formats =
		yyyy: Date::getUTCFullYear
		mm: -> @getUTCMonth() + 1
		dd: Date::getUTCDate
		HH: Date::getUTCHours
		MM: Date::getUTCMinutes
		SS: Date::getUTCSeconds
		MS: Date::getUTCMilliseconds
	format_keys = Object.keys(formats).sort().reverse()

	parsers =
		yyyy: Date::setUTCFullYear
		mm: (x) -> @setUTCMonth(x - 1)
		dd: Date::setUTCDate
		HH: Date::setUTCHours
		MM: Date::setUTCMinutes
		SS: Date::setUTCSeconds
		MS: Date::setUTCMilliseconds
	parser_keys = Object.keys(parsers).sort().reverse()

	floor = Math.floor

	$.type.register "date",
		match: (o) -> $.isType Date, o
		array: (o) -> [o]
		string: (o, fmt, unit) -> $.date.format o, fmt, unit
		number: (o, unit) -> $.date.stamp o, unit

	$.type.extend 'string', date: (o, fmt = $.date.defaultFormat) -> new Date $.date.parse o, fmt, "ms"
	$.type.extend 'number', date: (o, unit) -> $.date.unstamp o, unit

	adder = (key) ->
		(stamp, delta, stamp_unit = $.date.defaultUnit) ->
			date = $.date.unstamp(stamp, stamp_unit)
			parsers[key].call date, (formats[key].call date) + delta
			$.date.stamp date, stamp_unit

	$:
		date:
			defaultUnit: "s"
			defaultFormat: "yyyy-mm-dd HH:MM:SS"
			stamp: (date = new Date, unit = $.date.defaultUnit) ->
				floor (date / units[unit])
			unstamp: (stamp, unit = $.date.defaultUnit) ->
				new Date floor(stamp * units[unit])
			convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
				(floor stamp * units[from] / units[to])
			midnight: (stamp, unit = $.date.defaultUnit) ->
				$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
			format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
				date = $.date.unstamp stamp, unit
				for k in format_keys
					fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
				fmt
			parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
				date = new Date(0)
				for i in [0...fmt.length] by 1
					for k in parser_keys
						if fmt.indexOf(k, i) is i
							try
								parsers[k].call date,
									parseInt dateString[i...i+k.length], 10
							catch err
				$.date.stamp date, to
			addMilliseconds: adder("MS")
			addSeconds: adder("SS")
			addMinutes: adder("MM")
			addHours: adder("HH")
			addDays: adder("dd")
			addMonths: adder("mm")
			addYears: adder("yyyy")
			range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
				add = adder(interval_unit)
				ret = [from]
				while (cur = ret[ret.length-1]) < to
					ret.push add(cur, interval, stamp_unit)
				ret

	midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
	unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
	stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
	dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
	dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)


$.plugin
	provides: "delay"
	depends: "function"
, ->
	$:
		delay: (->
			timeoutQueue = $.extend [], (->
				next = (a) -> -> a.shift()() if a.length
				add: (f, n) ->
					f.order = n + $.now
					for i in [0..@length] by 1
						if i is @length or @[i].order > f.order
							@splice i,0,f
							break
					setTimeout next(@), n
					@
				cancel: (f) ->
					for i in [0...@length] by 1
						if @[i] == f
							@splice i, 1
							break
					@
			)()

			(n, f) ->
				if $.is("function",f) then timeoutQueue.add(f, n)
				cancel: -> timeoutQueue.cancel(f)

		)()

	delay: (n, f, c=@) ->
		$.delay n, $.bound(c, f)
		@
	interval: (n, f, c=@) ->
		g = $.bound c, f
		h = -> g(); $.delay n, h
		$.delay n, h
		@
if $.global.document?
	$.plugin
		depends: "function,type"
		provides: "dom"
	, ->
		$.type.register "nodelist",
			match:  (o) -> o? and $.isType "NodeList", o
			hash:   (o) -> $($.hash(i) for i in x).sum()
			array:  $.identity
			string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
			node:   (o) -> $(o).toFragment()
		$.type.register "node",
			match:  (o) -> o?.nodeType > 0
			hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "fragment",
			match:  (o) -> o?.nodeType is 11
			hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "html",
			match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
			node:   (h) ->
				(node = document.createElement('div')).innerHTML = h
				if n = (childNodes = node.childNodes).length is 1
					return node.removeChild(childNodes[0])
				df = document.createDocumentFragment()
				df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
				df
			array:  (o) -> $.type.lookup(h = Bling.HTML.parse o).array h
			repr:   (o) -> '"' + o + '"'
		$.type.extend
			unknown:  { node: -> null }
			bling:    { node: (o) -> o.toFragment() }
			node:     { html: (n) ->
				d = document.createElement "div"
				d.appendChild (n = n.cloneNode true)
				ret = d.innerHTML
				ret
			}
			string:
				node:  (o) -> $(o).toFragment()
				array: (o) -> document.querySelectorAll? o
			function: { node: (o) -> $(o.toString()).toFragment() }

		toFrag = (a) ->
			if not a.parentNode?
				df = document.createDocumentFragment()
				df.appendChild a
			a
		before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
		after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
		toNode = (x) -> $.type.lookup(x).node x
		escaper = false
		parser = false

		computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue k

		getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select p

		selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )

		return {
			$:

				HTML:
					parse: (h) -> $.type.lookup(h).node h
					stringify: (n) -> $.type.lookup(n).html n
					escape: (h) ->
						escaper or= $("<div>&nbsp;</div>").child 0
						ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
						escaper.zap('data', '')
						ret

			html: (h) ->
				return switch $.type h
					when "undefined","null" then @select 'innerHTML'
					when "string","html" then @zap 'innerHTML', h
					when "bling" then @html h.toFragment()
					when "node"
							@replaceChild @childNodes[0], h
							while @childNodes.length > 1
								@removeChild @childNodes[1]

				@each -> @appendChild x.cloneNode true

				clones = @map( -> @cloneNode true)
				i = 0
				$(x).each -> @appendChild clones[i++]
				clones

				if x?
					x = toNode x
					@take(1).each ->
						before @childNodes[0], x
					@skip(1).each ->
						before @childNodes[0], x.cloneNode true
				@

				if x?
					$(x).prepend(@)
				@

				if x?
					x = toNode x
					@take(1).each -> before @, x
					@skip(1).each -> before @, x.cloneNode true
				@

				if x?
					x = toNode x
					@take(1).each -> after @, x
					@skip(1).each -> after @, x.cloneNode true
				@

				parent = toNode parent
				if $.is "fragment", parent
					throw new Error("cannot call .wrap() with a fragment as the parent")
				@each (child) ->
					if ($.is "fragment", child) or not child.parentNode
						return parent.appendChild child
					grandpa = child.parentNode
					marker = document.createElement "dummy"
					parent.appendChild grandpa.replaceChild marker, child
					grandpa.replaceChild parent, marker

				@each ->
					if @parentNode and @parentNode.parentNode
						@parentNode.parentNode.replaceChild(@, @parentNode)
					else if @parentNode
						@parentNode.removeChild(@)

				n = toNode n
				clones = @map(-> n.cloneNode true)
				for i in [0...clones.length] by 1
					@[i].parentNode?.replaceChild clones[i], @[i]
				clones

				return switch v
					when undefined then @select("getAttribute").call(a, v)
					when null then @select("removeAttribute").call(a, v)
					else
						@select("setAttribute").call(a, v)
						@


				notempty = (y) -> y isnt ""
				@removeClass(x).each ->
					c = @className.split(" ").filter notempty
					c.push x
					@className = c.join " "

				notx = (y) -> y != x
				@each ->
					c = @className.split(" ").filter(notx).join(" ")
					if c.length is 0
						@removeAttribute('class')

				notx = (y) -> y isnt x
				@each ->
					cls = @className.split(" ")
					filter = $.not $.isEmpty
					if( cls.indexOf(x) > -1 )
						filter = $.and notx, filter
					else
						cls.push x
					c = cls.filter(filter).join(" ")
					@className = c
					if c.length is 0
						@removeAttribute('class')

				@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1

				return @zap('textContent', t) if t?
				return @select('textContent')

				return @zap('value', v) if v?
				return @select('value')

			css: (k,v) ->
				if v? or $.is "object", k
					setter = @select 'style.setProperty'
					if $.is "object", k then setter.call i, k[i], "" for i of k
					else if $.is "string", v then setter.call k, v, ""
					else if $.is "array", v
						setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
					return @
				else
					cv = @map computeCSSProperty k
					ov = @select('style').select k
					ov.weave(cv).fold (x,y) -> x or y

			defaultCss: (k, v) ->
				sel = @selector
				style = ""
				if $.is "string", k
					if $.is "string", v
					else throw Error("defaultCss requires a value with a string key")
				else if $.is "object", k
					"} "
				$("<style></style>").text(style).appendTo("head")
				@

			rect: -> @select('getBoundingClientRect').call()

			width: getOrSetRect("width")

			height: getOrSetRect("height")

			top: getOrSetRect("top")

			left: getOrSetRect("left")

			bottom: getOrSetRect("bottom")

			right: getOrSetRect("right")

			position: (left, top) ->
				switch true
					when not left? then @rect()
					when not top? then @css("left", $.px(left))
					else @css({top: $.px(top), left: $.px(left)})

			scrollToCenter: ->
				document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
				@

			child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]

			parents: selectChain('parentNode')

			prev: selectChain('previousSibling')

			next: selectChain('nextSibling')

			remove: -> @each -> @parentNode?.removeChild(@)

			find: (css) ->
				@filter("*")
					.map( -> $(css, @) )
					.flatten()

			clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @

			toFragment: ->
				if @length > 1
					df = document.createDocumentFragment()
					(@map toNode).map $.bound df, df.appendChild
					return df
				return toNode @[0]
		}
$.plugin
	provides: "EventEmitter"
	depends: "type,hook"
, ->
	$: EventEmitter: $.hook("bling-init").append (obj = Object.create(null)) ->
		listeners = {}
		list = (e) -> (listeners[e] or= [])
		$.inherit {
			emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
			addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
			on:                 (e, h) -> @addListener e, h
			removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
			removeAllListeners: (e) -> listeners[e] = []
			listeners:          (e) -> list(e).slice 0
		}, obj
$.plugin
	depends: "dom,function,core"
	provides: "event"
, ->
	EVENTSEP_RE = /,* +/
	events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
		'load','unload','reset','submit','keyup','keydown','change',
		'abort','cut','copy','paste','selection','drag','drop','orientationchange',
		'touchstart','touchmove','touchend','touchcancel',
		'gesturestart','gestureend','gesturecancel',
		'hashchange'
	]

	binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)

	register_live = (selector, context, evt, f, h) ->
		$(context).bind(evt, h)
			.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h

	unregister_live = (selector, context, e, f) ->
		$c = $(context)
		$c.each ->
			a = (@__alive__ or= {})
			b = (a[selector] or= {})
			c = (b[e] or= {})
			$c.unbind(e, c[f])
			delete c[f]

	triggerReady = $.once ->
		$(document).trigger("ready").unbind("ready")
		document.removeEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.removeEventListener?("load", triggerReady, false)
	bindReady = $.once ->
		document.addEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.addEventListener?("load", triggerReady, false)
	bindReady()

	ret = {
		bind: (e, f) ->
			c = (e or "").split(EVENTSEP_RE)
			h = (evt) ->
				ret = f.apply @, arguments
				if ret is false
					evt.preventAll()
				ret
			@each -> (@addEventListener i, h, false) for i in c

		unbind: (e, f) ->
			c = (e or "").split EVENTSEP_RE
			@each -> (@removeEventListener i, f, null) for i in c

		trigger: (evt, args = {}) ->
			args = $.extend
				bubbles: true
				cancelable: true
			, args

			for evt_i in (evt or "").split(EVENTSEP_RE)
					e = document.createEvent "MouseEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						button: 0,
						relatedTarget: null
					, args
					e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.button, args.relatedTarget

					e = document.createEvent "UIEvents"
					e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1

					e = document.createEvent "TouchEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						touches: [],
						targetTouches: [],
						changedTouches: [],
						scale: 1.0,
						rotation: 0.0
					, args
					e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)

					e = document.createEvent "GestureEvents"
					args = $.extend {
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						target: null,
						scale: 1.0,
						rotation: 0.0
					}, args
					e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.target, args.scale, args.rotation

				else
					e = document.createEvent "Events"
					e.initEvent evt_i, args.bubbles, args.cancelable
					try
						e = $.extend e, args
					catch err

				if not e
					continue
				else
					try
						@each -> @dispatchEvent e
					catch err
						$.log "dispatchEvent error:", err
			@

		live: (e, f) ->
			selector = @selector
			context = @context
			handler = (evt) ->
				$(selector, context)
					.intersect($(evt.target).parents().first().union($(evt.target)))
					.each -> f.call(evt.target = @, evt)
			register_live selector, context, e, f, handler
			@

		die: (e, f) ->
			$(@context).unbind e, unregister_live(@selector, @context, e, f)
			@

		click: (f = {}) ->
			if @css("cursor") in ["auto",""]
				@css "cursor", "pointer"
			if $.is "function", f then @bind 'click', f
			else @trigger 'click', f
			@

		ready: (f) ->
			return (f.call @) if triggerReady.exhausted
			@bind "ready", f
	}

	events.forEach (x) -> ret[x] = binder(x)
	return ret

(($) ->
	$.plugin
		depends: "experimental"
	, ->
		pruners = {}
		register = (type, f) -> (pruners[type] = f)
		lookup = (obj) -> pruners[obj.t or obj.type]
		stack = []

		$.type.extend null,        { compact: (o) -> $.toString(o) }
		$.type.extend "undefined", { compact: (o) -> "" }
		$.type.extend "null",      { compact: (o) -> "" }
		$.type.extend "string",    { compact: $.identity }
		$.type.extend "array",     { compact: (o) -> (Object.Compact(x) for x in o).join("") }
		$.type.extend "bling",     { compact: (o) -> o.map(Object.Compact).join("") }
		$.type.extend "object",    { compact: (o) -> Object.Compact(lookup(o)?.call o, o) }

		Object.Compact = (o) ->
			stack.push(o)
			$.type.lookup(o)?.compact(o)
			stack.pop()
		$.extend Object.Compact,
			register: register
			lookup: lookup

		register 'page', -> [
			"<!DOCTYPE html><html><head>",
				@head,
			"</head><body>",
				@body,
			"</body></html>"
		]
		register 'text', -> @EN
		register 'link', ->
			a = $(["<a"])
			a.extend(" ",k,"='",@[k],"'") for k in ["href","name","target"] when k of @
			a.extend(">",node.content,"</a>")

		$.assert(Object.Compact({ t: "page", head: [], body: {type: "text", EN: "Hello World"} }) is
			"<!DOCTYPE html><html><head></head><body>Hello World</body></html>")

		return { name: "Compact" }
)(Bling)

(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'ClientRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts

				post: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "POST"
					$.http url, opts

				get: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "GET"
					$.http url, opts
		}
)(Bling)
(($) ->
		operatorHtml = "<span class='opr'>$&</span>"
		keywords = /\b[Ff]unction\b|\bvar\b|\.prototype\b|\.__proto__\b|\bString\b|\bArray\b|\bNumber\b|\bObject\b|\bbreak\b|\bcase\b|\bcontinue\b|\bdelete\b|\bdo\b|\bif\b|\belse\b|\bfinally\b|\binstanceof\b|\breturn\b|\bthrow\b|\btry\b|\btypeof\b|\btrue\b|\bfalse\b/g
		keywordHtml = "<span class='kwd'>$&</span>"
		allNumbers = /\d+\.*\d*/g
		numberHtml = "<span class='num'>$&</span>"
		blingSymbol = /\$(\(|\.)/g
		blingHtml = "<span class='bln'>$$</span>$1"
		tabs = /\t/g
		tabHtml = "&nbsp;&nbsp;"
		singlelineComment = /\/\/.*?(?:\n|$)/
		multilineComment = /\/\*(?:.|\n)*?\*\//
		commentHtml = (comment) ->
		quotedHtml = (quoted) ->

			a = s.indexOf('"', i)
			b = s.indexOf("'", i)
			a = s.length if a is -1
			b = s.length if b is -1
			return [null, -1] if a is b
			return ['"', a] if a < b
			return ["'", b]
			r = s.indexOf(q, i)
			while( s.charAt(r-1) is "\\" and 0 < r < s.length)
				r = s.indexOf(q, r+1)
			r
			i = 0
			n = s.length
			ret = []
			if not Object.IsString(s)
				if not Object.IsFunction(s.toString)
					throw TypeError("invalid string argument to split_quoted")
				else
					s = s.toString()
					n = s.length
			while( i < n )
				q = firstQuote(s, i)
				j = q[1]
				if( j is -1 )
					ret.push(s.substring(i))
					break
				ret.push(s.substring(i,j))
				k = closingQuote(s, j+1, q[0])
				if( k is -1 )
					throw Error("unclosed quote: "+q[0]+" starting at "+j)
				ret.push(s.substring(j, k+1))
				i = k+1
			ret

		firstComment = (s) ->
			a = s.match(singlelineComment)
			b = s.match(multilineComment)
			return [-1, null] if a is b
			return [b.index, b[0]] if a == null and b != null
			return [a.index, a[0]] if a != null && b == null
			return [b.index, b[0]] if b.index < a.index
			return [a.index, a[0]]

		splitComments = (s) ->
			ret = []
			i = 0
			n = s.length
			while( i < n )
				ss = s.substring(i)
				q = firstComment(ss)
				j = q[0]
				if( j > -1 )
					ret.push(ss.substring(0,j))
					ret.push(q[1])
					i += j + q[1].length
				else
					ret.push(ss)
					break
			ret

		foldCodeAndQuoted = (code, quoted) ->
			code.replace(operators, operatorHtml).replace(allNumbers, numberHtml).replace(keywords, keywordHtml).replace(blingSymbol, blingHtml).replace(tabs, tabHtml) + quotedHtml(quoted)

		foldTextAndComments = (text, comment) ->
			$(splitQuoted(text)).fold(foldCodeAndQuoted).join('') + commentHtml(comment)

		return {
			name: "PrettyPrint"
			$:
				prettyPrint: (js, colors) ->
					js = js.toString() if Object.IsFunction(js)
					if not Object.IsString(js)
						throw TypeError("prettyPrint requires a function or string to format, not '"+Object.Type(js)+"'")
						css = "code.pp .bln { font-size: 17px; } "
						colors = Object.Extend(
						, colors)
						for cls of colors
							.text(css)
							.appendTo("head")
					ret = "<code class='pp'>" + ($(splitComments(js)).fold(foldTextAndComments).join('')) + "</code>"
		}

)(Bling)
require "../../dist/bling"

do ($ = Bling) ->

	$.plugin
		provides: "text-analysis"
	, ->
		indices = $.memoize (str, substr) ->
			switch substr.length
				when 0 then $.range 0, str.length
				when 1
					i = -1
					i while (i = str.indexOf substr, i+1) > -1
				else
					subsub = substr[0...substr.length-1]
					indices(str, subsub).filter (x) -> str.indexOf(substr,x) is x

		ld = $.memoize (s, t) ->
			switch true
				when not s then t.length
				when not t then s.length
				when s is t then 0
				when s[0] is t[0] then ld s[1..],t[1..]
				else 1 + Math.min(
					ld(s, t[1..]),
					ld(s[1..], t),
					ld(s[1..], t[1..])
				)

		commonSubstrings = (a,b,min_length=1,limit=1) ->
			a = a.toLowerCase()
			b = b.toLowerCase()
			ret = {}
			for i in [0...b.length]
				for j in [0...b.length]
					if (j - i) < min_length-1 then continue
					c = b[i..j]
					if (indices a,c).length > 0
							ret[c] = 1
			$(Object.keys ret)
				.sort((x,y) -> y.length - x.length)
				.take(limit)

		$:
			stringDistance: ld
			stringsInCommon: commonSubstrings

(($) ->

	$.plugin () ->

		Dialog = (selector, opts) ->
			opts = $.extend({
				autoOpen: false
				draggable: true
			}, opts)
			dialog = $(selector)
				.addClass("dialog")
			if opts.draggable
				dialog.draggable()
			if opts.autoOpen
				dialog.show().center()
			dialog
				.find("button.close, .close-button")
				.bind "click touchstart", () ->
					dialog.hide()
					false
			dialog
		
		Draggable = (selector, opts) ->
			opts = $.extend({
				handleCSS: {}
			}, opts)

			opts.handleCSS = $.extend({
				position: "absolute"
				top: "0px"
				left: "0px"
				width: "100%"
				height: "6px"
			}, opts.handleCSS)

			dragObject = $(selector)
			moving = false
			oX = oY = 0
			handle = $
				.synth("div.handle")
				.defaultCss({
					height: "6px"
					"border-radius": "3px"
					cursor: "move"
				})
				.css(opts.handleCSS)
				.bind 'mousedown, touchstart', (evt) ->
					moving = true
					oX or= evt.pageX
					oY or= evt.pageY
					false
			$(document)
			.bind 'mousemove, touchmove', (evt) ->
				if moving
					dX = (evt.pageX - oX)
					dY = (evt.pageY - oY)
					dragObject.transform({
						translate: [ dX, dY ]
					}, 0)
					.trigger 'drag', {
						dragObject: dragObject
					}
					false
			.bind 'mouseup, touchend', (evt) ->
				if moving
					moving = false
					pos = handle.position()[0]
					$(document.elementFromPoint(pos.left, pos.top - 1))
					.trigger 'drop',
						dropObject: dragObject

			dragObject
				.addClass("draggable")
				.css {
					position: "relative"
					"padding-top": dragObject.css("padding-top")
						.map(Number.AtLeast(parseInt(opts.handleCSS.height,10)))
						.px().first()
				}
				.append(handle)

		ProgressBar = (selector, opts) ->
			opts = $.extend({
				change: null
				barColor: "rgba(0,128,0,0.5)"
				textColor: "white"
				reset: false
			}, opts)

			node = $(selector)
				.addClass('progress-bar')
				_bg = node.css("background").first()
				_color = node.css("color").first()

			node.zap 'updateProgress', (pct) ->
				while pct < 1.0
					pct *= 100.0
					node.css
						background: _bg
						color: _color
				else
					node.css
						background:"""
						"""
						color: opts.textColor
				if $.is "function", opts.change
					opts.change pct

		Accordion = (selector, opts) ->
			opts = $.extend({
				exclusive: false
				sticky: false
			}, opts)
			node = $(selector).addClass("accordion")
			selectedChild = null

			initRow = (n) ->
				t = $(n).children().first().filter("*")
				if( t.len() isnt 2 )
				title = t.eq(0).addClass("title")
				body = t.eq(1).addClass("body").hide()
				bodyVisible = false
				title.click () ->
					if opts.exclusive
						node.find(".body").hide()
					if bodyVisible
						if not opts.sticky
							body.hide().removeClass("visible")
							title.removeClass("selected").trigger("deselect")
							bodyVisible = false
						else
							body.show().addClass("visible")
							title.addClass("selected").trigger("select")
							bodyVisible = true
					else
						body.show().addClass("visible")
						title.addClass("selected").trigger("select")
						bodyVisible = true

			node.bind "DOMNodeInserted", (evt) ->
				directChildren = node.children().first().filter("*")
				parentsOfInserted = $(evt.target).parents().first()
				initRow(parentsOfInserted.intersect(directChildren))

			node.children().first()
				.map(initRow)

			return node

		ViewStack = (selector, opts) ->
			items = $(selector)
				.css {
					position: "relative"
					top: "0px"
					left: "0px"
				}
				.hide()
				.map($)
			active = 0
			items[active].show()
			items.next = () ->
				items[active].hide()
				active = (++active % items.length)
				items[active].show()
			items.activate = (k) ->
				items[active].hide()
				active = k
				items[k].show()
			for j in [0...items.len()]
				items[j]
				.zap("_viewIndex", j)
				.zap "activate", ->
					items.activate(this._viewIndex)
			items

		Tabs = (selector, views) ->
			tabs = $(selector)
			views = $(views).viewStack()
			nn = tabs.len()
			tabs._tabIndex = i for i in [0..nn]
			$(tabs[0]).addClass("active")
			tabs.click () ->
				tabs.removeClass("active")
				views.activate(this._tabIndex)
				$(this).addClass("active")

		return {
			$:
				UI:
					Draggable: Draggable
					ProgressBar: ProgressBar
					ViewStack: ViewStack
					Tabs: Tabs
					Accordion: Accordion

			dialog: (opts) -> Dialog(this, opts)
			progressBar: (opts) -> ProgressBar(this, opts)
			viewStack: (opts) -> ViewStack(this, opts)
			tabs: (views) -> Tabs(this, views)
			accordion: (opts) -> Accordion(this, opts)
			draggable: (opts) -> Draggable(this, opts)
		}

)(Bling)


	units = ["px","pt","pc","em","%","in","cm","mm","ex",""]
	UNIT_RE = /(\d+\.*\d*)(px|pt|pc|em|%|in|cm|mm|ex)/

	parseUnits = (s) -> UNIT_RE.exec(s)[2] if UNIT_RE.test(s) else ""

	conv = (a,b) -> conv[a][b]()
	for a in units
		for b in units
			(conv[a] or= {})[b] = trick +(a is b or a is "" or b is "")
	conv.in.pt = -> 72
	conv.in.px = -> 96
	conv.in.cm = -> 2.54
	conv.pc.pt = -> 12
	conv.cm.mm = -> 10
	conv.em.px = ->
		x = $("<span style='font-size:1em;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.px = ->
		x = $("<span style='font-size:1ex;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.em = -> 2
	fillIn = ->
		for a in units
			for b in units
				if not conv(a,b) and conv(b,a)
					conv[a][b] = trick 1.0/conv(b,a)
				for c in units
					if not conv(a,c) and conv(a,b) and conv(b,c)
						conv[a][c] = trick conv(a,b) * conv(b,c)
	fillIn(); fillIn()
	
	convertUnits = (number, unit) -> parseFloat(number) * conv[parseUnits(number)][unit]() + unit

	$.assert(convertUnits("300px", "cm") == "10cm")

	convertAll = (to, a) ->
		for i in [0...a.length]
			a[i] = convertTo(to, a[i])

	Object.Type.register "units",
		match: (x) -> UNIT_RE.test(x)

	unit_scalar = (f) ->
		(a...) ->
			convertAll( unit = parseUnits(@[0]), @)
			(f.apply @, a) + unit
	unit_vector = (f) ->
		(a...) ->
			u = @map parseUnits
			f.apply(@floats(), a).map ->

	{
		min: unit_scalar -> @reduce (a) -> Math.min parseFloat(@), a
		max: unit_scalar -> @reduce (a) -> Math.max parseFloat(@), a
		sum: unit_scalar -> @reduce (a) -> parseFloat(@) + a
		mean: unit_scalar -> parseFloat(@sum()) / @length
		magnitude: unit_scalar -> Math.sqrt @floats().squares().sum()
		squares: -> @map -> (x=parseFloat(@)) * x
		scale: (n) -> @map -> n * parseFloat(@)
		add: (d) -> @map -> d + @
		normalize: -> @scale(1/@magnitude())
	}


	EOF = -> "EOF"

	BackgroundQueue = (opts) ->
		opts = extend {
			item: -> EOF
			action: Function.Identity
			latency: 10
		}, opts

		return extend new $.EventEmitter(), {
			run: ->
				r = () =>
					if (item = opts.action(opts.item())) isnt EOF
						@emit("data", item)
						setTimeout r, opts.latency
				setTimeout r, opts.latency
		}

	data = x for x in [0...1000]
	i = 0
	BackgroundQueue
		item: ->
			return data[i++] if i < data.length else EOF
		action: (item) -> (item*item) - 1
		latency: 10
	.on "data", (x) -> console.log "data:", x
	.on "error", (x) -> console.log "error:", x
	
$.plugin
	provides: "function"
	depends: "hash"
, ->
	$:
		identity: (o) -> o
		not: (f) -> -> not f.apply @, arguments
		compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
		and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
		once: (f, n=1) ->
			$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
				"exhausted",
					get: -> n <= 0
		cycle: (f...) ->
			i = -1
			-> f[i = ++i % f.length].apply @, arguments
		bound: (t, f, args = []) ->
			if $.is "function", f.bind
				args.splice 0, 0, t
				r = f.bind.apply f, args
			else
				r = (a...) -> f.apply t, (args if args.length else a)
		E: (callback) -> (f) -> (err, data) ->
			return f(data) unless err
			callback err, data

$.plugin
	provides: "groupBy"
, ->
	groupBy: (key) ->
		groups = {}
		switch $.type key
			when 'array','bling'
				@each ->
					c = (@[k] for k in key).join ","
					(groups[c] or= $()).push @
			else @each -> (groups[@[key]] or= $()).push @
		return $.valuesOf groups
$.plugin
	provides: "hash"
	depends: "type"
, ->
	$.type.extend
		unknown: { hash: (o) -> $.checksum $.toString o }
		object:  { hash: (o) ->
			$.hash(Object) +
				$($.hash(o[k]) for k of o).sum() +
				$.hash Object.keys o
		}
		array:   { hash: (o) ->
			$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
				(a*a)+(x|0)
			, 1
		}
		bool:    { hash: (o) -> parseInt(1 if o) }
	return {
		$:
			hash: (x) -> $.type.lookup(x).hash(x)
		hash: -> $.hash @
	}
$.plugin ->
	$:
		histogram: (data, bucket_width=1, output_width=80) ->
			buckets = $()
			len = 0
			for x in data
				i = Math.floor( x / bucket_width )
				buckets[i] ?= 0
				buckets[i] += 1
				len = Math.max(len, i+1)
			buckets.length = len

			max = buckets.max()
			buckets = buckets.map((x) -> x or 0)
				.scale(1/max)
				.scale(output_width)
			sum = buckets.sum()

			ret = ""
			pct_sum = 0
			for n in [0...len] by 1
				end = (n+1) * bucket_width
				pct = (buckets[n]*100/sum)
				pct_sum += pct
			ret
	histogram: -> $.histogram @
$.plugin
	provides: "hook"
	depends: "type"
, ->





	hooks = {}
	hook = (name, args) ->
		p = (hooks[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args

	hook("bling-init").prepend (args) ->
		if args.length is 1
			args = $.type.lookup(args[0]).array(args[0])
		$.inherit Bling, args

	$: hook: hook

$.plugin
	depends: "dom"
	provides: "http"
, ->

	$.type.register "http",
		match: (o) -> $.isType 'XMLHttpRequest', o
		array: (o) -> [o]

	return {
		$:
			http: (url, opts = {}) ->
				xhr = new XMLHttpRequest()
				if $.is "function", opts
					opts = success: $.bound(xhr, opts)
				opts = $.extend {
					method: "GET"
					data: null
					async: true
					asBlob: false
					followRedirects: false
					withCredentials: false
				}, opts
				opts.state = $.bound(xhr, opts.state)
				opts.success = $.bound(xhr, opts.success)
				opts.error = $.bound(xhr, opts.error)
				if opts.data and opts.method is "GET"
					url += "?" + formencode(opts.data)
				else if opts.data and opts.method is "POST"
					opts.data = formencode(opts.data)
				xhr.open(opts.method, url, opts.async)
				xhr = $.extend xhr,
					asBlob: opts.asBlob
					timeout: opts.timeout
					followRedirects: opts.followRedirects
					withCredentials: opts.withCredentials
					onreadystatechange: ->
						opts.state?()
						if xhr.readyState is 4
							if xhr.status is 200
								opts.success xhr.responseText
							else
								opts.error xhr.status, xhr.statusText
				xhr.send opts.data
				return $(xhr)

			post: (url, opts = {}) ->
				if $.is("function",opts)
					opts = success: opts
				opts.method = "POST"
				$.http(url, opts)

			get: (url, opts = {}) ->
				if( $.is("function",opts) )
					opts = success: opts
				opts.method = "GET"
				$.http(url, opts)
	}
$.depends 'hook', ->
	$.hook('bling-init').append (obj) ->
		map = Object.create(null)
		keyMakers = []
		$.inherit {
			index: (keyFunc) ->
				if keyMakers.indexOf(keyFunc) is -1
					keyMakers.push keyFunc
					map[keyFunc] = Object.create(null)
				@each (x) ->
					map[keyFunc][keyFunc(x)] = x
			query: (criteria) ->
				for keyMaker in keyMakers
					key = keyMaker(criteria)
					return map[keyMaker][key] if key of map[keyMaker]
				null
		}, obj

$.plugin
	depends: "dom"
	provides: "lazy"
, ->
	lazy_load = (elementName, props) ->
		$("head").append $.extend document.createElement(elementName), props
	$:
		script: (src) ->
			lazy_load "script", { src: src }
		style: (src) ->
			lazy_load "link", { href: src, rel: "stylesheet" }

$.plugin
	provides: "math"
	depends: "core"
, ->
	$.type.extend
		bool: { number: (o) -> if o then 1 else 0 }
		number: { bool: (o) -> not not o }

	_By = (cmp) ->
		(field) ->
			valueOf = switch $.type field
				when "string" then (o) -> o[field]
				when "function" then field
				else throw new Error ".maxBy first argument should be a string or function"
			x = @first()
			@skip(1).each ->
				if cmp valueOf(@), valueOf(x)
					x = @
			return x

	$:
		range: (start, end, step = 1) ->
			if not end? then (end = start; start = 0)
			$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
		zeros: (n) -> $( 0 for i in [0...n] )
		ones: (n) -> $( 1 for i in [0...n] )
		deg2rad: (n) -> n * Math.PI / 180
		rad2deg: (n) -> n * 180 / Math.PI
	floats: -> @map parseFloat
	ints: -> @map -> parseInt @, 10
	px: (delta) -> @ints().map -> $.px @,delta
	min: -> @filter( isFinite ).reduce Math.min
	max: -> @filter( isFinite ).reduce Math.max
	maxBy: _By (a,b) -> a > b
	minBy: _By (a,b) -> a < b
	mean: mean = -> if not @length then 0 else @sum() / @length
	avg: mean
	sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
	product: -> @filter( isFinite ).reduce (a) -> a * @
	squares: -> @pow(2)
	pow: (n) -> @map -> Math.pow @, n
	magnitude: -> Math.sqrt @floats().squares().sum()
	scale: (r) -> @map -> r * @
	add: add = (d) -> switch $.type(d)
		when "number" then @map -> d + @
		when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
	plus: add
	vecAdd: (v) ->
		d = $()
		for i in [0...@length] by 1
			d[i] = @[i] + v[i]
		d
	normalize: -> @scale 1 / @magnitude()
	deg2rad: -> @filter( isFinite ).map -> @ * Math.PI / 180
	rad2deg: -> @filter( isFinite ).map -> @ * 180 / Math.PI
$.plugin
	depends: 'function'
	provides: 'memoize'
, ->
	$:
		memoize: (f) ->
			cache = Object.create(null)
		memoize: (opts) ->
			if $.is 'function', opts
				opts = f: opts
			if not $.is 'object', opts
				throw new Error "Argument Error: memoize requires either a function or object as first argument"
			opts.cache or= Object.create(null)
			opts.hash or= $.identity
			return ->
				opts.cache[opts.hash(arguments)] ?= opts.f.apply @, arguments

	
$.plugin
	provides: "pubsub"
, ->
	$:
		publish: (e, args...) ->
			f.apply null, args for f in (subscribers[e] or= [])
			args
		publisher: (e, func) ->
			(args...) ->
				$.publish e, func.apply @, args
		subscribe: (e, func) ->
			(subscribers[e] or= []).push func
			func
		unsubscribe: (e, func) ->
			if not func?
				subscribers[e] = []
			else
				a = (subscribers[e] or= [])
				if (i = a.indexOf func)  > -1
					a.splice(i,i)
$.plugin
	provides: 'random'
	depends: 'type'
, ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""

		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615

		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)

			index = (index + 1) % 624
			(y + a) / b

		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()

		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u

$.plugin
	provides: "sendgrid"
	depends: "config"
, ->
	try
		nodemailer = require 'nodemailer'
	catch err
		`return`
	transport = nodemailer.createTransport 'SMTP',
		service: 'SendGrid'
		auth:
			user: $.config.get 'SENDGRID_USERNAME'

	$:
		sendMail: (mail, callback) ->
			mail.transport ?= transport
			mail.from ?= $.config.get 'EMAILS_FROM'
			mail.bcc ?= $.config.get 'EMAILS_BCC'

			if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
				nodemailer.sendMail mail, callback
			else
$.plugin
	provides: "sortBy,sortedIndex"
, ->
	$:
		sortedIndex: (array, item, iterator) ->
			cmp = switch $.type iterator
				when "string" then (a,b) -> a[iterator] - b[iterator]
				when "function" then (a,b) -> iterator(a) - iterator(b)
				else (a,b) -> a - b
				if cmp(array[i], item) > 0
					return i
			return array.length
	sortBy: (iterator) ->
		a = $()
		for item in @
			n = $.sortedIndex a, item, iterator
			a.splice n, 0, item
		a
	sortedInsert: (item, iterator) ->
		@splice ($.sortedIndex @, item, iterator), 0, item
		@

		
$.plugin
	provides: "string"
	depends: "function"
, ->
	safer = (f) ->
		(a...) ->
			try return f(a...)
	$.type.extend
		unknown:
			string: safer (o) -> o.toString?() ? String(o)
			repr: safer (o) -> $.type.lookup(o).string(o)
			number: safer (o) -> parseFloat String o
		null: { string: -> "null" }
		undefined: { string: -> "undefined" }
		string:
			number: safer parseFloat
		array:  { string: safer (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
		object: { string: safer (o) ->
			ret = []
			for k of o
				try
					v = o[k]
				catch err
			"{" + ret.join(', ') + "}"
		}
		function:
			string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
		number:
			repr:   (n) -> String(n)
			string: safer (n) ->
				switch true
					when n.precision? then n.toPrecision(n.precision)
					when n.fixed? then n.toFixed(n.fixed)
					else String(n)

	return {
		$:
			toString: (x) ->
				if not x? then "function Bling(selector, context) { [ ... ] }"
				else
					try
						$.type.lookup(x).string(x)
					catch err

			toRepr: (x) -> $.type.lookup(x).repr(x)

			px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"



			capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")

			dashize: (name) ->
				ret = ""
				for i in [0...(name?.length|0)]
					c = name.charCodeAt i
					if 91 > c > 64
						c += 32
						ret += '-'
					ret += String.fromCharCode(c)
				ret

			camelize: (name) ->
				name.split('-')
				while (i = name?.indexOf('-')) > -1
					name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
				name

			padLeft: (s, n, c = " ") ->
				while s.length < n
					s = c + s
				s

			padRight: (s, n, c = " ") ->
				while s.length < n
					s = s + c
				s

			stringTruncate: (s, n, c = "...") ->
				s = s.split(' ')
				r = []
				while n > 0
					x = s.shift()
					n -= x.length
					if n >= 0
						r.push x
				r.join('') + c


			stringCount: (s, x, i = 0, n = 0) ->
				if (j = s.indexOf x,i) > i-1
					$.stringCount s, x, j+1, n+1
				else n

			stringSplice: (s, i, j, n) ->
				nn = s.length
				end = j
				if end < 0
					end += nn
				start = i
				if start < 0
					start += nn
				s.substring(0,start) + n + s.substring(end)

			checksum: (s) ->
				a = 1; b = 0
				for i in [0...s.length]
					a = (a + s.charCodeAt(i)) % 65521
					b = (b + a) % 65521
				(b << 16) | a

			repeat: (x, n=2) ->
				switch true
					when n is 1 then x
					when n < 1 then ""
					when $.is "string", x then x + $.repeat(x, n-1)
					else $(x).extend $.repeat(x, n-1)

			stringBuilder: ->
				if $.is("global", @) then return new $.stringBuilder()
				items = []
				@length   = 0
				@append   = (s) => items.push s; @length += s?.toString().length|0
				@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
				@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
				@toString = ( ) => items.join("")
				@
		toString: -> $.toString @
		toRepr: -> $.toRepr @
	}


$.plugin
	provides: "symbol"
	depends: "type"
, ->
	symbol = null
	cache = {}
	g = $.global
	g.Bling = Bling
	if module?
		module.exports = Bling
	$.defineProperty $, "symbol",
		set: (v) ->
			g[symbol] = cache[symbol]
			cache[symbol = v] = g[v]
			g[v] = Bling
		get: -> symbol
	return $:
		symbol: "$"
		noConflict: ->
			Bling.symbol = "Bling"
			Bling
$.plugin
	provides: "StateMachine"
, ->
	$: StateMachine: class StateMachine
		constructor: (stateTable) ->
			@debug = false
			@reset()
			@table = stateTable
			Object.defineProperty @, "modeline",
				get: -> @table[@_mode]
			Object.defineProperty @, "mode",
				set: (m) ->
					@_lastMode = @_mode
					@_mode = m
					if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
						ret = @modeline['enter'].call @
						while $.is("function",ret)
							ret = ret.call @
					m
				get: -> @_mode

		reset: ->
			@_mode = null
			@_lastMode = null

		GO: (m) -> -> @mode = m
		@GO: (m) -> -> @mode = m
		
		tick: (c) ->
			row = @modeline
			if not row?
				ret = null
			else if c of row
				ret = row[c]
			else if 'def' of row
				ret = row['def']
			while $.is "function",ret
				ret = ret.call @, c
			ret

		run: (inputs) ->
			@mode = 0
			for c in inputs
				ret = @tick(c)
			if $.is "function",@modeline?.eof
				ret = @modeline.eof.call @
			while $.is "function",ret
				ret = ret.call @
			@reset()
			return @

$.plugin
	provides: "synth"
	depends: "StateMachine, type"
, ->
	class SynthMachine extends $.StateMachine
		basic =
			".": @GO 3
			"[": @GO 4
			'"': @GO 6
			"'": @GO 7
			" ": @GO 8
			",": @GO 10
			"+": @GO 11
			eof: @GO 13

		@STATE_TABLE = [
				enter: ->
					@tag = @id = @cls = @attr = @val = @text = ""
					@attrs = {}
					@GO 1
			},
				def: (c) -> @tag += c
			}, basic),
				def: (c) -> @id += c
			}, basic),
				enter: -> @cls += " " if @cls.length > 0
				def: (c) -> @cls += c
			}, basic),
				"=": @GO 5
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @attr += c
				eof: @GO 12
			},
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @val += c
				eof: @GO 12
			},
				'"': @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				"'": @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = null
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = @cursor?.parentNode
					@GO 0
			},
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
			}
		]
		constructor: ->
			super(SynthMachine.STATE_TABLE)
			@fragment = @cursor = document.createDocumentFragment()
		emitNode: ->
			if @tag
				node = document.createElement @tag
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@cursor.appendChild node
				@cursor = node
		emitText: ->
			@cursor.appendChild $.type.lookup("<html>").node(@text)
			@text = ""

	return {
		$:
			synth: (expr) ->
				s = new SynthMachine()
				s.run(expr)
				if s.fragment.childNodes.length == 1
					$(s.fragment.childNodes[0])
				else
					$(s.fragment)
	}
do ($ = Bling) ->

		current_engine = null
		engines = {}

		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine

		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()

		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop] by 1
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1

	$.template.register_engine 'pythonic', (() ->

		chunk_re = /%[\(\/]/

		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n] by 1
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}

			if not cache?
			n = cache.length

			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""

		return render
	)()

		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
$.plugin
	provides: "throttle"
	depends: "core"
, ->
	$:
		throttle: (ms, f) ->
			last = 0
			(a...) ->
				gap = $.now - last
				if gap > ms
					last += gap
					return f.apply @,a
				null
		debounce: (ms, f) ->
			last = 0
			(a...) ->
				last += (gap = $.now - last)
				return f.apply @,a if gap > ms else null
	parseOne = (data) ->
		i = data.indexOf ":"
		if i > 0
			len = parseInt data[0...i], 10
			item = data[i+1...i+1+len]
			type = data[i+1+len]
			extra = data[i+len+2...]
			item = switch type
				when "'" then String(item)
				when "!" then (item is "true")
				when "~" then null
				when "]" then parseArray(item)
				when "}" then parseObject(item)
			return [item, extra]
		return undefined
	parseArray = (x) ->
		data = []
		while x.length > 0
			[one, x] = parseOne(x)
			data.push(one)
		data
	parseObject = (x) ->
		data = {}
		while x.length > 0
			[key, x] = parseOne(x)
			[value, x] = parseOne(x)
			data[key] = value
		data
	$:
		TNET:
			stringify: (x) ->
				[data, type] = switch $.type x
					when "string" then [x, "'"]
					when "function" then [String(x), "'"]
					when "boolean" then [String(not not x), "!"]
					when "null" then ["", "~"]
					when "undefined" then ["", "~"]
					when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
					when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
				return (data.length|0) + ":" + data + type
			parse: (x) ->
				parseOne(x)?[0]
$.plugin
	provides: "trace"
	depends: "function,type"
, ->
	$.type.extend
		unknown: { trace: $.identity }
		function:
			trace: (label, f, tracer) ->
				label or= f.name
				r = (a...) ->
					f.apply @, a
				r
	return $: trace: (label, o, tracer) ->
		if not $.is "string", label
			[tracer, o] = [o, label]
		tracer or= $.log
		label or= ""
		$.type.lookup(o).trace(label, o, tracer)
$.plugin
	depends: "dom"
, ->
	COMMASEP = ", "
		"slow": 700
		"medium": 500
		"normal": 300
		"fast": 100
		"instant": 0
		"now": 0
	accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
	testStyle = document.createElement("div").style

	transformProperty = "transform"
	transitionProperty = "transition-property"
	transitionDuration = "transition-duration"
	transitionTiming = "transition-timing-function"

	if "WebkitTransform" of testStyle
		transformProperty = "-webkit-transform"
		transitionProperty = "-webkit-transition-property"
		transitionDuration = "-webkit-transition-duration"
		transitionTiming = "-webkit-transition-timing-function"
	else if "MozTransform" of testStyle
		transformProperty = "-moz-transform"
		transitionProperty = "-moz-transition-property"
		transitionDuration = "-moz-transition-duration"
		transitionTiming = "-moz-transition-timing-function"
	else if "OTransform" of testStyle
		transformProperty = "-o-transform"
		transitionProperty = "-o-transition-property"
		transitionDuration = "-o-transition-duration"
		transitionTiming = "-o-transition-timing-function"

	return {
		$:
			duration: (speed) ->
				d = speeds[speed]
				return d if d?
				return parseFloat speed

		transform: (end_css, speed, easing, callback) ->

			if $.is("function",speed)
				callback = speed
				speed = easing = null
			else if $.is("function",easing)
				callback = easing
				easing = null
			speed ?= "normal"
			easing or= "ease"
			duration = $.duration(speed) + "ms"
			props = []
			trans = ""
			css = {}
			for i of end_css
				if accel_props_re.test(i)
					ii = end_css[i]
					if ii.join
						ii = $(ii).px().join COMMASEP
					else if ii.toString
						ii = ii.toString()
					trans += " " + i + "(" + ii + ")"
				else css[i] = end_css[i]
			(props.push i) for i of css
			if trans
				props.push transformProperty

			css[transitionProperty] = props.join COMMASEP
			css[transitionDuration] = props.map(-> duration).join COMMASEP
			css[transitionTiming] = props.map(-> easing).join COMMASEP

			if trans
				css[transformProperty] = trans
			@css css
			@delay duration, callback

			@each ->
				if @style
					if @style.display is not "none"
						@_display = @syle.display
					@style.display = "none"
			.trigger "hide"
			.delay updateDelay, callback

			@each ->
				if @style
					@style.display = @_display
					delete @_display
			.trigger "show"
			.delay updateDelay, callback

			@weave(@css("display"))
				.fold (display, node) ->
					if display is "none"
						node.style.display = node._display or ""
						delete node._display
						$(node).trigger "show"
					else
						node._display = display
						node.style.display = "none"
						$(node).trigger "hide"
					node
				.delay(updateDelay, callback)

			@.css('opacity','0.0')
				.show ->
					@transform {
						opacity:"1.0",
						translate3d: [0,0,0]
					}, speed, callback
			@transform {
				opacity:"0.0",
				translate3d:[x,y,0.0]
			}, speed, -> @hide(callback)
		fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
		fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
		fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
		fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
	}
$.plugin
	provides: "type"
, ->


	isType = (T, o) ->
		if not o? then T in [o,"null","undefined"]
		else o.constructor is T or
			o.constructor.name is T or

	inherit = (parent, obj) ->
		if typeof parent is "function"
			parent = parent.prototype
		if parent.__proto__ is Object.prototype
			parent.__proto__ = obj.__proto__
		obj.__proto__ = parent
		obj

	_type = do ->

		cache = {}

		base =
			name: 'unknown'
			match: (o) -> true

		order = []

		register = (name, data) ->
			order.unshift name if not (name of cache)
			cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
			cache[name][name] = (o) -> o

		_extend = (name, data) ->
			if typeof name is "string"
				cache[name] ?= register name, {}
				cache[name] = extend cache[name], data
			else if typeof name is "object"
				(_extend k, name[k]) for k of name

		lookup = (obj) ->
			for name in order
				if cache[name]?.match.call obj, obj
					return cache[name]

		register "unknown",   base
		register "object",    match: -> typeof @ is "object"
		register "error",     match: -> isType 'Error', @
		register "regexp",    match: -> isType 'RegExp', @
		register "string",    match: -> typeof @ is "string" or isType String, @
		register "number",    match: -> (isType Number, @) and @ isnt NaN
		register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
		register "array",     match: -> Array.isArray?(@) or isType Array, @
		register "function",  match: -> typeof @ is "function"
		register "undefined", match: (x) -> x is undefined
		register "null",      match: (x) -> x is null

		return extend ((o) -> lookup(o).name),
			register: register
			lookup: lookup
			extend: _extend
			is: (t, o) -> cache[t]?.match.call o, o
			as: (t, o, rest...) -> lookup(o)[t]?(o, rest...)



	_type.extend
		unknown:   { array: (o) -> [o] }

		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }

	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) -> o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"

	$:
		inherit: inherit
		extend: extend
		defineProperty: (o, name, opts) ->
			Object.defineProperty o, name, extend({ configurable: true, enumerable: true }, opts)
			o
		isType: isType
		type: _type
		is: _type.is
		as: _type.as
		isSimple: (o) -> _type(o) in ["string", "number", "bool"]
		isEmpty: (o) -> o in ["", null, undefined] or o.length is 0 or (typeof o is "object" and Object.keys(o).length is 0)
	defineProperty: (name, opts) -> @each -> $.defineProperty @, name, opts
$.plugin
	provides: "unittest"
	depends: "core,function"
, ->
	testCount = passCount = failCount = 0
	failed = []
	invokeTest = (group, name, func) ->
		return if not $.is "function", func
		shouldFail = name.toLowerCase().indexOf("fail") isnt -1
		done = $.once (err) ->
			testCount--
			if (!!err isnt shouldFail)
				failCount++
				failed.push name
			else
				_log "pass"
				passCount++
				$.provide name
		f = (done) ->
			try func(done)
			catch err then done(err)
			finally
				if name.toLowerCase().indexOf("async") is -1 then done()
		testCount++
		try f(done)
		catch err then done(err)

	testReport = $.once ->
		if failCount > 0
			try process.exit(failCount)

	$:
		approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
		assertEqual: (a, b, label) ->
			if a isnt b
		assertArrayEqual: (a, b, label) ->
			for i in [0...a.length] by 1
				try
					$.assertEqual(a[i], b[i], label)
				catch err
		testGroup: (name, funcs) ->
			interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
			for k,func of funcs
				invokeTest(name, k, func)
	assertEqual: (args...) ->
				if $.is "function", x then x.call(@,@) else x
			a = args[0]
			for i in [1...args.length]
				$.assertEqual a, args[i]
		return @
dom = require("jldom")
dom.registerGlobals(global)
global.document = dom.createDocument()
global.window = global
require "../dist/bling.js"
assert = require 'assert'
document.body.innerHTML = """
	<table>
		<tr><td>1,1</td><td>1,2</td></tr>
		<tr><td>2,1</td><td>2,2</td></tr>
		<tr><td>3,1</td><td class='d'>3,2</td></tr>
		<tr><td>4,1</td><td>4,2</td></tr>
	</table>
	<div class='c'>C</div>
	<p><span>foobar</span></p>
"""

describe "Object", ->
	it "should have a keys method", ->
		assert typeof Object.keys is "function"
	it "should have a values method", ->
		assert typeof Object.values is "function"
	describe ".keys()", ->
		it "should return the list of keys", ->
			assert.deepEqual Object.keys( "a": 1, b: 2 ), ['a', 'b']
	describe ".values()", ->
		it "should return the list of values", ->
			assert.deepEqual Object.values( "a": 1, b: 2 ), [1, 2]

describe "Bling", ->
	it "should have a symbol with side effects", ->
		assert Bling?
		assert.equal Bling.symbol, "$"
		assert.equal global.$, Bling
		Bling.symbol = "_"
		assert.equal global._, Bling
		global.$ = "before"
		Bling.symbol = "$"
		assert.equal global.$, Bling
		Bling.symbol = "_"
		assert.equal global.$, "before"
		Bling.symbol = "$"
		assert.equal global.$, Bling
	it "should be constructable by call (python style)", ->
		b = Bling([1,2,3])
		assert.equal b[0], 1
		assert.equal b[1], 2
		assert.equal b[2], 3
	it "should have have the right constructor name", ->
		assert.equal Bling([1,2]).constructor.name, "Bling"
	it "should correct the length value", ->
		assert.equal(Array(10).length,10)
		assert.equal(Bling(10).length, 0)

	it "can be created from an array", ->
		assert.deepEqual $([1,2,3]), [1,2,3]
	it "can be created from multiple arguments", ->
		assert.deepEqual $(1,2,3), [1,2,3]
	it "can be created from DOM nodes", ->
		assert.equal $("td").length, 8

	describe ".type()", ->
		describe "should classify", ->
			it "'string'", -> assert.equal $.type(''), 'string'
			it "'number'", -> assert.equal $.type(42), 'number'
			it "'undefined'", -> assert.equal $.type(), "undefined"
			it "'null'", -> assert.equal $.type(null), "null"
			it "'array'", -> assert.equal $.type([]), "array"
			it "'function'", -> assert.equal $.type(->), "function"
			it "'bool'", -> assert.equal $.type(true), "bool"
			it "'regexp'", -> assert.equal $.type(//), "regexp"
			it "'window'", -> assert.equal $.type(window), "global"

	describe ".is()", ->
		describe "should identify", ->
			it "'array'", -> assert $.is "array", []
			it "'function'", -> assert $.is "function", ->

	describe ".inherit(a,b)", ->
		a = a: 1
		b = b: 2
		$.inherit a, b
		it "should set b's __proto__ to a", ->
			assert.equal b.__proto__, a
		it "b should inherit properties from a", ->
			assert.equal b.a, 1
		it "but b should not own those properties", ->
			assert not b.hasOwnProperty "a"

	describe ".extend(a,b)", ->
		a = a: 1
		b = b: 2
		c = $.extend a, b
		it "should return the modified a", -> assert.equal c, a
		it "should give a properties from b", -> assert.equal a.b, 2
		it "should copy those properties", ->
			a.b = 3
			assert.equal b.b, 2

	describe ".defineProperty()", ->
		describe "getters", ->
			a = {}
			$.defineProperty a, "getter",
				get: -> 2
			it "should be readable", ->
				assert.equal a.getter, 2
			it "should not be settable", ->
				a.getter = 3
				assert.equal a.getter, 2
			it "should be enumerable", ->
				assert.notEqual -1, Object.keys(a).indexOf("getter")
			it "should be configurable"
		describe "setters", ->
			a = {}
			$.defineProperty a, "setter",
				set: (v) ->
			it "should be settable", ->
				a.setter = 10
			it "should not be gettable", ->
				assert.equal a.setter, undefined
			it "should be enumerable", ->
				assert.notEqual -1, Object.keys(a).indexOf("setter")

	describe ".isType()", ->
		it "should compare against actual types", ->
			assert $.isType Array, []
		it "or against names of constructors", ->
			assert( $.isType('Array', []) )
		it "should work on non-builtin types", ->
			class Foo
			f = new Foo()
			assert $.isType Foo, f

	describe ".isSimple()", ->
		describe "should accept", ->
			it "strings", -> assert $.isSimple ""
			it "numbers", -> assert $.isSimple 42.0
			it "bools", -> assert( $.isSimple false )
		describe "should reject", ->
			it "objects", -> assert not $.isSimple {}
			it "arrays", -> assert not $.isSimple []

	describe ".isEmpty()", ->
		describe "should accept", ->
			it "empty strings", -> assert $.isEmpty ""
			it "nulls", -> assert $.isEmpty null
			it "undefineds", -> assert $.isEmpty undefined
			it "empty arrays", -> assert $.isEmpty []
			it "empty objects", -> assert $.isEmpty {}
		describe "should reject", ->
			it "full strings", -> assert not $.isEmpty "abc"
			it "arrays with items", -> assert not $.isEmpty [1,2,3]
			it "objects with keys", -> assert not $.isEmpty a:1

	describe ".toArray()", ->
		a = $([1,2,3])
		b = a.toArray()
		it "should produce an Array", ->
			assert.equal b.constructor.name, "Array"
		it "should preserve data", ->
			assert.equal b[1], 2
		it "should preserve length", ->
			assert.equal b.length, 3
		it "should not preserve bling functions", ->
			assert not b.zap

	describe ".as()", ->
		describe "should convert", ->
			it "strings to numbers", -> assert.equal ($.as "number", "1234"), 1234

	describe ".identity", ->
		it "should be a function", -> assert $.is "function", $.identity
		it "should echo anything", -> assert.equal $.identity(a = {}), a

	describe ".bound", ->
		f = -> @value
		a = value:'a'
		b = value:'b'
		it "binding to a should return a's value", ->
			assert.equal do $.bound(a, f), 'a'
		it "binding to b should return b's value", ->
			assert.equal do $.bound(b, f), 'b'

	describe ".trace", ->
		f = -> 42
		h = $.trace "label", f, (a...) ->
			g.push a.join ''
		it "should not trace the original function", ->
			f()
		it "should trace the returned function", ->
			assert.deepEqual g, [ "global.label('one','two')" ]

	describe ".px()", ->
		describe "converts ... to pixel strings", ->
			it "integers", -> assert.equal $.px(100), "100px"
			it "floats", -> assert.equal $.px(-100.0), "-100px"
			it "negatives", -> assert.equal $.px(-100.0), "-100px"
			it "pixel strings", -> assert.equal $.px("100.0px"), "100px"

	describe ".padLeft()", ->
		it "adds padding when needed", ->
			assert.equal $.padLeft("foo", 5), "  foo"
		it "does not add padding when not needed", ->
			assert.equal $.padLeft("foo", 2), "foo"
		it "does not add padding when barely not needed", ->
			assert.equal $.padLeft("foo", 3), "foo"
		it "can pad with non-default character", ->
			assert.equal $.padLeft("foo", 5, "X"), "XXfoo"

	describe ".padRight()", ->
		it "adds padding when needed", -> assert.equal $.padRight("foo", 5), "foo  "
		it "doesnt when not", -> assert.equal $.padRight("foo", 2), "foo"
		it "doesnt when not", -> assert.equal $.padRight("foo", 3), "foo"
		it "can pad with non-default character", -> assert.equal $.padRight("foo", 5, "X"), "fooXX"

	describe ".stringSplice()", ->
		it "should insert text", ->
			assert.equal $.stringSplice("foobar",3,3,"baz"), "foobazbar"
		it "should partially replace text", ->
			assert.equal $.stringSplice("foobar",1,5,"baz"), "fbazr"
		it "should completely replace text", ->
			assert.equal $.stringSplice("foobar",0,6,"baz"), "baz"
		it "should prepend text", ->
			assert.equal $.stringSplice("foobar",0,0,"baz"), "bazfoobar"

	describe ".checkSum()", ->
		it "should compute the same hash as adler32", ->
			assert.equal $.checksum("foobar"), 145425018
		it "should not just hash the one thing", ->
			assert.equal $.checksum("foobarbaz"), 310051767

	describe ".toString()", ->
		describe "should output", ->
			it "blings", ->
				assert.equal $([2,3,4]).toString(), "$([2, 3, 4])"
			it "functions", ->
				assert.equal $.toString(-> $.log), "function () { ... }"
			it "objects", ->assert.equal $.toString({a:{b:1}}), "{a:{b:1}}"
		it "should not fail", ->
			obj = a: 1
			$.defineProperty obj, 'xxx',
				get: -> throw new Error "forbidden"
			assert.equal $.toString(obj), "{a:1, xxx:[Error: forbidden]}"

	describe ".stringTruncate()", ->
		it "should truncate long strings and add ellipses", ->
			assert.equal ($.stringTruncate "long string", 6), "long..."

	describe ".plugin()", ->
		describe "creating new plugins", ->
			$.plugin ->
				$:
					testGlobal: -> 9
				testOp: -> 42
			it "should define new globals", ->
				assert.equal $.testGlobal?(), 9
			it "should define new instance methods", ->
				assert.equal $().testOp?(), 42
			it "should provide a default global wrapper", ->
				assert.equal $.testOp?(), 42

	describe ".avg()", ->
		it "average of an empty set is 0", ->
			assert.equal $([]).avg(), 0
		it "should compute the average", ->
			assert.equal $([1,2,3,4]).avg(), 2.5
		it "should be aliased as .mean()", ->
			assert.equal $.prototype.avg, $.prototype.mean

	describe ".sum()", ->
		it "should add an empty set as 0", ->
			assert.equal $([]).sum(), 0
		it "should compute the sum", ->
			assert.equal $([1,2,3,4,5]).sum(), 15
		it "should ignore non-numbers", ->
			assert.equal($([1,2,NaN,3]).sum(), 6)

	describe ".range(start,end)", ->
		it "should produce a sequence of ints from start to end", ->
			assert.equal($.range(1,6).toRepr(), '$([1, 2, 3, 4, 5])')
		it "start is optional, defaults to 0", ->
			assert.equal($.range(5).toRepr(), '$([0, 1, 2, 3, 4])')

	describe ".zeros()", ->
		it "should produce a set", ->
			assert $.is 'bling', $.zeros 10
		it "should produce all zeros", ->
			assert.equal 0, $.zeros(10).sum()

	describe ".ones()", ->
		it "should produce a set of ones", ->
			assert.equal $.ones(10).sum(), 10

	describe ".floats()", ->
		it "should convert everything to floats", ->
			assert.equal $(["12.1","29.9"]).floats().sum(), 42

	describe ".ints()", ->
		it "should convert everything to ints", ->
			assert.equal $(["12.1","29.9px"]).ints().sum(), 41

	describe ".px()", ->
		it "should convert everything to -px strings (for CSS)", ->
			assert.equal $(["12.1", "29.9"]).px(2).toRepr(), "$(['14px', '31px'])"

	describe ".min()", ->
		it "should return the smallest item", ->
			assert.equal $([12.1, 29.9]).min(), 12.1
		it "should ignore non-numbers", ->
			assert.equal( $([12.1, NaN, 29.9]).min(), 12.1)
		it "should return 0 for an empty set?"

	describe ".max()", ->
		it "should return the largest item", -> assert.equal( $([12.1, 29.9]).max(), 29.9)
		it "should ignore non-numbers", -> assert.equal( $([12.1, NaN, 29.9]).max(), 29.9)
		it "should return Infinity for an empty set?"
	
	describe ".maxBy()", ->
		it "should return the largest item", ->
			assert.deepEqual $( {a:1}, {a:3}, {a:2} ).maxBy('a'), a:3
		it "accepts a value function", ->
			assert.deepEqual $( {a:1}, {a:3}, {a:2} ).maxBy((o) -> Math.pow(o.a,2)), a:3
	
	describe ".minBy()", ->
		it "should return the smallest item", ->
			assert.deepEqual $( {a:3}, {a:1}, {a:2} ).minBy('a'), a:1
		it "accepts a value function", ->
			assert.deepEqual $( {a:1}, {a:3}, {a:2} ).minBy((o) -> Math.pow(o.a,2)), a:1
	
	describe ".product()", ->
		it "computes the product of everything (like .sum() with *)", ->
			assert.equal $(2,4,6).product(), 48
	
	describe ".squares()", ->
		it "squares everything", -> assert.deepEqual $(2,4,6).squares(), [4, 16, 36]
	
	describe ".pow(n)", ->
		it "maps Math.pow", -> assert.deepEqual $(2,4,6).pow(3), [8,64,6*6*6]
	
	describe ".magnitude()", ->
		it "computes the vector length", -> assert.equal $(2,4,6).magnitude(), 7.483314773547883
	
	describe ".scale(r)", ->
		it "mulitiplies everything by a constant factor", -> assert.deepEqual $(2,4,6).scale(3), [6,12,18]
	
	describe ".add(n)", ->
		it "does vector addition (with a scalar)", ->
			assert.deepEqual $(2,4,6).add(2), [4,6,8]
		it "adds two vectors", ->
			assert.deepEqual $(2,4,6).add([3,5,9]), [5,9,15]
		it "truncates the longer vector if mis-sized", ->
			assert.deepEqual $(2,4,6,8).add([3,5,9]), [5,9,15]
	
	describe ".normalize()", ->
		it "scales so that .magnitude() is 1", -> assert.equal $(2,4,6).normalize().magnitude(), 1
	
	describe ".deg2rad()", ->
		it "works as a global", -> assert.equal $.deg2rad(180), Math.PI
		it "works on a set", -> assert.deepEqual $(0,180).deg2rad(), [0, Math.PI]
	describe ".rad2deg()", ->
		it "works as a global", -> assert.equal $.rad2deg(Math.PI), 180
		it "works on a set", -> assert.deepEqual $(0,Math.PI).rad2deg(), [0, 180]

	describe ".random()", ->
		assert 0.0 < $.random() < 1.0
		describe ".real()", ->
			r = $.random.real 10,100
			it "should produce a number", ->
				assert $.is 'number', r
			it "is in the range", ->
				assert 10.0 < r < 100.0
		describe ".integer()", ->
			r = $.random.integer(3,9)
			it "should be an integer", ->
				assert.equal Math.floor(r), r
			it "is in the range", ->
				assert 3 <= r <= 9
		describe ".string()", ->
			s = $.random.string(16)
			it "is a string", ->
				assert $.is 'string', s
			it "has the right length", ->
				assert.equal s.length, 16
		describe ".seed()", ->
			$.random.seed = 42
			r = $.random.string(16)
			$.random.seed = 43
			s = $.random.string(16)
			$.random.seed = 42
			t = $.random.string(16)
			it "should produce same output for the same seed", ->
				assert.equal r, t
			it "should produce different output for a new seed", ->
				assert.notEqual r, s

	describe ".hash()", ->
		describe "hashes any type of object", ->
			it "number", -> assert $.hash(42) isnt $.hash(43)
			it "string", -> assert $.hash("foo") isnt $.hash("bar")
			it "array", -> assert $.hash("poop") isnt $.hash(["poop"])
			it "object", -> assert ($.hash a:1) isnt ($.hash a:2)
			it "bling", -> assert ($.hash $)?
		describe "always produces finite hashes", ->
			it "for objects", -> assert isFinite $.hash a:1
			it "for empty objects", -> assert isFinite $.hash {}
		describe "the order of elements matters", ->
			it "in arrays", -> assert.notEqual $.hash(["a","b"]), $.hash(["b","a"])
			it "in objects", -> assert.notEqual $.hash({}), $.hash []
			it "in blings", -> assert.notEqual $.hash($(["a","b"])), $.hash $(["b","a"])

	describe ".hook()", ->
		it "is a function", ->
			assert $.is 'function', $.hook
		it "returns a hook with append/prepend", ->
			p = $.hook('unit-test')
			assert $.is 'function', p.append
			assert $.is 'function', p.prepend
		it "computes values when called", ->
			$.hook('unit-test').append (x) -> x += 2
			$.hook('unit-test').prepend (x) -> x *= 2
			assert.equal $.hook('unit-test', 4), 10

	describe ".eq()", ->
		it "selects a new set with only one element", ->
			assert.equal $([1,2,3]).eq(1)[0], 2

	describe ".each(f)", ->
		it "repeats f for each element", ->
			check = 0
			$([1,2,3]).each -> check += 1
			assert.equal check, 3

	describe ".map(f)", ->
		it "returns a new set", ->
			a = $([1,2,3])
			b = a.map (->)
			assert.notEqual a,b
		it "containing the results of f(each item)", ->
			assert.deepEqual $([1,2,3]).map(->@*@), [1,4,9]
	
	describe ".filterMap(f)", ->
		it "works like map, but can omit some results", ->
			assert.deepEqual $(1,2,3,4).filterMap(->
				if @ % 2 then @*@
				else null
			), [1, 9]
	
	describe ".replaceWith", ->
		it "copies values from array to this", ->
			assert.deepEqual $(1,2,3,4).replaceWith([5,6,7,8]), [5,6,7,8]
		it "does not create a new Bling", ->
			d = $(1,2,3,4)
			e = d.replaceWith([5,6,7])
			assert.deepEqual d, [5,6,7,4]

	describe ".coalesce()", ->
		it "should return the first non-null item", ->
			assert.equal $.coalesce(null, 42, 22), 42
		it "should accept an array as argument", ->
			assert.equal($.coalesce([null, 14, 42]), 14)
		it "should descend arrays if nested", ->
			assert.equal($.coalesce([null, [null, 14], 42]), 14)
		it "should span arrays if given multiple", ->
			assert.equal $.coalesce([null, null], [null, [null, 14], 42]), 14

	describe ".reduce()", ->
		it "applies a combiner to accumulate a single result", ->
			assert.equal $([1,2,3,4]).reduce( (a,x) -> a + x ), 10

	describe ".union()", ->
		it "combines two sets, eliminating duplicates", ->
			assert.deepEqual $([1,2,3,4]).union([2,3,4,5]), [1,2,3,4,5]

	describe ".intersect()", ->
		it "combines two sets, leaving only the duplicates", ->
			assert.deepEqual($([1,2,3,4]).intersect([2,3,4,5]), [2,3,4])

	describe ".distinct()", ->
		it "removes duplicates from a single set", ->
			assert.deepEqual($([1,2,2,3,4,3]).distinct(), [1,2,3,4])

	describe ".contains()", ->
		it "returns true if an item is found in the set", ->
			assert $([1,2,3]).contains 3
		it "returns false if an item is not found", ->
			assert not $([1,2,3]).contains 4

	describe ".count()", ->
		it "returns the number of matching items, if given an item", ->
			assert.equal $([1,2,2,3,4,3]).count(3), 2
		it "returns the total count if no item is given", ->
			assert.equal $([1,2,2,3,4,3]).count(), 6

	describe ".select()", ->
		it "extracts values from properties of items in a set", ->
			assert.deepEqual $([ {id:1}, {id:2}, {id:3} ]).select('id'), [1,2,3]
		it "supports nested property names", ->
			assert.deepEqual $([
				{a:{b:2}},
				{a:{b:4}},
				{a:{b:6}}
			]).select("a.b"), [2,4,6]
		it "supports nesting into arrays", ->
			assert.deepEqual $([
				{a:[{b:3}]},
				{a:[{b:6}]},
				{a:[{b:9}]}
			]).select("a.0.b"), [3,6,9]

	describe ".zap()", ->
		it "assigns values to properties of items in a set", ->
			assert.deepEqual $([ {id:1}, {id:2}, {id:3} ]).zap('id', 13).select('id'), [13,13,13]
		it "supports using a function to compute the assigned values", ->
			assert.deepEqual $([ {id:1}, {id:2}, {id:3} ]).zap('id', -> @ * 2).select('id'), [2,4,6]
		it "supports nested property names", ->
			assert.deepEqual $([ {sub:{id:1}}, {sub:{id:2}}, {sub:{id:3}} ]).zap('sub.id', -> @*2).select('sub.id'), [2,4,6]

	describe ".take()", ->
		it "take0", -> assert.deepEqual $([1,2,3,4]).take(0), []
		it "take1", -> assert.deepEqual $([1,2,3,4]).take(1), [1]
		it "take2", -> assert.deepEqual $([1,2,3,4]).take(2), [1,2]
		it "take3", -> assert.deepEqual $([1,2,3,4]).take(3), [1,2,3]
		it "take4", -> assert.deepEqual $([1,2,3,4]).take(4), [1,2,3,4]
		it "take5", -> assert.deepEqual $([1,2,3,4]).take(5), [1,2,3,4]

	describe ".skip()", ->
		it "skip0", -> assert.deepEqual $([1,2,3,4]).skip(0), [1,2,3,4]
		it "skip1", -> assert.deepEqual $([1,2,3,4]).skip(1), [2,3,4]
		it "skip2", -> assert.deepEqual $([1,2,3,4]).skip(2), [3,4]
		it "skip3", -> assert.deepEqual $([1,2,3,4]).skip(3), [4]
		it "skip4", -> assert.deepEqual $([1,2,3,4]).skip(4), []
		it "skip5", -> assert.deepEqual $([1,2,3,4]).skip(5), []

	describe ".first()", ->
		a = $([1,2,3,4])
		it "returns a single element", -> assert.equal a.first(), 1
		it "acts like take", -> assert.deepEqual a.first(5), [1,2,3,4]
		it "acts like take", -> assert.deepEqual a.first(2), [1,2]
		it "acts like take", -> assert.deepEqual a.first(0), []

	describe ".last()", ->
		a = $([1,2,3,4])
		it "returns last element", -> assert.equal a.last(), 4
		it "returns multiple if asked", -> assert.deepEqual a.last(5), [1,2,3,4]
		it "returns multiple if asked", -> assert.deepEqual a.last(2), [3,4]
		it "returns multiple if asked", -> assert.deepEqual a.last(0), []

	describe ".slice()", ->
		a = $([1,2,3,4,5])
		it "slice1", -> assert.deepEqual $([1,2,3,4,5]).slice(0,5), [1,2,3,4,5]
		it "slice2", -> assert.deepEqual $([1,2,3,4,5]).slice(1,5), [2,3,4,5]
		it "slice3", -> assert.deepEqual $([1,2,3,4,5]).slice(2,5), [3,4,5]
		it "slice4", -> assert.deepEqual $([1,2,3,4,5]).slice(3,5), [4,5]
		it "slice5", -> assert.deepEqual $([1,2,3,4,5]).slice(4,5), [5]
		it "slice6", -> assert.deepEqual $([1,2,3,4,5]).slice(1,-2), [2,3]
		it "slice7", -> assert.deepEqual $([1,2,3,4,5]).slice(-1,-3), [5,4]
		it "slice8", -> assert.deepEqual $([1,2,3,4,5]).slice(-1,-4), [5,4,3]

	describe ".push()", ->
		it "appends to the set", ->
			assert.deepEqual $([1,2]).push(3), [1,2,3]
		it "overrides Array::push()", ->
			assert.notEqual Array::push, Bling::push
		it "returns the resulting set", ->
			assert $.is 'bling', $([1,2]).push(3)

	describe ".filter()", ->
		it "filters by a function", -> assert.deepEqual $([1,2,3,4,5]).filter((x) -> x % 2), [1,3,5]
		it "supports regular expressions", -> assert.deepEqual $(["foo","bar","baz"]).filter(/^ba/), ["bar","baz"]
		it "can chain DOM filters", -> assert.equal $("*").filter("td").filter(".d").length, 1
		it "filters might remove all nodes", -> assert.equal $("*").filter("td").filter(".none").length, 0
		it "filters DOM nodes by CSS selector", -> assert.deepEqual $("*").filter("td").length, 8

	describe ".matches()", ->
		describe "supports", ->
			it "CSS selectors", ->
				assert.deepEqual $("td").matches(".d"), [false,false,false,false,false,true,false,false]
			it "regular expressions", ->
				assert.deepEqual $(["one","two","three"]).matches(/o/), [true, true, false]

	describe ".weave()", ->
		it "interleaves items from two sets", ->
			assert.deepEqual($([1,1,1]).weave([2,2,2]), [2,1,2,1,2,1])
		it "supports blinged arguments", ->
			assert.deepEqual($([1,1,1]).weave($([2,2,2])), [2,1,2,1,2,1])

	describe ".querySelectorAll()", ->
		it "queries children for DOM nodes", ->
			assert.deepEqual($("tr").querySelectorAll("td.d")[0].className, "d")

	describe ".fold()", ->
		it "is like a partial reduce", ->
			assert.deepEqual $([1,1,1]).weave([2,2,2]).fold( (a,b) -> a+b ), [3,3,3]
		it "returns half the items", ->
			assert.deepEqual $([1,2,3,4,5,6]).fold( (a,b) -> a+b ).length, 3

	describe ".flatten()", ->
		it "combines subsets", ->
			assert.deepEqual $([[1,2],[3,4]]).flatten(), [1,2,3,4]
		it "allows duplicates (unlike union)", ->
			assert.deepEqual $([[1,2],[1,2]]).flatten(), [1,2,1,2]

	describe ".call()", ->
		it "calls every function in the set", ->
			assert.deepEqual $([((x) -> x*2), ((x) -> x*x)]).call(4), [8, 16]
		it "skips non-functions", ->
			assert.deepEqual $([((x) -> x*2), NaN, ((x) -> x*x)]).call(4), [8, 16]

	describe ".apply()", ->
		it "calls every function in the set, with a specific context", ->
			assert.deepEqual($([((x) -> @+x), ((x) -> @*x)]).apply(4,[2]), [6, 8])

	describe ".keysOf()", ->
		it "is like Object.keys", ->
			assert.deepEqual $.keysOf(a:1), ['a']
		it "returns a bling", ->
			assert $.is 'bling', $.keysOf(a:1)
		it "includes any enumerable property", ->
			a = a: 1
			$.defineProperty a, "b", get: -> 2
			assert.deepEqual $.keysOf(a), ["a", "b"]

	describe ".valuesOf()", ->
		it "returns a bling", ->
			assert $.is 'bling', $.valuesOf(a:1)
		it "returns the set of values", ->
			assert.deepEqual $.valuesOf(a:1), [1]
		it "includes any enumerable properties", ->
			a = a: 1
			$.defineProperty a, "b", get: -> 2
			assert.deepEqual $.valuesOf(a), [1, 2]

	describe "EventEmitter", ->
		it "works", ->
			a = $.EventEmitter a:1
			v = false
			a.on "event", -> v = true
			a.emit "event"
			assert v
		it "works on new blings automatically", ->
			b = $()
			v = false
			b.on "event", -> v = true
			b.emit "event"
			assert v
		it "provides (almost) the same API as node's EventEmitter", ->
			b = $()
			["addListener", "emit", "listeners", "on", "removeAllListeners", "removeListener", "setMaxListeners"].forEach (k) ->
				assert $.is 'function', b[k]
		it "can bless an object in-place", ->
			a = a:1
			b = $.EventEmitter(a)
			assert $.is 'function', a.emit
			assert $.is 'function', b.emit
		it "does not leak listeners", ->
			a = $.EventEmitter a:1
			a.on "smoke", -> "fire"
			a.on "smoke", -> "flee"
			assert.equal a.listeners("smoke").length, 2
			a.listeners("smoke").push("water")
			assert.equal a.listeners("smoke").length, 2
		describe "class extends support", ->
			class Foo extends $.EventEmitter
				constructor: ->
					super @
					@x = 1
				method: ->
			f = new Foo()
			it "gives new instances the EE interface", ->
				assert.equal $.type(f.on), "function"
			it "does not clobber instance methods", ->
				assert.equal $.type(f.method), "function"
			it "does not clobber instance properties", ->
				assert.equal $.type(f.x), "number"
			it "works", ->
				flag = false
				f.on 'event', -> flag = true
				f.emit 'event'
				assert.equal flag, true
			describe "inheritance chain", ->
				class A extends $.EventEmitter
					A: ->
				class B extends A
					B: ->
				class C extends B
					constructor: ->
						super(@)
				a = new A()
				b = new B()
				c = new C()
				it "goes through one level", ->
					assert.equal $.type(a.on), "function"
				it "goes through two levels", ->
					assert.equal $.type(b.on), "function"
				it "goes through three levels", ->
					assert.equal $.type(c.on), "function"


	describe ".date", ->
		it "adds the 'date' type", ->
			assert $.is 'date', new Date(0)
		describe 'converts', ->
			it "date to string", ->
				assert.equal ($.as "string", new Date 1,2,3,4,5,6), "1901-03-03 09:05:06"
			it "string to date", ->
				assert.equal ($.as "date", "1901-03-03 09:05:06").toString(), new Date(1,2,3,4,5,6).toString()
			it "date to number", ->
				assert.equal ($.as "number", new Date 1,2,3,4,5,6), -2172149694
			it "number to date", ->
				assert.equal ($.as "date", -2172149694).toString(), (new Date 1,2,3,4,5,6).toString()
		describe ".stamp()", ->
			describe "converts date objects to numbers (with units)", ->
				it "ms", -> assert $.date.stamp(new Date(1000000), "ms") is 1000000
				it "seconds", -> assert $.date.stamp(new Date(1000000), "s") is 1000
		describe ".unstamp()", ->
			it "converts a number to a real date", ->
				assert $.is 'date', $.date.unstamp 0
			it "is the reverse of stamp", ->
				d1 = new Date(1000000)
				d2 = $.date.unstamp $.date.stamp d1
				assert d1.toString() is d2.toString()
			it "supports chaining as .unstamp()", ->
				assert $.is 'date', $([1000000]).unstamp().first()
		describe ".convert()", ->
			assert $.date.convert(1000000, "ms", "s") is 1000
		describe ".midnight()", ->
			it "returns a stamp", ->
				assert $.is 'number', $.date.midnight new Date 0
			it "shifts a date to midnight of that day", ->
				assert.notEqual -1, $.date.unstamp($.date.midnight new Date 1000000000).toUTCString().indexOf("00:00:00 GMT")
			it "supports chaining", ->
				assert.equal $($.date.range 1000, 1000000, 3)
					.midnight()
					.dateFormat("HHMMSS")
					.ints().sum(), 0
		describe ".format()", ->
			d1 = new Date(1000000000)
			describe "supports fields", ->
				it "yyyy", -> assert.equal $.date.format(d1, "yyyy"), "1970"
				it "mm", -> assert.equal $.date.format(d1, "mm"), "01"
				it "dd", -> assert.equal $.date.format(d1, "dd"), "12"
				it "HH", -> assert.equal $.date.format(d1, "HH"), "13"
				it "MM", -> assert.equal $.date.format(d1, "MM"), "46"
				it "SS", -> assert.equal $.date.format(d1, "SS"), "40"
			it "supports spacing and punctuation", ->
				assert.equal $.date.format(d1, "yyyy-mm-dd HH:MM:SS"), "1970-01-12 13:46:40"
			it "supports chaining as .dateFormat()", ->
				assert.equal $($.date.range 1000, 1000000, 3)
					.dateFormat("dd")
					.ints().sum(), 35
		describe ".parse()", ->
			it "supports the same formats as .format()", ->
				assert $.date.parse("1970-01-12 13:46:40", "yyyy-mm-dd HH:MM:SS", "ms") is 1000000000
			it "supports chaining as .dateParse()", ->
				assert $(["1970-01-12 13:46:40"]).dateParse("yyyy-mm-dd HH:MM:SS", "ms").first() is 1000000000
		describe ".range()", ->
			it "generates a range of date stamps", ->
				assert.equal $($.date.range(1000, 1000000, 3))
					.unstamp()
					.select("getUTCDate").call()

	describe ".TNET", ->
		describe ".parse()", ->
			it "parses TNET format strings into objects", ->
		describe ".stringify()", ->
			it "creates TNET strings from objects", ->

	describe ".StateMachine", ->
		it "allows subclassing to define machines", ->
			class T extends $.StateMachine
			t = new T
			assert $.is 'function', t.run
		describe ".run()", ->
			it "reads input and rules from @STATE_TABLE", ->
				class Capper extends $.StateMachine
					@STATE_TABLE = [
						{
							enter: ->
								@output = "<<"
								@GO 1
						}
						{
							def: (c) -> @output += c.toUpperCase()
							eof: @GO 2
						}
						{
							enter: -> @output += ">>"
						}
					]
					constructor: ->
						super(Capper.STATE_TABLE)

				assert.equal new Capper().run("hello").output, "<<HELLO>>"

	describe ".synth()", ->
		it "creates DOM nodes", ->
			assert $.is 'node', $.synth('div').first()
		it "uses CSS-like selectors", ->
		describe "supports CSS selectors:", ->
			it "class", -> assert.equal $.synth('div.cls').first().className, "cls"
			it "attributes", -> assert.equal $.synth('div[foo=bar]').first().attributes.foo, "bar"
			it "attributes (multiple)", -> assert.deepEqual $.synth('div[a=b][c=d]').first().attributes, {a:'b',c:'d'}
			it "text (single quotes)", -> assert.equal $.synth("div 'text'").first().toString(), "<div>text</div>"
			it "text (double quotes)", -> assert.equal $.synth('div "text"').first().toString(), "<div>text</div>"
			it "entity escaped", -> assert.equal $.synth('div "text&amp;stuff"').first().toString(), "<div>text&amp;stuff</div>"
			it "entity un-escaped", -> assert.equal $.synth('div "text&stuff"').first().toString(), "<div>text&stuff</div>"

	describe ".delay(ms, f)", ->
		it "runs f after a delay of ms", (done) ->
			t = $.now
			$.delay 100, ->
				delta = Math.abs(($.now - t) - 100)
				assert delta < 25
				done()

	describe ".config(name, def)", ->
		it "gets config from the environment", ->
			try
				process.env.UNIT_TEST_MAGIC = "magic"
				assert.equal $.config.get("UNIT_TEST_MAGIC"), "magic"
			finally
				delete process.env.UNIT_TEST_MAGIC
		it "supports a default value", ->
			assert.equal $.config.get("NOT_FOUND", "default"), "default"
		it "can be called directly", ->
			assert.equal $.config("NOT_FOUND", "default"), "default"

	describe ".index(keyMaker)", ->
		keyMaker = (obj) -> obj.a
		it "creates a private index", ->
			$([{a:1,b:2}, {a:2,b:3}]).index keyMaker
		it "cannot query until index has been built", ->
			assert.equal $([1,2,3]).query(a:1), null
		it "can .query() after indexing", ->
			a = $([{a:1,b:'b'},{a:2},{a:3}]).index keyMaker
			assert.equal a.query(a:1).b, 'b'
		it "can use compound keys", ->
			compoundKeyMaker = (obj) -> obj.a + "-" + obj.b
			a = $([{a:1,b:'b'},{a:2,b:1},{a:3,b:2,c:'c'}]).index compoundKeyMaker
			assert.equal a.query(a:3,b:2).c, 'c'
		describe "using more than one key maker", ->
			keyMakerOne = (obj) -> obj.a
			keyMakerTwo = (obj) -> obj.b
			keyMakerThree = (obj) -> obj.a + '-' + obj.b
			a = $([{a:1,b:'b'},{a:2,b:1},{a:3,b:2,c:'c'}])
			it "wont hurt if you re-index by the same keyMaker", ->
				a.index keyMakerOne
				a.index keyMakerOne
				assert.equal a.query(a:3).b, 2
			it "will allow querying against a second keyMaker", ->
				a.index keyMakerTwo
				assert.equal a.query(a:3).b, 2
				assert.equal a.query(b:2).a, 3
			it "will allow querying against N keyMakers", ->
				a.index keyMakerOne
				a.index keyMakerTwo
				a.index keyMakerThree
				assert.equal a.query(a:3).b, 2
				assert.equal a.query(b:'b').a, 1
				assert.equal a.query({a:3,b:2}).c, 'c'
	
	describe ".groupBy(key)", ->
		objs = $([
			{name: "a", k: 1, val: 1},
			{name: "a", k: 1, val: 2},
			{name: "a", k: 2, val: 3},
			{name: "b", k: 1, val: 4},
			{name: "c", k: 1, val: 5},
			{ val: 6 }

		])
		it "groups objects by the key", ->
			assert.deepEqual objs.groupBy('name'), [
				[ {name: "a", k:1, val: 1},
					{name: "a", k:1, val: 2},
					{name: "a", k:2, val: 3} ],
				[ {name: "b", k:1, val: 4} ],
				[ {name: "c", k:1, val: 5} ],
				[ { val: 6 } ]
			]
		it "can group by multiple keys", ->
			assert.deepEqual objs.groupBy(['name','k']), [
				[ {name: "a", k:1, val: 1},
					{name: "a", k:1, val: 2}
				],
				[ {name: "b", k:1, val: 4} ],
				[ {name: "c", k:1, val: 5} ],
				[ { val: 6 } ]
			]

		it "is mappable", ->
			assert.deepEqual objs.groupBy('name').map(-> @select('val').sum()),
				[ 6, 4, 5, 6 ]

		it "is mappable to a new object", ->
			assert.deepEqual objs.groupBy(['name','k']).map(->
				name: @select('name').first()
				sum: @select('val').sum()
				k: @select('k').first()
			),
				[ { name: "a", sum: 3, k:1 },
					{ name: "a", sum: 3, k:2 },
				  { name: "b", sum: 4, k:1 },
					{ name: "c", sum: 5, k:1 }
					{ name: undefined, sum: 6, k:undefined }
				]
	
	describe "$.sortedIndex()", ->
		it "returns the index to insert at", ->
			assert.equal $.sortedIndex([1,2,4], 3), 2
		it "will insert at end", ->
			assert.equal $.sortedIndex([1,2,3], 4), 3
		it "will insert at beginning", ->
			assert.equal $.sortedIndex([2,3,4], 1), 0
		it "can use a field for comparison", ->
			assert.equal $.sortedIndex([{a:1},{a:2},{a:4}], {a:3}, 'a'), 2
		it "can use a comparison function", ->
			assert.equal $.sortedIndex([1,2,4], 3, null, (x)->Math.pow(x,2)), 2

	describe ".sortBy(field,cmp)", ->
		it "can sort", ->
			assert.deepEqual $(3,1,2).sortBy(), [1,2,3]
		it "can sort by a field", ->
			assert.deepEqual $( {a:2}, {a:1}, {a:3} ).sortBy('a').select('a'), [1,2,3]
		it "does NOT sort in-place", ->
			a = $(2,3,1)
			b = a.sortBy()
			assert.deepEqual b, [1,2,3]
			assert a isnt b


describe "DOM", ->
	it "parse", ->
		d = $.HTML.parse "<div><a></a><b></b><c></c></div>"
		assert.equal $.type(d), "node"
		assert.equal d.nodeName, "DIV"
	it "stringify", -> assert.equal $.HTML.stringify($.HTML.parse(h = "<div><a/><b/><c/></div>")), h
	it "select_childNodes", -> assert.equal( $("<div><a></a><b></b><c></c></div>").select("childNodes").flatten().map($.type).toRepr(), "$(['node', 'node', 'node'])" )
	it "child", -> i = 0; d = $("<div><a></a><b></b><c></c></div>"); assert.equal( d.select('childNodes').flatten().map( () -> d.child(i++) ).toRepr(), "$([$([<a/>]), $([<b/>]), $([<c/>])])")
	it "child2", -> assert.equal($("tr").child(0).select('nodeName').toRepr(), "$(['TD', 'TD', 'TD', 'TD'])")
	it "textData", ->
		d = $("<div>&nbsp;</div>")
		assert.equal d.toRepr(), "$([<div>&nbsp;</div>])"
		t = d.child 0
		assert.equal t.toRepr(), "$([&nbsp;])"
		t.zap 'data', '<p>'
		assert.equal d.select('innerHTML').first(), '&lt;p&gt;'
	it "escape", -> assert.equal $.HTML.escape("<p>"), "&lt;p&gt;"
	it "dashName1", -> assert.equal $.dashize("fooBar"), "foo-bar"
	it "dashName2", -> assert.equal $.dashize("FooBar"), "-foo-bar"
	it "html1", -> assert.equal $("tr").html().first(), "<td>1,1</td><td>1,2</td>"
	it "html2", -> assert.equal $("div").html("<span>C</span>").html().first(), "<span>C</span>"
	it "append", ->
		try
			assert.equal($("tr td.d").append("<span>Hi</span>").html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	it "appendTo1", -> assert.equal($("<span>Hi</span>").toRepr(), "$([<span>Hi</span>])")
	it "appendTo2", ->
		try
			assert.equal($("<span>Hi</span>").appendTo("tr td.d").toRepr(), "$([<span>Hi</span>])")
		finally
			$("tr td.d span").remove()
	it "appendTo3", ->
		try
			assert.equal($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').toRepr(), '$([<td class="d">3,2<span>Hi</span></td>])')
		finally
			$("tr td.d span").remove()
	it "appendTo4", ->
		try
			assert.equal($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	it "prepend", ->
		try
			assert.equal($("tr td.d").prepend("<span>Hi</span>").html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	it "prependTo", ->
		try
			assert.equal($("<span>Hi</span>").prependTo("tr td.d").select('parentNode').html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	it "before", -> assert.equal($("<a><b></b></a>").find("b").before("<c></c>").select('parentNode').toRepr(), "$([<a><c/><b/></a>])")
	it "after1", -> assert.equal($("<a><b></b></a>").find("b").after("<c></c>").select('parentNode').toRepr(), "$([<a><b/><c/></a>])")
	it "after2", -> assert.equal($("<b></b>").after("<c></c>").select('parentNode').toRepr(), "$([<b/><c/>])")
	it "wrap", -> assert.equal($("<b></b>").wrap("<a></a>").select('parentNode').toRepr(), "$([<a><b/></a>])")
	it "unwrap", -> assert.equal($("<a><b/></a>").find("b").unwrap().first().parentNode, null)
	it "replace", -> assert.equal($("<a><b/><c/><b/></a>").find("b").replace("<p/>").eq(0).select('parentNode').toRepr(), "$([<a><p/><c/><p/></a>])")
	it "removeClass", -> assert.equal($("<a class='test'></a>").removeClass('test').toRepr(), "$([<a/>])")
	it "removeClass2", -> assert.equal($("<a></a>").removeClass('test').toRepr(), "$([<a/>])")
	it "addClass", -> assert.equal($("<a></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	it "addClass2", -> assert.equal($("<a class='test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	it "addClass3", -> assert.equal($("<a class='test test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	it "toggleClass", -> assert.equal($("<a class='on'></a>").toggleClass("on").toRepr(), "$([<a/>])")
	it "toggleClass2", -> assert.equal($("<a class='off'></a>").toggleClass("on").toRepr(), '$([<a class="off on"/>])')
	it "toggleClass3", -> assert.equal($("<a class=''></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	it "toggleClass4", -> assert.equal($("<a></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	it "hasClass", -> assert.equal($("<a class='foo'></a>").hasClass("foo").first(), true)
	it "hasClass2", -> assert.equal($("<a class='bar'></a>").hasClass("foo").first(), false)
	it "text1", -> assert.equal($("<a>Hello<b>World</b></a>").select('innerText').toRepr(), "$(['HelloWorld'])")
	it "text3", -> assert.equal($("<a>Hello<b>World</b></a>").text().toRepr(), "$(['HelloWorld'])")
	it "text2", -> assert.equal($("<a>Hello<b>World</b></a>").text("Goodbye").toRepr(), "$([<a>Goodbye</a>])")
	it "value1", -> assert.equal($("<input type='text' value='foo'/>").val().toRepr(), "$(['foo'])")
	it "value2", -> assert.equal($("<input />").val().toRepr(), "$([''])")
	it "value3", -> assert.equal($("<input type='checkbox' checked />").val().toRepr(), "$(['on'])")
	it "parents", -> assert.equal($("td.d").parents().first().select('nodeName').toRepr(), "$(['TR', 'TABLE', 'BODY', 'HTML'])")
	it "remove", ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
		b = a.find(".x")
			.assert.equal(2, -> @length)
			.assert.equal("$(['B', 'C'])", -> @select('nodeName').toRepr())
			.remove()
			.assert.equal("$([null, null])", -> @select('parentNode').toRepr() )
		assert.equal a.toRepr(), '$([<a><d/></a>])'
	it "find", ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
			.find(".x")
			.assert.equal(2, -> @length)
			.assert.equal("$(['B', 'C'])", -> @select('nodeName').toRepr())
	it "clone", ->
		c = $("div.c").clone()[0]
		d = $("div.c")[0]
		c.a = "magic"
		assert.equal( typeof d.a, "undefined")
		assert.equal( typeof c.a, "string")
	it "toFragment", ->
		assert.equal($("td").clone().toFragment().childNodes.length, 8)

require 'bling'
Readline = require 'readline'
Cs = require 'coffee-script'

usage = ->
	process.exit 1

exports.run = run = (input, output) ->
	urlString = null
	for arg in process.argv
		url = require('url').parse arg
		if "mongo:" is url?.protocol
			urlString = url.href
			break
	if not urlString?
		usage()
	console.log "Connecting to " + urlString

	Cs.eval """
	db = do ->
		db.collections (err, collections) -> collections.forEach (coll) -> db.bind coll.collectionName
		db
	callback = cb = (err, data) ->
		(console.error err) if err
		(console.log data) if data
	"""



	io = Readline.createInterface
		input: input
		output: output

	io.on 'line', (cmd) ->
		try
			if cmd?.length < 1 then return
			ret = Cs.eval("it = " + cmd)
			if ret?
				console.log switch true
					when "_dbconn" of ret then describeDb(ret._dbconn)
					when "cursor" of ret
						ret.limit(20).toArray (err, data) ->
							(console.log err) if err
							(console.log item) for item in data when data
						if ret.count() > 20
							console.log "...More..."
						""
					else ret
		catch err
			console.log err
		finally
			io.prompt()

	io.on 'SIGINT', ->
		process.exit(1)

	io.setPrompt "mongo> "
	io.prompt()

if require.main is module
	run process.stdin, process.stdout

abort = ->

mixin = (fields) ->
	(args...) ->
		obj = args.pop()
		fields.init?.apply obj, args
		for f,v of fields
				if $.is 'function', v
					p = obj[f] ? ->
					obj[f] = (b...) ->
						if (i = v.apply @, b) isnt abort
							j = p?.apply @, b
						return i ? j
		obj

position = mixin
	init: (x=0,y=0) ->
		@x ?= x
		@y ?= y

area = mixin
	init: (w=30,h=30) ->
		@w ?= w
		@h ?= h

bounded = mixin
	init: (@boundx=320,@boundy=240,@bounce=1) ->
		if @constructor.name is "Array"
			for i in [0...@length]
				@[i] = bounded @boundx,@boundy,@[i]
	tick: (dt) ->
		if @boundy < @y or @y < 0 then @vy *= -@bounce
		if @boundx < @x or @x < 0 then @vx *= -@bounce

velocity = mixin
	init: (@vx=0,@vy=0)->
	tick: (dt) ->
		@x += (@vx * dt)
		@y += (@vy * dt)
	draw: (ctx) ->
		return
		ctx.zap('strokeStyle', 'rgba(0,0,255,0.5)')
		ctx.select('drawLine').call @x,@y,@x+@vx,@y+@vy

drag = mixin
	init: (@dragx=0.0,@dragy=0.0) ->
	tick: (dt) ->
		@vx *= (1.0 - @dragx * dt)
		@vy *= (1.0 - @dragy * dt)

circle = mixin
	init: (@r=30) ->
	draw: (ctx) -> ctx.select('drawCircle').call(@x,@y,@r)
	clipPoint: (p) ->	$([p[0]-@x,p[1]-@y]).normalize().scale(@r).weave([@x,@y]).fold((a,b)->a+b)
	doesClip: (p) -> $([p[0]-@x,p[1]-@y]).magnitude() < @r

fill = mixin
	draw: (ctx) -> ctx.zap('fillStyle',@fillStyle)

group = mixin
	draw: (ctx) -> x.draw?(ctx) for x in @
	tick: (dt) -> x.tick?(dt) for x in @
	clip: (x,y) -> (x.clip?(dt) for x in @).reduce (a,x) -> a or x

box_clipPoint = (p,tx,ty,tw,th) ->
	minda = 9999
	min = null
	for a in [ [tx,ty-th/2], [tx+tw/2,ty-th], [tx+tw,ty-th/2], [tx+tw/2,ty] ]
		da = $(p).weave(a).fold((i,j)->i-j).magnitude()
		if da < minda
			min = a
			minda = da
	return min

box_doesClip = (p,tx,ty,tw,th) -> return (tx <= p[0] <= tx+tw) and (ty <= p[1] <= ty+th)

text = mixin
	init: (@text="Hello") ->
		@w = 0
		@h = 16
	draw: (ctx) ->
		ctx.select('fillText').call(@text, @x, @y)
		@w = ctx.select('measureText').call(@text).select('width').first()
		
labels = {
	"hello": "Hello World"
	"fps": "FPS: 0"
}
label = mixin
	init: (@label="hello") ->
	draw: (ctx) ->
		ctx.select('fillText').call(labels[@label], @x, @y)

font = mixin
	init: (@font="1em sans normal") ->
	draw: (ctx) -> ctx.zap('font', @font)

border = mixin
	draw: (ctx) ->
		ctx.select('beginPath').call()
		ctx.select('rect').call(@x,@y,@w,@h)
		ctx.select('stroke').call()
		ctx.select('closePath').call()

mass = mixin
	init: (@mass=0) ->

accel = mixin
	init: (ax=0,ay=0) ->
		@acc or= []
		@acc.push [ax,ay]
	tick: (dt) ->
		for v in @acc
			@vx += v[0] * dt
			@vy += v[1] * dt

force = mixin
	init: (dx=0,dy=0) ->
		@vx += dx
		@vy += dy

bodies = []
collide = mixin
	init: ->
		bodies.push @
		@showCollideNotice = 0
	tick: (dt) ->
		if @showCollideNotice > 0
			@showCollideNotice -= dt
		dvx = dvy = 0
		for body in bodies
			if body is this then continue
			cpa = @clipPoint? [body.x, body.y]
			cpb = body.clipPoint? [@x,@y]
			if body.doesClip?(cpa) or @doesClip?(cpb)
				@showCollideNotice = .100
				@vx += dvx
				@vy += dvx
	clipPoint: (p) -> [0,0]
	doesClip: (p) -> false
	draw: (ctx) ->
		for body in bodies
			if body is this then continue
			b = [body.x,body.y]
			cpa = @clipPoint?(b)
			if cpa?
				ctx.zap('fillStyle', 'yellow').select('drawCircle').call(cpa[0],cpa[1],2)
			else
				ctx.zap('fillStyle', 'purple').select('drawCircle').call(@x+5,@y+5,5)
		if @showCollideNotice > 0
			ctx.zap('fillStyle', 'pink').select('drawCircle').call(@x+5,@y-5,5)

gravity = (o) -> accel 0,9, o
physical = (o) -> collide gravity velocity 0,0, drag 0.1,0.1, o

class Scene
	constructor: (selector, items, @fps=60) ->
		@scene = items
		@ctx = $(selector).bind("mousemove", (evt) ->
			rect = $(this).rect().first()
			x = evt.pageX - rect.left
			y = evt.pageY - rect.top
		).select("getContext").call("2d").map -> $.extend @,
			drawCircle: (x,y,r) ->
				@beginPath()
				@arc(x,y,r,0,2*Math.PI)
				@fill()
				@stroke()
				@closePath()
			drawLine: (x1,y1,x2,y2) ->
				@beginPath()
				@moveTo x1,y1
				@lineTo x2,y2
				@stroke()
				@closePath()
		@last = +new Date
	tick: (dt) ->
		@ctx.select('clearRect').call 0,0, @scene.boundx ? 320, @scene.boundy ? 240
		@scene.tick(dt)
		@scene.draw(@ctx)
	resume: ->
		@last = +new Date / 1000
		@intervalId = setInterval (=>
			now = +new Date / 1000
			@last += (dt = now - @last)
			@tick(dt)
		), Math.floor(1000/@fps)
	pause: ->
		clearInterval @intervalId


$(document).ready ->
	window.scene = new Scene "canvas", bounded 320,240, area 320,240, position 0,0, border group [
	]
	scene.resume()
	$("canvas").click -> scene.scene.forEach (x) -> force( $.random.integer(-10,10), -30, x )

	setTimeout (-> scene.pause()), 5000
	$("button.start").click -> scene.resume()
	$("button.stop").click -> scene.pause()
class StringScanner

	constructor: (@str = '') ->
		@str = '' + @str
		@pos = 0
		@lastMatch = {
			reset: ->
				@str = null
				@captures = []
				this
		}.reset()
		this

	bol: -> @pos<=0 || (this.str[this.pos-1] is "\n")

	captures: -> @lastMatch.captures

	check: (pattern) ->
		if @str.substr(@pos).search(pattern) isnt 0
			@lastMatch.reset()
			return null
		matches = @str.substr(@pos).match pattern
		@lastMatch.str = matches[0]
		@lastMatch.captures = matches.slice 1
		this.lastMatch.str

	checkUntil: (pattern) ->
		patternPos = @str.substr(@pos).search pattern
		if patternPos < 0
			@lastMatch.reset()
			return null
		matches = @str.substr(@pos+patternPos).match pattern
		@lastMatch.captures = matches.slice 1
		@lastMatch.str = @str.substr(@pos,patternPos) + matches[0]

	clone: ->
		clone = new @constructor(@str)
		clone.pos = @pos
		clone.lastMatch = {}
		clone.lastMatch[prop] = value for prop, value of @lastMatch
		clone

	concat: (str) ->
		@str += str
		this

	eos: -> @pos is @str.length

	exists: (pattern) ->
		patternPos = @str.substr(@pos).search pattern
		if patternPos < 0
			@lastMatch.reset()
			return null
		matches = @str.substr(@pos+patternPos).match pattern
		@lastMatch.str = matches[0]
		@lastMatch.captures = matches.slice 1
		patternPos

	getch: -> @scan /./

	match: -> @lastMatch.str

	matches: (pattern) ->
		@check pattern
		@matchSize()

	matched: -> @lastMatch.str?

	matchSize: -> if @matched() then this.match().length else null

	peek: (len) -> @str.substr @pos, len

	pointer: -> @pos

	setPointer: (pos) ->
		pos = +pos
		pos = 0 if pos < 0
		pos = @str.length if pos > @str.length
		@pos = pos

	reset: ->
		@lastMatch.reset()
		@pos = 0
		this

	rest: -> @str.substr @pos

	scan: (pattern) ->
		chk = @check pattern
		this.pos += chk.length if chk?
		chk

	scanUntil: (pattern) ->
		chk = @checkUntil pattern
		this.pos += chk.length if chk?
		chk

	skip: (pattern) ->
		@scan pattern
		@matchSize()

	skipUntil: (pattern) ->
		@scanUntil pattern
		@matchSize()

	string: -> @str

	terminate: ->
		@pos = @str.length
		@lastMatch.reset()
		this

	toString: ->


StringScanner::beginningOfLine = StringScanner::bol
StringScanner::clear           = StringScanner::terminate
StringScanner::dup             = StringScanner::clone
StringScanner::endOfString     = StringScanner::eos
StringScanner::exist           = StringScanner::exists
StringScanner::getChar         = StringScanner::getch
StringScanner::position        = StringScanner::pointer


StringScanner.StringScanner = StringScanner
module.exports = StringScanner
StringScanner = require '../lib/StringScanner'
assert = require 'assert'
[eq, ok] = [assert.strictEqual, assert.ok]

arrayEqual = (a, b) ->
  if a is b
    a isnt 0 or 1/a is 1/b
  else if a instanceof Array and b instanceof Array
    return no unless a.length is b.length
    return no for el, idx in a when not arrayEqual el, b[idx]
    yes
  else
    a isnt a and b isnt b

arrayEq = (a, b, msg) -> ok arrayEqual(a, b), msg

test = (feature, fn) -> fn new StringScanner 'abc123 def456'

console.log '\033[0m(' + new Date().toLocaleTimeString() + ') Running tests...\033[0;31m'


test 'StringScanner::bol and StringScanner::beginningOfLine', (ss) ->
	eq true , ss.bol()
	eq true , ss.beginningOfLine()
	ss.getch()
	eq false, ss.bol()
	eq false, ss.beginningOfLine()
	ss.reset()
	eq true , ss.bol()
	eq true , ss.beginningOfLine()
	ss = new StringScanner 'abc\ndef'
	ss.scan /\w{3}\n/
	eq true , ss.bol()
	eq true , ss.beginningOfLine()

test 'StringScanner::captures', (ss) ->
	ss.scan /([a-z]+)\d+(\s*)/
	arrayEq ['abc', ' '], ss.captures()
	ss.scan /[a-z]+\d+/
	arrayEq [], ss.captures()
	eq null, ss.check /(\s+)/
	arrayEq [], ss.captures()
	ss.reset()
	ss.check /.*(..) (..)/
	arrayEq ['23', 'de'], ss.captures()

test 'StringScanner::check', (ss) ->
	eq 'abc' , ss.check /[a-z]+/i
	eq 'abc' , ss.check /[a-z]+/i
	eq 'abc' , ss.scan /[a-z]+/i
	eq null  , ss.check /[a-z]+/i
	eq '123 ', ss.check /[\d\s]+/

test 'StringScanner::checkUntil', (ss) ->
	eq 'abc123 ', ss.checkUntil /\s/
	eq 'abc123 ', ss.checkUntil /\s/
	eq null     , ss.checkUntil /r/
	ss.scanUntil /e/
	eq null     , ss.checkUntil /\s/

test 'StringScanner::clone', (ss) ->
	ss.scan /([a-z])[a-z]+/
	eq 'abc', ss.match()
	arrayEq ['a'], ss.captures()
	clone0 = ss.clone()
	eq 'abc', clone0.match()
	arrayEq ['a'], clone0.captures()
	ss.scan /\d+(\d)/
	eq '123', ss.match()
	arrayEq ['3'], ss.captures()
	eq 'abc', clone0.match()
	arrayEq ['a'], clone0.captures()
	clone1 = ss.clone()
	clone1.scan /\s+/
	eq '123', ss.match()
	arrayEq ['3'], ss.captures()
	eq 'abc', clone0.match()
	arrayEq ['a'], clone0.captures()
	eq ' ', clone1.match()
	arrayEq [], clone1.captures()

test 'StringScanner::concat', (ss) ->
	eq null, ss.checkUntil /h/
	ss.concat ' ghi789'
	eq 'abc123 def456 ghi789', ss.string()

test 'StringScanner::eos and StringScanner::endOfString', (ss) ->
	eq ss.eos, ss.endOfString
	eq false, ss.eos()
	ss.scan /.*/
	eq true , ss.eos()
	ss.reset()
	eq false, ss.eos()

test 'StringScanner::exists and StringScanner::exist', (ss) ->
	eq ss.exists, ss.exist
	eq 2    , ss.exists /c/
	eq 'c'  , ss.match()
	eq true , ss.matched()
	eq 0    , ss.exists /a/
	eq 'a'  , ss.match()
	eq true , ss.matched()
	eq 0    , ss.exists /b*/
	eq ''   , ss.match()
	eq true , ss.matched()
	eq null , ss.exists /m/
	eq null , ss.match()
	eq false, ss.matched()

test 'StringScanner::getch and StringScanner::getChar', (ss) ->
	eq ss.getch, ss.getChar
	eq 'a' , ss.getch()
	eq 'b' , ss.getch()
	ss.scan /.*/
	eq null, ss.getch()
	ss.reset()
	eq 'a' , ss.getch()

test 'StringScanner::match', (ss) ->
	eq null , ss.match()
	ss.scan /[a-z]+/i
	eq 'abc', ss.match()
	ss.scan /[a-z]+/i
	eq null , ss.match()

test 'StringScanner::matches', (ss) ->
	eq 3   , ss.matches /[a-z]+/i
	eq 3   , ss.matches /[a-z]+/i
	ss.scan /[a-z]+/i
	eq null, ss.matches /[a-z]+/i
	eq 4   , ss.matches /\d+\s*/i

test 'StringScanner::matched', (ss) ->
	eq false, ss.matched()
	ss.scan /\w+/
	eq true , ss.matched()
	ss.scan /\w+/
	eq false, ss.matched()

test 'StringScanner::matchSize', (ss) ->
	eq null, ss.matchSize()
	ss.scan /\w+/
	eq 6, ss.matchSize()
	ss.check /\w*/
	eq 0, ss.matchSize()
	ss.check /\w+/
	eq null, ss.matchSize()

test 'StringScanner::peek', (ss) ->
	eq 'ab', ss.peek 2
	eq '', ss.peek 0
	eq '', ss.peek -3
	eq ss.string(), ss.peek()
	ss.scan /.*d/
	eq 'ef4', ss.peek 3
	eq 'ef456', ss.peek()
	eq 'ef456', ss.peek 9001
	eq '', ss.peek 0
	eq '', ss.peek -1

test 'StringScanner::pointer and StringScanner::position', (ss) ->
	eq ss.pointer, ss.position
	eq 0, ss.pointer()
	ss.scan /\w+\d+\s+/i
	eq 7, ss.pointer()
	ss.scan /[a-z]+/i
	eq 10, ss.pointer()
	ss.reset()
	eq 0, ss.pointer()

test 'StringScanner::setPointer', (ss) ->
	eq 0 , ss.pointer()
	eq 4 , ss.setPointer 4
	eq 4 , ss.pointer()
	ss.getch()
	eq 5 , ss.pointer()
	eq 0 , ss.setPointer -3
	eq 0 , ss.pointer()
	eq 13, ss.setPointer 9001
	eq 13, ss.pointer()

test 'StringScanner::reset', (ss) ->
	ss.scan /\w+/
	eq 'abc123', ss.match()
	eq true    , ss.matched()
	eq 6       , ss.matchSize()
	eq 6       , ss.pointer()
	ss.reset()
	eq null    , ss.match()
	eq false   , ss.matched()
	eq null    , ss.matchSize()
	eq 0       , ss.pointer()
	ok ss.check /\w+/

test 'StringScanner::rest', (ss) ->
	eq ss.string(), ss.rest()
	ss.scanUntil /\s/
	eq 'def456'   , ss.rest()
	ss.reset()
	eq ss.string(), ss.rest()
	ss.setPointer 12
	eq '6'        , ss.rest()

test 'StringScanner::scan', (ss) ->
	eq 'abc'   , ss.scan /[a-z]+/
	eq null    , ss.scan /[a-z]+/
	eq ''      , ss.scan /[a-z]*/
	eq '123'   , ss.scan /[0-9]+/
	ss.check /\s+/
	eq ' '     , ss.scan /\s+/
	eq 'def456', ss.scan /.*/
	eq ''      , ss.scan /.*/
	eq null    , ss.scan /./

test 'StringScanner::scanUntil', (ss) ->
	eq 'abc1'  , ss.scanUntil /\d/
	eq 4       , ss.position()
	eq '23 '   , ss.scanUntil /\s/
	eq 7       , ss.position()
	eq null    , ss.scanUntil /z/
	eq ''      , ss.scanUntil /(?:)/
	eq ''      , ss.scanUntil()
	eq 7       , ss.position()
	eq 'def456', ss.scanUntil /$/
	ok ss.eos()

test 'StringScanner::skip', (ss) ->
	eq 3   , ss.skip /[a-z]+/
	eq 0   , ss.skip /[a-z]*/
	eq null, ss.skip /[a-z]+/
	eq 3   , ss.position()
	eq 4   , ss.skip /(\d|\s)+/
	eq 7   , ss.position()
	eq 6   , ss.skip /.*/
	ok ss.eos()

test 'StringScanner::skipUntil', (ss) ->
	eq 0   , ss.position()
	eq 7   , ss.skipUntil /\s/
	eq 7   , ss.position()
	eq 3   , ss.skipUntil /f/
	eq null, ss.skipUntil /f/
	eq 3   , ss.skipUntil /$/
	ok ss.eos()

test 'StringScanner::string', (ss) ->
	eq 'abc123 def456', ss.string()
	eq '', (new StringScanner '').string()
	eq 'abc', (new StringScanner 'abc').string()
	eq '', (new StringScanner null).string()
	eq '', (new StringScanner undefined).string()
	eq '0', (new StringScanner 0).string()

test 'StringScanner::terminate and StringScanner::clear', (ss) ->
	eq ss.terminate, ss.clear
	eq 0, ss.pointer()
	ss.terminate()
	ok ss.eos()
	ss.reset()
	eq 0, ss.pointer()
	ss.terminate()
	ok ss.eos()


console.log '\033[0;32mall tests passed\033[0m'
launch() if ignition is on

volume = 10 if band isnt SpinalTap

letTheWildRumpusBegin() unless answer is no

if car.speed < limit then accelerate()

winner = yes if pick in [47, 92, 13]

eat food for food in ['toast', 'cheese', 'wine']

courses = ['greens', 'caviar', 'truffles', 'roast', 'cake']
menu i + 1, dish for dish, i in courses

foods = ['broccoli', 'spinach', 'chocolate']
eat food for food in foods when food isnt 'chocolate'
CoffeeScript Compiler v1.3.3
Released under the MIT License


fs = require 'fs'

option '-o', '--output [DIR]', 'directory for compiled code'

task 'build:parser', 'rebuild the Jison parser', (options) ->
  require 'jison'
  code = require('./lib/grammar').parser.generate()
  dir  = options.output or 'lib'
  constructor: (@name) ->

  move: (meters) ->

class Snake extends Animal
  move: ->
    alert "Slithering..."
    super 5

class Horse extends Animal
  move: ->
    alert "Galloping..."
    super 45

sam = new Snake "Sammy the Python"
tom = new Horse "Tommy the Palomino"

sam.move()
tom.move()




cholesterol = 127

healthy = 200 > cholesterol > 60


mood = greatlyImproved if singing

if happy and knowsIt
  clapsHands()
  chaChaCha()
else
  showIt()

date = if friday then sue else jill



fill = (container, liquid = "coffee") ->






for filename in list
  do (filename) ->
    fs.readFile filename, (err, contents) ->
      compile filename, contents.toString()hi = `function() {
  return [document.title, "Hello JavaScript"].join(": ");
}`



solipsism = true if mind? and not world?

speed = 0
speed ?= 15

footprints = yeti ? "bear"






 grade = (student) ->
  if student.excellentWork
    "A+"
  else if student.okayStuff
    if student.triedHard then "B" else "B-"
  else
    "C"

eldest = if 24 > 21 then "Liz" else "Ike"six = (one = 1) + (two = 2) + (three = 3)



globals = (name for name of window)[0...10]alert(
  try
    nonexistent / undefined
  catch error
)

Account = (customer, cart) ->
  @customer = customer
  @cart = cart

  $('.shopping_cart').bind 'click', (event) =>
    @customer.purchase @cartsquare = (x) -> x * x
cube   = (x) -> square(x) * x
html = """
       <strong>
         cup of coffeescript
       </strong>
       """
       
OPERATOR = /// ^ (
) ///


author = "Wittgenstein"






weatherReport = (location) ->
  [location, 72, "Mostly Sunny"]

[city, temp, forecast] = weatherReport "Berkeley, CA"




yearsOld = max: 10, ida: 9, tim: 11

ages = for child, age of yearsOld
futurists =
  sculptor: "Umberto Boccioni"
  painter:  "Vladimir Burliuk"
  poet:
    name:   "F.T. Marinetti"
    address: [
      "Via Roma 42R"
      "Bellagio, Italy 22021"
    ]

{poet: {name, address: [street, city]}} = futurists



song = ["do", "re", "mi", "fa", "so"]

singers = {Jagger: "Rock", Elvis: "Roll"}

bitlist = [
  1, 0, 1
  0, 0, 1
  1, 1, 0
]

kids =
  brother:
    name: "Max"
    age:  11
  sister:
    name: "Ida"
    age:  9


$('.account').attr class: 'active'

log object.class


number   = 42
opposite = true

number = -42 if opposite

square = (x) -> x * x

list = [1, 2, 3, 4, 5]

math =
  root:   Math.sqrt
  square: square
  cube:   (x) -> x * square x

race = (winner, runners...) ->
  print winner, runners

alert "I knew it!" if elvis?

cubes = (math.cube num for num in list)
theBait   = 1000
theSwitch = 0

[theBait, theSwitch] = [theSwitch, theBait]




 tag = "<impossible>"

[open, contents..., close] = tag.split("")






String::dasherize = ->
  this.replace /_/g, "-"

countdown = (num for num in [10..1])

outer = 1
changeNumbers = ->
  inner = -1
  outer = 10
inner = changeNumbers()numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]

start   = numbers[0..2]

middle  = numbers[3...6]

end     = numbers[6..]

copy    = numbers[..]
zip = lottery.drawWinner?().address?.zipcode
gold = silver = rest = "unknown"

awardMedals = (first, second, others...) ->
  gold   = first
  silver = second
  rest   = others

contenders = [
  "Michael Phelps"
  "Liu Xiang"
  "Yao Ming"
  "Allyson Felix"
  "Shawn Johnson"
  "Roman Sebrle"
  "Guo Jingjing"
  "Tyson Gay"
  "Asafa Powell"
  "Usain Bolt"
]

awardMedals contenders...

alert "Gold: " + gold
alert "Silver: " + silver
alert "The Field: " + rest


numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

numbers[3..6] = [-3, -4, -5, -6]



 mobyDick = "Call me Ishmael. Some years ago --
 never mind how long precisely -- having little
 or no money in my purse, and nothing particular
 to interest me on shore, I thought I would sail
 about a little and see the watery part of the
 world..."


switch day
  when "Mon" then go work
  when "Tue" then go relax
  when "Thu" then go iceFishing
  when "Fri", "Sat"
    if day is bingoDay
      go bingo
      go dancing
  when "Sun" then go church
  else go worktry
  allHellBreaksLoose()
  catsAndDogsLivingTogether()
catch error
  print error
finally
  cleanUp()

if this.studyingEconomics
  buy()  while supply > demand
  sell() until supply > demand

num = 6
lyrics = while num -= 1
    One fell out and bumped his head."

index = (list, target) ->
  [low, high] = [0, list.length]
  while low < high
    mid = (low + high) >> 1
    val = list[mid]
    return mid if val is target
    if val < target then low = mid + 1 else high = mid
  return -1

console.log 2 is index [10, 20, 30, 40, 50], 30
console.log 4 is index [-97, 35, 67, 88, 1200], 1200

runtime = (N) ->
  [sum, t] = [0, 0]
  for n in [1..N]
    sum += 2 * t
    t = n - 1 + sum / n
  t

console.log runtime(3) is 2.6666666666666665
console.log runtime(5) is 7.4
console.log runtime(8) is 16.92142857142857

match = (regexp, text) ->
  return match_here(regexp.slice(1), text) if regexp[0] is '^'
  while text
    return true if match_here(regexp, text)
    text = text.slice(1)
  false

match_here = (regexp, text) ->
  [cur, next] = [regexp[0], regexp[1]]
  if regexp.length is 0 then return true
  if next is '*' then return match_star(cur, regexp.slice(2), text)
  if cur is '$' and not next then return text.length is 0
  if text and (cur is '.' or cur is text[0]) then return match_here(regexp.slice(1), text.slice(1))
  false

match_star = (c, regexp, text) ->
  loop
    return true if match_here(regexp, text)
    return false unless text and (text[0] is c or c is '.')
    text = text.slice(1)

console.log match("ex", "some text")
console.log match("s..t", "spit")
console.log match("^..t", "buttercup")
console.log match("i..$", "cherries")
console.log match("o*m", "vrooooommm!")

get '/hello', ->
  'Hello World'


append = (location, data) ->
  path = new Pathname location
  throw new Error "Location does not exist" unless fs.existsSync(location)

  File.open path, 'a', (file) ->
    file.console.log YAML.dump data

  data


File.open = (path, mode, block) ->
  io = new File path, mode

  return io unless block

  try
    block io
  finally
    io.close() unless io.closed()


write = (location, data) ->
  path = new Pathname location
  throw new Error "Location does not exist" unless fs.existsSync(location)

  File.open path, 'w', (file) ->
    return false if Digest.MD5.hexdigest(file.read()) is data.hash()
    file.console.log YAML.dump data
    true


index = ->
  people = Person.find 'all'

  respond_to (format) ->
    format.html()
    format.xml -> render xml: people.xml()


synchronize = (block) ->
  lock()
  try block() finally unlock()
square = (x) -> x * x

sum = (x, y) -> x + y

odd = (x) -> x % 2 isnt 0

even = (x) -> x % 2 is 0

run_loop = ->
  fire_events((e) -> e.stopPropagation())
  listen()
  wait()

dense_object_literal = {one: 1, two: 2, three: 3}

spaced_out_multiline_object =
  pi: 3.14159
  list: [1, 2, 3, 4]
  regex: /match[ing](every|thing|\/)/gi
  three: new Idea

  inner_obj:
    freedom: -> _.freedom()

stooges = [{moe: 45}, {curly: 43}, {larry: 46}]

exponents = [((x) -> x), ((x) -> x * x), ((x) -> x * x * x)]

empty = []

multiline = [
  'line one'
  'line two'
]

if submarine.shields_up
  full_speed_ahead()
  fire_torpedos()
else if submarine.sinking
  abandon_ship()
else
  run_away()

eldest = if 25 > 21 then liz else marge

decoration = medal_of_honor if war_hero

go_to_sleep() unless coffee

race = ->
  run()
  walk()
  crawl()
  if tired then return sleep()
  race()

good or= evil
wine and= cheese

((moon.turn(360))).shapes[3].move({x: 45, y: 30}).position['top'].offset('x')

a = b = c = 5

callback(
  `function(e) { e.stop(); }`
)

try
  all_hell_breaks_loose()
  dogs_and_cats_living_together()
  throw "up"
catch error
  print(error)
finally
  clean_up()

try all_hell_breaks_loose() catch error then print(error) finally clean_up()

while demand > supply
  sell()
  restock()

while supply > demand then buy()

loop
  break if broken
  continue if continuing

!!true

v_1 = 5
change_a_and_set_b = ->
  v_1 = 10
  v_2 = 15
v_2 = 20

supper = food.capitalize() for food in ['toast', 'cheese', 'wine']

drink bottle for bottle, i in ['soda', 'wine', 'lemonade'] when even i

activity = switch day
  when "Tuesday"   then eat_breakfast()
  when "Sunday"    then go_to_church()
  when "Saturday"  then go_to_the_park()
  when "Wednesday"
    if day is bingo_day
      go_to_bingo()
    else
      eat_breakfast()
      go_to_work()
      eat_dinner()
  else go_to_work()

wednesday = -> eat_breakfast(); go_to_work(); eat_dinner()

story = "Lorem ipsum dolor \"sit\" amet, consectetuer adipiscing elit,
sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna
aliquam erat volutpat. Ut wisi enim ad."

class Animal
  (@name) ->

  move: (meters) ->
    alert this.name + " moved " + meters + "m."

class Snake extends Animal
  move: ->
    alert 'Slithering...'
    super 5

class Horse extends Animal
  move: ->
    alert 'Galloping...'
    super 45

sam = new Snake "Sammy the Snake"
tom = new Horse "Tommy the Horse"

sam.move()
tom.move()

a_googol =  1e100
hex      =  0xff0000
negative =  -1.0
infinity =  Infinity
nan      =  NaN

binary_search = (items, value) ->

  start = 0
  stop  = items.length - 1
  pivot = Math.floor (start + stop) / 2

  while items[pivot] isnt value and start < stop

    stop  = pivot - 1 if value < items[pivot]
    start = pivot + 1 if value > items[pivot]

    pivot = Math.floor (stop + start) / 2

  if items[pivot] is value then pivot else -1


console.log 2 is binary_search [10, 20, 30, 40, 50], 30
console.log 4 is binary_search [-97, 35, 67, 88, 1200], 1200
console.log 0 is binary_search [0, 45, 70], 0
bubble_sort = (list) ->
  for i in [0...list.length]
    for j in [0...list.length - i]
      [list[j], list[j+1]] = [list[j+1], list[j]] if list[j] > list[j+1]
  list


console.log bubble_sort([3, 2, 1]).join(' ') is '1 2 3'
class LinkedList

  ->


  add: (data) ->

    node = data: data, next: null

    current = this._head or= node

    if this._head isnt node
      (current = current.next) while current.next
      current.next = node

    this


  item: (index) ->

    return null if index < 0

    current = this._head or null
    i = -1

    (current = current.next) while current and index > (i += 1)

    current and current.data


  remove: (index) ->

    return null if index < 0

    current = this._head or null
    i = -1

    if index is 0
      this._head = current.next
    else

      ([previous, current] = [current, current.next]) while index > (i += 1)

      previous.next = current.next

    current and current.data


  size: ->
    current = this._head
    count = 0

    while current
      count += 1
      current = current.next

    count


  toArray: ->
    result  = []
    current = this._head

    while current
      result.push current.data
      current = current.next

    result


  toString: -> this.toArray().toString()


list = new LinkedList

list.add("Hi")
console.log list.size()  is 1
console.log list.item(0) is "Hi"
console.log list.item(1) is null

list = new LinkedList
list.add("zero").add("one").add("two")
console.log list.size()     is 3
console.log list.item(2)    is "two"
console.log list.remove(1)  is "one"
console.log list.item(0)    is "zero"
console.log list.item(1)    is "two"
console.log list.size()     is 2
console.log list.item(-10)  is null

is_valid_identifier = (identifier) ->

  sum = 0
  alt = false

  for i in [identifier.length - 1..0] by -1

    num = parseInt identifier.charAt(i), 10

    return false if isNaN(num)

    if alt
      num *= 2
      num = (num % 10) + 1 if num > 9

    alt = !alt

    sum += num

  sum % 10 is 0


console.log is_valid_identifier("49927398716")      is true
console.log is_valid_identifier("4408041234567893") is true
console.log is_valid_identifier("4408041234567890") is false
merge_sort = (list) ->

  return list if list.length is 1

  result  = []
  pivot   = Math.floor list.length / 2
  left    = merge_sort list.slice 0, pivot
  right   = merge_sort list.slice pivot

  while left.length and right.length
    result.push(if left[0] < right[0] then left.shift() else right.shift())

  result.concat(left).concat(right)


console.log merge_sort([3, 2, 1]).join(' ') is '1 2 3'
selection_sort = (list) ->
  len = list.length

  for i in [0...len]

    min = i

    min = k for v, k in list[i+1...] when v < list[min]

    [list[i], list[min]] = [list[min], list[i]] if i isnt min

  list


console.log selection_sort([3, 2, 1]).join(' ') is '1 2 3'


['toast', 'wine', 'cheese'].each (food) -> print food.capitalize()




LotteryTicket =
  get_picks:      -> @picks
  set_picks:      (@picks) ->
  get_purchased:  -> @purchase
  set_purchased:  (@purchased) ->




LotteryDraw =
  play: ->
    result  = LotteryTicket.new_random()
    winners = {}
    this.tickets.each (buyer, ticket_list) ->
      ticket_list.each (ticket) ->
        score = ticket.score result
        return if score is 0
        winners[buyer] or= []
        winners[buyer].push [ticket, score]
    this.tickets = {}
    winners




WishScanner =
  scan_for_a_wish: ->
    wish = this.read().detect (thought) -> thought.index('wish: ') is 0
    wish.replace 'wish: ', ''




Creature =

  hit: (damage) ->
    p_up = Math.rand this.charisma
    if p_up % 9 is 7
      this.life += p_up / 4
      console.log "[" + this.name + " magick powers up " + p_up + "!]"
    this.life -= damage
    if this.life <= 0 then console.log "[" + this.name + " has died.]"

  fight: (enemy, weapon) ->
    if this.life <= 0 then return console.log "[" + this.name + "is too dead to fight!]"

    your_hit = Math.rand this.strength + weapon
    console.log "[You hit with " + your_hit + "points of damage!]"
    enemy.hit your_hit

    console.log enemy
    if enemy.life > 0
      enemy_hit = Math.rand enemy.strength + enemy.weapon
      console.log "[Your enemy hit with " + enemy_hit + "points of damage!]"
      this.hit enemy_hit




print "Enter your new idea: "
idea = gets()
code_words.each (real, code) -> idea.replace(real, code)

print "File encoded. Please enter a name for this idea: "
idea_name = gets().strip()
File.open "idea-" + idea_name + '.txt', 'w', (file) -> file.write idea




wipe_mutterings_from = (sentence) ->
  throw new Error "cannot wipe mutterings" unless sentence.indexOf
  while sentence.indexOf('(') >= 0
    open     = sentence.indexOf('(') - 1
    close    = sentence.indexOf(')') + 1
    sentence = sentence.slice(0, open) + sentence.slice(close, sentence.length)
    sentence


print "Odelay!" for i in [1..5]



add = (x, y) -> x + y
print add 2, 4



loop print 'quaff'



print ['cheese', 'bread', 'mayo'][1]



print {language: 'Potion', pointless: true}['language']



minus = (x, y) -> x - y
minus 6, 10



foods = ['cheese', 'bread', 'mayo']
foods[2]



for key, val of {dog: 'canine', cat: 'feline', fox: 'vulpine'}
  print key + ' is a ' + val



class Person
  print: ->
    print 'My name is ' + @name + '.'



p = new Person
print p.name



class Policeman extends Person
  (@rank) ->

  print: ->
    print 'My name is ' + @name + " and I'm a " + @rank + '.'

print new Policeman 'Constable'



app =
  window:
    width: 200
    height: 200
  para:    'Welcome.'
  button:  'OK'

app.window



x = 1
y = 2

x = 1; y = 2



table =
  language: 'Potion'
  pointless: yes



String::length = -> 10



block = ->
  print 'potion'



if age > 100 then 'ancient'



switch author
  when 'Jonathan Strange & Mr. Norrell'
    'Susanna Clarke'
  when 'The Star Diaries'
    'Stanislaw Lem'
  when 'The Slynx'
    'Tatyana Tolstaya'
  else
    '... probably Philip K. Dick'



count = 8
while count > 0
  print 'quaff'
  count--



print a for a in [1..5]



if 3.gender?
  print "Huh? Numbers are sexed? That's amazing."



HomePage::get = (url) ->
  session = url.query.session if url.query?



BTree   = ->
b       = new BTree
b.left  = new BTree
b.right = new BTree



BTree = ->
b = new BTree

print 'left path found!' if b.left?



root = this


previousUnderscore = root._


breaker = if typeof(StopIteration) is 'undefined' then '__break__' else StopIteration


escapeRegExp = (string) -> string.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1')


ArrayProto           = Array.prototype
ObjProto             = Object.prototype


slice                = ArrayProto.slice
unshift              = ArrayProto.unshift
toString             = ObjProto.toString
hasOwnProperty       = ObjProto.hasOwnProperty
propertyIsEnumerable = ObjProto.propertyIsEnumerable


nativeForEach        = ArrayProto.forEach
nativeMap            = ArrayProto.map
nativeReduce         = ArrayProto.reduce
nativeReduceRight    = ArrayProto.reduceRight
nativeFilter         = ArrayProto.filter
nativeEvery          = ArrayProto.every
nativeSome           = ArrayProto.some
nativeIndexOf        = ArrayProto.indexOf
nativeLastIndexOf    = ArrayProto.lastIndexOf
nativeIsArray        = Array.isArray
nativeKeys           = Object.keys


_ = (obj) -> new wrapper(obj)


if typeof(exports) != 'undefined' then exports._ = _


root._ = _


_.VERSION = '1.1.0'



_.each = (obj, iterator, context) ->
  try
    if nativeForEach and obj.forEach is nativeForEach
      obj.forEach iterator, context
    else if _.isNumber obj.length
      iterator.call context, obj[i], i, obj for i in [0...obj.length]
    else
      iterator.call context, val, key, obj  for own key, val of obj
  catch e
    throw e if e isnt breaker
  obj


_.map = (obj, iterator, context) ->
  return obj.map(iterator, context) if nativeMap and obj.map is nativeMap
  results = []
  _.each obj, (value, index, list) ->
    results.push iterator.call context, value, index, list
  results


_.reduce = (obj, iterator, memo, context) ->
  if nativeReduce and obj.reduce is nativeReduce
    iterator = _.bind iterator, context if context
    return obj.reduce iterator, memo
  _.each obj, (value, index, list) ->
    memo = iterator.call context, memo, value, index, list
  memo


_.reduceRight = (obj, iterator, memo, context) ->
  if nativeReduceRight and obj.reduceRight is nativeReduceRight
    iterator = _.bind iterator, context if context
    return obj.reduceRight iterator, memo
  reversed = _.clone(_.toArray(obj)).reverse()
  _.reduce reversed, iterator, memo, context


_.detect = (obj, iterator, context) ->
  result = null
  _.each obj, (value, index, list) ->
    if iterator.call context, value, index, list
      result = value
      _.breakLoop()
  result


_.filter = (obj, iterator, context) ->
  return obj.filter iterator, context if nativeFilter and obj.filter is nativeFilter
  results = []
  _.each obj, (value, index, list) ->
    results.push value if iterator.call context, value, index, list
  results


_.reject = (obj, iterator, context) ->
  results = []
  _.each obj, (value, index, list) ->
    results.push value if not iterator.call context, value, index, list
  results


_.every = (obj, iterator, context) ->
  iterator ||= _.identity
  return obj.every iterator, context if nativeEvery and obj.every is nativeEvery
  result = true
  _.each obj, (value, index, list) ->
    _.breakLoop() unless (result = result and iterator.call(context, value, index, list))
  result


_.some = (obj, iterator, context) ->
  iterator ||= _.identity
  return obj.some iterator, context if nativeSome and obj.some is nativeSome
  result = false
  _.each obj, (value, index, list) ->
    _.breakLoop() if (result = iterator.call(context, value, index, list))
  result


_.include = (obj, target) ->
  return _.indexOf(obj, target) isnt -1 if nativeIndexOf and obj.indexOf is nativeIndexOf
  return true for own key, val of obj when val is target
  false


_.invoke = (obj, method) ->
  args = _.rest arguments, 2
  (if method then val[method] else val).apply(val, args) for val in obj


_.pluck = (obj, key) ->
  _.map(obj, (val) -> val[key])


_.max = (obj, iterator, context) ->
  return Math.max.apply(Math, obj) if not iterator and _.isArray(obj)
  result = computed: -Infinity
  _.each obj, (value, index, list) ->
    computed = if iterator then iterator.call(context, value, index, list) else value
    computed >= result.computed and (result = {value: value, computed: computed})
  result.value


_.min = (obj, iterator, context) ->
  return Math.min.apply(Math, obj) if not iterator and _.isArray(obj)
  result = computed: Infinity
  _.each obj, (value, index, list) ->
    computed = if iterator then iterator.call(context, value, index, list) else value
    computed < result.computed and (result = {value: value, computed: computed})
  result.value


_.sortBy = (obj, iterator, context) ->
  _.pluck(((_.map obj, (value, index, list) ->
    {value: value, criteria: iterator.call(context, value, index, list)}
  ).sort((left, right) ->
    a = left.criteria; b = right.criteria
    if a < b then -1 else if a > b then 1 else 0
  )), 'value')


_.sortedIndex = (array, obj, iterator) ->
  iterator ||= _.identity
  low =  0
  high = array.length
  while low < high
    mid = (low + high) >> 1
    if iterator(array[mid]) < iterator(obj) then low = mid + 1 else high = mid
  low


_.toArray = (iterable) ->
  return []                   if (!iterable)
  return iterable.toArray()   if (iterable.toArray)
  return iterable             if (_.isArray(iterable))
  return slice.call(iterable) if (_.isArguments(iterable))
  _.values(iterable)


_.size = (obj) -> _.toArray(obj).length



_.first = (array, n, guard) ->
  if n and not guard then slice.call(array, 0, n) else array[0]


_.rest = (array, index, guard) ->
  slice.call(array, if _.isUndefined(index) or guard then 1 else index)


_.last = (array) -> array[array.length - 1]


_.compact = (array) -> item for item in array when item


_.flatten = (array) ->
  _.reduce array, (memo, value) ->
    return memo.concat(_.flatten(value)) if _.isArray value
    memo.push value
    memo
  , []


_.without = (array) ->
  values = _.rest arguments
  val for val in _.toArray(array) when not _.include values, val


_.uniq = (array, isSorted) ->
  memo = []
  for el, i in _.toArray array
    memo.push el if i is 0 || (if isSorted is true then _.last(memo) isnt el else not _.include(memo, el))
  memo


_.intersect = (array) ->
  rest = _.rest arguments
  _.select _.uniq(array), (item) ->
    _.all rest, (other) ->
      _.indexOf(other, item) >= 0


_.zip = ->
  length =  _.max _.pluck arguments, 'length'
  results = new Array length
  for i in [0...length]
    results[i] = _.pluck arguments, String i
  results


_.indexOf = (array, item) ->
  return array.indexOf item if nativeIndexOf and array.indexOf is nativeIndexOf
  i = 0; l = array.length
  while l - i
    if array[i] is item then return i else i++
  -1


_.lastIndexOf = (array, item) ->
  return array.lastIndexOf(item) if nativeLastIndexOf and array.lastIndexOf is nativeLastIndexOf
  i = array.length
  while i
    if array[i] is item then return i else i--
  -1


_.range = (start, stop, step) ->
  a         = arguments
  solo      = a.length <= 1
  i = start = if solo then 0 else a[0]
  stop      = if solo then a[0] else a[1]
  step      = a[2] or 1
  len       = Math.ceil((stop - start) / step)
  return []   if len <= 0
  range     = new Array len
  idx       = 0
  loop
    return range if (if step > 0 then i - stop else stop - i) >= 0
    range[idx] = i
    idx++
    i+= step



_.bind = (func, obj) ->
  args = _.rest arguments, 2
  -> func.apply obj or root, args.concat arguments


_.bindAll = (obj) ->
  funcs = if arguments.length > 1 then _.rest(arguments) else _.functions(obj)
  _.each funcs, (f) -> obj[f] = _.bind obj[f], obj
  obj


_.delay = (func, wait) ->
  args = _.rest arguments, 2
  setTimeout((-> func.apply(func, args)), wait)


_.memoize = (func, hasher) ->
  memo = {}
  hasher or= _.identity
  ->
    key = hasher.apply this, arguments
    return memo[key] if key of memo
    memo[key] = func.apply this, arguments


_.defer = (func) ->
  _.delay.apply _, [func, 1].concat _.rest arguments


_.wrap = (func, wrapper) ->
  -> wrapper.apply wrapper, [func].concat arguments


_.compose = ->
  funcs = arguments
  ->
    args = arguments
    for i in [funcs.length - 1..0] by -1
      args = [funcs[i].apply(this, args)]
    args[0]



_.keys = nativeKeys or (obj) ->
  return _.range 0, obj.length if _.isArray(obj)
  key for key, val of obj


_.values = (obj) ->
  _.map obj, _.identity


_.functions = (obj) ->
  _.filter(_.keys(obj), (key) -> _.isFunction(obj[key])).sort()


_.extend = (obj) ->
  for source in _.rest(arguments)
    obj[key] = val for key, val of source
  obj


_.clone = (obj) ->
  return obj.slice 0 if _.isArray obj
  _.extend {}, obj


_.tap = (obj, interceptor) ->
  interceptor obj
  obj


_.isEqual = (a, b) ->
  return true if a is b
  atype = typeof(a); btype = typeof(b)
  return false if atype isnt btype
  return true if `a == b`
  return false if (!a and b) or (a and !b)
  return a.isEqual(b) if a.isEqual
  return a.getTime() is b.getTime() if _.isDate(a) and _.isDate(b)
  return false if _.isNaN(a) and _.isNaN(b)
  if _.isRegExp(a) and _.isRegExp(b)
    return a.source     is b.source and
           a.global     is b.global and
           a.ignoreCase is b.ignoreCase and
           a.multiline  is b.multiline
  return false if atype isnt 'object'
  return false if a.length and (a.length isnt b.length)
  aKeys = _.keys(a); bKeys = _.keys(b)
  return false if aKeys.length isnt bKeys.length
  return false for key, val of a when !(key of b) or !_.isEqual(val, b[key])
  true


_.isEmpty = (obj) ->
  return obj.length is 0 if _.isArray(obj) or _.isString(obj)
  return false for own key of obj
  true


_.isElement   = (obj) -> obj and obj.nodeType is 1


_.isArray     = nativeIsArray or (obj) -> !!(obj and obj.concat and obj.unshift and not obj.callee)


_.isArguments = (obj) -> obj and obj.callee


_.isFunction  = (obj) -> !!(obj and obj.constructor and obj.call and obj.apply)


_.isString    = (obj) -> !!(obj is '' or (obj and obj.charCodeAt and obj.substr))


_.isNumber    = (obj) -> (obj is +obj) or toString.call(obj) is '[object Number]'


_.isBoolean   = (obj) -> obj is true or obj is false


_.isDate      = (obj) -> !!(obj and obj.getTimezoneOffset and obj.setUTCFullYear)


_.isRegExp    = (obj) -> !!(obj and obj.exec and (obj.ignoreCase or obj.ignoreCase is false))


_.isNaN       = (obj) -> _.isNumber(obj) and window.isNaN(obj)


_.isNull      = (obj) -> obj is null


_.isUndefined = (obj) -> typeof obj is 'undefined'



_.noConflict = ->
  root._ = previousUnderscore
  this


_.identity = (value) -> value


_.times = (n, iterator, context) ->
  iterator.call context, i for i in [0...n]


_.breakLoop = -> throw breaker


_.mixin = (obj) ->
  for name in _.functions(obj)
    addToWrapper name, _[name] = obj[name]


idCounter = 0
_.uniqueId = (prefix) ->
  (prefix or '') + idCounter++


_.templateSettings = {
  start:        '<%'
  end:          '%>'
  interpolate:  /<%=(.+?)%>/g
}


_.template = (str, data) ->
  c = _.templateSettings
  endMatch = new RegExp("'(?=[^"+c.end.substr(0, 1)+"]*"+escapeRegExp(c.end)+")","g")
  fn = new Function 'obj',
    'var p=[],print=function(){p.push.apply(p,arguments);};' +
    'with(obj||{}){p.push(\'' +
    str.replace(/\r/g, '\\r')
       .replace(/\n/g, '\\n')
       .replace(/\t/g, '\\t')
       .replace(endMatch,"✄")
       .split("'").join("\\'")
       .split("✄").join("'")
       .replace(c.interpolate, "',$1,'")
       .split(c.start).join("');")
       .split(c.end).join("p.push('") +
       "');}return p.join('');"
  if data then fn(data) else fn



_.forEach  = _.each
_.foldl    = _.inject = _.reduce
_.foldr    = _.reduceRight
_.select   = _.filter
_.all      = _.every
_.any      = _.some
_.contains = _.include
_.head     = _.first
_.tail     = _.rest
_.methods  = _.functions



wrapper = (obj) ->
  this._wrapped = obj
  this


result = (obj, chain) ->
  if chain then _(obj).chain() else obj


addToWrapper = (name, func) ->
  wrapper.prototype[name] = ->
    args = _.toArray arguments
    unshift.call args, this._wrapped
    result func.apply(_, args), this._chain


_.mixin _


_.each ['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], (name) ->
  method = Array.prototype[name]
  wrapper.prototype[name] = ->
    method.apply(this._wrapped, arguments)
    result(this._wrapped, this._chain)


_.each ['concat', 'join', 'slice'], (name) ->
  method = Array.prototype[name]
  wrapper.prototype[name] = ->
    result(method.apply(this._wrapped, arguments), this._chain)


wrapper::chain = ->
  this._chain = true
  this


wrapper::value = -> this._wrapped

http = require 'http'

server = http.createServer (req, res) ->
  res.writeHeader 200, 'Content-Type': 'text/plain'
  res.write 'Hello, World!'
  res.end()

server.listen 3000

console.log "Server running at http://localhost:3000/"

CoffeeScript = require './coffee-script'
CoffeeScript.require = require

CoffeeScript.eval = (code, options = {}) ->
  options.bare ?= on
  eval CoffeeScript.compile code, options

CoffeeScript.run = (code, options = {}) ->
  options.bare = on
  Function(CoffeeScript.compile code, options)()

return unless window?

CoffeeScript.load = (url, callback) ->
  xhr = new (window.ActiveXObject or XMLHttpRequest)('Microsoft.XMLHTTP')
  xhr.open 'GET', url, true
  xhr.overrideMimeType 'text/plain' if 'overrideMimeType' of xhr
  xhr.onreadystatechange = ->
    if xhr.readyState is 4
      if xhr.status in [0, 200]
        CoffeeScript.run xhr.responseText
      else
      callback() if callback
  xhr.send null

runScripts = ->
  scripts = document.getElementsByTagName 'script'
  coffees = (s for s in scripts when s.type is 'text/coffeescript')
  index = 0
  length = coffees.length
  do execute = ->
    script = coffees[index++]
    if script?.type is 'text/coffeescript'
      if script.src
        CoffeeScript.load script.src, execute
      else
        CoffeeScript.run script.innerHTML
        execute()
  null

if window.addEventListener
  addEventListener 'DOMContentLoaded', runScripts, no
else
  attachEvent 'onload', runScripts

fs           = require 'fs'
path         = require 'path'
helpers      = require './helpers'
optparse     = require './optparse'
CoffeeScript = require './coffee-script'

existsSync   = fs.existsSync or path.existsSync

tasks     = {}
options   = {}
switches  = []
oparse    = null

helpers.extend global,

  task: (name, description, action) ->
    [action, description] = [description, action] unless action
    tasks[name] = {name, description, action}

  option: (letter, flag, description) ->
    switches.push [letter, flag, description]

  invoke: (name) ->
    missingTask name unless tasks[name]
    tasks[name].action options

exports.run = ->
  global.__originalDirname = fs.realpathSync '.'
  process.chdir cakefileDirectory __originalDirname
  args = process.argv[2..]
  CoffeeScript.run fs.readFileSync('Cakefile').toString(), filename: 'Cakefile'
  oparse = new optparse.OptionParser switches
  return printTasks() unless args.length
  try
    options = oparse.parse(args)
  catch e
  invoke arg for arg in options.arguments

printTasks = ->
  relative = path.relative or path.resolve
  cakefilePath = path.join relative(__originalDirname, process.cwd()), 'Cakefile'
  for name, task of tasks
    spaces = 20 - name.length
    spaces = if spaces > 0 then Array(spaces + 1).join(' ') else ''
  console.log oparse.help() if switches.length

fatalError = (message) ->
  console.error message + '\n'
  console.log 'To see a list of all tasks/options, run "cake"'
  process.exit 1


cakefileDirectory = (dir) ->
  return dir if existsSync path.join dir, 'Cakefile'
  parent = path.normalize path.join dir, '..'
  return cakefileDirectory parent unless parent is dir

fs               = require 'fs'
path             = require 'path'
{Lexer,RESERVED} = require './lexer'
{parser}         = require './parser'
vm               = require 'vm'

stripBOM = (content) ->
  if content.charCodeAt(0) is 0xFEFF then content.substring 1 else content

if require.extensions
  require.extensions['.coffee'] = (module, filename) ->
    content = compile stripBOM(fs.readFileSync filename, 'utf8'), {filename}
    module._compile content, filename

exports.VERSION = '1.3.3'

exports.RESERVED = RESERVED

exports.helpers = require './helpers'

exports.compile = compile = (code, options = {}) ->
  {merge} = exports.helpers
  try
    js = (parser.parse lexer.tokenize code).compile options
    return js unless options.header
  catch err
    throw err

exports.tokens = (code, options) ->
  lexer.tokenize code, options

exports.nodes = (source, options) ->
  if typeof source is 'string'
    parser.parse lexer.tokenize source, options
  else
    parser.parse source

exports.run = (code, options = {}) ->
  mainModule = require.main

  mainModule.filename = process.argv[1] =
      if options.filename then fs.realpathSync(options.filename) else '.'

  mainModule.moduleCache and= {}

  mainModule.paths = require('module')._nodeModulePaths path.dirname fs.realpathSync options.filename

  if path.extname(mainModule.filename) isnt '.coffee' or require.extensions
    mainModule._compile compile(code, options), mainModule.filename
  else
    mainModule._compile code, mainModule.filename

exports.eval = (code, options = {}) ->
  return unless code = code.trim()
  Script = vm.Script
  if Script
    if options.sandbox?
      if options.sandbox instanceof Script.createContext().constructor
        sandbox = options.sandbox
      else
        sandbox = Script.createContext()
        sandbox[k] = v for own k, v of options.sandbox
      sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox
    else
      sandbox = global
    sandbox.__filename = options.filename || 'eval'
    sandbox.__dirname  = path.dirname sandbox.__filename
    unless sandbox isnt global or sandbox.module or sandbox.require
      Module = require 'module'
      sandbox.module  = _module  = new Module(options.modulename || 'eval')
      sandbox.require = _require = (path) ->  Module._load path, _module, true
      _module.filename = sandbox.__filename
      _require[r] = require[r] for r in Object.getOwnPropertyNames require when r isnt 'paths'
      _require.paths = _module.paths = Module._nodeModulePaths process.cwd()
      _require.resolve = (request) -> Module._resolveFilename request, _module
  o = {}
  o[k] = v for own k, v of options
  js = compile code, o
  if sandbox is global
    vm.runInThisContext js
  else
    vm.runInContext js, sandbox

lexer = new Lexer

parser.lexer =
  lex: ->
    [tag, @yytext, @yylineno] = @tokens[@pos++] or ['']
    tag
  setInput: (@tokens) ->
    @pos = 0
  upcomingInput: ->
    ""

parser.yy = require './nodes'

fs             = require 'fs'
path           = require 'path'
helpers        = require './helpers'
optparse       = require './optparse'
CoffeeScript   = require './coffee-script'
{spawn, exec}  = require 'child_process'
{EventEmitter} = require 'events'

exists         = fs.exists or path.exists

helpers.extend CoffeeScript, new EventEmitter

printLine = (line) -> process.stdout.write line + '\n'
printWarn = (line) -> process.stderr.write line + '\n'

hidden = (file) -> /^\.|~$/.test file

BANNER = '''
  Usage: coffee [options] path/to/script.coffee -- [args]

  If called without options, `coffee` will run your script.
'''

SWITCHES = [
  ['-b', '--bare',            'compile without a top-level function wrapper']
  ['-c', '--compile',         'compile to JavaScript and save as .js files']
  ['-e', '--eval',            'pass a string from the command line as input']
  ['-h', '--help',            'display this help message']
  ['-i', '--interactive',     'run an interactive CoffeeScript REPL']
  ['-j', '--join [FILE]',     'concatenate the source CoffeeScript before compiling']
  ['-l', '--lint',            'pipe the compiled JavaScript through JavaScript Lint']
  ['-n', '--nodes',           'print out the parse tree that the parser produces']
  [      '--nodejs [ARGS]',   'pass options directly to the "node" binary']
  ['-o', '--output [DIR]',    'set the output directory for compiled JavaScript']
  ['-p', '--print',           'print out the compiled JavaScript']
  ['-r', '--require [FILE*]', 'require a library before executing your script']
  ['-s', '--stdio',           'listen for and compile scripts over stdio']
  ['-t', '--tokens',          'print out the tokens that the lexer/rewriter produce']
  ['-v', '--version',         'display the version number']
  ['-w', '--watch',           'watch scripts for changes and rerun commands']
]

opts         = {}
sources      = []
sourceCode   = []
notSources   = {}
watchers     = {}
optionParser = null

exports.run = ->
  parseOptions()
  return forkNode()                      if opts.nodejs
  return usage()                         if opts.help
  return version()                       if opts.version
  loadRequires()                         if opts.require
  return require './repl'                if opts.interactive
  if opts.watch and !fs.watch
  return compileStdio()                  if opts.stdio
  return compileScript null, sources[0]  if opts.eval
  return require './repl'                unless sources.length
  literals = if opts.run then sources.splice 1 else []
  process.argv = process.argv[0..1].concat literals
  process.argv[0] = 'coffee'
  process.execPath = require.main.filename
  for source in sources
    compilePath source, yes, path.normalize source

compilePath = (source, topLevel, base) ->
  fs.stat source, (err, stats) ->
    throw err if err and err.code isnt 'ENOENT'
    if err?.code is 'ENOENT'
      if topLevel and source[-7..] isnt '.coffee'
        return compilePath source, topLevel, base
      if topLevel
        process.exit 1
      return
    if stats.isDirectory()
      watchDir source, base if opts.watch
      fs.readdir source, (err, files) ->
        throw err if err and err.code isnt 'ENOENT'
        return if err?.code is 'ENOENT'
        index = sources.indexOf source
        files = files.filter (file) -> not hidden file
        sources[index..index] = (path.join source, file for file in files)
        sourceCode[index..index] = files.map -> null
        files.forEach (file) ->
          compilePath (path.join source, file), no, base
    else if topLevel or path.extname(source) is '.coffee'
      watch source, base if opts.watch
      fs.readFile source, (err, code) ->
        throw err if err and err.code isnt 'ENOENT'
        return if err?.code is 'ENOENT'
        compileScript(source, code.toString(), base)
    else
      notSources[source] = yes
      removeSource source, base


compileScript = (file, input, base) ->
  o = opts
  options = compileOptions file
  try
    t = task = {file, input, options}
    CoffeeScript.emit 'compile', task
    if      o.tokens      then printTokens CoffeeScript.tokens t.input
    else if o.nodes       then printLine CoffeeScript.nodes(t.input).toString().trim()
    else if o.run         then CoffeeScript.run t.input, t.options
    else if o.join and t.file isnt o.join
      sourceCode[sources.indexOf(t.file)] = t.input
      compileJoin()
    else
      t.output = CoffeeScript.compile t.input, t.options
      CoffeeScript.emit 'success', task
      if o.print          then printLine t.output.trim()
      else if o.compile   then writeJs t.file, t.output, base
      else if o.lint      then lint t.file, t.output
  catch err
    CoffeeScript.emit 'failure', err, task
    return if CoffeeScript.listeners('failure').length
    return printLine err.message + '\x07' if o.watch
    process.exit 1

compileStdio = ->
  code = ''
  stdin = process.openStdin()
  stdin.on 'data', (buffer) ->
    code += buffer.toString() if buffer
  stdin.on 'end', ->
    compileScript null, code

joinTimeout = null
compileJoin = ->
  return unless opts.join
  unless sourceCode.some((code) -> code is null)
    clearTimeout joinTimeout
    joinTimeout = wait 100, ->
      compileScript opts.join, sourceCode.join('\n'), opts.join

loadRequires = ->
  realFilename = module.filename
  module.filename = '.'
  require req for req in opts.require
  module.filename = realFilename

watch = (source, base) ->

  prevStats = null
  compileTimeout = null

  watchErr = (e) ->
    if e.code is 'ENOENT'
      return if sources.indexOf(source) is -1
      try
        rewatch()
        compile()
      catch e
        removeSource source, base, yes
        compileJoin()
    else throw e

  compile = ->
    clearTimeout compileTimeout
    compileTimeout = wait 25, ->
      fs.stat source, (err, stats) ->
        return watchErr err if err
        return rewatch() if prevStats and stats.size is prevStats.size and
          stats.mtime.getTime() is prevStats.mtime.getTime()
        prevStats = stats
        fs.readFile source, (err, code) ->
          return watchErr err if err
          compileScript(source, code.toString(), base)
          rewatch()

  try
    watcher = fs.watch source, compile
  catch e
    watchErr e

  rewatch = ->
    watcher?.close()
    watcher = fs.watch source, compile


watchDir = (source, base) ->
  readdirTimeout = null
  try
    watcher = fs.watch source, ->
      clearTimeout readdirTimeout
      readdirTimeout = wait 25, ->
        fs.readdir source, (err, files) ->
          if err
            throw err unless err.code is 'ENOENT'
            watcher.close()
            return unwatchDir source, base
          for file in files when not hidden(file) and not notSources[file]
            file = path.join source, file
            continue if sources.some (s) -> s.indexOf(file) >= 0
            sources.push file
            sourceCode.push null
            compilePath file, no, base
  catch e
    throw e unless e.code is 'ENOENT'

unwatchDir = (source, base) ->
  prevSources = sources[..]
  toRemove = (file for file in sources when file.indexOf(source) >= 0)
  removeSource file, base, yes for file in toRemove
  return unless sources.some (s, i) -> prevSources[i] isnt s
  compileJoin()

removeSource = (source, base, removeJs) ->
  index = sources.indexOf source
  sources.splice index, 1
  sourceCode.splice index, 1
  if removeJs and not opts.join
    jsPath = outputPath source, base
    exists jsPath, (itExists) ->
      if itExists
        fs.unlink jsPath, (err) ->
          throw err if err and err.code isnt 'ENOENT'

outputPath = (source, base) ->
  filename  = path.basename(source, path.extname(source)) + '.js'
  srcDir    = path.dirname source
  baseDir   = if base is '.' then srcDir else srcDir.substring base.length
  dir       = if opts.output then path.join opts.output, baseDir else srcDir
  path.join dir, filename

writeJs = (source, js, base) ->
  jsPath = outputPath source, base
  jsDir  = path.dirname jsPath
  compile = ->
    js = ' ' if js.length <= 0
    fs.writeFile jsPath, js, (err) ->
      if err
        printLine err.message
      else if opts.compile and opts.watch
  exists jsDir, (itExists) ->

wait = (milliseconds, func) -> setTimeout func, milliseconds

timeLog = (message) ->

lint = (file, js) ->
  printIt = (buffer) -> printLine file + ':\t' + buffer.toString().trim()
  conf = __dirname + '/../../extras/jsl.conf'
  jsl = spawn 'jsl', ['-nologo', '-stdin', '-conf', conf]
  jsl.stdout.on 'data', printIt
  jsl.stderr.on 'data', printIt
  jsl.stdin.write js
  jsl.stdin.end()

printTokens = (tokens) ->
  strings = for token in tokens
    [tag, value] = [token[0], token[1].toString().replace(/\n/, '\\n')]
  printLine strings.join(' ')

parseOptions = ->
  optionParser  = new optparse.OptionParser SWITCHES, BANNER
  o = opts      = optionParser.parse process.argv[2..]
  o.compile     or=  !!o.output
  o.run         = not (o.compile or o.print or o.lint)
  o.print       = !!  (o.print or (o.eval or o.stdio and o.compile))
  sources       = o.arguments
  sourceCode[i] = null for source, i in sources
  return

compileOptions = (filename) ->
  {filename, bare: opts.bare, header: opts.compile}

forkNode = ->
  nodeArgs = opts.nodejs.split /\s+/
  args     = process.argv[1..]
  args.splice args.indexOf('--nodejs'), 2
  spawn process.execPath, nodeArgs.concat(args),
    cwd:        process.cwd()
    env:        process.env
    customFds:  [0, 1, 2]

usage = ->
  printLine (new optparse.OptionParser SWITCHES, BANNER).help()

version = ->

{Parser} = require 'jison'


unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/

o = (patternString, action, options) ->
  patternString = patternString.replace /\s{2,}/g, ' '
  return [patternString, '$$ = $1;', options] unless action
  action = action.replace /\bnew /g, '$&yy.'
  action = action.replace /\b(?:Block\.wrap|extend)\b/g, 'yy.$&'


grammar =

  Root: [
    o '',                                       -> new Block
    o 'Body'
    o 'Block TERMINATOR'
  ]

  Body: [
    o 'Line',                                   -> Block.wrap [$1]
    o 'Body TERMINATOR Line',                   -> $1.push $3
    o 'Body TERMINATOR'
  ]

  Line: [
    o 'Expression'
    o 'Statement'
  ]

  Statement: [
    o 'Return'
    o 'Comment'
    o 'STATEMENT',                              -> new Literal $1
  ]

  Expression: [
    o 'Value'
    o 'Invocation'
    o 'Code'
    o 'Operation'
    o 'Assign'
    o 'If'
    o 'Try'
    o 'While'
    o 'For'
    o 'Switch'
    o 'Class'
    o 'Throw'
  ]

  Block: [
    o 'INDENT OUTDENT',                         -> new Block
    o 'INDENT Body OUTDENT',                    -> $2
  ]

  Identifier: [
    o 'IDENTIFIER',                             -> new Literal $1
  ]

  AlphaNumeric: [
    o 'NUMBER',                                 -> new Literal $1
    o 'STRING',                                 -> new Literal $1
  ]

  Literal: [
    o 'AlphaNumeric'
    o 'JS',                                     -> new Literal $1
    o 'REGEX',                                  -> new Literal $1
    o 'DEBUGGER',                               -> new Literal $1
    o 'UNDEFINED',                              -> new Undefined
    o 'NULL',                                   -> new Null
    o 'BOOL',                                   -> new Bool $1
  ]

  Assign: [
    o 'Assignable = Expression',                -> new Assign $1, $3
    o 'Assignable = TERMINATOR Expression',     -> new Assign $1, $4
    o 'Assignable = INDENT Expression OUTDENT', -> new Assign $1, $4
  ]

  AssignObj: [
    o 'ObjAssignable',                          -> new Value $1
    o 'ObjAssignable : Expression',             -> new Assign new Value($1), $3, 'object'
    o 'ObjAssignable :
       INDENT Expression OUTDENT',              -> new Assign new Value($1), $4, 'object'
    o 'Comment'
  ]

  ObjAssignable: [
    o 'Identifier'
    o 'AlphaNumeric'
    o 'ThisProperty'
  ]

  Return: [
    o 'RETURN Expression',                      -> new Return $2
    o 'RETURN',                                 -> new Return
  ]

  Comment: [
    o 'HERECOMMENT',                            -> new Comment $1
  ]

  Code: [
    o 'PARAM_START ParamList PARAM_END FuncGlyph Block', -> new Code $2, $5, $4
    o 'FuncGlyph Block',                        -> new Code [], $2, $1
  ]

  FuncGlyph: [
    o '->',                                     -> 'func'
    o '=>',                                     -> 'boundfunc'
  ]

  OptComma: [
    o ''
    o ','
  ]

  ParamList: [
    o '',                                       -> []
    o 'Param',                                  -> [$1]
    o 'ParamList , Param',                      -> $1.concat $3
    o 'ParamList OptComma TERMINATOR Param',    -> $1.concat $4
    o 'ParamList OptComma INDENT ParamList OptComma OUTDENT', -> $1.concat $4
  ]

  Param: [
    o 'ParamVar',                               -> new Param $1
    o 'ParamVar ...',                           -> new Param $1, null, on
    o 'ParamVar = Expression',                  -> new Param $1, $3
  ]

  ParamVar: [
    o 'Identifier'
    o 'ThisProperty'
    o 'Array'
    o 'Object'
  ]

  Splat: [
    o 'Expression ...',                         -> new Splat $1
  ]

  SimpleAssignable: [
    o 'Identifier',                             -> new Value $1
    o 'Value Accessor',                         -> $1.add $2
    o 'Invocation Accessor',                    -> new Value $1, [].concat $2
    o 'ThisProperty'
  ]

  Assignable: [
    o 'SimpleAssignable'
    o 'Array',                                  -> new Value $1
    o 'Object',                                 -> new Value $1
  ]

  Value: [
    o 'Assignable'
    o 'Literal',                                -> new Value $1
    o 'Parenthetical',                          -> new Value $1
    o 'Range',                                  -> new Value $1
    o 'This'
  ]

  Accessor: [
    o '.  Identifier',                          -> new Access $2
    o '?. Identifier',                          -> new Access $2, 'soak'
    o ':: Identifier',                          -> [(new Access new Literal 'prototype'), new Access $2]
    o '::',                                     -> new Access new Literal 'prototype'
    o 'Index'
  ]

  Index: [
    o 'INDEX_START IndexValue INDEX_END',       -> $2
    o 'INDEX_SOAK  Index',                      -> extend $2, soak : yes
  ]

  IndexValue: [
    o 'Expression',                             -> new Index $1
    o 'Slice',                                  -> new Slice $1
  ]

  Object: [
    o '{ AssignList OptComma }',                -> new Obj $2, $1.generated
  ]

  AssignList: [
    o '',                                                       -> []
    o 'AssignObj',                                              -> [$1]
    o 'AssignList , AssignObj',                                 -> $1.concat $3
    o 'AssignList OptComma TERMINATOR AssignObj',               -> $1.concat $4
    o 'AssignList OptComma INDENT AssignList OptComma OUTDENT', -> $1.concat $4
  ]

  Class: [
    o 'CLASS',                                           -> new Class
    o 'CLASS Block',                                     -> new Class null, null, $2
    o 'CLASS EXTENDS Expression',                        -> new Class null, $3
    o 'CLASS EXTENDS Expression Block',                  -> new Class null, $3, $4
    o 'CLASS SimpleAssignable',                          -> new Class $2
    o 'CLASS SimpleAssignable Block',                    -> new Class $2, null, $3
    o 'CLASS SimpleAssignable EXTENDS Expression',       -> new Class $2, $4
    o 'CLASS SimpleAssignable EXTENDS Expression Block', -> new Class $2, $4, $5
  ]

  Invocation: [
    o 'Value OptFuncExist Arguments',           -> new Call $1, $3, $2
    o 'Invocation OptFuncExist Arguments',      -> new Call $1, $3, $2
    o 'SUPER',                                  -> new Call 'super', [new Splat new Literal 'arguments']
    o 'SUPER Arguments',                        -> new Call 'super', $2
  ]

  OptFuncExist: [
    o '',                                       -> no
    o 'FUNC_EXIST',                             -> yes
  ]

  Arguments: [
    o 'CALL_START CALL_END',                    -> []
    o 'CALL_START ArgList OptComma CALL_END',   -> $2
  ]

  This: [
    o 'THIS',                                   -> new Value new Literal 'this'
    o '@',                                      -> new Value new Literal 'this'
  ]

  ThisProperty: [
    o '@ Identifier',                           -> new Value new Literal('this'), [new Access($2)], 'this'
  ]

  Array: [
    o '[ ]',                                    -> new Arr []
    o '[ ArgList OptComma ]',                   -> new Arr $2
  ]

  RangeDots: [
    o '..',                                     -> 'inclusive'
    o '...',                                    -> 'exclusive'
  ]

  Range: [
    o '[ Expression RangeDots Expression ]',    -> new Range $2, $4, $3
  ]

  Slice: [
    o 'Expression RangeDots Expression',        -> new Range $1, $3, $2
    o 'Expression RangeDots',                   -> new Range $1, null, $2
    o 'RangeDots Expression',                   -> new Range null, $2, $1
    o 'RangeDots',                              -> new Range null, null, $1
  ]

  ArgList: [
    o 'Arg',                                              -> [$1]
    o 'ArgList , Arg',                                    -> $1.concat $3
    o 'ArgList OptComma TERMINATOR Arg',                  -> $1.concat $4
    o 'INDENT ArgList OptComma OUTDENT',                  -> $2
    o 'ArgList OptComma INDENT ArgList OptComma OUTDENT', -> $1.concat $4
  ]

  Arg: [
    o 'Expression'
    o 'Splat'
  ]

  SimpleArgs: [
    o 'Expression'
    o 'SimpleArgs , Expression',                -> [].concat $1, $3
  ]

  Try: [
    o 'TRY Block',                              -> new Try $2
    o 'TRY Block Catch',                        -> new Try $2, $3[0], $3[1]
    o 'TRY Block FINALLY Block',                -> new Try $2, null, null, $4
    o 'TRY Block Catch FINALLY Block',          -> new Try $2, $3[0], $3[1], $5
  ]

  Catch: [
    o 'CATCH Identifier Block',                 -> [$2, $3]
  ]

  Throw: [
    o 'THROW Expression',                       -> new Throw $2
  ]

  Parenthetical: [
    o '( Body )',                               -> new Parens $2
    o '( INDENT Body OUTDENT )',                -> new Parens $3
  ]

  WhileSource: [
    o 'WHILE Expression',                       -> new While $2
    o 'WHILE Expression WHEN Expression',       -> new While $2, guard: $4
    o 'UNTIL Expression',                       -> new While $2, invert: true
    o 'UNTIL Expression WHEN Expression',       -> new While $2, invert: true, guard: $4
  ]

  While: [
    o 'WhileSource Block',                      -> $1.addBody $2
    o 'Statement  WhileSource',                 -> $2.addBody Block.wrap [$1]
    o 'Expression WhileSource',                 -> $2.addBody Block.wrap [$1]
    o 'Loop',                                   -> $1
  ]

  Loop: [
    o 'LOOP Block',                             -> new While(new Literal 'true').addBody $2
    o 'LOOP Expression',                        -> new While(new Literal 'true').addBody Block.wrap [$2]
  ]

  For: [
    o 'Statement  ForBody',                     -> new For $1, $2
    o 'Expression ForBody',                     -> new For $1, $2
    o 'ForBody    Block',                       -> new For $2, $1
  ]

  ForBody: [
    o 'FOR Range',                              -> source: new Value($2)
    o 'ForStart ForSource',                     -> $2.own = $1.own; $2.name = $1[0]; $2.index = $1[1]; $2
  ]

  ForStart: [
    o 'FOR ForVariables',                       -> $2
    o 'FOR OWN ForVariables',                   -> $3.own = yes; $3
  ]

  ForValue: [
    o 'Identifier'
    o 'ThisProperty'
    o 'Array',                                  -> new Value $1
    o 'Object',                                 -> new Value $1
  ]

  ForVariables: [
    o 'ForValue',                               -> [$1]
    o 'ForValue , ForValue',                    -> [$1, $3]
  ]

  ForSource: [
    o 'FORIN Expression',                               -> source: $2
    o 'FOROF Expression',                               -> source: $2, object: yes
    o 'FORIN Expression WHEN Expression',               -> source: $2, guard: $4
    o 'FOROF Expression WHEN Expression',               -> source: $2, guard: $4, object: yes
    o 'FORIN Expression BY Expression',                 -> source: $2, step:  $4
    o 'FORIN Expression WHEN Expression BY Expression', -> source: $2, guard: $4, step: $6
    o 'FORIN Expression BY Expression WHEN Expression', -> source: $2, step:  $4, guard: $6
  ]

  Switch: [
    o 'SWITCH Expression INDENT Whens OUTDENT',            -> new Switch $2, $4
    o 'SWITCH Expression INDENT Whens ELSE Block OUTDENT', -> new Switch $2, $4, $6
    o 'SWITCH INDENT Whens OUTDENT',                       -> new Switch null, $3
    o 'SWITCH INDENT Whens ELSE Block OUTDENT',            -> new Switch null, $3, $5
  ]

  Whens: [
    o 'When'
    o 'Whens When',                             -> $1.concat $2
  ]

  When: [
    o 'LEADING_WHEN SimpleArgs Block',            -> [[$2, $3]]
    o 'LEADING_WHEN SimpleArgs Block TERMINATOR', -> [[$2, $3]]
  ]

  IfBlock: [
    o 'IF Expression Block',                    -> new If $2, $3, type: $1
    o 'IfBlock ELSE IF Expression Block',       -> $1.addElse new If $4, $5, type: $3
  ]

  If: [
    o 'IfBlock'
    o 'IfBlock ELSE Block',                     -> $1.addElse $3
    o 'Statement  POST_IF Expression',          -> new If $3, Block.wrap([$1]), type: $2, statement: true
    o 'Expression POST_IF Expression',          -> new If $3, Block.wrap([$1]), type: $2, statement: true
  ]

  Operation: [
    o 'UNARY Expression',                       -> new Op $1 , $2
    o '-     Expression',                      (-> new Op '-', $2), prec: 'UNARY'
    o '+     Expression',                      (-> new Op '+', $2), prec: 'UNARY'

    o '-- SimpleAssignable',                    -> new Op '--', $2
    o '++ SimpleAssignable',                    -> new Op '++', $2
    o 'SimpleAssignable --',                    -> new Op '--', $1, null, true
    o 'SimpleAssignable ++',                    -> new Op '++', $1, null, true

    o 'Expression ?',                           -> new Existence $1

    o 'Expression +  Expression',               -> new Op '+' , $1, $3
    o 'Expression -  Expression',               -> new Op '-' , $1, $3

    o 'Expression MATH     Expression',         -> new Op $2, $1, $3
    o 'Expression SHIFT    Expression',         -> new Op $2, $1, $3
    o 'Expression COMPARE  Expression',         -> new Op $2, $1, $3
    o 'Expression LOGIC    Expression',         -> new Op $2, $1, $3
    o 'Expression RELATION Expression',         ->
      if $2.charAt(0) is '!'
        new Op($2[1..], $1, $3).invert()
      else
        new Op $2, $1, $3

    o 'SimpleAssignable COMPOUND_ASSIGN
       Expression',                             -> new Assign $1, $3, $2
    o 'SimpleAssignable COMPOUND_ASSIGN
       INDENT Expression OUTDENT',              -> new Assign $1, $4, $2
    o 'SimpleAssignable EXTENDS Expression',    -> new Extends $1, $3
  ]



operators = [
  ['left',      '.', '?.', '::']
  ['left',      'CALL_START', 'CALL_END']
  ['nonassoc',  '++', '--']
  ['left',      '?']
  ['right',     'UNARY']
  ['left',      'MATH']
  ['left',      '+', '-']
  ['left',      'SHIFT']
  ['left',      'RELATION']
  ['left',      'COMPARE']
  ['left',      'LOGIC']
  ['nonassoc',  'INDENT', 'OUTDENT']
  ['right',     '=', ':', 'COMPOUND_ASSIGN', 'RETURN', 'THROW', 'EXTENDS']
  ['right',     'FORIN', 'FOROF', 'BY', 'WHEN']
  ['right',     'IF', 'ELSE', 'FOR', 'WHILE', 'UNTIL', 'LOOP', 'SUPER', 'CLASS']
  ['right',     'POST_IF']
]


tokens = []
for name, alternatives of grammar
  grammar[name] = for alt in alternatives
    for token in alt[0].split ' '
      tokens.push token unless grammar[token]
    alt

exports.parser = new Parser
  tokens      : tokens.join ' '
  bnf         : grammar
  operators   : operators.reverse()
  startSymbol : 'Root'

exports.starts = (string, literal, start) ->
  literal is string.substr start, literal.length

exports.ends = (string, literal, back) ->
  len = literal.length
  literal is string.substr string.length - len - (back or 0), len

exports.compact = (array) ->
  item for item in array when item

exports.count = (string, substr) ->
  num = pos = 0
  return 1/0 unless substr.length
  num++ while pos = 1 + string.indexOf substr, pos
  num

exports.merge = (options, overrides) ->
  extend (extend {}, options), overrides

extend = exports.extend = (object, properties) ->
  for key, val of properties
    object[key] = val
  object

exports.flatten = flatten = (array) ->
  flattened = []
  for element in array
    if element instanceof Array
      flattened = flattened.concat flatten element
    else
      flattened.push element
  flattened

exports.del = (obj, key) ->
  val =  obj[key]
  delete obj[key]
  val

exports.last = (array, back) -> array[array.length - (back or 0) - 1]

exports.some = Array::some ? (fn) ->
  return true for e in this when fn e
  false

{Rewriter, INVERSES} = require './rewriter'

{count, starts, compact, last} = require './helpers'


exports.Lexer = class Lexer

  tokenize: (code, opts = {}) ->
    code     = code.replace(/\r/g, '').replace TRAILING_SPACES, ''


    i = 0
    while @chunk = code[i..]
      i += @identifierToken() or
           @commentToken()    or
           @whitespaceToken() or
           @lineToken()       or
           @heredocToken()    or
           @stringToken()     or
           @numberToken()     or
           @regexToken()      or
           @jsToken()         or
           @literalToken()

    @closeIndentation()
    return @tokens if opts.rewrite is off
    (new Rewriter).rewrite @tokens


  identifierToken: ->
    return 0 unless match = IDENTIFIER.exec @chunk
    [input, id, colon] = match

    if id is 'own' and @tag() is 'FOR'
      @token 'OWN', id
      return id.length
    forcedIdentifier = colon or
      (prev = last @tokens) and (prev[0] in ['.', '?.', '::'] or
      not prev.spaced and prev[0] is '@')
    tag = 'IDENTIFIER'

    if not forcedIdentifier and (id in JS_KEYWORDS or id in COFFEE_KEYWORDS)
      tag = id.toUpperCase()
      if tag is 'WHEN' and @tag() in LINE_BREAK
        tag = 'LEADING_WHEN'
      else if tag is 'FOR'
        @seenFor = yes
      else if tag is 'UNLESS'
        tag = 'IF'
      else if tag in UNARY
        tag = 'UNARY'
      else if tag in RELATION
        if tag isnt 'INSTANCEOF' and @seenFor
          tag = 'FOR' + tag
          @seenFor = no
        else
          tag = 'RELATION'
          if @value() is '!'
            @tokens.pop()
            id = '!' + id

    if id in JS_FORBIDDEN
      if forcedIdentifier
        tag = 'IDENTIFIER'
        id  = new String id
        id.reserved = yes
      else if id in RESERVED

    unless forcedIdentifier
      id  = COFFEE_ALIAS_MAP[id] if id in COFFEE_ALIASES
      tag = switch id
        when '!'                 then 'UNARY'
        when '==', '!='          then 'COMPARE'
        when '&&', '||'          then 'LOGIC'
        when 'true', 'false'     then 'BOOL'
        when 'break', 'continue' then 'STATEMENT'
        else  tag

    @token tag, id
    @token ':', ':' if colon
    input.length

  numberToken: ->
    return 0 unless match = NUMBER.exec @chunk
    number = match[0]
    if /^0[BOX]/.test number
    else if /E/.test(number) and not /^0x/.test number
    else if /^0\d*[89]/.test number
    else if /^0\d+/.test number
    lexedLength = number.length
    if octalLiteral = /^0o([0-7]+)/.exec number
      number = '0x' + (parseInt octalLiteral[1], 8).toString 16
    if binaryLiteral = /^0b([01]+)/.exec number
      number = '0x' + (parseInt binaryLiteral[1], 2).toString 16
    @token 'NUMBER', number
    lexedLength

  stringToken: ->
    switch @chunk.charAt 0
      when "'"
        return 0 unless match = SIMPLESTR.exec @chunk
        @token 'STRING', (string = match[0]).replace MULTILINER, '\\\n'
      when '"'
        return 0 unless string = @balancedString @chunk, '"'
          @interpolateString string[1...-1]
        else
          @token 'STRING', @escapeLines string
      else
        return 0
    if octalEsc = /^(?:\\.|[^\\])*\\(?:0[0-7]|[1-7])/.test string
    @line += count string, '\n'
    string.length

  heredocToken: ->
    return 0 unless match = HEREDOC.exec @chunk
    heredoc = match[0]
    quote = heredoc.charAt 0
    doc = @sanitizeHeredoc match[2], quote: quote, indent: null
      @interpolateString doc, heredoc: yes
    else
      @token 'STRING', @makeString doc, quote, yes
    @line += count heredoc, '\n'
    heredoc.length

  commentToken: ->
    return 0 unless match = @chunk.match COMMENT
    [comment, here] = match
    if here
      @token 'HERECOMMENT', @sanitizeHeredoc here,
        herecomment: true, indent: Array(@indent + 1).join(' ')
    @line += count comment, '\n'
    comment.length

  jsToken: ->
    return 0 unless @chunk.charAt(0) is '`' and match = JSTOKEN.exec @chunk
    @token 'JS', (script = match[0])[1...-1]
    @line += count script, '\n'
    script.length

  regexToken: ->
    return 0 if @chunk.charAt(0) isnt '/'
    if match = HEREGEX.exec @chunk
      length = @heregexToken match
      @line += count match[0], '\n'
      return length

    prev = last @tokens
    return 0 if prev and (prev[0] in (if prev.spaced then NOT_REGEX else NOT_SPACED_REGEX))
    return 0 unless match = REGEX.exec @chunk
    [match, regex, flags] = match
    if regex[..1] is '/*' then @error 'regular expressions cannot begin with `*`'
    if regex is '//' then regex = '/(?:)/'
    match.length

  heregexToken: (match) ->
    [heregex, body, flags] = match
      re = body.replace(HEREGEX_OMIT, '').replace(/\//g, '\\/')
      if re.match /^\*/ then @error 'regular expressions cannot begin with `*`'
      return heregex.length
    @token 'IDENTIFIER', 'RegExp'
    @tokens.push ['CALL_START', '(']
    tokens = []
    for [tag, value] in @interpolateString(body, regex: yes)
      if tag is 'TOKENS'
        tokens.push value...
      else
        continue unless value = value.replace HEREGEX_OMIT, ''
        value = value.replace /\\/g, '\\\\'
        tokens.push ['STRING', @makeString(value, '"', yes)]
      tokens.push ['+', '+']
    tokens.pop()
    @tokens.push ['STRING', '""'], ['+', '+'] unless tokens[0]?[0] is 'STRING'
    @tokens.push tokens...
    @tokens.push [',', ','], ['STRING', '"' + flags + '"'] if flags
    @token ')', ')'
    heregex.length

  lineToken: ->
    return 0 unless match = MULTI_DENT.exec @chunk
    indent = match[0]
    @line += count indent, '\n'
    @seenFor = no
    size = indent.length - 1 - indent.lastIndexOf '\n'
    noNewlines = @unfinished()
    if size - @indebt is @indent
      if noNewlines then @suppressNewlines() else @newlineToken()
      return indent.length
    if size > @indent
      if noNewlines
        @indebt = size - @indent
        @suppressNewlines()
        return indent.length
      diff = size - @indent + @outdebt
      @token 'INDENT', diff
      @indents.push diff
      @ends.push 'OUTDENT'
      @outdebt = @indebt = 0
    else
      @indebt = 0
      @outdentToken @indent - size, noNewlines
    @indent = size
    indent.length

  outdentToken: (moveOut, noNewlines) ->
    while moveOut > 0
      len = @indents.length - 1
      if @indents[len] is undefined
        moveOut = 0
      else if @indents[len] is @outdebt
        moveOut -= @outdebt
        @outdebt = 0
      else if @indents[len] < @outdebt
        @outdebt -= @indents[len]
        moveOut  -= @indents[len]
      else
        dent = @indents.pop() - @outdebt
        moveOut -= dent
        @outdebt = 0
        @pair 'OUTDENT'
        @token 'OUTDENT', dent
    @outdebt -= moveOut if dent
    @tokens.pop() while @value() is ';'
    @token 'TERMINATOR', '\n' unless @tag() is 'TERMINATOR' or noNewlines
    this

  whitespaceToken: ->
    return 0 unless (match = WHITESPACE.exec @chunk) or
                    (nline = @chunk.charAt(0) is '\n')
    prev = last @tokens
    prev[if match then 'spaced' else 'newLine'] = true if prev
    if match then match[0].length else 0

  newlineToken: ->
    @tokens.pop() while @value() is ';'
    @token 'TERMINATOR', '\n' unless @tag() is 'TERMINATOR'
    this

  suppressNewlines: ->
    @tokens.pop() if @value() is '\\'
    this

  literalToken: ->
    if match = OPERATOR.exec @chunk
      [value] = match
      @tagParameters() if CODE.test value
    else
      value = @chunk.charAt 0
    tag  = value
    prev = last @tokens
    if value is '=' and prev
      if not prev[1].reserved and prev[1] in JS_FORBIDDEN
      if prev[1] in ['||', '&&']
        prev[0] = 'COMPOUND_ASSIGN'
        prev[1] += '='
        return value.length
    if value is ';'
      @seenFor = no
      tag = 'TERMINATOR'
    else if value in MATH            then tag = 'MATH'
    else if value in COMPARE         then tag = 'COMPARE'
    else if value in COMPOUND_ASSIGN then tag = 'COMPOUND_ASSIGN'
    else if value in UNARY           then tag = 'UNARY'
    else if value in SHIFT           then tag = 'SHIFT'
    else if value in LOGIC or value is '?' and prev?.spaced then tag = 'LOGIC'
    else if prev and not prev.spaced
      if value is '(' and prev[0] in CALLABLE
        prev[0] = 'FUNC_EXIST' if prev[0] is '?'
        tag = 'CALL_START'
      else if value is '[' and prev[0] in INDEXABLE
        tag = 'INDEX_START'
        switch prev[0]
          when '?'  then prev[0] = 'INDEX_SOAK'
    switch value
      when '(', '{', '[' then @ends.push INVERSES[value]
      when ')', '}', ']' then @pair value
    @token tag, value
    value.length


  sanitizeHeredoc: (doc, options) ->
    {indent, herecomment} = options
    if herecomment
      if HEREDOC_ILLEGAL.test doc
        @error "block comment cannot contain \"*/\", starting"
      return doc if doc.indexOf('\n') <= 0
    else
      while match = HEREDOC_INDENT.exec doc
        attempt = match[1]
        indent = attempt if indent is null or 0 < attempt.length < indent.length
    doc = doc.replace /^\n/, '' unless herecomment
    doc

  tagParameters: ->
    return this if @tag() isnt ')'
    stack = []
    {tokens} = this
    i = tokens.length
    tokens[--i][0] = 'PARAM_END'
    while tok = tokens[--i]
      switch tok[0]
        when ')'
          stack.push tok
        when '(', 'CALL_START'
          if stack.length then stack.pop()
          else if tok[0] is '('
            tok[0] = 'PARAM_START'
            return this
          else return this
    this

  closeIndentation: ->
    @outdentToken @indent

  balancedString: (str, end) ->
    continueCount = 0
    stack = [end]
    for i in [1...str.length]
      if continueCount
        --continueCount
        continue
      switch letter = str.charAt i
        when '\\'
          ++continueCount
          continue
        when end
          stack.pop()
          unless stack.length
            return str[0..i]
          end = stack[stack.length - 1]
          continue
      if end is '}' and letter in ['"', "'"]
        stack.push end = letter
      else if end is '}' and letter is '/' and match = (HEREGEX.exec(str[i..]) or REGEX.exec(str[i..]))
        continueCount += match[0].length - 1
      else if end is '}' and letter is '{'
        stack.push end = '}'
        stack.push end = '}'
      prev = letter

  interpolateString: (str, options = {}) ->
    {heredoc, regex} = options
    tokens = []
    pi = 0
    i  = -1
    while letter = str.charAt i += 1
      if letter is '\\'
        i += 1
        continue
             (expr = @balancedString str[i + 1..], '}')
        continue
      tokens.push ['NEOSTRING', str[pi...i]] if pi < i
      inner = expr[1...-1]
      if inner.length
        nested = new Lexer().tokenize inner, line: @line, rewrite: off
        nested.pop()
        nested.shift() if nested[0]?[0] is 'TERMINATOR'
        if len = nested.length
          if len > 1
            nested.unshift ['(', '(', @line]
            nested.push    [')', ')', @line]
          tokens.push ['TOKENS', nested]
      i += expr.length
      pi = i + 1
    tokens.push ['NEOSTRING', str[pi..]] if i > pi < str.length
    return tokens if regex
    return @token 'STRING', '""' unless tokens.length
    tokens.unshift ['', ''] unless tokens[0][0] is 'NEOSTRING'
    @token '(', '(' if interpolated = tokens.length > 1
    for [tag, value], i in tokens
      @token '+', '+' if i
      if tag is 'TOKENS'
        @tokens.push value...
      else
        @token 'STRING', @makeString value, '"', heredoc
    @token ')', ')' if interpolated
    tokens

  pair: (tag) ->
    unless tag is wanted = last @ends
      @indent -= size = last @indents
      @outdentToken size, true
      return @pair tag
    @ends.pop()


  token: (tag, value) ->
    @tokens.push [tag, value, @line]

  tag: (index, tag) ->
    (tok = last @tokens, index) and if tag then tok[0] = tag else tok[0]

  value: (index, val) ->
    (tok = last @tokens, index) and if val then tok[1] = val else tok[1]

  unfinished: ->
    LINE_CONTINUER.test(@chunk) or
    @tag() in ['\\', '.', '?.', 'UNARY', 'MATH', '+', '-', 'SHIFT', 'RELATION'
               'COMPARE', 'LOGIC', 'THROW', 'EXTENDS']

  escapeLines: (str, heredoc) ->
    str.replace MULTILINER, if heredoc then '\\n' else ''

  makeString: (body, quote, heredoc) ->
    return quote + quote unless body
    body = body.replace /\\([\s\S])/g, (match, contents) ->
      if contents in ['\n', quote] then contents else match
    quote + @escapeLines(body, heredoc) + quote

  error: (message) ->


JS_KEYWORDS = [
  'true', 'false', 'null', 'this'
  'new', 'delete', 'typeof', 'in', 'instanceof'
  'return', 'throw', 'break', 'continue', 'debugger'
  'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally'
  'class', 'extends', 'super'
]

COFFEE_KEYWORDS = ['undefined', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when']

COFFEE_ALIAS_MAP =
  and  : '&&'
  or   : '||'
  is   : '=='
  isnt : '!='
  not  : '!'
  yes  : 'true'
  no   : 'false'
  on   : 'true'
  off  : 'false'

COFFEE_ALIASES  = (key for key of COFFEE_ALIAS_MAP)
COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat COFFEE_ALIASES

RESERVED = [
  'case', 'default', 'function', 'var', 'void', 'with', 'const', 'let', 'enum'
  'export', 'import', 'native', '__hasProp', '__extends', '__slice', '__bind'
  '__indexOf', 'implements', 'interface', 'package', 'private', 'protected'
  'public', 'static', 'yield'
]

STRICT_PROSCRIBED = ['arguments', 'eval']

JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED)

exports.RESERVED = RESERVED.concat(JS_KEYWORDS).concat(COFFEE_KEYWORDS).concat(STRICT_PROSCRIBED)
exports.STRICT_PROSCRIBED = STRICT_PROSCRIBED

IDENTIFIER = /// ^
  ( [$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]* )
///

NUMBER     = ///
///i

HEREDOC    = /// ^ ("""|''') ([\s\S]*?) (?:\n[^\n\S]*)? \1 ///

OPERATOR   = /// ^ (
) ///

WHITESPACE = /^[^\n\S]+/


CODE       = /^[-=]>/

MULTI_DENT = /^(?:\n[^\n\S]*)+/

SIMPLESTR  = /^'[^\\']*(?:\\.[^\\']*)*'/

JSTOKEN    = /^`[^\\`]*(?:\\.[^\\`]*)*`/

REGEX = /// ^
  (?:
           [^ \] \n \\ ]*
           (?: \\[\s\S] [^ \] \n \\ ]* )*
         ]
    ) [^ [ / \n \\ ]*
  )*
  /) ([imgy]{0,4}) (?!\w)
///

HEREGEX      = /// ^ /{3} ([\s\S]+?) /{3} ([imgy]{0,4}) (?!\w) ///


MULTILINER      = /\n/g

HEREDOC_INDENT  = /\n+([^\n\S]*)/g

HEREDOC_ILLEGAL = /\*\//

LINE_CONTINUER  = /// ^ \s* (?: , | \??\.(?![.\d]) | :: ) ///

TRAILING_SPACES = /\s+$/

COMPOUND_ASSIGN = [
  '-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|='
]

UNARY   = ['!', '~', 'NEW', 'TYPEOF', 'DELETE', 'DO']

LOGIC   = ['&&', '||', '&', '|', '^']

SHIFT   = ['<<', '>>', '>>>']

COMPARE = ['==', '!=', '<', '>', '<=', '>=']

MATH    = ['*', '/', '%']

RELATION = ['IN', 'OF', 'INSTANCEOF']

BOOL = ['TRUE', 'FALSE']

NOT_REGEX = ['NUMBER', 'REGEX', 'BOOL', 'NULL', 'UNDEFINED', '++', '--', ']']

NOT_SPACED_REGEX = NOT_REGEX.concat ')', '}', 'THIS', 'IDENTIFIER', 'STRING'

CALLABLE  = ['IDENTIFIER', 'STRING', 'REGEX', ')', ']', '}', '?', '::', '@', 'THIS', 'SUPER']
INDEXABLE = CALLABLE.concat 'NUMBER', 'BOOL', 'NULL', 'UNDEFINED'

LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR']

{Scope} = require './scope'
{RESERVED, STRICT_PROSCRIBED} = require './lexer'

{compact, flatten, extend, merge, del, starts, ends, last, some} = require './helpers'


YES     = -> yes
NO      = -> no
THIS    = -> this
NEGATE  = -> @negated = not @negated; this


exports.Base = class Base

  compile: (o, lvl) ->
    o        = extend {}, o
    o.level  = lvl if lvl
    node     = @unfoldSoak(o) or this
    node.tab = o.indent
    if o.level is LEVEL_TOP or not node.isStatement(o)
      node.compileNode o
    else
      node.compileClosure o

  compileClosure: (o) ->
    if @jumps()
      throw SyntaxError 'cannot use a pure statement in an expression.'
    o.sharedScope = yes
    Closure.wrap(this).compileNode o

  cache: (o, level, reused) ->
    unless @isComplex()
      ref = if level then @compile o, level else this
      [ref, ref]
    else
      ref = new Literal reused or o.scope.freeVariable 'ref'
      sub = new Assign ref, this
      if level then [sub.compile(o, level), ref.value] else [sub, ref]

  compileLoopReference: (o, name) ->
    src = tmp = @compile o, LEVEL_LIST
    unless -Infinity < +src < Infinity or IDENTIFIER.test(src) and o.scope.check(src, yes)
    [src, tmp]

  makeReturn: (res) ->
    me = @unwrapAll()
    if res
    else
      new Return me

  contains: (pred) ->
    contains = no
    @traverseChildren no, (node) ->
      if pred node
        contains = yes
        return no
    contains

  containsType: (type) ->
    this instanceof type or @contains (node) -> node instanceof type

  lastNonComment: (list) ->
    i = list.length
    return list[i] while i-- when list[i] not instanceof Comment
    null

  toString: (idt = '', name = @constructor.name) ->
    tree = '\n' + idt + name
    tree += '?' if @soak
    @eachChild (node) -> tree += node.toString idt + TAB
    tree

  eachChild: (func) ->
    return this unless @children
    for attr in @children when @[attr]
      for child in flatten [@[attr]]
        return this if func(child) is false
    this

  traverseChildren: (crossScope, func) ->
    @eachChild (child) ->
      return false if func(child) is false
      child.traverseChildren crossScope, func

  invert: ->
    new Op '!', this

  unwrapAll: ->
    node = this
    continue until node is node = node.unwrap()
    node

  children: []

  isStatement     : NO
  jumps           : NO
  isComplex       : YES
  isChainable     : NO
  isAssignable    : NO

  unwrap     : THIS
  unfoldSoak : NO

  assigns: NO


exports.Block = class Block extends Base
  constructor: (nodes) ->
    @expressions = compact flatten nodes or []

  children: ['expressions']

  push: (node) ->
    @expressions.push node
    this

  pop: ->
    @expressions.pop()

  unshift: (node) ->
    @expressions.unshift node
    this

  unwrap: ->
    if @expressions.length is 1 then @expressions[0] else this

  isEmpty: ->
    not @expressions.length

  isStatement: (o) ->
    for exp in @expressions when exp.isStatement o
      return yes
    no

  jumps: (o) ->
    for exp in @expressions
      return exp if exp.jumps o

  makeReturn: (res) ->
    len = @expressions.length
    while len--
      expr = @expressions[len]
      if expr not instanceof Comment
        @expressions[len] = expr.makeReturn res
        @expressions.splice(len, 1) if expr instanceof Return and not expr.expression
        break
    this

  compile: (o = {}, level) ->
    if o.scope then super o, level else @compileRoot o

  compileNode: (o) ->
    @tab  = o.indent
    top   = o.level is LEVEL_TOP
    codes = []
    for node in @expressions
      node = node.unwrapAll()
      node = (node.unfoldSoak(o) or node)
      if node instanceof Block
        codes.push node.compileNode o
      else if top
        node.front = true
        code = node.compile o
        unless node.isStatement o
        codes.push code
      else
        codes.push node.compile o, LEVEL_LIST
    if top
      if @spaced
      else
        return codes.join '\n'
    code = codes.join(', ') or 'void 0'

  compileRoot: (o) ->
    o.indent  = if o.bare then '' else TAB
    o.scope   = new Scope null, this, null
    o.level   = LEVEL_TOP
    @spaced   = yes
    prelude   = ""
    unless o.bare
      preludeExps = for exp, i in @expressions
        break unless exp.unwrap() instanceof Comment
        exp
      rest = @expressions[preludeExps.length...]
      @expressions = preludeExps
      @expressions = rest
    code = @compileWithDeclarations o
    return code if o.bare

  compileWithDeclarations: (o) ->
    code = post = ''
    for exp, i in @expressions
      exp = exp.unwrap()
      break unless exp instanceof Comment or exp instanceof Literal
    o = merge(o, level: LEVEL_TOP)
    if i
      rest = @expressions.splice i, 9e9
      [spaced, @spaced] = [@spaced, no]
      [code  , @spaced] = [(@compileNode o), spaced]
      @expressions = rest
    post = @compileNode o
    {scope} = o
    if scope.expressions is this
      declars = o.scope.hasDeclarations()
      assigns = scope.hasAssignments
      if declars or assigns
        code += '\n' if i
        if declars
          code += scope.declaredVariables().join ', '
        if assigns
        code += ';\n'
    code + post

  @wrap: (nodes) ->
    return nodes[0] if nodes.length is 1 and nodes[0] instanceof Block
    new Block nodes


exports.Literal = class Literal extends Base
  constructor: (@value) ->

  makeReturn: ->
    if @isStatement() then this else super

  isAssignable: ->
    IDENTIFIER.test @value

  isStatement: ->
    @value in ['break', 'continue', 'debugger']

  isComplex: NO

  assigns: (name) ->
    name is @value

  jumps: (o) ->
    return this if @value is 'break' and not (o?.loop or o?.block)
    return this if @value is 'continue' and not o?.loop

  compileNode: (o) ->
    code = if @value is 'this'
      if o.scope.method?.bound then o.scope.method.context else @value
    else if @value.reserved
    else
      @value

  toString: ->
    ' "' + @value + '"'

class exports.Undefined extends Base
  isAssignable: NO
  isComplex: NO
  compileNode: (o) ->
    if o.level >= LEVEL_ACCESS then '(void 0)' else 'void 0'

class exports.Null extends Base
  isAssignable: NO
  isComplex: NO
  compileNode: -> "null"

class exports.Bool extends Base
  isAssignable: NO
  isComplex: NO
  compileNode: -> @val
  constructor: (@val) ->


exports.Return = class Return extends Base
  constructor: (expr) ->
    @expression = expr if expr and not expr.unwrap().isUndefined

  children: ['expression']

  isStatement:     YES
  makeReturn:      THIS
  jumps:           THIS

  compile: (o, level) ->
    expr = @expression?.makeReturn()
    if expr and expr not instanceof Return then expr.compile o, level else super o, level

  compileNode: (o) ->


exports.Value = class Value extends Base
  constructor: (base, props, tag) ->
    return base if not props and base instanceof Value
    @base       = base
    @properties = props or []
    @[tag]      = true if tag
    return this

  children: ['base', 'properties']

  add: (props) ->
    @properties = @properties.concat props
    this

  hasProperties: ->
    !!@properties.length

  isArray        : -> not @properties.length and @base instanceof Arr
  isComplex      : -> @hasProperties() or @base.isComplex()
  isAssignable   : -> @hasProperties() or @base.isAssignable()
  isSimpleNumber : -> @base instanceof Literal and SIMPLENUM.test @base.value
  isString       : -> @base instanceof Literal and IS_STRING.test @base.value
  isAtomic       : ->
    for node in @properties.concat @base
      return no if node.soak or node instanceof Call
    yes

  isStatement : (o)    -> not @properties.length and @base.isStatement o
  assigns     : (name) -> not @properties.length and @base.assigns name
  jumps       : (o)    -> not @properties.length and @base.jumps o

  isObject: (onlyGenerated) ->
    return no if @properties.length
    (@base instanceof Obj) and (not onlyGenerated or @base.generated)

  isSplice: ->
    last(@properties) instanceof Slice

  unwrap: ->
    if @properties.length then this else @base

  cacheReference: (o) ->
    name = last @properties
    if @properties.length < 2 and not @base.isComplex() and not name?.isComplex()
    base = new Value @base, @properties[...-1]
      bref = new Literal o.scope.freeVariable 'base'
      base = new Value new Parens new Assign bref, base
      nref = new Literal o.scope.freeVariable 'name'
      name = new Index new Assign nref, name.index
      nref = new Index nref
    [base.add(name), new Value(bref or base.base, [nref or name])]

  compileNode: (o) ->
    @base.front = @front
    props = @properties
    code  = @base.compile o, if props.length then LEVEL_ACCESS else null
    code += prop.compile o for prop in props
    code

  unfoldSoak: (o) ->
    return @unfoldedSoak if @unfoldedSoak?
    result = do =>
      if ifn = @base.unfoldSoak o
        Array::push.apply ifn.body.properties, @properties
        return ifn
      for prop, i in @properties when prop.soak
        prop.soak = off
        fst = new Value @base, @properties[...i]
        snd = new Value @base, @properties[i..]
        if fst.isComplex()
          ref = new Literal o.scope.freeVariable 'ref'
          fst = new Parens new Assign ref, fst
          snd.base = ref
        return new If new Existence(fst), snd, soak: on
      null
    @unfoldedSoak = result or no


exports.Comment = class Comment extends Base
  constructor: (@comment) ->

  isStatement:     YES
  makeReturn:      THIS

  compileNode: (o, level) ->
    code = o.indent + code if (level or o.level) is LEVEL_TOP
    code


exports.Call = class Call extends Base
  constructor: (variable, @args = [], @soak) ->
    @isNew    = false
    @isSuper  = variable is 'super'
    @variable = if @isSuper then null else variable

  children: ['variable', 'args']

  newInstance: ->
    base = @variable?.base or @variable
    if base instanceof Call and not base.isNew
      base.newInstance()
    else
      @isNew = true
    this

  superReference: (o) ->
    method = o.scope.namedMethod()
    throw SyntaxError 'cannot call super outside of a function.' unless method
    {name} = method
    throw SyntaxError 'cannot call super on an anonymous function.' unless name?
    if method.klass
      accesses = [new Access(new Literal '__super__')]
      accesses.push new Access new Literal 'constructor' if method.static
      accesses.push new Access new Literal name
      (new Value (new Literal method.klass), accesses).compile o
    else

  superThis : (o) ->
    method = o.scope.method
    (method and not method.klass and method.context) or "this"

  unfoldSoak: (o) ->
    if @soak
      if @variable
        return ifn if ifn = unfoldSoak o, this, 'variable'
        [left, rite] = new Value(@variable).cacheReference o
      else
        left = new Literal @superReference o
        rite = new Value left
      rite = new Call rite, @args
      rite.isNew = @isNew
      return new If left, new Value(rite), soak: yes
    call = this
    list = []
    loop
      if call.variable instanceof Call
        list.push call
        call = call.variable
        continue
      break unless call.variable instanceof Value
      list.push call
      break unless (call = call.variable.base) instanceof Call
    for call in list.reverse()
      if ifn
        if call.variable instanceof Call
          call.variable = ifn
        else
          call.variable.base = ifn
      ifn = unfoldSoak o, call, 'variable'
    ifn

  filterImplicitObjects: (list) ->
    nodes = []
    for node in list
      unless node.isObject?() and node.base.generated
        nodes.push node
        continue
      obj = null
      for prop in node.base.properties
        if prop instanceof Assign or prop instanceof Comment
          nodes.push obj = new Obj properties = [], true if not obj
          properties.push prop
        else
          nodes.push prop
          obj = null
    nodes

  compileNode: (o) ->
    @variable?.front = @front
    if code = Splat.compileSplattedArray o, @args, true
      return @compileSplat o, code
    args = @filterImplicitObjects @args
    args = (arg.compile o, LEVEL_LIST for arg in args).join ', '
    if @isSuper
    else

  compileSuper: (args, o) ->

  compileSplat: (o, splatArgs) ->
    if @isNew
      idt = @tab + TAB
      return """
        (function(func, args, ctor) {
      """
    base = new Value @variable
    if (name = base.properties.pop()) and base.isComplex()
      ref = o.scope.freeVariable 'ref'
    else
      fun = base.compile o, LEVEL_ACCESS
      if name
        ref = fun
        fun += name.compile o
      else
        ref = 'null'


exports.Extends = class Extends extends Base
  constructor: (@child, @parent) ->

  children: ['child', 'parent']

  compile: (o) ->
    new Call(new Value(new Literal utility 'extends'), [@child, @parent]).compile o


exports.Access = class Access extends Base
  constructor: (@name, tag) ->
    @name.asKey = yes
    @soak  = tag is 'soak'

  children: ['name']

  compile: (o) ->
    name = @name.compile o

  isComplex: NO


exports.Index = class Index extends Base
  constructor: (@index) ->

  children: ['index']

  compile: (o) ->

  isComplex: ->
    @index.isComplex()


exports.Range = class Range extends Base

  children: ['from', 'to']

  constructor: (@from, @to, tag) ->
    @exclusive = tag is 'exclusive'
    @equals = if @exclusive then '' else '='

  compileVariables: (o) ->
    o = merge o, top: true
    [@fromC, @fromVar]  =  @from.cache o, LEVEL_LIST
    [@toC, @toVar]      =  @to.cache o, LEVEL_LIST
    [@step, @stepVar]   =  step.cache o, LEVEL_LIST if step = del o, 'step'
    [@fromNum, @toNum]  = [@fromVar.match(SIMPLENUM), @toVar.match(SIMPLENUM)]
    @stepNum            = @stepVar.match(SIMPLENUM) if @stepVar

  compileNode: (o) ->
    @compileVariables o unless @fromVar
    return @compileArray(o) unless o.index

    known    = @fromNum and @toNum
    idx      = del o, 'index'
    idxName  = del o, 'name'
    namedIndex = idxName and idxName isnt idx

    condPart = if @stepNum
    else if known
      [from, to] = [+@fromNum, +@toNum]
    else

    stepPart = if @stepVar
    else if known
      if namedIndex
      else
    else
      if namedIndex
      else




  compileArray: (o) ->
    if @fromNum and @toNum and Math.abs(@fromNum - @toNum) <= 20
      range = [+@fromNum..+@toNum]
      range.pop() if @exclusive
    idt    = @tab + TAB
    i      = o.scope.freeVariable 'i'
    result = o.scope.freeVariable 'results'
    if @fromNum and @toNum
      o.index = i
      body    = @compileNode o
    else
    hasArgs = (node) -> node?.contains (n) -> n instanceof Literal and n.value is 'arguments' and not n.asKey
    args   = ', arguments' if hasArgs(@from) or hasArgs(@to)


exports.Slice = class Slice extends Base

  children: ['range']

  constructor: (@range) ->
    super()

  compileNode: (o) ->
    {to, from} = @range
    fromStr    = from and from.compile(o, LEVEL_PAREN) or '0'
    compiled   = to and to.compile o, LEVEL_PAREN
    if to and not (not @range.exclusive and +compiled is -1)
      toStr = ', ' + if @range.exclusive
        compiled
      else if SIMPLENUM.test compiled
      else
        compiled = to.compile o, LEVEL_ACCESS


exports.Obj = class Obj extends Base
  constructor: (props, @generated = false) ->
    @objects = @properties = props or []

  children: ['properties']

  compileNode: (o) ->
    props = @properties
    return (if @front then '({})' else '{}') unless props.length
    if @generated
      for node in props when node instanceof Value
        throw new Error 'cannot have an implicit value in an implicit object'
    idt         = o.indent += TAB
    lastNoncom  = @lastNonComment @properties
    props = for prop, i in props
      join = if i is props.length - 1
        ''
      else if prop is lastNoncom or prop instanceof Comment
        '\n'
      else
        ',\n'
      indent = if prop instanceof Comment then '' else idt
      if prop instanceof Value and prop.this
        prop = new Assign prop.properties[0].name, prop, 'object'
      if prop not instanceof Comment
        if prop not instanceof Assign
          prop = new Assign prop, prop, 'object'
        (prop.variable.base or prop.variable).asKey = yes
      indent + prop.compile(o, LEVEL_TOP) + join
    props = props.join ''

  assigns: (name) ->
    for prop in @properties when prop.assigns name then return yes
    no


exports.Arr = class Arr extends Base
  constructor: (objs) ->
    @objects = objs or []

  children: ['objects']

  filterImplicitObjects: Call::filterImplicitObjects

  compileNode: (o) ->
    return '[]' unless @objects.length
    o.indent += TAB
    objs = @filterImplicitObjects @objects
    return code if code = Splat.compileSplattedArray o, objs
    code = (obj.compile o, LEVEL_LIST for obj in objs).join ', '
    if code.indexOf('\n') >= 0
    else

  assigns: (name) ->
    for obj in @objects when obj.assigns name then return yes
    no


exports.Class = class Class extends Base
  constructor: (@variable, @parent, @body = new Block) ->
    @boundFuncs = []
    @body.classBody = yes

  children: ['variable', 'parent', 'body']

  determineName: ->
    return null unless @variable
    decl = if tail = last @variable.properties
      tail instanceof Access and tail.name.value
    else
      @variable.base.value
    if decl in STRICT_PROSCRIBED
    decl and= IDENTIFIER.test(decl) and decl

  setContext: (name) ->
    @body.traverseChildren false, (node) ->
      return false if node.classBody
      if node instanceof Literal and node.value is 'this'
        node.value    = name
      else if node instanceof Code
        node.klass    = name
        node.context  = name if node.bound

  addBoundFunctions: (o) ->
    if @boundFuncs.length
      for bvar in @boundFuncs
        lhs = (new Value (new Literal "this"), [new Access bvar]).compile o

  addProperties: (node, name, o) ->
    props = node.base.properties[..]
    exprs = while assign = props.shift()
      if assign instanceof Assign
        base = assign.variable.base
        delete assign.context
        func = assign.value
        if base.value is 'constructor'
          if @ctor
            throw new Error 'cannot define more than one constructor in a class'
          if func.bound
            throw new Error 'cannot define a constructor as a bound function'
          if func instanceof Code
            assign = @ctor = func
          else
            @externalCtor = o.scope.freeVariable 'class'
            assign = new Assign new Literal(@externalCtor), func
        else
          if assign.variable.this
            func.static = yes
            if func.bound
              func.context = name
          else
            assign.variable = new Value(new Literal(name), [(new Access new Literal 'prototype'), new Access base ])
            if func instanceof Code and func.bound
              @boundFuncs.push base
              func.bound = no
      assign
    compact exprs

  walkBody: (name, o) ->
    @traverseChildren false, (child) =>
      return false if child instanceof Class
      if child instanceof Block
        for node, i in exps = child.expressions
          if node instanceof Value and node.isObject(true)
            exps[i] = @addProperties node, name, o
        child.expressions = exps = flatten exps

  hoistDirectivePrologue: ->
    index = 0
    {expressions} = @body
    ++index while (node = expressions[index]) and node instanceof Comment or
      node instanceof Value and node.isString()
    @directives = expressions.splice 0, index

  ensureConstructor: (name) ->
    if not @ctor
      @ctor = new Code
      @ctor.body.makeReturn()
      @body.expressions.unshift @ctor
    @ctor.ctor     = @ctor.name = name
    @ctor.klass    = null
    @ctor.noReturn = yes

  compileNode: (o) ->
    decl  = @determineName()
    name  = decl or '_Class'
    lname = new Literal name

    @hoistDirectivePrologue()
    @setContext name
    @walkBody name, o
    @ensureConstructor name
    @body.spaced = yes
    @body.expressions.unshift @ctor unless @ctor instanceof Code
    @body.expressions.push lname
    @body.expressions.unshift @directives...
    @addBoundFunctions o

    call  = Closure.wrap @body

    if @parent
      @superClass = new Literal o.scope.freeVariable 'super', no
      @body.expressions.unshift new Extends lname, @superClass
      call.args.push @parent
      params = call.variable.params or call.variable.base.params
      params.push new Param @superClass

    klass = new Parens call, yes
    klass = new Assign @variable, klass if @variable
    klass.compile o


exports.Assign = class Assign extends Base
  constructor: (@variable, @value, @context, options) ->
    @param = options and options.param
    @subpattern = options and options.subpattern
    forbidden = (name = @variable.unwrapAll().value) in STRICT_PROSCRIBED
    if forbidden and @context isnt 'object'

  children: ['variable', 'value']

  isStatement: (o) ->
    o?.level is LEVEL_TOP and @context? and "?" in @context

  assigns: (name) ->
    @[if @context is 'object' then 'value' else 'variable'].assigns name

  unfoldSoak: (o) ->
    unfoldSoak o, this, 'variable'

  compileNode: (o) ->
    if isValue = @variable instanceof Value
      return @compilePatternMatch o if @variable.isArray() or @variable.isObject()
      return @compileSplice       o if @variable.isSplice()
      return @compileConditional  o if @context in ['||=', '&&=', '?=']
    name = @variable.compile o, LEVEL_LIST
    unless @context
      unless (varBase = @variable.unwrapAll()).isAssignable()
      unless varBase.hasProperties?()
        if @param
          o.scope.add name, 'var'
        else
          o.scope.find name
    if @value instanceof Code and match = METHOD_DEF.exec name
      @value.klass = match[1] if match[1]
      @value.name  = match[2] ? match[3] ? match[4] ? match[5]
    val = @value.compile o, LEVEL_LIST

  compilePatternMatch: (o) ->
    top       = o.level is LEVEL_TOP
    {value}   = this
    {objects} = @variable.base
    unless olen = objects.length
      code = value.compile o
    isObject = @variable.isObject()
    if top and olen is 1 and (obj = objects[0]) not instanceof Splat
      if obj instanceof Assign
        {variable: {base: idx}, value: obj} = obj
      else
        if obj.base instanceof Parens
          [obj, idx] = new Value(obj.unwrapAll()).cacheReference o
        else
          idx = if isObject
            if obj.this then obj.properties[0].name else obj
          else
            new Literal 0
      acc   = IDENTIFIER.test idx.unwrap().value or 0
      value = new Value value
      value.properties.push new (if acc then Access else Index) idx
      if obj.unwrap().value in RESERVED
      return new Assign(obj, value, null, param: @param).compile o, LEVEL_TOP
    vvar    = value.compile o, LEVEL_LIST
    assigns = []
    splat   = false
    if not IDENTIFIER.test(vvar) or @variable.assigns(vvar)
      vvar = ref
    for obj, i in objects
      idx = i
      if isObject
        if obj instanceof Assign
          {variable: {base: idx}, value: obj} = obj
        else
          if obj.base instanceof Parens
            [obj, idx] = new Value(obj.unwrapAll()).cacheReference o
          else
            idx = if obj.this then obj.properties[0].name else obj
      if not splat and obj instanceof Splat
        name = obj.name.unwrap().value
        obj = obj.unwrap()
        if rest = olen - i - 1
          ivar = o.scope.freeVariable 'i'
        else
          val += ") : []"
        val   = new Literal val
      else
        name = obj.unwrap().value
        if obj instanceof Splat
          obj = obj.name.compile o
          throw new SyntaxError \
        if typeof idx is 'number'
          idx = new Literal splat or idx
          acc = no
        else
          acc = isObject and IDENTIFIER.test idx.unwrap().value or 0
        val = new Value new Literal(vvar), [new (if acc then Access else Index) idx]
      if name? and name in RESERVED
      assigns.push new Assign(obj, val, null, param: @param, subpattern: yes).compile o, LEVEL_LIST
    assigns.push vvar unless top or @subpattern
    code = assigns.join ', '

  compileConditional: (o) ->
    [left, right] = @variable.cacheReference o
    if not left.properties.length and left.base instanceof Literal and 
           left.base.value != "this" and not o.scope.check left.base.value
    if "?" in @context then o.isExistentialEquals = true
    new Op(@context[...-1], left, new Assign(right, @value, '=') ).compile o

  compileSplice: (o) ->
    {range: {from, to, exclusive}} = @variable.properties.pop()
    name = @variable.compile o
    [fromDecl, fromRef] = from?.cache(o, LEVEL_OP) or ['0', '0']
    if to
      if from?.isSimpleNumber() and to.isSimpleNumber()
        to = +to.compile(o) - +fromRef
        to += 1 unless exclusive
      else
        to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef
        to += ' + 1' unless exclusive
    else
      to = "9e9"
    [valDef, valRef] = @value.cache o, LEVEL_LIST


exports.Code = class Code extends Base
  constructor: (params, body, tag) ->
    @params  = params or []
    @body    = body or new Block
    @bound   = tag is 'boundfunc'
    @context = '_this' if @bound

  children: ['params', 'body']

  isStatement: -> !!@ctor

  jumps: NO

  compileNode: (o) ->
    o.scope         = new Scope o.scope, @body, this
    o.scope.shared  = del(o, 'sharedScope')
    o.indent        += TAB
    delete o.bare
    delete o.isExistentialEquals
    params = []
    exprs  = []
      unless o.scope.check name then o.scope.parameter name
    for param in @params when param.splat
      for {name: p} in @params
        if p.this then p = p.properties[0].name
        if p.value then o.scope.add p.value, 'var', yes
      splats = new Assign new Value(new Arr(p.asReference o for p in @params)),
                          new Value new Literal 'arguments'
      break
    for param in @params
      if param.isComplex()
        val = ref = param.asReference o
        val = new Op '?', ref, param.value if param.value
        exprs.push new Assign new Value(param.name), val, '=', param: yes
      else
        ref = param
        if param.value
          lit = new Literal ref.name.value + ' == null'
          val = new Assign new Value(param.name), param.value, '='
          exprs.push new If lit, val
      params.push ref unless splats
    wasEmpty = @body.isEmpty()
    exprs.unshift splats if splats
    @body.expressions.unshift exprs... if exprs.length
    o.scope.parameter params[i] = p.compile o for p, i in params
    uniqs = []
    for name in @paramNames()
      uniqs.push name
    @body.makeReturn() unless wasEmpty or @noReturn
    if @bound
      if o.scope.parent.method?.bound
        @bound = @context = o.scope.parent.method.context
      else if not @static
        o.scope.parent.assign '_this', 'this'
    idt   = o.indent
    code  = 'function'
    code  += ' ' + @name if @ctor
    code  += '(' + params.join(', ') + ') {'
    code  += '}'
    return @tab + code if @ctor

  paramNames: ->
    names = []
    names.push param.names()... for param in @params
    names

  traverseChildren: (crossScope, func) ->
    super(crossScope, func) if crossScope


exports.Param = class Param extends Base
  constructor: (@name, @value, @splat) ->
    if (name = @name.unwrapAll().value) in STRICT_PROSCRIBED

  children: ['name', 'value']

  compile: (o) ->
    @name.compile o, LEVEL_LIST

  asReference: (o) ->
    return @reference if @reference
    node = @name
    if node.this
      node = node.properties[0].name
      if node.value.reserved
        node = new Literal o.scope.freeVariable node.value
    else if node.isComplex()
      node = new Literal o.scope.freeVariable 'arg'
    node = new Value node
    node = new Splat node if @splat
    @reference = node

  isComplex: ->
    @name.isComplex()

  names: (name = @name)->
    atParam = (obj) ->
      {value} = obj.properties[0].name
      return if value.reserved then [] else [value]
    return [name.value] if name instanceof Literal
    return atParam(name) if name instanceof Value
    names = []
    for obj in name.objects
      if obj instanceof Assign
        names.push obj.value.unwrap().value
      else if obj instanceof Splat
        names.push obj.name.unwrap().value
      else if obj instanceof Value
        if obj.isArray() or obj.isObject()
          names.push @names(obj.base)...
        else if obj.this
          names.push atParam(obj)...
        else names.push obj.base.value
      else
    names


exports.Splat = class Splat extends Base

  children: ['name']

  isAssignable: YES

  constructor: (name) ->
    @name = if name.compile then name else new Literal name

  assigns: (name) ->
    @name.assigns name

  compile: (o) ->
    if @index? then @compileParam o else @name.compile o

  unwrap: -> @name

  @compileSplattedArray: (o, list, apply) ->
    index = -1
    continue while (node = list[++index]) and node not instanceof Splat
    return '' if index >= list.length
    if list.length is 1
      code = list[0].compile o, LEVEL_LIST
      return code if apply
    args = list[index..]
    for node, i in args
      code = node.compile o, LEVEL_LIST
      args[i] = if node instanceof Splat
    base = (node.compile o, LEVEL_LIST for node in list[...index])


exports.While = class While extends Base
  constructor: (condition, options) ->
    @condition = if options?.invert then condition.invert() else condition
    @guard     = options?.guard

  children: ['condition', 'guard', 'body']

  isStatement: YES

  makeReturn: (res) ->
    if res
      super
    else
      @returns = not @jumps loop: yes
      this

  addBody: (@body) ->
    this

  jumps: ->
    {expressions} = @body
    return no unless expressions.length
    for node in expressions
      return node if node.jumps loop: yes
    no

  compileNode: (o) ->
    o.indent += TAB
    set      = ''
    {body}   = this
    if body.isEmpty()
      body = ''
    else
      if @returns
        body.makeReturn rvar = o.scope.freeVariable 'results'
      if @guard
        if body.expressions.length > 1
          body.expressions.unshift new If (new Parens @guard).invert(), new Literal "continue"
        else
          body = Block.wrap [new If @guard, body] if @guard
    if @returns
    code


exports.Op = class Op extends Base
  constructor: (op, first, second, flip ) ->
    return new In first, second if op is 'in'
    if op is 'do'
      return @generateDo first
    if op is 'new'
      return first.newInstance() if first instanceof Call and not first.do and not first.isNew
      first = new Parens first   if first instanceof Code and first.bound or first.do
    @operator = CONVERSIONS[op] or op
    @first    = first
    @second   = second
    @flip     = !!flip
    return this

  CONVERSIONS =
    '==': '==='
    '!=': '!=='
    'of': 'in'

  INVERSIONS =
    '!==': '==='
    '===': '!=='

  children: ['first', 'second']

  isSimpleNumber: NO

  isUnary: ->
    not @second

  isComplex: ->
    not (@isUnary() and (@operator in ['+', '-'])) or @first.isComplex()

  isChainable: ->
    @operator in ['<', '>', '>=', '<=', '===', '!==']

  invert: ->
    if @isChainable() and @first.isChainable()
      allInvertable = yes
      curr = this
      while curr and curr.operator
        allInvertable and= (curr.operator of INVERSIONS)
        curr = curr.first
      return new Parens(this).invert() unless allInvertable
      curr = this
      while curr and curr.operator
        curr.invert = !curr.invert
        curr.operator = INVERSIONS[curr.operator]
        curr = curr.first
      this
    else if op = INVERSIONS[@operator]
      @operator = op
      if @first.unwrap() instanceof Op
        @first.invert()
      this
    else if @second
      new Parens(this).invert()
    else if @operator is '!' and (fst = @first.unwrap()) instanceof Op and
                                  fst.operator in ['!', 'in', 'instanceof']
      fst
    else
      new Op '!', this

  unfoldSoak: (o) ->
    @operator in ['++', '--', 'delete'] and unfoldSoak o, this, 'first'

  generateDo: (exp) ->
    passedParams = []
    func = if exp instanceof Assign and (ref = exp.value.unwrap()) instanceof Code
      ref
    else
      exp
    for param in func.params or []
      if param.value
        passedParams.push param.value
        delete param.value
      else
        passedParams.push param
    call = new Call exp, passedParams
    call.do = yes
    call

  compileNode: (o) ->
    isChain = @isChainable() and @first.isChainable()
    @first.front = @front unless isChain
    if @operator is 'delete' and o.scope.check(@first.unwrapAll().value)
      throw SyntaxError 'delete operand may not be argument or var'
    if @operator in ['--', '++'] and @first.unwrapAll().value in STRICT_PROSCRIBED
      throw SyntaxError 'prefix increment/decrement may not have eval or arguments operand'
    return @compileUnary     o if @isUnary()
    return @compileChain     o if isChain
    return @compileExistence o if @operator is '?'
    code = @first.compile(o, LEVEL_OP) + ' ' + @operator + ' ' +
           @second.compile(o, LEVEL_OP)

  compileChain: (o) ->
    [@first.second, shared] = @first.second.cache o
    fst = @first.compile o, LEVEL_OP

  compileExistence: (o) ->
    if @first.isComplex()
      ref = new Literal o.scope.freeVariable 'ref'
      fst = new Parens new Assign ref, @first
    else
      fst = @first
      ref = fst
    new If(new Existence(fst), ref, type: 'if').addElse(@second).compile o

  compileUnary: (o) ->
    if o.level >= LEVEL_ACCESS
      return (new Parens this).compile o
    parts = [op = @operator]
    plusMinus = op in ['+', '-']
    parts.push ' ' if op in ['new', 'typeof', 'delete'] or
                      plusMinus and @first instanceof Op and @first.operator is op
    if (plusMinus && @first instanceof Op) or (op is 'new' and @first.isStatement o)
      @first = new Parens @first
    parts.push @first.compile o, LEVEL_OP
    parts.reverse() if @flip
    parts.join ''

  toString: (idt) ->
    super idt, @constructor.name + ' ' + @operator

exports.In = class In extends Base
  constructor: (@object, @array) ->

  children: ['object', 'array']

  invert: NEGATE

  compileNode: (o) ->
    if @array instanceof Value and @array.isArray()
      for obj in @array.base.objects when obj instanceof Splat
        hasSplat = yes
        break
      return @compileOrTest o unless hasSplat
    @compileLoopTest o

  compileOrTest: (o) ->
    [sub, ref] = @object.cache o, LEVEL_OP
    [cmp, cnj] = if @negated then [' !== ', ' && '] else [' === ', ' || ']
    tests = for item, i in @array.base.objects
      (if i then ref else sub) + cmp + item.compile o, LEVEL_ACCESS
    tests = tests.join cnj

  compileLoopTest: (o) ->
    [sub, ref] = @object.cache o, LEVEL_LIST
           if @negated then '< 0' else '>= 0'
    return code if sub is ref
    code = sub + ', ' + code

  toString: (idt) ->
    super idt, @constructor.name + if @negated then '!' else ''


exports.Try = class Try extends Base
  constructor: (@attempt, @error, @recovery, @ensure) ->

  children: ['attempt', 'recovery', 'ensure']

  isStatement: YES

  jumps: (o) -> @attempt.jumps(o) or @recovery?.jumps(o)

  makeReturn: (res) ->
    @attempt  = @attempt .makeReturn res if @attempt
    @recovery = @recovery.makeReturn res if @recovery
    this

  compileNode: (o) ->
    o.indent  += TAB
    tryPart   = @attempt.compile o, LEVEL_TOP

    catchPart = if @recovery
      if @error.value in STRICT_PROSCRIBED
      o.scope.add @error.value, 'param' unless o.scope.check @error.value
    else unless @ensure or @recovery
      ' catch (_error) {}'




exports.Throw = class Throw extends Base
  constructor: (@expression) ->

  children: ['expression']

  isStatement: YES
  jumps:       NO

  makeReturn: THIS

  compileNode: (o) ->


exports.Existence = class Existence extends Base
  constructor: (@expression) ->

  children: ['expression']

  invert: NEGATE

  compileNode: (o) ->
    @expression.front = @front
    code = @expression.compile o, LEVEL_OP
    if IDENTIFIER.test(code) and not o.scope.check code
      [cmp, cnj] = if @negated then ['===', '||'] else ['!==', '&&']
    else


exports.Parens = class Parens extends Base
  constructor: (@body) ->

  children: ['body']

  unwrap    : -> @body
  isComplex : -> @body.isComplex()

  compileNode: (o) ->
    expr = @body.unwrap()
    if expr instanceof Value and expr.isAtomic()
      expr.front = @front
      return expr.compile o
    code = expr.compile o, LEVEL_PAREN
    bare = o.level < LEVEL_OP and (expr instanceof Op or expr instanceof Call or
      (expr instanceof For and expr.returns))


exports.For = class For extends While
  constructor: (body, source) ->
    {@source, @guard, @step, @name, @index} = source
    @body    = Block.wrap [body]
    @own     = !!source.own
    @object  = !!source.object
    [@name, @index] = [@index, @name] if @object
    throw SyntaxError 'index cannot be a pattern matching expression' if @index instanceof Value
    @range   = @source instanceof Value and @source.base instanceof Range and not @source.properties.length
    @pattern = @name instanceof Value
    throw SyntaxError 'indexes do not apply to range loops' if @range and @index
    throw SyntaxError 'cannot pattern match over range loops' if @range and @pattern
    @returns = false

  children: ['body', 'source', 'guard', 'step']

  compileNode: (o) ->
    body      = Block.wrap [@body]
    lastJumps = last(body.expressions)?.jumps()
    @returns  = no if lastJumps and lastJumps instanceof Return
    source    = if @range then @source.base else @source
    scope     = o.scope
    name      = @name  and @name.compile o, LEVEL_LIST
    index     = @index and @index.compile o, LEVEL_LIST
    scope.find(name)  if name and not @pattern
    scope.find(index) if index
    rvar      = scope.freeVariable 'results' if @returns
    ivar      = (@object and index) or scope.freeVariable 'i'
    kvar      = (@range and name) or index or ivar
    stepvar   = scope.freeVariable "step" if @step and not @range
    name      = ivar if @pattern
    varPart   = ''
    guardPart = ''
    defPart   = ''
    idt1      = @tab + TAB
    if @range
      forPart = source.compile merge(o, {index: ivar, name, @step})
    else
      svar    = @source.compile o, LEVEL_LIST
      if (name or @own) and not IDENTIFIER.test svar
        svar       = ref
      if name and not @pattern
      unless @object
        lvar       = scope.freeVariable 'len'
    if @returns
      body.makeReturn rvar
    if @guard
      if body.expressions.length > 1
        body.expressions.unshift new If (new Parens @guard).invert(), new Literal "continue"
      else
        body = Block.wrap [new If @guard, body] if @guard
    if @pattern
    defPart     += @pluckDirectCall o, body
    if @object
    body        = body.compile merge(o, indent: idt1), LEVEL_TOP
    body        = '\n' + body + '\n' if body
    """
    """

  pluckDirectCall: (o, body) ->
    defs = ''
    for expr, idx in body.expressions
      expr = expr.unwrapAll()
      continue unless expr instanceof Call
      val = expr.variable.unwrapAll()
      continue unless (val instanceof Code) or
                      (val instanceof Value and
                      val.base?.unwrapAll() instanceof Code and
                      val.properties.length is 1 and
                      val.properties[0].name?.value in ['call', 'apply'])
      fn    = val.base?.unwrapAll() or val
      ref   = new Literal o.scope.freeVariable 'fn'
      base  = new Value ref
      if val.base
        [val.base, base] = [base, val]
      body.expressions[idx] = new Call base, expr.args
      defs += @tab + new Assign(ref, fn).compile(o, LEVEL_TOP) + ';\n'
    defs


exports.Switch = class Switch extends Base
  constructor: (@subject, @cases, @otherwise) ->

  children: ['subject', 'cases', 'otherwise']

  isStatement: YES

  jumps: (o = {block: yes}) ->
    for [conds, block] in @cases
      return block if block.jumps o
    @otherwise?.jumps o

  makeReturn: (res) ->
    pair[1].makeReturn res for pair in @cases
    @otherwise or= new Block [new Literal 'void 0'] if res
    @otherwise?.makeReturn res
    this

  compileNode: (o) ->
    idt1 = o.indent + TAB
    idt2 = o.indent = idt1 + TAB
    for [conditions, block], i in @cases
      for cond in flatten [conditions]
        cond  = cond.invert() unless @subject
      code += body + '\n' if body = block.compile o, LEVEL_TOP
      break if i is @cases.length - 1 and not @otherwise
      expr = @lastNonComment block.expressions
      continue if expr instanceof Return or (expr instanceof Literal and expr.jumps() and expr.value isnt 'debugger')
      code += idt2 + 'break;\n'
    code +  @tab + '}'


exports.If = class If extends Base
  constructor: (condition, @body, options = {}) ->
    @condition = if options.type is 'unless' then condition.invert() else condition
    @elseBody  = null
    @isChain   = false
    {@soak}    = options

  children: ['condition', 'body', 'elseBody']

  bodyNode:     -> @body?.unwrap()
  elseBodyNode: -> @elseBody?.unwrap()

  addElse: (elseBody) ->
    if @isChain
      @elseBodyNode().addElse elseBody
    else
      @isChain  = elseBody instanceof If
      @elseBody = @ensureBlock elseBody
    this

  isStatement: (o) ->
    o?.level is LEVEL_TOP or
      @bodyNode().isStatement(o) or @elseBodyNode()?.isStatement(o)

  jumps: (o) -> @body.jumps(o) or @elseBody?.jumps(o)

  compileNode: (o) ->
    if @isStatement o then @compileStatement o else @compileExpression o

  makeReturn: (res) ->
    @elseBody  or= new Block [new Literal 'void 0'] if res
    @body     and= new Block [@body.makeReturn res]
    @elseBody and= new Block [@elseBody.makeReturn res]
    this

  ensureBlock: (node) ->
    if node instanceof Block then node else new Block [node]

  compileStatement: (o) ->
    child    = del o, 'chainChild'
    exeq     = del o, 'isExistentialEquals'

    if exeq
      return new If(@condition.invert(), @elseBodyNode(), type: 'if').compile o

    cond     = @condition.compile o, LEVEL_PAREN
    o.indent += TAB
    body     = @ensureBlock(@body)
    ifPart   = @tab + ifPart unless child
    return ifPart unless @elseBody
    ifPart + ' else ' + if @isChain
      o.indent = @tab
      o.chainChild = yes
      @elseBody.unwrap().compile o, LEVEL_TOP
    else

  compileExpression: (o) ->
    cond = @condition.compile o, LEVEL_COND
    body = @bodyNode().compile o, LEVEL_LIST
    alt  = if @elseBodyNode() then @elseBodyNode().compile(o, LEVEL_LIST) else 'void 0'

  unfoldSoak: ->
    @soak and this



Closure =

  wrap: (expressions, statement, noReturn) ->
    return expressions if expressions.jumps()
    func = new Code [], Block.wrap [expressions]
    args = []
    if (mentionsArgs = expressions.contains @literalArgs) or expressions.contains @literalThis
      meth = new Literal if mentionsArgs then 'apply' else 'call'
      args = [new Literal 'this']
      args.push new Literal 'arguments' if mentionsArgs
      func = new Value func, [new Access meth]
    func.noReturn = noReturn
    call = new Call func, args
    if statement then Block.wrap [call] else call

  literalArgs: (node) ->
    node instanceof Literal and node.value is 'arguments' and not node.asKey

  literalThis: (node) ->
    (node instanceof Literal and node.value is 'this' and not node.asKey) or
      (node instanceof Code and node.bound) or
      (node instanceof Call and node.isSuper)

unfoldSoak = (o, parent, name) ->
  return unless ifn = parent[name].unfoldSoak o
  parent[name] = ifn.body
  ifn.body = new Value parent
  ifn


UTILITIES =

  extends: -> """
  """

  bind: -> '''
    function(fn, me){ return function(){ return fn.apply(me, arguments); }; }
  '''

  indexOf: -> """
    [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }
  """

  hasProp: -> '{}.hasOwnProperty'
  slice  : -> '[].slice'


TAB = '  '

IDENTIFIER_STR = "[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*"
SIMPLENUM  = /^[+-]?\d+$/
METHOD_DEF = ///
  ^
    (?:
      \.prototype
      (?:
      | \[("(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*')\]
      | \[(0x[\da-fA-F]+ | \d*\.?\d+ (?:[eE][+-]?\d+)?)\]
      )
    )
  |
  $
///

IS_STRING = /^['"]/


utility = (name) ->
  Scope.root.assign ref, UTILITIES[name]()
  ref

multident = (code, tab) ->
  code = code.replace /\n/g, '$&' + tab
  code.replace /\s+$/, ''
exports.OptionParser = class OptionParser

  constructor: (rules, @banner) ->
    @rules = buildRules rules

  parse: (args) ->
    options = arguments: []
    skippingArgument = no
    originalArgs = args
    args = normalizeArguments args
    for arg, i in args
      if skippingArgument
        skippingArgument = no
        continue
      if arg is '--'
        pos = originalArgs.indexOf '--'
        options.arguments = options.arguments.concat originalArgs[(pos + 1)..]
        break
      isOption = !!(arg.match(LONG_FLAG) or arg.match(SHORT_FLAG))
      seenNonOptionArg = options.arguments.length > 0
      unless seenNonOptionArg
        matchedRule = no
        for rule in @rules
          if rule.shortFlag is arg or rule.longFlag is arg
            value = true
            if rule.hasArgument
              skippingArgument = yes
              value = args[i + 1]
            options[rule.name] = if rule.isList then (options[rule.name] or []).concat value else value
            matchedRule = yes
            break
      if seenNonOptionArg or not isOption
        options.arguments.push arg
    options

  help: ->
    lines = []
    for rule in @rules
      spaces  = 15 - rule.longFlag.length
      spaces  = if spaces > 0 then Array(spaces + 1).join(' ') else ''
      letPart = if rule.shortFlag then rule.shortFlag + ', ' else '    '
      lines.push '  ' + letPart + rule.longFlag + spaces + rule.description


LONG_FLAG  = /^(--\w[\w\-]*)/
SHORT_FLAG = /^(-\w)$/
MULTI_FLAG = /^-(\w{2,})/
OPTIONAL   = /\[(\w+(\*?))\]/

buildRules = (rules) ->
  for tuple in rules
    tuple.unshift null if tuple.length < 3
    buildRule tuple...

buildRule = (shortFlag, longFlag, description, options = {}) ->
  match     = longFlag.match(OPTIONAL)
  longFlag  = longFlag.match(LONG_FLAG)[1]
  {
    name:         longFlag.substr 2
    shortFlag:    shortFlag
    longFlag:     longFlag
    description:  description
    hasArgument:  !!(match and match[1])
    isList:       !!(match and match[2])
  }

normalizeArguments = (args) ->
  args = args[..]
  result = []
  for arg in args
    if match = arg.match MULTI_FLAG
      result.push '-' + l for l in match[1].split ''
    else
      result.push arg
  result

stdin = process.openStdin()
stdout = process.stdout

CoffeeScript = require './coffee-script'
readline     = require 'readline'
{inspect}    = require 'util'
{Script}     = require 'vm'
Module       = require 'module'


REPL_PROMPT = 'coffee> '
REPL_PROMPT_MULTILINE = '------> '
REPL_PROMPT_CONTINUATION = '......> '
enableColours = no
unless process.platform is 'win32'
  enableColours = not process.env.NODE_DISABLE_COLORS

error = (err) ->
  stdout.write (err.stack or err.toString()) + '\n'


ACCESSOR  = /\s*([\w\.]+)(?:\.(\w*))$/
SIMPLEVAR = /(\w+)$/i

autocomplete = (text) ->
  completeAttribute(text) or completeVariable(text) or [[], text]

completeAttribute = (text) ->
  if match = text.match ACCESSOR
    [all, obj, prefix] = match
    try obj = Script.runInThisContext obj
    catch e
      return
    return unless obj?
    obj = Object obj
    candidates = Object.getOwnPropertyNames obj
    while obj = Object.getPrototypeOf obj
      for key in Object.getOwnPropertyNames obj when key not in candidates
        candidates.push key
    completions = getCompletions prefix, candidates
    [completions, prefix]

completeVariable = (text) ->
  free = text.match(SIMPLEVAR)?[1]
  free = "" if text is ""
  if free?
    vars = Script.runInThisContext 'Object.getOwnPropertyNames(Object(this))'
    keywords = (r for r in CoffeeScript.RESERVED when r[..1] isnt '__')
    candidates = vars
    for key in keywords when key not in candidates
      candidates.push key
    completions = getCompletions free, candidates
    [completions, free]

getCompletions = (prefix, candidates) ->
  el for el in candidates when 0 is el.indexOf prefix

process.on 'uncaughtException', error

backlog = ''

run = (buffer) ->
  buffer = buffer.replace /[\r\n]+$/, ""
  if multilineMode
    repl.setPrompt REPL_PROMPT_CONTINUATION
    repl.prompt()
    return
  if !buffer.toString().trim() and !backlog
    repl.prompt()
    return
  code = backlog += buffer
  if code[code.length - 1] is '\\'
    repl.setPrompt REPL_PROMPT_CONTINUATION
    repl.prompt()
    return
  repl.setPrompt REPL_PROMPT
  backlog = ''
  try
    _ = global._
      filename: 'repl'
      modulename: 'repl'
    }
    if returnValue is undefined
      global._ = _
  catch err
    error err
  repl.prompt()

if stdin.readable and stdin.isRaw
  pipedInput = ''
  repl =
    prompt: -> stdout.write @_prompt
    setPrompt: (p) -> @_prompt = p
    input: stdin
    output: stdout
    on: ->
  stdin.on 'data', (chunk) ->
    pipedInput += chunk
    return unless /\n/.test pipedInput
    lines = pipedInput.split "\n"
    pipedInput = lines[lines.length - 1]
    for line in lines[...-1] when line
      run line
    return
  stdin.on 'end', ->
    for line in pipedInput.trim().split "\n" when line
      run line
    stdout.write '\n'
    process.exit 0
else
  if readline.createInterface.length < 3
    repl = readline.createInterface stdin, autocomplete
    stdin.on 'data', (buffer) -> repl.write buffer
  else
    repl = readline.createInterface stdin, stdout, autocomplete

multilineMode = off

repl.input.on 'keypress', (char, key) ->
  return unless key and key.ctrl and not key.meta and not key.shift and key.name is 'v'
  cursorPos = repl.cursor
  repl.output.cursorTo 0
  repl.output.clearLine 1
  multilineMode = not multilineMode
  repl._line() if not multilineMode and backlog
  backlog = ''
  repl.setPrompt (newPrompt = if multilineMode then REPL_PROMPT_MULTILINE else REPL_PROMPT)
  repl.prompt()
  repl.output.cursorTo newPrompt.length + (repl.cursor = cursorPos)

repl.input.on 'keypress', (char, key) ->
  return unless multilineMode and repl.line
  return unless key and key.ctrl and not key.meta and not key.shift and key.name is 'd'
  multilineMode = off
  repl._line()

repl.on 'attemptClose', ->
  if multilineMode
    multilineMode = off
    repl.output.cursorTo 0
    repl.output.clearLine 1
    repl._onLine repl.line
    return
  if backlog or repl.line
    backlog = ''
    repl.historyIndex = -1
    repl.setPrompt REPL_PROMPT
    repl.output.write '\n(^C again to quit)'
    repl._line (repl.line = '')
  else
    repl.close()

repl.on 'close', ->
  repl.output.write '\n'
  repl.input.destroy()

repl.on 'line', run

repl.setPrompt REPL_PROMPT
repl.prompt()

class exports.Rewriter


  rewrite: (@tokens) ->
    @removeLeadingNewlines()
    @removeMidExpressionNewlines()
    @closeOpenCalls()
    @closeOpenIndexes()
    @addImplicitIndentation()
    @tagPostfixConditionals()
    @addImplicitBraces()
    @addImplicitParentheses()
    @tokens

  scanTokens: (block) ->
    {tokens} = this
    i = 0
    i += block.call this, token, i, tokens while token = tokens[i]
    true

  detectEnd: (i, condition, action) ->
    {tokens} = this
    levels = 0
    while token = tokens[i]
      return action.call this, token, i     if levels is 0 and condition.call this, token, i
      return action.call this, token, i - 1 if not token or levels < 0
      if token[0] in EXPRESSION_START
        levels += 1
      else if token[0] in EXPRESSION_END
        levels -= 1
      i += 1
    i - 1

  removeLeadingNewlines: ->
    break for [tag], i in @tokens when tag isnt 'TERMINATOR'
    @tokens.splice 0, i if i

  removeMidExpressionNewlines: ->
    @scanTokens (token, i, tokens) ->
      return 1 unless token[0] is 'TERMINATOR' and @tag(i + 1) in EXPRESSION_CLOSE
      tokens.splice i, 1
      0

  closeOpenCalls: ->

    condition = (token, i) ->
      token[0] in [')', 'CALL_END'] or
      token[0] is 'OUTDENT' and @tag(i - 1) is ')'

    action = (token, i) ->
      @tokens[if token[0] is 'OUTDENT' then i - 1 else i][0] = 'CALL_END'

    @scanTokens (token, i) ->
      @detectEnd i + 1, condition, action if token[0] is 'CALL_START'
      1

  closeOpenIndexes: ->

    condition = (token, i) ->
      token[0] in [']', 'INDEX_END']

    action = (token, i) ->
      token[0] = 'INDEX_END'

    @scanTokens (token, i) ->
      @detectEnd i + 1, condition, action if token[0] is 'INDEX_START'
      1

  addImplicitBraces: ->

    stack       = []
    start       = null
    startsLine  = null
    sameLine    = yes
    startIndent = 0
    startIndex  = 0

    condition = (token, i) ->
      [one, two, three] = @tokens[i + 1 .. i + 3]
      return no if 'HERECOMMENT' is one?[0]
      [tag] = token
      sameLine = no if tag in LINEBREAKS
      return (
        (tag in ['TERMINATOR', 'OUTDENT'] or 
          (tag in IMPLICIT_END and sameLine and not (i - startIndex is 1))) and
        ((!startsLine and @tag(i - 1) isnt ',') or
          not (two?[0] is ':' or one?[0] is '@' and three?[0] is ':'))) or
        (tag is ',' and one and
          one[0] not in ['IDENTIFIER', 'NUMBER', 'STRING', '@', 'TERMINATOR', 'OUTDENT']
      )

    action = (token, i) ->
      tok = @generate '}', '}', token[2]
      @tokens.splice i, 0, tok

    @scanTokens (token, i, tokens) ->
      if (tag = token[0]) in EXPRESSION_START
        stack.push [(if tag is 'INDENT' and @tag(i - 1) is '{' then '{' else tag), i]
        return 1
      if tag in EXPRESSION_END
        start = stack.pop()
        return 1
      return 1 unless tag is ':' and
        ((ago = @tag i - 2) is ':' or stack[stack.length - 1]?[0] isnt '{')
      sameLine = yes
      startIndex = i + 1
      stack.push ['{']
      idx =  if ago is '@' then i - 2 else i - 1
      idx -= 2 while @tag(idx - 2) is 'HERECOMMENT'
      prevTag = @tag(idx - 1)
      startsLine = not prevTag or (prevTag in LINEBREAKS)
      value = new String('{')
      value.generated = yes
      tok = @generate '{', value, token[2]
      tokens.splice idx, 0, tok
      @detectEnd i + 2, condition, action
      2

  addImplicitParentheses: ->

    noCall = seenSingle = seenControl = no

    condition = (token, i) ->
      [tag] = token
      return yes if not seenSingle and token.fromThen
      seenSingle  = yes if tag in ['IF', 'ELSE', 'CATCH', '->', '=>', 'CLASS']
      seenControl = yes if tag in ['IF', 'ELSE', 'SWITCH', 'TRY', '=']
      return yes if tag in ['.', '?.', '::'] and @tag(i - 1) is 'OUTDENT'
      not token.generated and @tag(i - 1) isnt ',' and (tag in IMPLICIT_END or
        (tag is 'INDENT' and not seenControl)) and
        (tag isnt 'INDENT' or
          (@tag(i - 2) not in ['CLASS', 'EXTENDS'] and @tag(i - 1) not in IMPLICIT_BLOCK and
          not ((post = @tokens[i + 1]) and post.generated and post[0] is '{')))

    action = (token, i) ->
      @tokens.splice i, 0, @generate 'CALL_END', ')', token[2]

    @scanTokens (token, i, tokens) ->
      tag     = token[0]
      noCall  = yes if tag in ['CLASS', 'IF', 'FOR', 'WHILE']
      [prev, current, next] = tokens[i - 1 .. i + 1]
      callObject  = not noCall and tag is 'INDENT' and
                    next and next.generated and next[0] is '{' and
                    prev and prev[0] in IMPLICIT_FUNC
      seenSingle  = no
      seenControl = no
      noCall      = no if tag in LINEBREAKS
      token.call  = yes if prev and not prev.spaced and tag is '?'
      return 1 if token.fromThen
      return 1 unless callObject or
        prev?.spaced and (prev.call or prev[0] in IMPLICIT_FUNC) and
        (tag in IMPLICIT_CALL or not (token.spaced or token.newLine) and tag in IMPLICIT_UNSPACED_CALL)
      tokens.splice i, 0, @generate 'CALL_START', '(', token[2]
      @detectEnd i + 1, condition, action
      prev[0] = 'FUNC_EXIST' if prev[0] is '?'
      2

  addImplicitIndentation: ->

    starter = indent = outdent = null

    condition = (token, i) ->
      token[1] isnt ';' and token[0] in SINGLE_CLOSERS and
      not (token[0] is 'ELSE' and starter not in ['IF', 'THEN'])

    action = (token, i) ->
      @tokens.splice (if @tag(i - 1) is ',' then i - 1 else i), 0, outdent

    @scanTokens (token, i, tokens) ->
      [tag] = token
      if tag is 'TERMINATOR' and @tag(i + 1) is 'THEN'
        tokens.splice i, 1
        return 0
      if tag is 'ELSE' and @tag(i - 1) isnt 'OUTDENT'
        tokens.splice i, 0, @indentation(token)...
        return 2
      if tag is 'CATCH' and @tag(i + 2) in ['OUTDENT', 'TERMINATOR', 'FINALLY']
        tokens.splice i + 2, 0, @indentation(token)...
        return 4
      if tag in SINGLE_LINERS and @tag(i + 1) isnt 'INDENT' and
         not (tag is 'ELSE' and @tag(i + 1) is 'IF')
        starter = tag
        [indent, outdent] = @indentation token, yes
        indent.fromThen   = true if starter is 'THEN'
        tokens.splice i + 1, 0, indent
        @detectEnd i + 2, condition, action
        tokens.splice i, 1 if tag is 'THEN'
        return 1
      return 1

  tagPostfixConditionals: ->

    original = null

    condition = (token, i) ->
      token[0] in ['TERMINATOR', 'INDENT']

    action = (token, i) ->
      if token[0] isnt 'INDENT' or (token.generated and not token.fromThen)
        original[0] = 'POST_' + original[0]

    @scanTokens (token, i) ->
      return 1 unless token[0] is 'IF'
      original = token
      @detectEnd i + 1, condition, action
      1

  indentation: (token, implicit = no) ->
    indent  = ['INDENT', 2, token[2]]
    outdent = ['OUTDENT', 2, token[2]]
    indent.generated = outdent.generated = yes if implicit
    [indent, outdent]

  generate: (tag, value, line) ->
    tok = [tag, value, line]
    tok.generated = yes
    tok

  tag: (i) -> @tokens[i]?[0]


BALANCED_PAIRS = [
  ['(', ')']
  ['[', ']']
  ['{', '}']
  ['INDENT', 'OUTDENT'],
  ['CALL_START', 'CALL_END']
  ['PARAM_START', 'PARAM_END']
  ['INDEX_START', 'INDEX_END']
]

exports.INVERSES = INVERSES = {}

EXPRESSION_START = []
EXPRESSION_END   = []

for [left, rite] in BALANCED_PAIRS
  EXPRESSION_START.push INVERSES[rite] = left
  EXPRESSION_END  .push INVERSES[left] = rite

EXPRESSION_CLOSE = ['CATCH', 'WHEN', 'ELSE', 'FINALLY'].concat EXPRESSION_END

IMPLICIT_FUNC    = ['IDENTIFIER', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS']

IMPLICIT_CALL    = [
  'IDENTIFIER', 'NUMBER', 'STRING', 'JS', 'REGEX', 'NEW', 'PARAM_START', 'CLASS'
  'IF', 'TRY', 'SWITCH', 'THIS', 'BOOL', 'NULL', 'UNDEFINED', 'UNARY', 'SUPER'
  '@', '->', '=>', '[', '(', '{', '--', '++'
]

IMPLICIT_UNSPACED_CALL = ['+', '-']

IMPLICIT_BLOCK   = ['->', '=>', '{', '[', ',']

IMPLICIT_END     = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR']

SINGLE_LINERS    = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN']
SINGLE_CLOSERS   = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN']

LINEBREAKS       = ['TERMINATOR', 'INDENT', 'OUTDENT']

{extend, last} = require './helpers'

exports.Scope = class Scope

  @root: null

  constructor: (@parent, @expressions, @method) ->
    @variables = [{name: 'arguments', type: 'arguments'}]
    @positions = {}
    Scope.root = this unless @parent

  add: (name, type, immediate) ->
    return @parent.add name, type, immediate if @shared and not immediate
    if Object::hasOwnProperty.call @positions, name
      @variables[@positions[name]].type = type
    else
      @positions[name] = @variables.push({name, type}) - 1

  namedMethod: ->
    return @method if @method.name or !@parent
    @parent.namedMethod()

  find: (name) ->
    return yes if @check name
    @add name, 'var'
    no

  parameter: (name) ->
    return if @shared and @parent.check name, yes
    @add name, 'param'

  check: (name) ->
    !!(@type(name) or @parent?.check(name))

  temporary: (name, index) ->
    if name.length > 1
      '_' + name + if index > 1 then index - 1 else ''
    else
      '_' + (index + parseInt name, 36).toString(36).replace /\d/g, 'a'

  type: (name) ->
    return v.type for v in @variables when v.name is name
    null

  freeVariable: (name, reserve=true) ->
    index = 0
    index++ while @check((temp = @temporary name, index))
    @add temp, 'var', yes if reserve
    temp

  assign: (name, value) ->
    @add name, {value, assigned: yes}, yes
    @hasAssignments = yes

  hasDeclarations: ->
    !!@declaredVariables().length

  declaredVariables: ->
    realVars = []
    tempVars = []
    for v in @variables when v.type is 'var'
      (if v.name.charAt(0) is '_' then tempVars else realVars).push v.name
    realVars.sort().concat tempVars.sort()

  assignedVariables: ->



test "trailing commas", ->
  trailingComma = [1, 2, 3,]
  ok (trailingComma[0] is 1) and (trailingComma[2] is 3) and (trailingComma.length is 3)

  trailingComma = [
    1, 2, 3,
    4, 5, 6
    7, 8, 9,
  ]
  (sum = (sum or 0) + n) for n in trailingComma

  a = [((x) -> x), ((x) -> x * x)]
  ok a.length is 2

test "incorrect indentation without commas", ->
  result = [['a']
   {b: 'c'}]
  ok result[0][0] is 'a'
  ok result[1]['b'] is 'c'



test "array splat expansions with assignments", ->
  nums = [1, 2, 3]
  list = [a = 0, nums..., b = 4]
  eq 0, a
  eq 4, b
  arrayEq [0,1,2,3,4], list


test "mixed shorthand objects in array lists", ->

  arr = [
    a:1
    'b'
    c:1
  ]
  ok arr.length is 3
  ok arr[2].c is 1

  arr = [b: 1, a: 2, 100]
  eq arr[1], 100

  arr = [a:0, b:1, (1 + 1)]
  eq arr[1], 2

  arr = [a:1, 'a', b:1, 'b']
  eq arr.length, 4
  eq arr[2].b, 1
  eq arr[3], 'b'


test "array splats with nested arrays", ->
  nonce = {}
  a = [nonce]
  list = [1, 2, a...]
  eq list[0], 1
  eq list[2], nonce

  a = [[nonce]]
  list = [1, 2, a...]
  arrayEq list, [1, 2, [nonce]]

  a = false
  fn = -> a = true
  [] = fn()
  ok a


test "context property assignment (using @)", ->
  nonce = {}
  addMethod = ->
    @method = -> nonce
    this
  eq nonce, addMethod.call({}).method()

test "unassignable values", ->
  nonce = {}
  for nonref in ['', '""', '0', 'f()'].concat CoffeeScript.RESERVED


test "boolean operators", ->
  nonce = {}

  a  = 0
  a or= nonce
  eq nonce, a

  b  = 1
  b or= nonce
  eq 1, b

  c = 0
  c and= nonce
  eq 0, c

  d = 1
  d and= nonce
  eq nonce, d

  e = f = false
  e and= f or true
  eq false, e

test "compound assignment as a sub expression", ->
  [a, b, c] = [1, 2, 3]
  eq 6, (a + b += c)
  eq 1, a
  eq 5, b
  eq 3, c

test "compound assignment should be careful about caching variables", ->
  count = 0
  list = []

  list[++count] or= 1
  eq 1, list[1]
  eq 1, count

  list[++count] ?= 2
  eq 2, list[2]
  eq 2, count

  list[count++] and= 6
  eq 6, list[2]
  eq 3, count

  base = ->
    ++count
    base

  base().four or= 4
  eq 4, base.four
  eq 4, count

  base().five ?= 5
  eq 5, base.five
  eq 5, count

test "compound assignment with implicit objects", ->
  obj = undefined
  obj ?=
    one: 1

  eq 1, obj.one

  obj and=
    two: 2

  eq undefined, obj.one
  eq         2, obj.two

test "compound assignment (math operators)", ->
  num = 10
  num -= 5
  eq 5, num

  num *= 10
  eq 50, num

  num /= 10
  eq 5, num

  num %= 3
  eq 2, num

test "more compound assignment", ->
  a = {}
  val = undefined
  val ||= a
  val ||= true
  eq a, val

  b = {}
  val &&= true
  eq val, true
  val &&= b
  eq b, val

  c = {}
  val = null
  val ?= c
  val ?= true
  eq c, val



test "empty destructuring assignment", ->
  {} = [] = undefined

test "chained destructuring assignments", ->
  [a] = {0: b} = {'0': c} = [nonce={}]
  eq nonce, a
  eq nonce, b
  eq nonce, c

test "variable swapping to verify caching of RHS values when appropriate", ->
  a = nonceA = {}
  b = nonceB = {}
  c = nonceC = {}
  [a, b, c] = [b, c, a]
  eq nonceB, a
  eq nonceC, b
  eq nonceA, c
  [a, b, c] = [b, c, a]
  eq nonceC, a
  eq nonceA, b
  eq nonceB, c
  fn = ->
    [a, b, c] = [b, c, a]
  arrayEq [nonceA,nonceB,nonceC], fn()
  eq nonceA, a
  eq nonceB, b
  eq nonceC, c

  nonces = [nonceA={},nonceB={}]
  eq nonces, [a, b] = [c, d] = nonces
  eq nonceA, a
  eq nonceA, c
  eq nonceB, b
  eq nonceB, d

test "destructuring assignment with splats", ->
  a = {}; b = {}; c = {}; d = {}; e = {}
  [x,y...,z] = [a,b,c,d,e]
  eq a, x
  arrayEq [b,c,d], y
  eq e, z

test "deep destructuring assignment with splats", ->
  a={}; b={}; c={}; d={}; e={}; f={}; g={}; h={}; i={}
  [u, [v, w..., x], y..., z] = [a, [b, c, d, e], f, g, h, i]
  eq a, u
  eq b, v
  arrayEq [c,d], w
  eq e, x
  arrayEq [f,g,h], y
  eq i, z

test "destructuring assignment with objects", ->
  a={}; b={}; c={}
  obj = {a,b,c}
  {a:x, b:y, c:z} = obj
  eq a, x
  eq b, y
  eq c, z

test "deep destructuring assignment with objects", ->
  a={}; b={}; c={}; d={}
  obj = {
    a
    b: {
      'c': {
        d: [
          b
          {e: c, f: d}
        ]
      }
    }
  }
  {a: w, 'b': {c: d: [x, {'f': z, e: y}]}} = obj
  eq a, w
  eq b, x
  eq c, y
  eq d, z

test "destructuring assignment with objects and splats", ->
  a={}; b={}; c={}; d={}
  obj = a: b: [a, b, c, d]
  {a: b: [y, z...]} = obj
  eq a, y
  arrayEq [b,c,d], z

test "destructuring assignment against an expression", ->
  a={}; b={}
  [y, z] = if true then [a, b] else [b, a]
  eq a, y
  eq b, z

test "bracket insertion when necessary", ->
  [a] = [0] ? [1]
  eq a, 0


test "destructuring assignment with context (@) properties", ->
  a={}; b={}; c={}; d={}; e={}
  obj =
    fn: () ->
      local = [a, {b, c}, d, e]
      [@a, {b: @b, c: @c}, @d, @e] = local
  eq undefined, obj[key] for key in ['a','b','c','d','e']
  obj.fn()
  eq a, obj.a
  eq b, obj.b
  eq c, obj.c
  eq d, obj.d
  eq e, obj.e

  eq 2 * [] = 3 + 5, 16

  disallowed = ['eval', 'arguments'].concat CoffeeScript.RESERVED
  t = tSplat = null
  doesNotThrow ->
    for v in disallowed

  {length} = new Array
  eq 0, length



test "existential assignment", ->
  nonce = {}
  a = false
  a ?= nonce
  eq false, a
  b = undefined
  b ?= nonce
  eq nonce, b
  c = null
  c ?= nonce
  eq nonce, c

  throws (-> CoffeeScript.compile "x ?= 10"),        null, "prohibit (x ?= 10)"
  throws (-> CoffeeScript.compile "x ||= 10"),       null, "prohibit (x ||= 10)"
  throws (-> CoffeeScript.compile "x or= 10"),       null, "prohibit (x or= 10)"
  throws (-> CoffeeScript.compile "do -> x ?= 10"),  null, "prohibit (do -> x ?= 10)"
  throws (-> CoffeeScript.compile "do -> x ||= 10"), null, "prohibit (do -> x ||= 10)"
  throws (-> CoffeeScript.compile "do -> x or= 10"), null, "prohibit (do -> x or= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; x ?= 10"),        "allow (x = null; x ?= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; x ||= 10"),       "allow (x = null; x ||= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; x or= 10"),       "allow (x = null; x or= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; do -> x ?= 10"),  "allow (x = null; do -> x ?= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; do -> x ||= 10"), "allow (x = null; do -> x ||= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; do -> x or= 10"), "allow (x = null; do -> x or= 10)"
  
  throws (-> CoffeeScript.compile "-> -> -> x ?= 10"), null, "prohibit (-> -> -> x ?= 10)"
  doesNotThrow (-> CoffeeScript.compile "x = null; -> -> -> x ?= 10"), "allow (x = null; -> -> -> x ?= 10)"
  
test "more existential assignment", ->
  global.temp ?= 0
  eq global.temp, 0
  global.temp or= 100
  eq global.temp, 100
  delete global.temp

  nonce = {}
  a = nonce
  b = (a ?= 0)
  eq nonce, b
  eq a ?= b ?= 1, nonce
  
  if a then a ?= 2 else a = 3
  eq a, nonce

  nonce = {}
  for nonref in ['', '""', '0', 'f()', '(->)'].concat CoffeeScript.RESERVED

  nonce = {}
  accesses = ['o.a', 'o["a"]', '(o.a)', '(o.a).a', '@o.a', 'C::a', 'C::', 'f().a', 'o?.a', 'o?.a.b', 'f?().a']
  for access in accesses
      code =
        """
        nonce = {}; nonce2 = {}; nonce3 = {};
        @o = o = new (class C then a:{}); f = -> o
        """
      eq nonce, unless (try CoffeeScript.run code, bare: true catch e then true) then nonce
  subpatterns = ['[sub, sub2, sub3]', '{0: sub, 1: sub2, 2: sub3}']
  for subpattern in subpatterns
    for i,j in [1,2,3]
      code =
        """
        nonce = {}; nonce2 = {}; nonce3 = {};
        unless sub is nonce and sub2 is nonce2 and sub3 is nonce3 then throw new Error('[sub...]')
        """
      eq nonce, unless (try CoffeeScript.run code, bare: true catch e then true) then nonce

  name =
  'dave'

  eq name, 'dave'

  doesNotThrow -> CoffeeScript.compile '([a...]) ->'
  doesNotThrow -> CoffeeScript.compile '([a...],b) ->'
  doesNotThrow -> CoffeeScript.compile '([a...],[b...]) ->'
  throws -> CoffeeScript.compile '([a...,[a...]]) ->'
  doesNotThrow -> CoffeeScript.compile '([a...,[b...]]) ->'

  throws -> CoffeeScript.compile '([a()])->'
  throws -> CoffeeScript.compile '([a:b()])->'
  throws -> CoffeeScript.compile '([a:b.c()])->'
  throws -> CoffeeScript.compile '({a()})->'
  throws -> CoffeeScript.compile '({a:b()})->'
  throws -> CoffeeScript.compile '({a:b.c()})->'


  toString = Boolean::toString

  eq toString, true['toString']
  eq toString, false['toString']
  eq toString, yes['toString']
  eq toString, no['toString']
  eq toString, on['toString']
  eq toString, off['toString']

  eq toString, true.toString
  eq toString, false.toString
  eq toString, yes.toString
  eq toString, no.toString
  eq toString, on.toString
  eq toString, off.toString


test "classes with a four-level inheritance chain", ->

  class Base
    func: (string) ->

    @static: (string) ->

  class FirstChild extends Base
    func: (string) ->
      super('one/') + string

  SecondChild = class extends FirstChild
    func: (string) ->
      super('two/') + string

  thirdCtor = ->
    @array = [1, 2, 3]

  class ThirdChild extends SecondChild
    constructor: -> thirdCtor.call this

    func: (string) ->
      super('three/') + string

  result = (new ThirdChild).func 'four'

  ok result is 'zero/one/two/three/four'
  ok Base.static('word') is 'static/word'

  FirstChild::func = (string) ->
    super('one/').length + string

  result = (new ThirdChild).func 'four'

  ok result is '9two/three/four'

  ok (new ThirdChild).array.join(' ') is '1 2 3'


test "constructors with inheritance and super", ->

  identity = (f) -> f

  class TopClass
    constructor: (arg) ->
      @prop = 'top-' + arg

  class SuperClass extends TopClass
    constructor: (arg) ->
      identity super 'super-' + arg

  class SubClass extends SuperClass
    constructor: ->
      identity super 'sub'

  ok (new SubClass).prop is 'top-super-sub'


test "Overriding the static property new doesn't clobber Function::new", ->

  class OneClass
    @new: 'new'
    function: 'function'
    constructor: (name) -> @name = name

  class TwoClass extends OneClass
  delete TwoClass.new

  Function.prototype.new = -> new this arguments...

  ok (TwoClass.new('three')).name is 'three'
  ok (new OneClass).function is 'function'
  ok OneClass.new is 'new'

  delete Function.prototype.new


test "basic classes, again, but in the manual prototype style", ->

  Base = ->
  Base::func = (string) ->
    'zero/' + string
  Base::['func-func'] = (string) ->

  FirstChild = ->
  SecondChild = ->
  ThirdChild = ->
    @array = [1, 2, 3]
    this

  ThirdChild extends SecondChild extends FirstChild extends Base

  FirstChild::func = (string) ->
    super('one/') + string

  SecondChild::func = (string) ->
    super('two/') + string

  ThirdChild::func = (string) ->
    super('three/') + string

  result = (new ThirdChild).func 'four'

  ok result is 'zero/one/two/three/four'

  ok (new ThirdChild)['func-func']('thing') is 'dynamic-thing'


test "super with plain ol' functions as the original constructors", ->

TopClass = (arg) ->
  @prop = 'top-' + arg
  this

SuperClass = (arg) ->
  super 'super-' + arg
  this

SubClass = ->
  super 'sub'
  this

SuperClass extends TopClass
SubClass extends SuperClass

ok (new SubClass).prop is 'top-super-sub'


test "'@' referring to the current instance, and not being coerced into a call", ->

  class ClassName
    amI: ->
      @ instanceof ClassName

  obj = new ClassName
  ok obj.amI()


test "super() calls in constructors of classes that are defined as object properties", ->

  class Hive
    constructor: (name) -> @name = name

  class Hive.Bee extends Hive
    constructor: (name) -> super

  maya = new Hive.Bee 'Maya'
  ok maya.name is 'Maya'


test "classes with JS-keyword properties", ->

  class Class
    class: 'class'
    name: -> @class

  instance = new Class
  ok instance.class is 'class'
  ok instance.name() is 'class'


test "Classes with methods that are pre-bound to the instance, or statically, to the class", ->

  class Dog
    constructor: (name) ->
      @name = name

    bark: =>

    @static = =>
      new this('Dog')

  spark = new Dog('Spark')
  fido  = new Dog('Fido')
  fido.bark = spark.bark

  ok fido.bark() is 'Spark woofs!'

  obj = func: Dog.static

  ok obj.func().name is 'Dog'


test "a bound function in a bound function", ->

  class Mini
    num: 10
    generate: =>
      for i in [1..3]
        =>
          @num

  m = new Mini
  eq (func() for func in m.generate()).join(' '), '10 10 10'


test "contructor called with varargs", ->

  class Connection
    constructor: (one, two, three) ->
      [@one, @two, @three] = [one, two, three]

    out: ->

  list = [3, 2, 1]
  conn = new Connection list...
  ok conn instanceof Connection
  ok conn.out() is '3-2-1'


test "calling super and passing along all arguments", ->

  class Parent
    method: (args...) -> @args = args

  class Child extends Parent
    method: -> super

  c = new Child
  c.method 1, 2, 3, 4
  ok c.args.join(' ') is '1 2 3 4'


test "classes wrapped in decorators", ->

  func = (klass) ->
    klass::prop = 'value'
    klass

  func class Test
    prop2: 'value2'

  ok (new Test).prop  is 'value'
  ok (new Test).prop2 is 'value2'


test "anonymous classes", ->

  obj =
    klass: class
      method: -> 'value'

  instance = new obj.klass
  ok instance.method() is 'value'


test "Implicit objects as static properties", ->

  class Static
    @static =
      one: 1
      two: 2

  ok Static.static.one is 1
  ok Static.static.two is 2


test "nothing classes", ->

  c = class
  ok c instanceof Function


test "classes with static-level implicit objects", ->

  class A
    @static = one: 1
    two: 2

  class B
    @static = one: 1,
    two: 2

  eq A.static.one, 1
  eq A.static.two, undefined
  eq (new A).two, 2

  eq B.static.one, 1
  eq B.static.two, 2
  eq (new B).two, undefined


test "classes with value'd constructors", ->

  counter = 0
  classMaker = ->
    inner = ++counter
    ->
      @value = inner

  class One
    constructor: classMaker()

  class Two
    constructor: classMaker()

  eq (new One).value, 1
  eq (new Two).value, 2
  eq (new One).value, 1
  eq (new Two).value, 2


test "exectuable class bodies", ->

  class A
    if true
      b: 'b'
    else
      c: 'c'

  a = new A

  eq a.b, 'b'
  eq a.c, undefined


test "mild metaprogramming", ->

  class Base
    @attr: (name) ->
      @::[name] = (val) ->
        if arguments.length > 0
        else

  class Robot extends Base
    @attr 'power'
    @attr 'speed'

  robby = new Robot

  ok robby.power() is undefined

  robby.power 11
  robby.speed Infinity

  eq robby.power(), 11
  eq robby.speed(), Infinity


test "namespaced classes do not reserve their function name in outside scope", ->

  one = {}
  two = {}

  class one.Klass
    @label = "one"

  class two.Klass
    @label = "two"

  eq typeof Klass, 'undefined'
  eq one.Klass.label, 'one'
  eq two.Klass.label, 'two'


test "nested classes", ->

  class Outer
    constructor: ->
      @label = 'outer'

    class @Inner
      constructor: ->
        @label = 'inner'

  eq (new Outer).label, 'outer'
  eq (new Outer.Inner).label, 'inner'


test "variables in constructor bodies are correctly scoped", ->

  class A
    x = 1
    constructor: ->
      x = 10
      y = 20
    y = 2
    captured: ->
      {x, y}

  a = new A
  eq a.captured().x, 10
  eq a.captured().y, 2



  class A
    @B: class
      @c = -> 5

  eq A.B.c(), 5


test "`class extends this`", ->

  class A
    func: -> 'A'

  B = null
  makeClass = ->
    B = class extends this
      func: -> super + ' B'

  makeClass.call A

  eq (new B()).func(), 'A B'


test "ensure that constructors invoked with splats return a new object", ->

  args = [1, 2, 3]
  Type = (@args) ->
  type = new Type args

  ok type and type instanceof Type
  ok type.args and type.args instanceof Array
  ok v is args[i] for v, i in type.args

  Type1 = (@a, @b, @c) ->
  type1 = new Type1 args...

  ok type1 instanceof   Type1
  eq type1.constructor, Type1
  ok type1.a is args[0] and type1.b is args[1] and type1.c is args[2]

  called = 0
  get = -> if called++ then false else class Type
  new get() args...

test "`new` shouldn't add extra parens", ->

  ok new Date().constructor is Date


test "`new` works against bare function", ->

  eq Date, new ->
    eq this, new => this
    Date


  ctor = ->
    @val = 1
  class A
  class B extends A
    constructor: ctor
  eq (new B).val, 1

  ctor = ->
  class A
  class B extends A
    method: ->
    constructor: ctor
  ok B::method

  nonce = {}
  class A
  class B extends A
    prop: nonce
    constructor: ->
  eq nonce, B::prop

  counter = 0
  makeFn = (n) -> eq n, ++counter; ->
  class B extends (makeFn 1)
    @B: makeFn 2
    constructor: makeFn 3

  fn = ->
    {one: 1}
    this
  class B
  class A
    constructor: fn
    method: => this instanceof A
  ok (new A).method.call(new B)

  class C
    delete: =>
  ok C::delete

  class C
    do: -> super
  ok C::do

  class B
    0: -> super
  ok B::[0]

  nonce  = {}
  nonce2 = {}
  class C
    constructor: (@id) ->
    @boundStaticColon: => new this(nonce)
    @boundStaticEqual= => new this(nonce2)
  eq nonce,  C.boundStaticColon().id
  eq nonce2, C.boundStaticEqual().id

  eq 'function', typeof (class @for)
  ok not /\beval\b/.test (class @eval).toString()
  ok not /\barguments\b/.test (class @arguments).toString()
).call {}

  id = (x) -> x
  nonce = {}
  class A then nonce: nonce
  class B extends id A
  eq nonce, (new B).nonce


  class Parent
    method: ->
      'NO'
    @method: ->
      'yes'

  class Child extends Parent
    @method: ->
      'pass? ' + super

  eq Child.method(), 'pass? yes'


  class Store
    @bound: =>
      do =>
        eq this, Store

  Store.bound()


  class Store

    eq this, Store

    @bound: =>
      do =>
        eq this, Store

    @unbound: ->
      eq this, Store

    instance: =>
      ok this instanceof Store

  Store.bound()
  Store.unbound()
  (new Store).instance()

  class A
  class @A extends A

  ok (new @A) instanceof A

  ident = (x) -> x

  result = ident class A then x = 1

  eq result, A

  result = ident class B extends A
    x = 1

  eq result, B

  ctor = -> {}
  class A then constructor: ctor
  ok (new A) not instanceof A


  class A

  class B extends A
    @static: => 'value'

  eq B.static(), 'value'

  nonce = {}
  error = 'do -> ok this'
  return unless (try CoffeeScript.run strictTest, bare: yes catch e then nonce) is nonce


  comments = ["""
  class
    'use strict'
  """
  class
    'use strict'
  """
  class
    'use strict'
  ]
  throws (-> CoffeeScript.run comment, bare: yes) for comment in comments

  directives = ["""
  class
    'directive 1'
    'use strict'
  """
  class
    'use strict'
    'directive 2'
  """
  class
    'directive 1'
    'use strict'
  """
  class
    'directive 1'
    'use strict'
  ]
  throws (-> CoffeeScript.run directive, bare: yes) for directive in directives

  try
    do ->
      'use strict'
      class A
  catch e
    ok no



test "comments in objects", ->
  obj1 = {
    one: 1
    two: 2
  }

  ok Object::hasOwnProperty.call(obj1,'one')
  eq obj1.one, 1
  ok Object::hasOwnProperty.call(obj1,'two')
  eq obj1.two, 2

test "comments in YAML-style objects", ->
  obj2 =
    three: 3
    four: 4

  ok Object::hasOwnProperty.call(obj2,'three')
  eq obj2.three, 3
  ok Object::hasOwnProperty.call(obj2,'four')
  eq obj2.four, 4

test "comments following operators that continue lines", ->
  sum =
    1 +
    1
  eq 3, sum

test "comments in functions", ->
  fn = ->
    false
    false

    true

  ok fn()

    fn()

  ok fn2()

test "trailing comment before an outdent", ->
  nonce = {}
  fn3 = ->
    if true
    nonce

  eq nonce, fn3()

test "comments in a switch", ->
  nonce = {}
    when false then undefined
      undefined

  eq nonce, result

test "comment with conditional statements", ->
  nonce = {}
    undefined
    nonce
  eq nonce, result

test "spaced comments with conditional statements", ->
  nonce = {}
  result = if false
    undefined

  else if false
    undefined

  else
    nonce

  eq nonce, result



  This is a here-comment.
  Kind of like a heredoc.

test "block comments in objects", ->
  a = {}
  b = {}
  obj = {
    a: a
    comment
    b: b
  }

  eq a, obj.a
  eq b, obj.b

test "block comments in YAML-style", ->
  a = {}
  b = {}
  obj =
    a: a
    comment
    b: b

  eq a, obj.a
  eq b, obj.b


test "block comments in functions", ->
  nonce = {}

  fn1 = ->
    true
    false

  ok fn1()

  fn2 =  ->
    block comment
    nonce

  eq nonce, fn2()

  fn3 = ->
    nonce
  block comment

  eq nonce, fn3()

  fn4 = ->
    one = ->
        block comment
      two = ->
        three = ->
          nonce

  eq nonce, fn4()()()()

test "block comments inside class bodies", ->
  class A
    a: ->

    Comment
    b: ->

  ok A.prototype.b instanceof Function

  class B
    Comment
    a: ->
    b: ->

  ok B.prototype.a instanceof Function


cantCompile = (code) ->
  throws -> CoffeeScript.compile code


test "ensure that carriage returns don't break compilation on Windows", ->
  doesNotThrow -> CoffeeScript.compile 'one\r\ntwo', bare: on

test "--bare", ->
  eq -1, CoffeeScript.compile('x = y', bare: on).indexOf 'function'
  ok 'passed' is CoffeeScript.eval '"passed"', bare: on, filename: 'test'

  eq 0, CoffeeScript.compile('x = y', header: on).indexOf header

test "header is disabled by default", ->
  eq -1, CoffeeScript.compile('x = y').indexOf header

test "multiple generated references", ->
  a = {b: []}
  a.b[true] = -> this == a.b
  c = 0
  d = []
  ok a.b[0<++c<2] d...

test "splat on a line by itself is invalid", ->
  cantCompile "x 'a'\n...\n"

test "Issue 750", ->

  cantCompile 'f(->'

  cantCompile 'a = (break)'

  cantCompile 'a = (return 5 for item in list)'

  cantCompile 'a = (return 5 while condition)'

  cantCompile 'a = for x in y\n  return 5'

  λ = 5
  eq λ, 5

test "don't accidentally stringify keywords", ->
  ok (-> this == 'this')() is false

  cantCompile '''
    if a
      b
    else
      c
    else
      d
  '''


  object = eq
  @["__proto__"] = true
  ok __proto__

test "reference named hasOwnProperty", ->
  CoffeeScript.compile 'hasOwnProperty = 0; a = 1'



test "Basic array comprehensions.", ->

  nums    = (n * n for n in [1, 2, 3] when n & 1)
  results = (n * 2 for n in nums)

  ok results.join(',') is '2,18'


test "Basic object comprehensions.", ->

  obj   = {one: 1, two: 2, three: 3}
  names = (prop + '!' for prop of obj)
  odds  = (prop + '!' for prop, value of obj when value & 1)

  ok names.join(' ') is "one! two! three!"
  ok odds.join(' ')  is "one! three!"


test "Basic range comprehensions.", ->

  nums = (i * 3 for i in [1..3])

  negs = (x for x in [-20..-5*2])
  negs = negs[0..2]

  result = nums.concat(negs).join(', ')

  ok result is '3, 6, 9, -20, -19, -18'


test "With range comprehensions, you can loop in steps.", ->

  results = (x for x in [0...15] by 5)
  ok results.join(' ') is '0 5 10'

  results = (x for x in [0..100] by 10)
  ok results.join(' ') is '0 10 20 30 40 50 60 70 80 90 100'


test "And can loop downwards, with a negative step.", ->

  results = (x for x in [5..1])

  ok results.join(' ') is '5 4 3 2 1'
  ok results.join(' ') is [(10-5)..(-2+3)].join(' ')

  results = (x for x in [10..1])
  ok results.join(' ') is [10..1].join(' ')

  results = (x for x in [10...0] by -2)
  ok results.join(' ') is [10, 8, 6, 4, 2].join(' ')


test "Range comprehension gymnastics.", ->


  a = 6
  b = 0
  c = -2



test "Multiline array comprehension with filter.", ->

  evens = for num in [1, 2, 3, 4, 5, 6] when not (num & 1)
             num *= -1
             num -= 2
             num * -1
  eq evens + '', '4,6,8'


  test "The in operator still works, standalone.", ->

    ok 2 of evens


test "all isn't reserved.", ->

  all = 1


test "Ensure that the closure wrapper preserves local variables.", ->

  obj = {}

  for method in ['one', 'two', 'three'] then do (method) ->
    obj[method] = ->
      "I'm " + method

  ok obj.one()   is "I'm one"
  ok obj.two()   is "I'm two"
  ok obj.three() is "I'm three"


test "Index values at the end of a loop.", ->

  i = 0
  for i in [1..3]
    -> 'func'
    break if false
  ok i is 4


test "Ensure that local variables are closed over for range comprehensions.", ->

  funcs = for i in [1..3]
    do (i) ->
      -> -i

  eq (func() for func in funcs).join(' '), '-1 -2 -3'
  ok i is 4


test "Even when referenced in the filter.", ->

  list = ['one', 'two', 'three']

  methods = for num, i in list when num isnt 'two' and i isnt 1
    do (num, i) ->
      -> num + ' ' + i

  ok methods.length is 2
  ok methods[0]() is 'one 0'
  ok methods[1]() is 'three 2'


test "Even a convoluted one.", ->

  funcs = []

  for i in [1..3]
    do (i) ->
      x = i * 2
      ((z)->
        funcs.push -> z + ' ' + i
      )(x)

  ok (func() for func in funcs).join(', ') is '2 1, 4 2, 6 3'

  funcs = []

  results = for i in [1..3]
    do (i) ->
      z = (x * 3 for x in [1..i])
      ((a, b, c) -> [a, b, c].join(' ')).apply this, z

  ok results.join(', ') is '3  , 3 6 , 3 6 9'


test "Naked ranges are expanded into arrays.", ->

  array = [0..10]
  ok(num % 2 is 0 for num in array by 2)


test "Nested shared scopes.", ->

  foo = ->
    for i in [0..7]
      do (i) ->
        for j in [0..7]
          do (j) ->
            -> i + j

  eq foo()[3][4](), 7


test "Scoped loop pattern matching.", ->

  a = [[0], [1]]
  funcs = []

  for [v] in a
    do (v) ->
      funcs.push -> v

  eq funcs[0](), 0
  eq funcs[1](), 1


test "Nested comprehensions.", ->

  multiLiner =
    for x in [3..5]
      for y in [3..5]
        [x, y]

  singleLiner =
    (([x, y] for y in [3..5]) for x in [3..5])

  ok multiLiner.length is singleLiner.length
  ok 5 is multiLiner[2][2][1]
  ok 5 is singleLiner[2][2][1]


test "Comprehensions within parentheses.", ->

  result = null
  store = (obj) -> result = obj
  store (x * 2 for x in [3, 2, 1])

  ok result.join(' ') is '6 4 2'


test "Closure-wrapped comprehensions that refer to the 'arguments' object.", ->

  expr = ->
    result = (item * item for item in arguments)

  ok expr(2, 4, 8).join(' ') is '4 16 64'


test "Fast object comprehensions over all properties, including prototypal ones.", ->

  class Cat
    constructor: -> @name = 'Whiskers'
    breed: 'tabby'
    hair:  'cream'

  whiskers = new Cat
  own = (value for own key, value of whiskers)
  all = (value for key, value of whiskers)

  ok own.join(' ') is 'Whiskers'
  ok all.sort().join(' ') is 'Whiskers cream tabby'


test "Optimized range comprehensions.", ->

  exxes = ('x' for [0...10])
  ok exxes.join(' ') is 'x x x x x x x x x x'
  
  
test "Loop variables should be able to reference outer variables", ->
  outer = 1
  do ->
    null for outer in [1, 2, 3]
  eq outer, 3


test "Lenient on pure statements not trying to reach out of the closure", ->

  val = for i in [1]
    for j in [] then break
    i
  ok val[0] is i


test "Comprehensions only wrap their last line in a closure, allowing other lines
  to have pure expressions in them.", ->

  func = -> for i in [1]
    break if i is 2
    j for j in [1]

  ok func()[0][0] is 1

  i = 6
  odds = while i--
    continue unless i & 1
    i

  ok odds.join(', ') is '5, 3, 1'



  facets = {}
  list = ['one', 'two']

  (->
    for entity in list
      facets[entity] = -> entity
  )()

  eq typeof entity, 'undefined'
  eq facets['two'](), 'two'



  a = {b: {c: [1, 2, 3]}}
  for d in a.b?.c
    e = d

  eq e, 3



  funcs = []
  list  = ->
    [1, 2, 3]

  for y in list()
    do (y) ->
      z = y

  eq funcs[1](), "y is 2 and z is 2"


test "Cancel the comprehension if there's a jump inside the loop.", ->

  result = try
    for i in [0...10]
      continue if i < 5
    i

  eq result, 10


test "Comprehensions over break.", ->

  arrayEq (break for [1..10]), []


test "Comprehensions over continue.", ->

  arrayEq (continue for [1..10]), []


test "Comprehensions over function literals.", ->

  a = 0
  for f in [-> a = 1]
    do (f) ->
      do f

  eq a, 1


test "Comprehensions that mention arguments.", ->

  list = [arguments: 10]
  args = for f in list
    do (f) ->
      f.arguments
  eq args[0], 10


test "expression conversion under explicit returns", ->
  nonce = {}
  fn = ->
    return (nonce for x in [1,2,3])
  arrayEq [nonce,nonce,nonce], fn()
  fn = ->
    return [nonce for x in [1,2,3]][0]
  arrayEq [nonce,nonce,nonce], fn()
  fn = ->
    return [(nonce for x in [1..3])][0]
  arrayEq [nonce,nonce,nonce], fn()


test "implicit destructuring assignment in object of objects", ->
  a={}; b={}; c={}
  obj = {
    a: { d: a },
    b: { d: b }
    c: { d: c }
  }
  result = ([y,z] for y, { d: z } of obj)
  arrayEq [['a',a],['b',b],['c',c]], result


test "implicit destructuring assignment in array of objects", ->
  a={}; b={}; c={}; d={}; e={}; f={}
  arr = [
    { a: a, b: { c: b } },
    { a: c, b: { c: d } },
    { a: e, b: { c: f } }
  ]
  result = ([y,z] for { a: y, b: { c: z } } in arr)
  arrayEq [[a,b],[c,d],[e,f]], result


test "implicit destructuring assignment in array of arrays", ->
  a={}; b={}; c={}; d={}; e={}; f={}
  arr = [[a, [b]], [c, [d]], [e, [f]]]
  result = ([y,z] for [y, [z]] in arr)
  arrayEq [[a,b],[c,d],[e,f]], result

  lista = [1, 2, 3, 4, 5]
  listb = (_i + 1 for _i in lista)
  arrayEq [2, 3, 4, 5, 6], listb

  a = [0,1,2]
  fi = gi = hi = 0
  f = -> ++fi
  g = -> ++gi
  h = -> ++hi

  forCompile = []
  rangeCompileSimple = []

  for v,i in a by f() then forCompile.push i

  rangeCompileSimple = (i for i in [0..2] by g())

  arrayEq a, forCompile
  arrayEq a, rangeCompileSimple

  ns = for n in [0..99]
    if n > 9
      break
    else if n & 1
      continue
    else
      n

  ns = for n in [1..9]
    if n % 2
      continue unless n % 5
      n

  ns = for n in [1..9]
    switch
      when n % 2
        continue unless n % 5
        n

  eq '3,4,5', do ->
    for a in [1..9] then \
    for b in [1..9]
      c = Math.sqrt a*a + b*b
      return String [a, b, c] unless c % 1

  n = 1
  iterations = 0
  arr = [0..n]
  for v, k in arr
    ++iterations
    v = k = 5
    eq 5, k
  eq 2, k
  eq 2, iterations

  iterations = 0
  for v in [0..n]
    ++iterations
  eq 2, k
  eq 2, iterations

  arr = ([v, v + 1] for v in [0..5])
  iterations = 0
  for own [v0, v1], k in arr when v0
    k += 3
    ++iterations
  eq 6, k
  eq 5, iterations

  y = for x in [1, 2]
    foo: "foo" + x
  eq 2, y.length
  eq "foo1", y[0].foo
  eq "foo2", y[1].foo

  x = 2
  y = while x
    x: --x
  eq 2, y.length
  eq 1, y[0].x
  eq 0, y[1].x
  
  obj = {
    item: null
    method: ->
      for @item in [1, 2, 3]
        null
  }
  eq obj.item, null
  obj.method()
  eq obj.item, 3



id = (_) -> if arguments.length is 1 then _ else Array::slice.call(arguments)


test "basic conditionals", ->
  if false
    ok false
  else if false
    ok false
  else
    ok true

  if true
    ok true
  else if true
    ok false
  else
    ok true

  unless true
    ok false
  else unless true
    ok false
  else
    ok true

  unless false
    ok true
  else unless false
    ok false
  else
    ok true

test "single-line conditional", ->
  if false then ok false else ok true
  unless false then ok true else ok false

test "nested conditionals", ->
  nonce = {}
  eq nonce, (if true
    unless false
      if false then false else
        if true
          nonce)

test "nested single-line conditionals", ->
  nonce = {}

  a = if false then undefined else b = if 0 then undefined else nonce
  eq nonce, a
  eq nonce, b

  c = if false then undefined else (if 0 then undefined else nonce)
  eq nonce, c

  d = if true then id(if false then undefined else nonce)
  eq nonce, d

test "empty conditional bodies", ->
  eq undefined, (if false
  else if false
  else)

test "conditional bodies containing only comments", ->
  eq undefined, (if true
    block comment
  else
  )

  eq undefined, (if false
  else if true
    block comment
  else)

test "return value of if-else is from the proper body", ->
  nonce = {}
  eq nonce, if false then undefined else nonce

test "return value of unless-else is from the proper body", ->
  nonce = {}
  eq nonce, unless true then undefined else nonce

test "assign inside the condition of a conditional statement", ->
  nonce = {}
  if a = nonce then 1
  eq nonce, a
  1 if b = nonce
  eq nonce, b



test "single-line function definition with single-line conditional", ->
  fn = -> if 1 < 0.5 then 1 else -1
  ok fn() is -1

test "function resturns conditional value with no `else`", ->
  fn = ->
    return if false then true
  eq undefined, fn()

test "function returns a conditional value", ->
  a = {}
  fnA = ->
    return if false then undefined else a
  eq a, fnA()

  b = {}
  fnB = ->
    return unless false then b else undefined
  eq b, fnB()

test "passing a conditional value to a function", ->
  nonce = {}
  eq nonce, id if false then undefined else nonce

test "unmatched `then` should catch implicit calls", ->
  a = 0
  trueFn = -> true
  if trueFn undefined then a++
  eq 1, a



test "if-to-ternary with instanceof requires parentheses", ->
  nonce = {}
  eq nonce, (if {} instanceof Object
    nonce
  else
    undefined)

test "if-to-ternary as part of a larger operation requires parentheses", ->
  ok 2, 1 + if false then 0 else 1



test "if-else indented within an assignment", ->
  nonce = {}
  result =
    if false
      undefined
    else
      nonce
  eq nonce, result

test "suppressed indentation via assignment", ->
  nonce = {}
  result =
    if      false then undefined
    else if no    then undefined
    else if 0     then undefined
    else if 1 < 0 then undefined
    else               id(
         if false then undefined
         else          nonce
    )
  eq nonce, result

test "tight formatting with leading `then`", ->
  nonce = {}
  eq nonce,
  if true
  then nonce
  else undefined

  nonce = {}
  fn = if true then -> nonce
  eq nonce, fn()

  nonce = {}
  obj = delete: true
  result = if obj.delete
    nonce
  eq nonce, result


test "basic `while` loops", ->

  i = 5
  list = while i -= 1
    i * 2
  ok list.join(' ') is "8 6 4 2"

  i = 5
  list = (i * 3 while i -= 1)
  ok list.join(' ') is "12 9 6 3"

  i = 5
  func   = (num) -> i -= num
  assert = -> ok i < 5 > 0
  results = while func 1
    assert()
    i
  ok results.join(' ') is '4 3 2 1'

  i = 10
  results = while i -= 1 when i % 2 is 0
    i * 2
  ok results.join(' ') is '16 12 8 4'


test "Issue 759: `if` within `while` condition", ->

  2 while if 1 then 0


test "assignment inside the condition of a `while` loop", ->

  nonce = {}
  count = 1
  a = nonce while count--
  eq nonce, a
  count = 1
  while count--
    b = nonce
  eq nonce, b


test "While over break.", ->

  i = 0
  result = while i < 10
    i++
    break
  arrayEq result, []


test "While over continue.", ->

  i = 0
  result = while i < 10
    i++
    continue
  arrayEq result, []


test "Basic `until`", ->

  value = false
  i = 0
  results = until value
    value = true if i is 5
    i++
  ok i is 6


test "Basic `loop`", ->

  i = 5
  list = []
  loop
    i -= 1
    break if i is 0
    list.push i * 2
  ok list.join(' ') is '8 6 4 2'


test "break at the top level", ->
  for i in [1,2,3]
    result = i
    if i == 2
      break
  eq 2, result

test "break *not* at the top level", ->
  someFunc = ->
    i = 0
    while ++i < 3
      result = i
      break if i > 1
    result
  eq 2, someFunc()


test "basic `switch`", ->

  num = 10
  result = switch num
    when 5 then false
    when 'a'
      true
      true
      false
    when 10 then true


    when 11 then false
    else false

  ok result


  func = (num) ->
    switch num
      when 2, 4, 6
        true
      when 1, 3, 5
        false

  ok func(2)
  ok func(6)
  ok !func(3)
  eq func(8), undefined


test "Ensure that trailing switch elses don't get rewritten.", ->

  result = false
  switch "word"
    when "one thing"
      doSomething()
    else
      result = true unless false

  ok result

  result = false
  switch "word"
    when "one thing"
      doSomething()
    when "other thing"
      doSomething()
    else
      result = true unless false

  ok result


test "Should be able to handle switches sans-condition.", ->

  result = switch
    when null                     then 0
    when !1                       then 1
    when '' not of {''}           then 2
    when [] not instanceof Array  then 3
    when true is false            then 4
    when 'x' < 'y' > 'z'          then 5
    when 'a' in ['b', 'c']        then 6
    when 'd' in (['e', 'f'])      then 7
    else ok

  eq result, ok


test "Should be able to use `@properties` within the switch clause.", ->

  obj = {
    num: 101
    func: ->
      switch @num
        when 101 then '101!'
        else 'other'
  }

  ok obj.func() is '101!'


test "Should be able to use `@properties` within the switch cases.", ->

  obj = {
    num: 101
    func: (yesOrNo) ->
      result = switch yesOrNo
        when yes then @num
        else 'other'
      result
  }

  ok obj.func(yes) is 101


test "Switch with break as the return value of a loop.", ->

  i = 10
  results = while i > 0
    i--
    switch i % 2
      when 1 then i
      when 0 then break

  eq results.join(', '), '9, 7, 5, 3, 1'



  val = 1
  switch true
    when true
      if false
        return 5
    else
      val = 2

  eq val, 1


test "Throw should be usable as an expression.", ->

  try
    false or throw 'up'
    throw new Error 'failed'
  catch e
    ok e is 'up'
if vm = require? 'vm'

  test "CoffeeScript.eval runs in the global context by default", ->
    global.punctuation = '!'
    code = '''
    '''
    result = CoffeeScript.eval code
    eq result, 'global superpower!'
    eq fhqwhgads, 'global superpower!'

  test "CoffeeScript.eval can run in, and modify, a Script context sandbox", ->
    sandbox = vm.Script.createContext()
    sandbox.foo = 'bar'
    code = '''
    global.foo = 'not bar!'
    '''
    result = CoffeeScript.eval code, {sandbox}
    eq result, 'not bar!'
    eq sandbox.foo, 'not bar!'

  test "CoffeeScript.eval can run in, but cannot modify, an ordinary object sandbox", ->
    sandbox = {foo: 'bar'}
    code = '''
    global.foo = 'not bar!'
    '''
    result = CoffeeScript.eval code, {sandbox}
    eq result, 'not bar!'
    eq sandbox.foo, 'bar'

nonce = {}



test "basic exception throwing", ->
  throws (-> throw 'error'), 'error'



test "try can exist alone", ->
  try

test "try/catch with empty try, empty catch", ->
  try
  catch err

test "single-line try/catch with empty try, empty catch", ->
  try catch err

test "try/finally with empty try, empty finally", ->
  try
  finally

test "single-line try/finally with empty try, empty finally", ->
  try finally

test "try/catch/finally with empty try, empty catch, empty finally", ->
  try
  catch err
  finally

test "single-line try/catch/finally with empty try, empty catch, empty finally", ->
  try catch err then finally



test "return the result of try when no exception is thrown", ->
  result = try
    nonce
  catch err
    undefined
  finally
    undefined
  eq nonce, result

test "single-line result of try when no exception is thrown", ->
  result = try nonce catch err then undefined
  eq nonce, result

test "return the result of catch when an exception is thrown", ->
  fn = ->
    try
      throw ->
    catch err
      nonce
  doesNotThrow fn
  eq nonce, fn()

test "single-line result of catch when an exception is thrown", ->
  fn = ->
    try throw (->) catch err then nonce
  doesNotThrow fn
  eq nonce, fn()

test "optional catch", ->
  fn = ->
    try throw ->
    nonce
  doesNotThrow fn
  eq nonce, fn()



test "try/catch with empty catch as last statement in a function body", ->
  fn = ->
    try nonce
    catch err
  eq nonce, fn()



test "try/catch with a reused variable name.", ->
  do ->
    try
      inner = 5
    catch inner
  eq typeof inner, 'undefined'




doesNotThrow -> CoffeeScript.compile "a = then b"

test "multiple semicolon-separated statements in parentheticals", ->
  nonce = {}
  eq nonce, (1; 2; nonce)
  eq nonce, (-> return (1; 2; nonce))()



test "chained accesses split on period/newline, backwards and forwards", ->
  str = 'abc'
  result = str.
    split('').
    reverse().
    reverse().
    reverse()
  arrayEq ['c','b','a'], result
  arrayEq ['c','b','a'], str.
    split('').
    reverse().
    reverse().
    reverse()
  result = str
    .split('')
    .reverse()
    .reverse()
    .reverse()
  arrayEq ['c','b','a'], result
  arrayEq ['c','b','a'], str
    .split('')
    .reverse()
    .reverse()
    .reverse()
  arrayEq ['c','b','a'], str.
    split('')
    .reverse().
    reverse()
    .reverse()


test "newline suppression for operators", ->
  six =
    1 +
    2 +
    3
  eq 6, six

test "`?.` and `::` should continue lines", ->
  ok not Date
  ::
  ?.foo

doesNotThrow -> CoffeeScript.compile """
  oh. yes
  oh?. true
  oh:: return
  """

doesNotThrow -> CoffeeScript.compile """
  a?[b..]
  a?[...b]
  a?[b..c]
  """


test "indented array literals don't trigger whitespace rewriting", ->
  getArgs = -> arguments
  result = getArgs(
    [[[[[],
                  []],
                [[]]]],
      []])
  eq 1, result.length


doesNotThrow -> CoffeeScript.compile """
  obj = then fn 1,
    1: 1
    a:
      b: ->
        fn c,
          d: e
    f: 1
  """


test "indented heredoc", ->
  result = ((_) -> _)(
                """
                abc
                """)
  eq "abc", result

  js = CoffeeScript.compile '(0;0)'
  eq -1, js.indexOf ';;'

  preNewline = (numSemicolons) ->
    """
    nonce = {}; nonce2 = {}
    nonce2
    unless f() is nonce then throw new Error('; before linebreak should = newline')
    """
  CoffeeScript.run(preNewline(n), bare: true) for n in [1,2,3]

  lastChar = '-> lastChar;'
  doesNotThrow -> CoffeeScript.compile lastChar, bare: true

  try
    CoffeeScript.compile '''
      [{
         ]}
    '''
    ok no
  catch e
    eq 'unmatched ] on line 2', e.message


id = (_) -> if arguments.length is 1 then _ else [arguments...]


test "basic argument passing", ->

  a = {}
  b = {}
  c = {}
  eq 1, (id 1)
  eq 2, (id 1, 2)[1]
  eq a, (id a)
  eq c, (id a, b, c)[2]


test "passing arguments on separate lines", ->

  a = {}
  b = {}
  c = {}
  ok(id(
    a
    b
    c
  )[1] is b)
  eq(0, id(
    0
    10
  )[0])
  eq(a,id(
    a
  ))
  eq b,
  (id b)


test "optional parens can be used in a nested fashion", ->

  call = (func) -> func()
  add = (a,b) -> a + b
  result = call ->
    inner = call ->
      add 5, 5
  ok result is 10


test "hanging commas and semicolons in argument list", ->

  fn = () -> arguments.length
  eq 2, fn(0,1,)
  eq 3, fn 0, 1,
  2
  eq 2, fn(0, 1;)
  throws -> CoffeeScript.compile "fn(0,1,;;)"
  throws -> CoffeeScript.compile "fn(0, 1;,)"
  throws -> CoffeeScript.compile "fn(,0)"
  throws -> CoffeeScript.compile "fn(;0)"


test "function invocation", ->

  func = ->
    return if true
  eq undefined, func()

  result = ("hello".slice) 3
  ok result is 'lo'


test "And even with strange things like this:", ->

  funcs  = [((x) -> x), ((x) -> x * x)]
  result = funcs[1] 5
  ok result is 25


test "More fun with optional parens.", ->

  fn = (arg) -> arg
  ok fn(fn {prop: 101}).prop is 101

  okFunc = (f) -> ok(f())
  okFunc -> true


test "chained function calls", ->
  nonce = {}
  identityWrap = (x) ->
    -> x
  eq nonce, identityWrap(identityWrap(nonce))()()
  eq nonce, (identityWrap identityWrap nonce)()()


test "Multi-blocks with optional parens.", ->

  fn = (arg) -> arg
  result = fn( ->
    fn ->
      "Wrapped"
  )
  ok result()() is 'Wrapped'


test "method calls", ->

  fnId = (fn) -> -> fn.apply this, arguments
  math = {
    add: (a, b) -> a + b
    anonymousAdd: (a, b) -> a + b
    fastAdd: fnId (a, b) -> a + b
  }
  ok math.add(5, 5) is 10
  ok math.anonymousAdd(10, 10) is 20
  ok math.fastAdd(20, 20) is 40


test "Ensure that functions can have a trailing comma in their argument list", ->

  mult = (x, mids..., y) ->
    x *= n for n in mids
    x *= y
  ok mult(1, 2,) is 2
  ok mult(1, 2, 3,) is 6
  ok mult(10, (i for i in [1..6])...) is 7200


test "`@` and `this` should both be able to invoke a method", ->
  nonce = {}
  fn          = (arg) -> eq nonce, arg
  fn.withAt   = -> @ nonce
  fn.withThis = -> this nonce
  fn.withAt()
  fn.withThis()


test "Trying an implicit object call with a trailing function.", ->

  a = null
  meth = (arg, obj, func) -> a = [obj.a, arg, func()].join ' '
  meth 'apple', b: 1, a: 13, ->
    'orange'
  ok a is '13 apple orange'


test "Ensure that empty functions don't return mistaken values.", ->

  obj =
    func: (@param, @rest...) ->
  ok obj.func(101, 102, 103, 104) is undefined
  ok obj.param is 101
  ok obj.rest.join(' ') is '102 103 104'


test "Passing multiple functions without paren-wrapping is legal, and should compile.", ->

  sum = (one, two) -> one() + two()
  result = sum ->
    7 + 9
  , ->
    1 + 3
  ok result is 20


test "Implicit call with a trailing if statement as a param.", ->

  func = -> arguments[1]
  result = func 'one', if false then 100 else 13
  ok result is 13


test "Test more function passing:", ->

  sum = (one, two) -> one() + two()

  result = sum( ->
    1 + 2
  , ->
    2 + 1
  )
  ok result is 6

  sum = (a, b) -> a + b
  result = sum(1
  , 2)
  ok result is 3


test "Chained blocks, with proper indentation levels:", ->

  counter =
    results: []
    tick: (func) ->
      @results.push func()
      this
  counter
    .tick ->
      3
    .tick ->
      2
    .tick ->
      1
  arrayEq [3,2,1], counter.results


test "This is a crazy one.", ->

  x = (obj, func) -> func obj
  ident = (x) -> x
  result = x {one: ident 1}, (obj) ->
    inner = ident(obj)
    ident inner
  ok result.one is 1


test "More paren compilation tests:", ->

  reverse = (obj) -> obj.reverse()
  ok reverse([1, 2].concat 3).join(' ') is '3 2 1'


test "Test for inline functions with parentheses and implicit calls.", ->

  combine = (func, num) -> func() * num
  result  = combine (-> 1 + 2), 3
  ok result is 9


test "Test for calls/parens/multiline-chains.", ->

  f = (x) -> x
  result = (f 1).toString()
    .length
  ok result is 1


test "Test implicit calls in functions in parens:", ->

  result = ((val) ->
    [].push val
    val
  )(10)
  ok result is 10


test "Ensure that chained calls with indented implicit object literals below are alright.", ->

  result = null
  obj =
    method: (val)  -> this
    second: (hash) -> result = hash.three
  obj
    .method(
      101
    ).second(
      one:
        two: 2
      three: 3
    )
  eq result, 3


test "Test newline-supressed call chains with nested functions.", ->

  obj  =
    call: -> this
  func = ->
    obj
      .call ->
        one two
      .call ->
        three four
    101
  eq func(), 101


test "Implicit objects with number arguments.", ->

  func = (x, y) -> y
  obj =
    prop: func "a", 1
  ok obj.prop is 1


test "Non-spaced unary and binary operators should cause a function call.", ->

  func = (val) -> val + 1
  ok (func +5) is 6
  ok (func -5) is -4


test "Prefix unary assignment operators are allowed in parenless calls.", ->

  func = (val) -> val + 1
  val = 5
  ok (func --val) is 5

  contextTest = -> eq @, if window? then window else global
  array = []
  contextTest array
  contextTest.apply null, array
  contextTest array...

  a = b = nonce = {}
  fn = ([a,b]) -> {a:a,b:b}
  result = fn([c={},d={}])
  eq c, result.a
  eq d, result.b
  eq nonce, a
  eq nonce, b

test "Simple Destructuring function arguments with same-named variables in scope", ->
  x = 1
  f = ([x]) -> x
  eq f([2]), 2
  eq x, 1

test "caching base value", ->

  obj =
    index: 0
    0: {method: -> this is obj[0]}
  ok obj[obj.index++].method([]...)


test "passing splats to functions", ->
  arrayEq [0..4], id id [0..4]...
  fn = (a, b, c..., d) -> [a, b, c, d]
  range = [0..3]
  [first, second, others, last] = fn range..., 4, [5...8]...
  eq 0, first
  eq 1, second
  arrayEq [2..6], others
  eq 7, last

test "splat variables are local to the function", ->
  outer = "x"
  clobber = (avar, outer...) -> outer
  clobber "foo", "bar"
  eq "x", outer


test "Issue 894: Splatting against constructor-chained functions.", ->

  x = null
  class Foo
    bar: (y) -> x = y
  new Foo().bar([101]...)
  eq x, 101


test "Functions with splats being called with too few arguments.", ->

  pen = null
  method = (first, variable..., penultimate, ultimate) ->
    pen = penultimate
  method 1, 2, 3, 4, 5, 6, 7, 8, 9
  ok pen is 8
  method 1, 2, 3
  ok pen is 2
  method 1, 2
  ok pen is 2


test "splats with super() within classes.", ->

  class Parent
    meth: (args...) ->
      args
  class Child extends Parent
    meth: ->
      nums = [3, 2, 1]
      super nums...
  ok (new Child).meth().join(' ') is '3 2 1'


  eq '1011', 11.toString [2]...
  eq '1011', (31).toString [3]...
  eq '1011', 69.0.toString [4]...
  eq '1011', (131.0).toString [5]...


test "splats and the `new` operator: functions that return `null` should construct their instance", ->
  args = []
  child = new (constructor = -> null) args...
  ok child instanceof constructor

test "splats and the `new` operator: functions that return functions should construct their return value", ->
  args = []
  fn = ->
  child = new (constructor = -> fn) args...
  ok child not instanceof constructor
  eq fn, child

test "implicit return", ->

  eq ok, new ->
    ok


test "implicit returns with multiple branches", ->
  nonce = {}
  fn = ->
    if false
      for a in b
        return c if d
    else
      nonce
  eq nonce, fn()


test "implicit returns with switches", ->
  nonce = {}
  fn = ->
    switch nonce
      when nonce then nonce
      else return undefined
  eq nonce, fn()


test "preserve context when generating closure wrappers for expression conversions", ->
  nonce = {}
  obj =
    property: nonce
    method: ->
      this.result = if false
        10
      else
        "a"
        "b"
        this.property
  eq nonce, obj.method()
  eq nonce, obj.property


test "don't wrap 'pure' statements in a closure", ->
  nonce = {}
  items = [0, 1, 2, 3, nonce, 4, 5]
  fn = (items) ->
    for item in items
      return item if item is nonce
  eq nonce, fn items


test "usage of `new` is careful about where the invocation parens end up", ->
  eq 'object', typeof new try Array
  eq 'object', typeof new do -> ->


test "implicit call against control structures", ->
  result = null
  save   = (obj) -> result = obj

  save switch id false
    when true
      'true'
    when false
      'false'

  eq result, 'false'

  save if id false
    'false'
  else
    'true'

  eq result, 'true'

  save unless id false
    'true'
  else
    'false'

  eq result, 'true'

  save try
    doesnt exist
  catch error
    'caught'

  eq result, 'caught'

  save try doesnt(exist) catch error then 'caught2'

  eq result, 'caught2'


  fn = -> (f) -> f()
  nonce = {}
  eq nonce, (fn() -> nonce)

  nonce = {}
  obj = new new -> -> {prop: nonce}
  eq obj.prop, nonce

  nonce = {}
  argNonceA = {}
  argNonceB = {}
  fn = (a) -> (b) -> {a, b, prop: nonce}
  obj = new new fn(argNonceA)(argNonceB)
  eq obj.prop, nonce
  eq obj.a, argNonceA
  eq obj.b, argNonceB

  doesNotThrow -> CoffeeScript.compile 'fn()::prop'

  nonce = {}
  class Test then id: nonce

  dotAccess = -> Test::
  protoAccess = -> Test

  eq dotAccess().id, nonce
  eq protoAccess()::id, nonce


  do (nonExistent = 'one') ->
    eq nonExistent, 'one'

  overridden = 1
  do (overridden = 2) ->
    eq overridden, 2

  two = 2
  do (one = 1, two, three = 3) ->
    eq one, 1
    eq two, 2
    eq three, 3

  ret = do func = (two) ->
    eq two, 2
    func
  eq ret, func




x = 1
y = {}
y.x = -> 3
ok x is 1
ok typeof(y.x) is 'function'
ok y.x instanceof Function
ok y.x() is 3

->
() ->

(one) -> (two) -> three four, (five) -> six seven, eight, (nine) ->

func = (x) -> (x) -> (x) -> x
ok func(1)(2)(3) is 3

func = ->
  obj = {
          key: 10
        }
  obj.key - 5
eq func(), 5

del = -> 5
ok del() is 5



obj =
  bound: ->
    (=> this)()
  unbound: ->
    (-> this)()
  nested: ->
    (=>
      (=>
        (=> this)()
      )()
    )()
eq obj, obj.bound()
ok obj isnt obj.unbound()
eq obj, obj.nested()


test "even more fancy bound functions", ->
  obj =
    one: ->
      do =>
        return this.two()
    two: ->
      do =>
        do =>
          do =>
            return this.three
    three: 3

  eq obj.one(), 3


test "self-referencing functions", ->
  changeMe = ->
    changeMe = 2

  changeMe()
  eq changeMe, 2



test "splats", ->
  arrayEq [0, 1, 2], (((splat...) -> splat) 0, 1, 2)
  arrayEq [2, 3], (((_, _1, splat...) -> splat) 0, 1, 2, 3)
  arrayEq [0, 1], (((splat..., _, _1) -> splat) 0, 1, 2, 3)
  arrayEq [2], (((_, _1, splat..., _2) -> splat) 0, 1, 2, 3)

test "destructured splatted parameters", ->
  arr = [0,1,2]
  splatArray = ([a...]) -> a
  splatArrayRest = ([a...],b...) -> arrayEq(a,b); b
  arrayEq splatArray(arr), arr
  arrayEq splatArrayRest(arr,0,1,2), arr

test "@-parameters: automatically assign an argument's value to a property of the context", ->
  nonce = {}

  ((@prop) ->).call context = {}, nonce
  eq nonce, context.prop

  ((splat..., @prop) ->).apply context = {}, [0, 0, nonce]
  eq nonce, context.prop

  ((@prop...) ->).call context = {}, 0, nonce, 0
  eq nonce, context.prop[1]

  eq nonce, (((@prop) -> prop).call {}, nonce)

test "@-parameters and splats with constructors", ->
  a = {}
  b = {}
  class Klass
    constructor: (@first, splat..., @last) ->

  obj = new Klass a, 0, 0, b
  eq a, obj.first
  eq b, obj.last

test "destructuring in function definition", ->
  (([{a: [b], c}]...) ->
    eq 1, b
    eq 2, c
  ) {a: [1], c: 2}

test "default values", ->
  nonceA = {}
  nonceB = {}
  a = (_,_1,arg=nonceA) -> arg
  eq nonceA, a()
  eq nonceA, a(0)
  eq nonceB, a(0,0,nonceB)
  eq nonceA, a(0,0,undefined)
  eq nonceA, a(0,0,null)
  eq false , a(0,0,false)
  eq nonceB, a(undefined,undefined,nonceB,undefined)
  b = (_,arg=nonceA,_1,_2) -> arg
  eq nonceA, b()
  eq nonceA, b(0)
  eq nonceB, b(0,nonceB)
  eq nonceA, b(0,undefined)
  eq nonceA, b(0,null)
  eq false , b(0,false)
  eq nonceB, b(undefined,nonceB,undefined)
  c = (arg=nonceA,_,_1) -> arg
  eq nonceA, c()
  eq      0, c(0)
  eq nonceB, c(nonceB)
  eq nonceA, c(undefined)
  eq nonceA, c(null)
  eq false , c(false)
  eq nonceB, c(nonceB,undefined,undefined)

test "default values with @-parameters", ->
  a = {}
  b = {}
  obj = f: (q = a, @p = b) -> q
  eq a, obj.f()
  eq b, obj.p

test "default values with splatted arguments", ->
  withSplats = (a = 2, b..., c = 3, d = 5) -> a * (b.length + 1) * c * d
  eq 30, withSplats()
  eq 15, withSplats(1)
  eq  5, withSplats(1,1)
  eq  1, withSplats(1,1,1)
  eq  2, withSplats(1,1,1,1)

test "default values with function calls", ->
  doesNotThrow -> CoffeeScript.compile "(x = f()) ->"

test "arguments vs parameters", ->
  doesNotThrow -> CoffeeScript.compile "f(x) ->"
  f = (g) -> g()
  eq 5, f (x) -> 5

  a = ((=>) for a in [0] for b in [0])
  eq 1, a.length

  list = [1, 2, 3]
  ok true if list.some (x) -> x is 2

  func = (
    a, b, c
  ) -> c
  eq func(1, 2, 3), 3
  
  func = (
    a
    b
    c
  ) -> b

{starts, ends, compact, count, merge, extend, flatten, del, last} = CoffeeScript.helpers



test "the `starts` helper tests if a string starts with another string", ->
  ok     starts('01234', '012')
  ok not starts('01234', '123')

test "the `starts` helper can take an optional offset", ->
  ok     starts('01234', '34', 3)
  ok not starts('01234', '01', 1)



test "the `ends` helper tests if a string ends with another string", ->
  ok     ends('01234', '234')
  ok not ends('01234', '012')

test "the `ends` helper can take an optional offset", ->
  ok     ends('01234', '012', 2)
  ok not ends('01234', '234', 6)



test "the `compact` helper removes falsey values from an array, preserves truthy ones", ->
  allValues = [1, 0, false, obj={}, [], '', ' ', -1, null, undefined, true]
  truthyValues = [1, obj, [], ' ', -1, true]
  arrayEq truthyValues, compact(allValues)



test "the `count` helper counts the number of occurances of a string in another string", ->
  eq 1/0, count('abc', '')
  eq 0, count('abc', 'z')
  eq 1, count('abc', 'a')
  eq 1, count('abc', 'b')
  eq 2, count('abcdc', 'c')
  eq 2, count('abcdabcd','abc')



test "the `merge` helper makes a new object with all properties of the objects given as its arguments", ->
  ary = [0, 1, 2, 3, 4]
  obj = {}
  merged = merge obj, ary
  ok merged isnt obj
  ok merged isnt ary
  for own key, val of ary
    eq val, merged[key]



test "the `extend` helper performs a shallow copy", ->
  ary = [0, 1, 2, 3]
  obj = {}
  eq obj, extend(obj, ary)
  eq 2, obj[2]



test "the `flatten` helper flattens an array", ->
  success = yes
  (success and= typeof n is 'number') for n in flatten [0, [[[1]], 2], 3, [4]]
  ok success



test "the `del` helper deletes a property from an object and returns the deleted value", ->
  obj = [0, 1, 2]
  eq 1, del(obj, 1)
  ok 1 not of obj



test "the `last` helper returns the last item of an array-like object", ->
  ary = [0, 1, 2, 3, 4]
  eq 4, last(ary)

test "the `last` helper allows one to specify an optional offset", ->
  ary = [0, 1, 2, 3, 4]
  eq 2, last(ary, 2)

unless window? or testingBrowser?
  test "coffeescript modules can be imported and executed", ->

    magicKey = __filename
    magicValue = 0xFFFF

    if global[magicKey]?
      if exports?
        local = magicValue
        exports.method = -> local
    else
      global[magicKey] = {}
      if require?.extensions?
        ok require(__filename).method() is magicValue
      delete global[magicKey]




    ok true
    "\"interpolations\""
  }"
} work"""



hello = 'Hello'
world = 'World'

[s, t, r, i, n, g] = ['s', 't', 'r', 'i', 'n', 'g']





list = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

obj = {
  name: 'Joe'
}
ok obj.hi() is "Hello Joe."
ok obj.cya() is "Goodbye Joe."





a = """
    """
ok a is "Hello Joe"

a = 1
b = 2
c = 3

result = null
stash = (str) -> result = str
ok result is 'a bb c'

foo = "hello"

val = 10
a = """
    on two lines
    """
b = '''
    on two lines
    '''
ok a is "basic heredoc 10\non two lines"

    ok yes
    "\"interpolations\""
  )()}"
} work"""




test "heregex interpolation", ->
   }
   \\ \"
  /// + ''


eq '\\`', `
  // Inline JS
  "\\\`"
`




test "Parser recognises binary numbers", ->
  eq 4, 0b100


test "call methods directly on numbers", ->
  eq 4, 4.valueOf()
  eq '11', 4.toString 3

eq -1, 3 -4

eq Number::toString, 42['toString']

eq Number::toString, 42.toString



value = .25 + .75
ok value is 1
value = 0.0 + -.25 - -.75 + 0.0
ok value is 0.5

eq Number::toString,   4['toString']
eq Number::toString, 4.2['toString']
eq Number::toString, .42['toString']
eq Number::toString, (4)['toString']

eq Number::toString,   4.toString
eq Number::toString, 4.2.toString
eq Number::toString, .42.toString
eq Number::toString, (4).toString

  eq 1, do ->
    1
    .5 + 0.5

test "Python-style octal literal notation '0o777'", ->
  eq 511, 0o777
  eq 1, 0o1
  eq 1, 0o00001
  eq parseInt('0777', 8), 0o777
  eq '777', 0o777.toString 8
  eq 4, 0o4.valueOf()
  eq Number::toString, 0o777['toString']
  eq Number::toString, 0o777.toString

  for char in ['b', 'o', 'x', 'e']
    doesNotThrow -> CoffeeScript.compile program, bare: yes
    throws -> CoffeeScript.compile program.toUpperCase(), bare: yes

  eq 176, 0x0b0
  eq 177, 0x0B1
  eq 225, 0xE1


trailingComma = {k1: "v1", k2: 4, k3: (-> true),}
ok trailingComma.k3() and (trailingComma.k2 is 4) and (trailingComma.k1 is "v1")

ok {a: (num) -> num is 10 }.a 10

moe = {
  name:  'Moe'
  greet: (salutation) ->
    salutation + " " + @name
  hello: ->
    @['greet'] "Hello"
  10: 'number'
}
ok moe.hello() is "Hello Moe"
ok moe[10] is 'number'
moe.hello = ->
  this['greet'] "Hello"
ok moe.hello() is 'Hello Moe'

obj = {
  is:     -> yes,
  'not':  -> no,
}
ok obj.is()
ok not obj.not()

obj: 1

obj = {class: 'höt'}
obj.function = 'dog'
ok obj.class + obj.function is 'hötdog'

pluck = (x) -> x.a
eq 100, pluck pluck pluck a: a: a: 100


test "YAML-style object literals", ->
  obj =
    a: 1
    b: 2
  eq 1, obj.a
  eq 2, obj.b

  config =
    development:
      server: 'localhost'
      timeout: 10

    production:
      server: 'dreamboat'
      timeout: 1000

  ok config.development.server  is 'localhost'
  ok config.production.server   is 'dreamboat'
  ok config.development.timeout is 10
  ok config.production.timeout  is 1000

obj =
  a: 1,
  b: 2,
ok obj.a is 1
ok obj.b is 2

obj =
  options:
    value: yes
  fn: ->
    {}
    null
ok obj.options.value is yes
ok obj.fn() is null

obj =
  'reverse': (obj) ->
    Array.prototype.reverse.call obj
  abc: ->
    @reverse(
      @reverse @reverse ['a', 'b', 'c'].reverse()
    )
  one: [1, 2,
    a: 'b'
  3, 4]
  red:
    orange:
          yellow:
                  green: 'blue'
    indigo: 'violet'
  misdent: [[],
  [],
                  [],
      []]
ok obj.abc().join(' ') is 'a b c'
ok obj.one.length is 5
ok obj.one[4] is 4
ok obj.one[2].a is 'b'
ok (key for key of obj.red).length is 2
ok obj.red.orange.yellow.green is 'blue'
ok obj.red.indigo is 'violet'
ok obj.misdent.toString() is ',,,'

{f: -> ok yes }.f() + 1

one =
  '>!': 3
six: -> 10
ok not one.six

obj =
  one: 1
  two: 2
  object: -> {@one, @two}
  list:   -> [@one, @two]
result = obj.object()
eq result.one, 1
eq result.two, 2
eq result.two, obj.list()[1]

third = (a, b, c) -> c
obj =
  one: 'one'
  two: third 'one', 'two', 'three'
ok obj.one is 'one'
ok obj.two is 'three'

test "invoking functions with implicit object literals", ->
  generateGetter = (prop) -> (obj) -> obj[prop]
  getA = generateGetter 'a'
  getArgs = -> arguments
  a = b = 30

  result = getA
    a: 10
  eq 10, result

  result = getA
    "a": 20
  eq 20, result

  result = getA a,
    b:1
  eq undefined, result

  result = getA b:1,
  a:43
  eq 43, result

  result = getA b:1,
    a:62
  eq undefined, result

  result = getA
    b:1
    a
  eq undefined, result

  result = getA
    a:
      b:2
    b:1
  eq 2, result.b

  result = getArgs
    a:1
    b
    c:1
  ok result.length is 3
  ok result[2].c is 1

  result = getA b: 13, a: 42, 2
  eq 42, result

  result = getArgs a:1, (1 + 1)
  ok result[1] is 2

  result = getArgs a:1, b
  ok result.length is 2
  ok result[1] is 30

  result = getArgs a:1, b, b:1, a
  ok result.length is 4
  ok result[2].b is 1

  throws -> CoffeeScript.compile "a = b:1, c"

test "some weird indentation in YAML-style object literals", ->
  two = (a, b) -> b
  obj = then two 1,
    1: 1
    a:
      b: ->
        fn c,
          d: e
    f: 1
  eq 1, obj[1]

  a = false
  fn = -> a = true
  {} = fn()
  ok a

  obj = {}
  eq no, obj.hasOwnProperty 'for'
  obj.for = 'foo' of obj
  eq yes, obj.hasOwnProperty 'for'

  ((obj, arg) ->
    eq obj.x * obj.y, 6
    ok not arg
  )
    x
    x: 2
    y: 3

  doesNotThrow -> CoffeeScript.run "{}?", bare: true
  doesNotThrow -> CoffeeScript.run "{}.a++", bare: true

  result = 'result'
  ident = (x) -> x

  result = ident one: 1 if false

  eq result, 'result'

  result = ident
    one: 1
    two: 2 for i in [1..3]

  eq result.two.join(' '), '2 2 2'


  obj = null

  obj ?=
    one: 1
    two: 2

  eq obj.two, 2

  obj = null

  obj or=
    three: 3
    four: 4

  eq obj.four, 4

  func = ->
    key: for i in [1, 2, 3] then i
      
  eq func().key.join(' '), '1 2 3'
  


test "binary (2-ary) math operators do not require spaces", ->
  a = 1
  b = -1
  eq +1, a*-b
  eq -1, a*+b
  eq +1, a/-b
  eq -1, a/+b

test "operators should respect new lines as spaced", ->
  a = 123 +
  456
  eq 579, a

  "456"
  eq '123456', b

test "multiple operators should space themselves", ->
  eq (+ +1), (- -1)

test "bitwise operators", ->
  eq  2, (10 &   3)
  eq 11, (10 |   3)
  eq  9, (10 ^   3)
  eq 80, (10 <<  3)
  eq  1, (10 >>  3)
  eq  1, (10 >>> 3)
  num = 10; eq  2, (num &=   3)
  num = 10; eq 11, (num |=   3)
  num = 10; eq  9, (num ^=   3)
  num = 10; eq 80, (num <<=  3)
  num = 10; eq  1, (num >>=  3)
  num = 10; eq  1, (num >>>= 3)

test "`instanceof`", ->
  ok new String instanceof String
  ok new Boolean instanceof Boolean
  ok new Number not instanceof String
  ok new Array not instanceof Boolean

test "use `::` operator on keywords `this` and `@`", ->
  nonce = {}
  obj =
    withAt:   -> @::prop
    withThis: -> this::prop
  obj.prototype = prop: nonce
  eq nonce, obj.withAt()
  eq nonce, obj.withThis()



test "binary existential operator", ->
  nonce = {}

  b = a ? nonce
  eq nonce, b

  a = null
  b = undefined
  b = a ? nonce
  eq nonce, b

  a = false
  b = a ? nonce
  eq false, b

  a = 0
  b = a ? nonce
  eq 0, b

test "binary existential operator conditionally evaluates second operand", ->
  i = 1
  func = -> i -= 1
  result = func() ? func()
  eq result, 0

test "binary existential operator with negative number", ->
  a = null ? - 1
  eq -1, a



test "postfix existential operator", ->
  ok (if nonexistent? then false else true)
  defined = true
  ok defined?
  defined = false
  ok defined?

test "postfix existential operator only evaluates its operand once", ->
  semaphore = 0
  fn = ->
    ok false if semaphore
    ++semaphore
  ok(if fn()? then true else false)

test "negated postfix existential operator", ->
  ok !nothing?.value

test "postfix existential operator on expressions", ->
  eq true, (1 or 0)?, true



test "`==` and `is` should be interchangeable", ->
  a = b = 1
  ok a is 1 and b == 1
  ok a == b
  ok a is b

test "`!=` and `isnt` should be interchangeable", ->
  a = 0
  b = 1
  ok a isnt 1 and b != 0
  ok a != b
  ok a isnt b



test "in, of", ->
  arr = [1]
  ok 0 of arr
  ok 1 in arr
  ok 1 not of arr
  ok 0 not in arr

test "`in` should be able to operate on an array literal", ->
  ok 2 in [0, 1, 2, 3]
  ok 4 not in [0, 1, 2, 3]
  arr = [0, 1, 2, 3]
  ok 2 in arr
  ok 4 not in arr
  arr = [0]
  val = 0
  ok val++ in arr
  ok val++ not in arr
  val = 0
  ok val++ of arr
  ok val++ not of arr

test "`of` and `in` should be able to operate on instance variables", ->
  obj = {
    list: [2,3]
    in_list: (value) -> value in @list
    not_in_list: (value) -> value not in @list
    of_list: (value) -> value of @list
    not_of_list: (value) -> value not of @list
  }
  ok obj.in_list 3
  ok obj.not_in_list 1
  ok obj.of_list 0
  ok obj.not_of_list 2

  eq 1, [Object() in Array()].length

  eq 1, 1 in [1] and 1

  share = 0
  a = -> share++ if share is 0
  b = -> share++ if share is 1
  c = -> share++ if share is 2
  ok a() not in [b(),c()]
  eq 3, share

  eq 1, [5 in []].length
  eq false, do -> return 0 in []

  a = [6, 9]
  eq 9 in [3, a...], true

  ok 0 in [1 and 0]
  ok 0 in [1, 1 and 0]
  ok not (0 in [1, 0 or 1])

  ok undefined not in length: 1

  0 for [1..2]
  ok not ('a' in ['b'])

  0 for [1..2]; ok not ('a' in ['b'])

  ok not ('a' in ['b'])

  ok 0 not in []



test "chainable operators", ->
  ok 100 > 10 > 1 > 0 > -1
  ok -1 < 0 < 1 < 10 < 100

test "`is` and `isnt` may be chained", ->
  ok true is not false is true is not false
  ok 0 is 0 isnt 1 is 1

test "different comparison operators (`>`,`<`,`is`,etc.) may be combined", ->
  ok 1 < 2 > 1
  ok 10 < 20 > 2+3 is 5

test "some chainable operators can be negated by `unless`", ->
  ok (true unless 0==10!=100)

test "operator precedence: `|` lower than `<`", ->
  eq 1, 1 | 2 < 3 < 4

test "preserve references", ->
  a = b = c = 1
  ok a == b <= c

test "chained operations should evaluate each value only once", ->
  a = 0
  ok 1 > a++ < 1

  ok (true unless 0 > 1 > 2)
  ok (true unless (NaN = 0/0) < 0/0 < NaN)

  nonce = {}
  class C
    method: -> @nonce
    nonce: nonce

  arr = []

  eq "': '", '' +
     "': '"

  x = 2
  eq (- --x), -1

test "Regression with implicit calls against an indented assignment", ->
  eq 1, a =
    1

  eq a, 1

  x = null
  func = -> x ?= (-> if true then 'hi')
  func()
  eq x(), 'hi'
  
  counter = 0
  func = -> counter++
  func()? ? 100
  eq counter, 1


return unless require?
{OptionParser} = require './../lib/coffee-script/optparse'

opt = new OptionParser [
  ['-r', '--required [DIR]',  'desc required']
  ['-o', '--optional',        'desc optional']
  ['-l', '--list [FILES*]',   'desc list']
]

test "basic arguments", ->
  args = ['one', 'two', 'three', '-r', 'dir']
  result = opt.parse args
  arrayEq args, result.arguments
  eq undefined, result.required

test "boolean and parameterised options", ->
  result = opt.parse ['--optional', '-r', 'folder', 'one', 'two']
  ok result.optional
  eq 'folder', result.required
  arrayEq ['one', 'two'], result.arguments

test "list options", ->
  result = opt.parse ['-l', 'one.txt', '-l', 'two.txt', 'three']
  arrayEq ['one.txt', 'two.txt'], result.list
  arrayEq ['three'], result.arguments

test "-- and interesting combinations", ->
  result = opt.parse ['-o','-r','a','-r','b','-o','--','-a','b','--c','d']
  arrayEq ['-a', 'b', '--c', 'd'], result.arguments
  ok result.optional
  eq 'b', result.required

  args = ['--','-o','a','-r','c','-o','--','-a','arg0','-b','arg1']
  result = opt.parse args
  eq undefined, result.optional
  eq undefined, result.required
  arrayEq args[1..], result.arguments


shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

test "basic inclusive ranges", ->
  arrayEq [1, 2, 3] , [1..3]
  arrayEq [0, 1, 2] , [0..2]
  arrayEq [0, 1]    , [0..1]
  arrayEq [0]       , [0..0]
  arrayEq [-1]      , [-1..-1]
  arrayEq [-1, 0]   , [-1..0]
  arrayEq [-1, 0, 1], [-1..1]

test "basic exclusive ranges", ->
  arrayEq [1, 2, 3] , [1...4]
  arrayEq [0, 1, 2] , [0...3]
  arrayEq [0, 1]    , [0...2]
  arrayEq [0]       , [0...1]
  arrayEq [-1]      , [-1...0]
  arrayEq [-1, 0]   , [-1...1]
  arrayEq [-1, 0, 1], [-1...2]

  arrayEq [], [1...1]
  arrayEq [], [0...0]
  arrayEq [], [-1...-1]

test "downward ranges", ->
  arrayEq shared, [9..0].reverse()
  arrayEq [5, 4, 3, 2] , [5..2]
  arrayEq [2, 1, 0, -1], [2..-1]

  arrayEq [3, 2, 1]  , [3..1]
  arrayEq [2, 1, 0]  , [2..0]
  arrayEq [1, 0]     , [1..0]
  arrayEq [0]        , [0..0]
  arrayEq [-1]       , [-1..-1]
  arrayEq [0, -1]    , [0..-1]
  arrayEq [1, 0, -1] , [1..-1]
  arrayEq [0, -1, -2], [0..-2]

  arrayEq [4, 3, 2], [4...1]
  arrayEq [3, 2, 1], [3...0]
  arrayEq [2, 1]   , [2...0]
  arrayEq [1]      , [1...0]
  arrayEq []       , [0...0]
  arrayEq []       , [-1...-1]
  arrayEq [0]      , [0...-1]
  arrayEq [0, -1]  , [0...-2]
  arrayEq [1, 0]   , [1...-1]
  arrayEq [2, 1, 0], [2...-1]

test "ranges with variables as enpoints", ->
  [a, b] = [1, 3]
  arrayEq [1, 2, 3], [a..b]
  arrayEq [1, 2]   , [a...b]
  b = -2
  arrayEq [1, 0, -1, -2], [a..b]
  arrayEq [1, 0, -1]    , [a...b]

test "ranges with expressions as endpoints", ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], [(a+1)..2*b]
  arrayEq [2, 3, 4, 5]   , [(a+1)...2*b]

test "large ranges are generated with looping constructs", ->
  down = [99..0]
  eq 100, (len = down.length)
  eq   0, down[len - 1]

  up = [0...100]
  eq 100, (len = up.length)
  eq  99, up[len - 1]

  expected = [0..9]
  argsAtStart = (-> [arguments[0]..9]) 0
  arrayEq expected, argsAtStart
  argsAtEnd = (-> [0..arguments[0]]) 9
  arrayEq expected, argsAtEnd
  argsAtBoth = (-> [arguments[0]..arguments[1]]) 0, 9
  arrayEq expected, argsAtBoth

  CoffeeScript.eval '[0..100]'



test "basic regular expression literals", ->
  ok 'a'.match(/a/)
  ok 'a'.match /a/
  ok 'a'.match(/a/g)
  ok 'a'.match /a/g

test "division is not confused for a regular expression", ->
  eq 2, 4 / 2 / 1

  a = 4
  b = 2
  g = 1
  eq 2, a / b/g

  a = 10
  b = a /= 4 / 2
  eq a, 5

  obj = method: -> 2
  two = 2
  eq 2, (obj.method()/two + obj.method()/two)

  i = 1
  eq 2, (4)/2/i
  eq 1, i/i/i


  ok /^a\/[/]b$/.test 'a//b'

  throws -> CoffeeScript.compile '/*/'



test "a heregex will ignore whitespace and comments", ->
  eq /^I'm\x20+[a]\s+Heregex?\/\/\//gim + '', ///
    ^ I'm \x20+ [a] \s+
  ///gim + ''

test "an empty heregex will compile to an empty, non-capturing group", ->
  eq /(?:)/ + '', ///  /// + ''

  throws -> CoffeeScript.compile '/// * ///'

test "empty regular expressions with flags", ->
  fn = (x) -> x
  a = "" + //i
  fn ""
  eq '/(?:)/i', a



test "reference `arguments` inside of functions", ->
  sumOfArgs = ->
    sum = (a,b) -> a + b
    sum = 0
    sum += num for num in arguments
    sum
  eq 10, sumOfArgs(0, 1, 2, 3, 4)

test "assignment to an Object.prototype-named variable should not leak to outer scope", ->
  (->
    constructor = 'word'
  )()
  ok constructor isnt 'word'

test "siblings of splat parameters shouldn't leak to surrounding scope", ->
  x = 10
  oops = (x, args...) ->
  oops(20, 1, 2, 3)
  eq x, 10

test "catch statements should introduce their argument to scope", ->
  try throw ''
  catch e
    do -> e = 5
    eq 5, e

class Object then hasOwnProperty: fail
  arr = [1..4]
  arrayEq [3, 4], arr[2..]
  obj = {arr}
  for own k of obj
    eq arr, obj[k]

  ok not x?
  arrayEq [0], ((@x...) -> @x).call {}, 0
  ok not x?

  dolater = (cb) -> cb()

  class A
  	constructor: ->
  		@_i = 0
  	foo : (cb) ->
  		dolater => 
  			@_i += 1 
  			cb()

  class B extends A
  	constructor : ->
  		super
  	foo : (cb) ->
  		dolater =>
  			dolater =>
  				@_i += 2
  				super cb
          
  b = new B
  b.foo => eq b._i, 3

  class A
    m : -> 10
    
  class B extends A
    constructor : -> super
    
  B::m = -> r = try super()
  
  eq (new B).m(), 10

  class A
    constructor: ->
      @i = 10
    foo : -> @i
    
  class B extends A
    foo : ->
      ret = switch 1
        when 0 then 0
        when 1 then super()
      ret
  eq (new B).foo(), 10
 
  class A
    @value = 'A'
    method: -> @constructor.value
    
  class B extends A
    method: => super
  


shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]


test "basic slicing", ->
  arrayEq [7, 8, 9]   , shared[7..9]
  arrayEq [2, 3]      , shared[2...4]
  arrayEq [2, 3, 4, 5], shared[2...6]

test "slicing with variables as endpoints", ->
  [a, b] = [1, 4]
  arrayEq [1, 2, 3, 4], shared[a..b]
  arrayEq [1, 2, 3]   , shared[a...b]

test "slicing with expressions as endpoints", ->
  [a, b] = [1, 3]
  arrayEq [2, 3, 4, 5, 6], shared[(a+1)..2*b]
  arrayEq [2, 3, 4, 5]   , shared[a+1...(2*b)]

test "unbounded slicing", ->
  arrayEq [7, 8, 9]   , shared[7..]
  arrayEq [8, 9]      , shared[-2..]
  arrayEq [9]         , shared[-1...]
  arrayEq [0, 1, 2]   , shared[...3]
  arrayEq [0, 1, 2, 3], shared[..-7]

  arrayEq shared      , shared[..-1]
  arrayEq shared[0..8], shared[...-1]

  for a in [-shared.length..shared.length]
    arrayEq shared[a..] , shared[a...]
  for a in [-shared.length+1...shared.length]
    arrayEq shared[..a][...-1] , shared[...a]

  arrayEq [1, 2, 3], [1, 2, 3][..]

  arrayEq shared, shared[0..-1]
  arrayEq shared, shared[..-1]
  arrayEq shared.slice(1,shared.length), shared[1..-1]

test "string slicing", ->
  str = "abcdefghijklmnopqrstuvwxyz"
  ok str[1...1] is ""
  ok str[1..1] is "b"
  ok str[1...5] is "bcde"
  ok str[0..4] is "abcde"
  ok str[-5..] is "vwxyz"

  list = [0..9]
  arrayEq [0..n], list[..n]
  arrayEq [0..n], list[..n or 0]
  arrayEq [0..n], list[..if n then n else 0]

  arrayEq [0, 1], [0..10][.."1"]



test "basic splicing", ->
  ary = [0..9]
  ary[5..9] = [0, 0, 0]
  arrayEq [0, 1, 2, 3, 4, 0, 0, 0], ary

  ary = [0..9]
  ary[2...8] = []
  arrayEq [0, 1, 8, 9], ary

test "unbounded splicing", ->
  ary = [0..9]
  ary[3..] = [9, 8, 7]
  arrayEq [0, 1, 2, 9, 8, 7]. ary

  ary[...3] = [7, 8, 9]
  arrayEq [7, 8, 9, 9, 8, 7], ary

  ary[..] = [1, 2, 3]
  arrayEq [1, 2, 3], ary

test "splicing with variables as endpoints", ->
  [a, b] = [1, 8]

  ary = [0..9]
  ary[a..b] = [2, 3]
  arrayEq [0, 2, 3, 9], ary

  ary = [0..9]
  ary[a...b] = [5]
  arrayEq [0, 5, 8, 9], ary

test "splicing with expressions as endpoints", ->
  [a, b] = [1, 3]

  ary = [0..9]
  ary[ a+1 .. 2*b+1 ] = [4]
  arrayEq [0, 1, 4, 8, 9], ary

  ary = [0..9]
  ary[a+1...2*b+1] = [4]
  arrayEq [0, 1, 4, 7, 8, 9], ary

test "splicing to the end, against a one-time function", ->
  ary = null
  fn = ->
    if ary
      throw 'err'
    else
      ary = [1, 2, 3]

  fn()[0..] = 1

  arrayEq ary, [1]

test "the return value of a splice literal should be the RHS", ->
  ary = [0, 0, 0]
  eq (ary[0..1] = 2), 2

  ary = [0, 0, 0]
  eq (ary[0..] = 3), 3

  arrayEq [ary[0..0] = 0], [0]


  list = [0..9]
  list[..n] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..n or 0] = n
  arrayEq [n..9], list

  list = [0..9]
  list[..if n then n else 0] = n
  arrayEq [n..9], list




test "soaked property access", ->
  nonce = {}
  obj = a: b: nonce
  eq nonce    , obj?.a.b
  eq nonce    , obj?['a'].b
  eq nonce    , obj.a?.b
  eq nonce    , obj?.a?['b']
  eq undefined, obj?.a?.non?.existent?.property

test "soaked property access caches method calls", ->
  nonce ={}
  obj = fn: -> a: nonce
  eq nonce    , obj.fn()?.a
  eq undefined, obj.fn()?.b

test "soaked property access caching", ->
  nonce = {}
  counter = 0
  fn = ->
    counter++
    'self'
  obj =
    self: -> @
    prop: nonce
  eq nonce, obj[fn()]()[fn()]()[fn()]()?.prop
  eq 3, counter

test "method calls on soaked methods", ->
  nonce = {}
  obj = null
  eq undefined, obj?.a().b()
  obj = a: -> b: -> nonce
  eq nonce    , obj?.a().b()

test "postfix existential operator mixes well with soaked property accesses", ->
  eq false, nonexistent?.property?

test "function invocation with soaked property access", ->
  id = (_) -> _
  eq undefined, id nonexistent?.method()

test "if-to-ternary should safely parenthesize soaked property accesses", ->
  ok (if nonexistent?.property then false else true)

  eq undefined, nonexistent?[Date()]

  a = null
  ok isNaN      a?.b.c +  1
  eq undefined, a?.b.c += 1
  eq undefined, ++a?.b.c
  eq undefined, delete a?.b.c

test "operations on soaked properties", ->
  a = b: {c: 0}
  eq 1,   a?.b.c +  1
  eq 1,   a?.b.c += 1
  eq 2,   ++a?.b.c
  eq yes, delete a?.b.c



test "soaked method invocation", ->
  nonce = {}
  counter = 0
  obj =
    self: -> @
    increment: -> counter++; @
  eq obj      , obj.self?()
  eq undefined, obj.method?()
  eq nonce    , obj.self?().property = nonce
  eq undefined, obj.method?().property = nonce
  eq obj      , obj.increment().increment().self?()
  eq 2        , counter

  a = b: {c: null}
  eq a.b?.c?(), undefined
  a.b?.c or= (it) -> it
  eq a.b?.c?(1), 1
  eq a.b?.c?([2, 3]...), 2



test "soaked function invocation", ->
  nonce = {}
  id = (_) -> _
  eq nonce    , id?(nonce)
  eq nonce    , (id? nonce)
  eq undefined, nonexistent?(nonce)
  eq undefined, (nonexistent? nonce)

test "soaked function invocation with generated functions", ->
  nonce = {}
  id = (_) -> _
  maybe = (fn, arg) -> if typeof fn is 'function' then () -> fn(arg)
  eq maybe(id, nonce)?(), nonce
  eq (maybe id, nonce)?(), nonce
  eq (maybe false, nonce)?(), undefined

test "soaked constructor invocation", ->
  eq 42       , +new Number? 42
  eq undefined,  new Other?  42

test "soaked constructor invocations with caching and property access", ->
  semaphore = 0
  nonce = {}
  class C
    constructor: ->
      ok false if semaphore
      semaphore++
    prop: nonce
  eq nonce, (new C())?.prop
  eq 1, semaphore

test "soaked function invocation safe on non-functions", ->
  eq undefined, 0?(1)
  eq undefined, 0? 1, 2


strict = (code, msg) ->
  throws (-> CoffeeScript.compile code), null, msg ? code
strictOk = (code, msg) ->
  doesNotThrow (-> CoffeeScript.compile code), msg ? code


test "octal integer literals prohibited", ->
  strict    '01'
  strict    '07777'
  strict    '09'
  strict    '079'
  strictOk  '`01`'

test "octal escape sequences prohibited", ->
  strict    '"\\1"'
  strict    '"\\7"'
  strict    '"\\001"'
  strict    '"\\777"'
  strict    '"_\\1"'
  strict    '"\\1_"'
  strict    '"_\\1_"'
  strict    '"\\\\\\1"'
  strictOk  '"\\0"'
  eq "\x00", "\0"
  strictOk  '"\\08"'
  eq "\x008", "\08"
  strictOk  '"\\0\\8"'
  eq "\x008", "\0\8"
  strictOk  '"\\8"'
  eq "8", "\8"
  strictOk  '"\\\\1"'
  eq "\\" + "1", "\\1"
  strictOk  '"\\\\\\\\1"'
  eq "\\\\" + "1", "\\\\1"
  strictOk  "`'\\1'`"
  eq "\\" + "1", `"\\1"`

test "duplicate formal parameters are prohibited", ->
  nonce = {}
  strict '(_,_)->',          'param, param'
  strict '(_,@_)->',         'param, @param'
  strict '(_,_...)->',       'param, param...'
  strict '(@_,_...)->',      '@param, param...'
  strict '(_,_ = true)->',   'param, param='
  strict '(@_,@_)->',        'two @params'
  strict '(_,@_ = true)->',  'param, @param='
  strict '(_,{_})->',        'param, {param}'
  strict '(@_,{_})->',       '@param, {param}'
  strict '({_,_})->',        '{param, param}'
  strict '({_,@_})->',       '{param, @param}'
  strict '(_,[_])->',        'param, [param]'
  strict '([_,_])->',        '[param, param]'
  strict '([_,@_])->',       '[param, @param]'
  strict '(_,[_]=true)->',   'param, [param]='
  strict '(_,[@_,{_}])->',   'param, [@param, {param}]'
  strict '(_,[_,{@_}])->',   'param, [param, {@param}]'
  strict '(_,[_,{_}])->',    'param, [param, {param}]'
  strict '(_,[_,{__}])->',   'param, [param, {param2}]'
  strict '(_,[__,{_}])->',   'param, [param2, {param}]'
  strict '(__,[_,{_}])->',   'param, [param2, {param2}]'
  strict '(0:a,1:a)->',      '0:param,1:param'
  strict '({0:a,1:a})->',    '{0:param,1:param}'
  strictOk '({},_arg)->'
  strictOk '({},{})->'
  strictOk '([]...,_arg)->'
  strictOk '({}...,_arg)->'
  strictOk '({}...,[],_arg)->'
  strictOk '([]...,{},_arg)->'
  strictOk '(@case,_case)->'
  strictOk '(@case,_case...)->'
  strictOk '(@case...,_case)->'
  strictOk '(_case,@case)->'
  strictOk '(_case,@case...)->'
  strictOk '(a:a)->'
  strictOk '(a:a,a:b)->'

test "`delete` operand restrictions", ->
  strict 'a = 1; delete a'
  strict '(a) -> delete a'
  strict '(@a) -> delete a'
  strict '(a...) -> delete a'
  strict '(a = 1) -> delete a'
  strict '([a]) -> delete a'
  strict '({a}) -> delete a'

test "`Future Reserved Word`s, `eval` and `arguments` restrictions", ->

  access = (keyword, check = strict) ->
  assign = (keyword, check = strict) ->
    check "{keyword}++"
    check "++{keyword}"
    check "{keyword}--"
    check "--{keyword}"
  destruct = (keyword, check = strict) ->
  invoke = (keyword, check = strict) ->
  fnDecl = (keyword, check = strict) ->
  param = (keyword, check = strict) ->
  prop = (keyword, check = strict) ->
  tryCatch = (keyword, check = strict) ->

  future = 'implements interface let package private protected public static yield'.split ' '
  for keyword in future
    access   keyword
    assign   keyword
    destruct keyword
    invoke   keyword
    fnDecl   keyword
    param    keyword
    prop     keyword, strictOk
    tryCatch keyword

  for keyword in ['eval', 'arguments']
    access   keyword, strictOk
    assign   keyword
    destruct keyword, strictOk
    invoke   keyword, strictOk
    fnDecl   keyword
    param    keyword
    prop     keyword, strictOk
    tryCatch keyword



test "backslash escapes", ->
  eq "\\/\\\\", /\/\\/.source

eq '(((dollars)))', '\(\(\(dollars\)\)\)'
eq 'one two three', "one
 two
 three"
eq "four five", 'four

 five'

eq "''Hello, World\\''", '''
'\'Hello, World\\\''
'''
eq '""Hello, World\\""', """
"\"Hello, World\\\""
"""
eq 'Hello, World\n', '''
Hello, World\

'''

a = """
    basic heredoc
    on two lines
    """
ok a is "basic heredoc\non two lines"

a = '''
    a
      "b
    c
    '''
ok a is "a\n  \"b\nc"

a = """
a
 b
  c
"""
ok a is "a\n b\n  c"

a = '''one-liner'''
ok a is 'one-liner'

a = """
      out
      here
"""
ok a is "out\nhere"

a = '''
       a
     b
   c
    '''
ok a is "    a\n  b\nc"

a = '''
a


b c
'''
ok a is "a\n\n\nb c"

a = '''more"than"one"quote'''
ok a is 'more"than"one"quote'

a = '''here's an apostrophe'''
ok a is "here's an apostrophe"

a = """
    one
    two

    """
ok a is "one\ntwo\n"

eq ''' line 0
  should not be relevant
    to the indent level
''', '
 line 0\n
should not be relevant\n
  to the indent level
'

eq ''' '\\\' ''', " '\\' "
eq """ "\\\" """, ' "\\" '

eq '''  <- keep these spaces ->  ''', '  <- keep these spaces ->  '



obj = foo: 'bar'

describe 'coffeescript', ->
  it 'should work', ->
    obj.should.eql foo: 'bar'fs = require 'fs'
path = require 'path'
{concat, foldl} = require './functional-helpers'
{numberLines, humanReadable} = require './helpers'
{Preprocessor} = require './preprocessor'
{Optimiser} = require './optimiser'
CoffeeScript = require './module'
cscodegen = try require 'cscodegen'
escodegen = try require 'escodegen'
uglifyjs = try require 'uglify-js'

inspect = (o) -> (require 'util').inspect o, no, 9e9, yes

args = process.argv[1 + (process.argv[0] is 'node') ..]

additionalArgs = []
if '--' in args then additionalArgs = (args.splice (args.indexOf '--'), 9e9)[1..]


options = {}
optionMap = {}

optionArguments = [
  [['parse',   'p'], off, 'output a JSON-serialised AST representation of the input']
  [['compile', 'c'], off, 'output a JSON-serialised AST representation of the output']
  [['optimise'    ],  on, 'enable optimisations (default: on)']
  [['debug'       ], off, 'output intermediate representations on stderr for debug']
  [['version', 'v'], off, 'display the version number']
  [['help'        ], off, 'display this help message']
]

parameterArguments = [
  [['cli'         ], 'INPUT', 'pass a string from the command line as input']
  [['input',   'i'], 'FILE' , 'file to be used as input instead of STDIN']
  [['nodejs'      ], 'OPTS' , 'pass options through to the node binary']
  [['output',  'o'], 'FILE' , 'file to be used as output instead of STDIN']
  [['watch',   'w'], 'FILE' , 'watch the given file/directory for changes']
]

if escodegen?
  [].push.apply optionArguments, [
    [['bare',    'b'], off, 'omit the top-level function wrapper']
    [['js',      'j'], off, 'generate JavaScript output']
    [['source-map'  ], off, 'generate source map']
    [['eval',    'e'], off, 'evaluate compiled JavaScript']
    [['repl'        ], off, 'run an interactive CoffeeScript REPL']
  ]
  if uglifyjs?
    optionArguments.push [['minify',  'm'], off, 'run compiled javascript output through a JS minifier']
  parameterArguments.push [['require', 'I'], 'FILE' , 'require a library before a script is executed']

if cscodegen?
  optionArguments.push [['cscodegen', 'f'], off, 'output cscodegen-generated CoffeeScript code']


shortOptionArguments = []
longOptionArguments = []
for opts in optionArguments
  options[opts[0][0]] = opts[1]
  for o in opts[0]
    optionMap[o] = opts[0][0]
    if o.length is 1 then shortOptionArguments.push o
    else if o.length > 1 then longOptionArguments.push o

shortParameterArguments = []
longParameterArguments = []
for opts in parameterArguments
  for o in opts[0]
    optionMap[o] = opts[0][0]
    if o.length is 1 then shortParameterArguments.push o
    else if o.length > 1 then longParameterArguments.push o


reShortOptionsShortParameter = ///
///


positionalArgs = []
while args.length
  arg = args.shift()
  if reShortOptionsShortParameter.exec arg
  else if reShortOptions.exec arg
    for o in arg[1..].split ''
      options[optionMap[o]] = on
  else if match = reLongOption.exec arg
    options[optionMap[match[2]]] = if match[1]? then off else on
  else if match = (reShortParameter.exec arg) ? reLongParameter.exec arg
    options[optionMap[match[1]]] = args.shift()
  else if match = /^(-.|--.*)$/.exec arg
    process.exit 1
  else
    positionalArgs.push arg



positionalArgs = positionalArgs.concat additionalArgs
unless options.compile or options.js or options['source-map'] or options.parse or options.eval or options.cscodegen
  if not escodegen?
    options.compile = on
  else if positionalArgs.length
    options.eval = on
    options.input = positionalArgs.shift()
    additionalArgs = positionalArgs
  else
    options.repl = on

if 1 isnt options.parse + options.compile + (options.js ? 0) + (options['source-map'] ? 0) + (options.eval ? 0) + (options.cscodegen ? 0) + (options.repl ? 0)
  console.error "Error: At most one of --parse (-p), --compile (-c), --js (-j), --source-map, --eval (-e), --cscodegen, or --repl may be used."
  process.exit 1

if 1 < options.input? + options.watch? + options.cli?
  console.error 'Error: At most one of --input (-i), --watch (-w), or --cli may be used.'
  process.exit 1

if options.require? and not options.eval
  console.error 'Error: --require (-I) depends on --eval (-e)'
  process.exit 1

if options.minify and not (options.js or options.eval)
  console.error 'Error: --minify does not make sense without --js or --eval'
  process.exit 1

if options.bare and not (options.compile or options.js or options['source-map'] or options.eval)
  console.error 'Error: --bare does not make sense without --compile, --js, --source-map, or --eval'
  process.exit 1

if options.input? and (fs.statSync options.input).isDirectory() and (not options.output? or (fs.statSync options.output)?.isFile())
  console.error 'Error: when --input is a directory, --output must be provided, and --output must not reference a file'

if options.cscodegen and not cscodegen?
  console.error 'Error: cscodegen must be installed to use --cscodegen'
  process.exit 1


if options.help
  $0 = if process.argv[0] is 'node' then process.argv[1] else process.argv[0]
  $0 = path.basename $0
  maxWidth = 85

  wrap = (lhsWidth, input) ->
    rhsWidth = maxWidth - lhsWidth
    pad = (Array lhsWidth + 4 + 1).join ' '
    rows = while input.length
      row = input[...rhsWidth]
      input = input[rhsWidth..]
      row

  formatOptions = (opts) ->
    opts = for opt in opts
      switch opt.length
        when 0 then continue
    opts.sort (a, b) -> a.length - b.length
    opts.join ', '

  console.log """
    Usage:

  """

  optionRows = for opt in optionArguments
    [(formatOptions opt[0]), opt[2]]
  parameterRows = for opt in parameterArguments
  leftColumnWidth = foldl 0, [optionRows..., parameterRows...], (memo, opt) ->
    Math.max memo, opt[0].length

  rows = [optionRows..., parameterRows...]
  rows.sort (a, b) ->
    a = a[0]; b = b[0]
    if a[0..1] is '--' and b[0..1] isnt '--' then return 1
    if b[0..1] is '--' and a[0..1] isnt '--' then return -1
    if a.toLowerCase() < b.toLowerCase() then -1 else 1
  for row in rows

  console.log """

    When none of -{-parse,p,-compile,c,-js,j,-eval,e,-cscodegen,-repl} are given
      If positional arguments were given
        * --eval is implied
        * the first positional argument is used as an input filename
        * additional positional arguments are passed as arguments to the script
      Else --repl is implied
  """

else if options.version
  pkg = require path.join __dirname, '..', '..', 'package.json'

else if options.repl
  console.error 'TODO: REPL'
  process.exit 1

else

  input = ''

  processInput = (err) ->

    throw err if err?
    result = null

    input = input.toString()
    if 0xFEFF is input.charCodeAt 0 then input = input[1..]

    if options.debug
      try
        console.error numberLines humanReadable Preprocessor.processSync input

    try result = CoffeeScript.parse input, optimise: no
    catch e
      console.error e.message
      process.exit 1
    if options.debug and options.optimise and result?
      console.error inspect result.toJSON()

    if options.optimise and result?
      result = Optimiser.optimise result

    if options.parse
      if result?
        console.log inspect result.toJSON()
        process.exit 0
      else process.exit 1

    if options.debug and result?
      console.error inspect result.toJSON()

    if options.cscodegen
      try result = cscodegen.generate result
      catch e
        console.error (e.stack or e.message)
        process.exit 1
      if result?
        console.log result
        process.exit 0
      else process.exit 1

    result = CoffeeScript.compile result, bare: options.bare

    if options.compile
      if result?
        console.log inspect result.toJSON()
        process.exit 0
      else process.exit 1

    if options.debug and result?
      console.error inspect result.toJSON()


    if options['source-map']
      try result = CoffeeScript.sourceMap result, options.input ? (options.cli and 'cli' or 'stdin')
      catch e
        console.error (e.stack or e.message)
        process.exit 1
      if result?
        process.exit 0
      else process.exit 1
    else
      try result = CoffeeScript.js result, minify: no
      catch e
        console.error (e.stack or e.message)
        process.exit 1

    if options.minify and result?
      try result = uglifyjs.uglify.gen_code uglifyjs.uglify.ast_squeeze uglifyjs.uglify.ast_mangle uglifyjs.parser.parse result
      catch e
        console.error (e.stack or e.message)
        process.exit 1

    if options.js
      if result?
        console.log result
        process.exit 0
      else process.exit 1

    if options.eval
      do -> (0; eval) result



  if options.input?
    fs.readFile options.input, (err, contents) ->
      throw err if err?
      input = contents
      do processInput
  else if options.watch?
  else if options.cli?
    input = options.cli
    do processInput
  else
    process.stdin.on 'data', (data) -> input += data
    process.stdin.on 'end', processInput
    process.stdin.setEncoding 'utf8'
    do process.stdin.resume
{any, concat, concatMap, difference, divMod, foldl1, map, nub, owns, span, union} = require './functional-helpers'
{beingDeclared, usedAsExpression, envEnrichments} = require './helpers'
CS = require './nodes'
JS = require './js-nodes'
exports = module?.exports ? this



jsReserved = [
  'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do',
  'else', 'enum', 'export', 'extends', 'false', 'finally', 'for', 'function', 'if', 'implements',
  'import', 'in', 'instanceof', 'interface', 'let', 'native', 'new', 'null', 'package', 'private',
  'protected', 'public', 'return', 'static', 'super', 'switch', 'this', 'throw', 'true', 'try',
  'typeof', 'var', 'void', 'while', 'with', 'yield', 'arguments', 'eval'
]


genSym = do ->
  genSymCounter = 0
  (pre) -> new JS.GenSym pre, ++genSymCounter


stmt = (e) ->
  return e unless e?
  if e.isStatement then e
  else if e.instanceof JS.SequenceExpression
    walk = (seq) ->
      concatMap seq.expressions, (e) ->
        if e.instanceof JS.SequenceExpression then walk e
        else [stmt e]
    new JS.BlockStatement walk e
  else if e.instanceof JS.ConditionalExpression
    new JS.IfStatement (expr e.test), (stmt e.consequent), stmt e.alternate
  else new JS.ExpressionStatement e

expr = (s) ->
  return s unless s?
  if s.isExpression then s
  else if s.instanceof JS.BlockStatement
    switch s.body.length
      when 0 then helpers.undef()
      when 1 then expr s.body[0]
      else new JS.SequenceExpression map s.body, expr
  else if s.instanceof JS.BreakStatement, JS.ContinueStatement, JS.ReturnStatement
    throw new Error "pure statement in an expression"
  else if s.instanceof JS.ExpressionStatement
    s.expression
  else if s.instanceof JS.IfStatement
    consequent = expr (s.consequent ? helpers.undef())
    alternate = expr (s.alternate ? helpers.undef())
    new JS.ConditionalExpression s.test, consequent, alternate
  else if s.instanceof JS.ForInStatement, JS.ForStatement, JS.WhileStatement
    accum = genSym 'accum'
    s.body = forceBlock s.body
    push = memberAccess accum, 'push'
    s.body.body[s.body.body.length - 1] = stmt new JS.CallExpression push, [expr s.body.body[-1..][0]]
    block = new JS.BlockStatement [s, new JS.ReturnStatement accum]
    iife = new JS.FunctionExpression null, [accum], block
    new JS.CallExpression (memberAccess iife, 'call'), [new JS.ThisExpression, new JS.ArrayExpression []]
  else if s.instanceof JS.SwitchStatement, JS.TryStatement
    block = new JS.BlockStatement [makeReturn s]
    iife = new JS.FunctionExpression null, [], block
    new JS.CallExpression (memberAccess iife, 'call'), [new JS.ThisExpression]
  else

makeReturn = (node) ->
  return new JS.ReturnStatement unless node?
  if node.instanceof JS.BlockStatement
    new JS.BlockStatement [node.body[...-1]..., makeReturn node.body[-1..][0]]
  else if node.instanceof JS.SequenceExpression
    new JS.SequenceExpression [node.expressions[...-1]..., makeReturn node.expressions[-1..][0]]
  else if node.instanceof JS.IfStatement
    new JS.IfStatement node.test, (makeReturn node.consequent), if node.alternate? then makeReturn node.alternate else null
  else if node.instanceof JS.SwitchStatement
    new JS.SwitchStatement node.discriminant, map node.cases, makeReturn
  else if node.instanceof JS.SwitchCase
    return node unless node.consequent.length
    stmts = if node.consequent[-1..][0].instanceof JS.BreakStatement then node.consequent[...-1] else node.consequent
    new JS.SwitchCase node.test, [stmts[...-1]..., makeReturn stmts[-1..][0]]
  else if node.instanceof JS.TryStatement
    new JS.TryStatement (makeReturn node.block), (map node.handlers, makeReturn), if node.finalizer? then makeReturn node.finalizer else null
  else if node.instanceof JS.CatchClause
    new JS.CatchClause node.param, makeReturn node.body
  else if node.instanceof JS.ThrowStatement, JS.ReturnStatement, JS.BreakStatement, JS.ContinueStatement then node
  else if (node.instanceof JS.UnaryExpression) and node.operator is 'void' then new JS.ReturnStatement
  else new JS.ReturnStatement expr node


generateMutatingWalker = (fn) -> (node, args...) ->
  for childName in node.childNodes
    continue unless node[childName]?
    node[childName] =
      if childName in node.listMembers
        for n in node[childName]
          fn.apply n, args
      else
        fn.apply node[childName], args
  node

declarationsNeeded = (node) ->
  return [] unless node?
  if (node.instanceof JS.AssignmentExpression) and node.operator is '=' and node.left.instanceof JS.Identifier then [node.left]
  else if node.instanceof JS.ForInStatement then [node.left]
  else []

declarationsNeededRecursive = (node) ->
  return [] unless node?
  if node.instanceof JS.FunctionExpression, JS.FunctionDeclaration then []
  else union (declarationsNeeded node), concatMap node.childNodes, (childName) ->
    return [] unless node[childName]?
    if childName in node.listMembers then concatMap node[childName], declarationsNeededRecursive
    else declarationsNeededRecursive node[childName]

collectIdentifiers = (node) -> nub switch
  when !node? then []
  when node.instanceof JS.Identifier then [node.name]
  when (node.instanceof JS.MemberExpression) and not node.computed
    collectIdentifiers node.object
  else concatMap node.childNodes, (childName) ->
    return [] unless node[childName]?
    if childName in node.listMembers
      concatMap node[childName], collectIdentifiers
    else
      collectIdentifiers node[childName]

needsCaching = (node) ->
  return no unless node?
  (envEnrichments node, []).length > 0 or
  (node.instanceof CS.FunctionApplications, CS.DoOp, CS.NewOp, CS.ArrayInitialiser, CS.ObjectInitialiser, CS.RegExp, CS.HeregExp, CS.PreIncrementOp, CS.PostIncrementOp, CS.PreDecrementOp, CS.PostDecrementOp) or
  (any (difference node.childNodes, node.listMembers), (n) -> needsCaching node[n]) or
  (any node.listMembers, (n) -> any node[n], needsCaching)

forceBlock = (node) ->
  return new JS.BlockStatement [] unless node?
  node = stmt node
  if node.instanceof JS.BlockStatement then node
  else new JS.BlockStatement [node]

makeVarDeclaration = (vars) ->
  vars.sort (a, b) ->
    a = a.name.toLowerCase()
    b = b.name.toLowerCase()
    if a < b then -1 else if a > b then 1 else 0
  decls = for v in vars
    new JS.VariableDeclarator v
  new JS.VariableDeclaration 'var', decls

memberAccess = (e, member) ->
  if member in jsReserved or not isIdentifierName.test member
  then new JS.MemberExpression yes, (expr e), new JS.Literal member
  else new JS.MemberExpression no, (expr e), new JS.Identifier member

dynamicMemberAccess = (e, index) ->
  if (index.instanceof JS.Literal) and typeof index.value is 'string'
  then memberAccess e, index.value
  else new JS.MemberExpression yes, e, index

assignment = (assignee, expression, valueUsed = no) ->
  assignments = []
  switch
    when assignee.instanceof JS.ArrayExpression
      e = expression
      if valueUsed or assignee.elements.length > 1
        e = genSym 'cache'
        assignments.push new JS.AssignmentExpression '=', e, expression

      elements = assignee.elements

      for m, i in elements
        break if m.rest
        assignments.push assignment m, (dynamicMemberAccess e, new JS.Literal i), valueUsed

      if elements.length > 0
        if elements[-1..][0].rest
          numElements = elements.length
          restName = elements[numElements - 1] = elements[numElements - 1].expression
          test = new JS.BinaryExpression '<=', (new JS.Literal numElements), memberAccess e, 'length'
          consequent = helpers.slice e, new JS.Literal (numElements - 1)
          alternate = new JS.ArrayExpression []
          assignments.push stmt new JS.AssignmentExpression '=', restName, new JS.ConditionalExpression test, consequent, alternate
        else if any elements, ((p) -> p.rest)
          restName = index = null
          for p, i in elements when p.rest
            restName = p.expression
            index = i
            break
          elements.splice index, 1
          numElements = elements.length
          size = genSym 'size'
          assignments.push new JS.AssignmentExpression '=', size, memberAccess e, 'length'
          test = new JS.BinaryExpression '>', size, new JS.Literal numElements
          consequent = helpers.slice e, (new JS.Literal index), new JS.BinaryExpression '-', size, new JS.Literal numElements - index
          assignments.push new JS.AssignmentExpression '=', restName, new JS.ConditionalExpression test, consequent, new JS.ArrayExpression []
          for p, i in elements[index...]
            assignments.push stmt new JS.AssignmentExpression '=', p, new JS.MemberExpression yes, e, new JS.BinaryExpression '-', size, new JS.Literal numElements - index - i
        if any elements, ((p) -> p.rest)
          throw new Error 'Positional destructuring assignments may not have more than one rest operator'

    when assignee.instanceof JS.ObjectExpression
      e = expression
      if valueUsed or assignee.properties.length > 1
        e = genSym 'cache'
        assignments.push new JS.AssignmentExpression '=', e, expression

      for m in assignee.properties
        propName = if m.key.instanceof JS.Identifier then new JS.Literal m.key.name else m.key
        assignments.push assignment m.value, (dynamicMemberAccess e, propName), valueUsed

    when assignee.instanceof JS.Identifier, JS.GenSym, JS.MemberExpression
      assignments.push new JS.AssignmentExpression '=', assignee, expr expression
    else
  switch assignments.length
    when 0 then (if e is expression then helpers.undef() else expression)
    when 1 then assignments[0]
    else new JS.SequenceExpression if valueUsed then [assignments..., e] else assignments


helperNames = {}
helpers =
  extends: ->
    protoAccess = (e) -> memberAccess e, 'prototype'
    child = new JS.Identifier 'child'
    parent = new JS.Identifier 'parent'
    ctor = new JS.Identifier 'ctor'
    key = new JS.Identifier 'key'
    block = [
        stmt new JS.AssignmentExpression '=', (new JS.MemberExpression yes, child, key), new JS.MemberExpression yes, parent, key
      new JS.FunctionDeclaration ctor, [], new JS.BlockStatement [
        stmt new JS.AssignmentExpression '=', (memberAccess new JS.ThisExpression, 'constructor'), child
      ]
      new JS.AssignmentExpression '=', (protoAccess ctor), protoAccess parent
      new JS.AssignmentExpression '=', (protoAccess child), new JS.NewExpression ctor, []
      new JS.AssignmentExpression '=', (memberAccess child, '__super__'), protoAccess parent
      new JS.ReturnStatement child
    ]
    new JS.FunctionDeclaration helperNames.extends, [child, parent], new JS.BlockStatement map block, stmt
  construct: ->
    child = new JS.Identifier 'child'
    ctor = new JS.Identifier 'ctor'
    fn = new JS.Identifier 'fn'
    args = new JS.Identifier 'args'
    result = new JS.Identifier 'result'
    block = [
      new JS.VariableDeclaration 'var', [
        new JS.VariableDeclarator fn, new JS.FunctionExpression null, [], new JS.BlockStatement []
      ]
      new JS.AssignmentExpression '=', (memberAccess fn, 'prototype'), memberAccess ctor, 'prototype'
      new JS.VariableDeclaration 'var', [
        new JS.VariableDeclarator child, new JS.NewExpression fn, []
        new JS.VariableDeclarator result, new JS.CallExpression (memberAccess ctor, 'apply'), [child, args]
      ]
      new JS.ReturnStatement new JS.ConditionalExpression (new JS.BinaryExpression '===', result, new JS.CallExpression (new JS.Identifier 'Object'), [result]), result, child
    ]
    new JS.FunctionDeclaration helperNames.construct, [ctor, args], new JS.BlockStatement map block, stmt
  isOwn: ->
    hop = memberAccess (new JS.ObjectExpression []), 'hasOwnProperty'
    params = args = [(new JS.Identifier 'o'), new JS.Identifier 'p']
    functionBody = [new JS.CallExpression (memberAccess hop, 'call'), args]
    new JS.FunctionDeclaration helperNames.isOwn, params, makeReturn new JS.BlockStatement map functionBody, stmt
  in: ->
    member = new JS.Identifier 'member'
    list = new JS.Identifier 'list'
    i = new JS.Identifier 'i'
    length = new JS.Identifier 'length'
    varDeclaration = new JS.VariableDeclaration 'var', [
      new JS.VariableDeclarator i, new JS.Literal 0
      new JS.VariableDeclarator length, memberAccess list, 'length'
    ]
    loopBody = new JS.IfStatement (new JS.BinaryExpression '&&', (new JS.BinaryExpression 'in', i, list), (new JS.BinaryExpression '===', (new JS.MemberExpression yes, list, i), member)), new JS.ReturnStatement new JS.Literal yes
    functionBody = [
      new JS.ForStatement varDeclaration, (new JS.BinaryExpression '<', i, length), (new JS.UpdateExpression '++', yes, i), loopBody
      new JS.Literal no
    ]
    new JS.FunctionDeclaration helperNames.in, [member, list], makeReturn new JS.BlockStatement map functionBody, stmt

enabledHelpers = []
for h, fn of helpers
  helperNames[h] = genSym h
  helpers[h] = do (h, fn) -> ->
    enabledHelpers.push fn()
    (helpers[h] = -> new JS.CallExpression helperNames[h], arguments).apply this, arguments

inlineHelpers =
  exp: -> new JS.CallExpression (memberAccess (new JS.Identifier 'Math'), 'pow'), arguments
  undef: -> new JS.UnaryExpression 'void', new JS.Literal 0
  slice: -> new JS.CallExpression (memberAccess (memberAccess (new JS.ArrayExpression []), 'slice'), 'call'), arguments

for h, fn of inlineHelpers
  helpers[h] = fn



class exports.Compiler

  @compile = => (new this).compile arguments...

  defaultRules = [
    [CS.Program, ({body, inScope, options}) ->
      return new JS.Program [] unless body?
      block = stmt body
      block =
        if block.instanceof JS.BlockStatement then block.body
        else [block]
      [].push.apply block, enabledHelpers
      decls = nub concatMap block, declarationsNeededRecursive
      if decls.length > 0
        if options.bare
          block.unshift makeVarDeclaration decls
        else
          block = [stmt new JS.UnaryExpression 'void', new JS.CallExpression (memberAccess (new JS.FunctionExpression null, [], new JS.BlockStatement block), 'call'), [new JS.ThisExpression]]
      program = new JS.Program block
      program.leadingComments = [
        type: 'Line'
      ]
      program
    ]
    [CS.Block, ({statements}) ->
      switch statements.length
        when 0 then new JS.EmptyStatement
        when 1 then new stmt statements[0]
        else new JS.BlockStatement map statements, stmt
    ]
    [CS.SeqOp, ({left, right})-> new JS.SequenceExpression [left, right]]
    [CS.Conditional, ({condition, consequent, alternate, ancestry}) ->
      if alternate?
        throw new Error 'Conditional with non-null alternate requires non-null consequent' unless consequent?
        alternate = forceBlock alternate unless alternate.instanceof JS.IfStatement
      if alternate? or ancestry[0]?.instanceof CS.Conditional
        consequent = forceBlock consequent
      new JS.IfStatement (expr condition), (stmt consequent), alternate
    ]
    [CS.ForIn, ({valAssignee, keyAssignee, target, step, filter, body}) ->
      i = genSym 'i'
      length = genSym 'length'
      block = forceBlock body
      e = if needsCaching @target then genSym 'cache' else target
      varDeclaration = new JS.VariableDeclaration 'var', [
        new JS.VariableDeclarator i, new JS.Literal 0
        new JS.VariableDeclarator length, memberAccess e, 'length'
      ]
      unless e is target
        varDeclaration.declarations.unshift new JS.VariableDeclarator e, target
      if @filter?
        block.body.unshift stmt new JS.IfStatement (new JS.UnaryExpression '!', filter), new JS.ContinueStatement
      if keyAssignee?
        block.body.unshift stmt assignment keyAssignee, i
      block.body.unshift stmt assignment valAssignee, new JS.MemberExpression yes, e, i
      new JS.ForStatement varDeclaration, (new JS.BinaryExpression '<', i, length), (new JS.UpdateExpression '++', yes, i), block
    ]
    [CS.ForOf, ({keyAssignee, valAssignee, target, filter, body}) ->
      block = forceBlock body
      e = if @isOwn and needsCaching @target then genSym 'cache' else expr target
      if @filter?
        block.body.unshift stmt new JS.IfStatement (new JS.UnaryExpression '!', filter), new JS.ContinueStatement
      if valAssignee?
        block.body.unshift stmt assignment valAssignee, new JS.MemberExpression yes, e, keyAssignee
      if @isOwn
        block.body.unshift stmt new JS.IfStatement (new JS.UnaryExpression '!', helpers.isOwn e, keyAssignee), new JS.ContinueStatement
      right = if e is target then e else new JS.AssignmentExpression '=', e, target
      new JS.ForInStatement keyAssignee, right, block
    ]
    [CS.While, ({condition, body}) -> new JS.WhileStatement (expr condition), forceBlock body]
    [CS.Switch, ({expression, cases, alternate}) ->
      cases = concat cases
      unless expression?
        expression = new JS.Literal false
        for c in cases
          c.test = new JS.UnaryExpression '!', c.test
      if alternate?
        cases.push new JS.SwitchCase null, [stmt alternate]
      for c in cases[...-1] when c.consequent?.length > 0
        c.consequent.push new JS.BreakStatement
      new JS.SwitchStatement expression, cases
    ]
    [CS.SwitchCase, ({conditions, consequent}) ->
      cases = map conditions, (c) ->
        new JS.SwitchCase c, []
      block = stmt consequent
      block = if block?
        if block.instanceof JS.BlockStatement then block.body else [block]
      else []
      cases[cases.length - 1].consequent = block
      cases
    ]
    [CS.Try, ({body, catchAssignee, catchBody, finallyBody}) ->
      finallyBlock = if finallyBody? then forceBlock finallyBody else null
      handlers = []
      if catchBody? or catchAssignee?
        e = genSym 'e'
        catchBlock = forceBlock catchBody
        catchBlock.body.unshift stmt assignment catchAssignee, e
        handlers = [new JS.CatchClause e, catchBlock]
      new JS.TryStatement (forceBlock body), handlers, finallyBlock
    ]
    [CS.Throw, ({expression}) -> new JS.ThrowStatement expression]

    [CS.Range, ({left: left_, right: right_}) ->
      if ((@left.instanceof CS.Int) or  ((@left.instanceof CS.UnaryNegateOp) and  @left.expression.instanceof CS.Int)) and
      (  (@right.instanceof CS.Int) or ((@right.instanceof CS.UnaryNegateOp) and @right.expression.instanceof CS.Int))
        rawLeft = if @left.instanceof CS.UnaryNegateOp then -@left.expression.data else @left.data
        rawRight = if @right.instanceof CS.UnaryNegateOp then -@right.expression.data else @right.data
        if (Math.abs rawLeft - rawRight) <= 20
          range = if @isInclusive then [rawLeft..rawRight] else [rawLeft...rawRight]
          return new JS.ArrayExpression map range, (n) -> if n < 0 then new JS.UnaryExpression '-', new JS.Literal -n else new JS.Literal n

      accum = genSym 'accum'
      body = [stmt new JS.AssignmentExpression '=', accum, new JS.ArrayExpression []]

      if needsCaching left_
        left = genSym 'from'
        body.push stmt new JS.AssignmentExpression '=', left, left_
      else left = left_
      if needsCaching right_
        right = genSym 'to'
        body.push stmt new JS.AssignmentExpression '=', right, right_
      else right = right_

      i = genSym 'i'
      vars = new JS.VariableDeclaration 'var', [new JS.VariableDeclarator i, left]

      conditionTest = new JS.BinaryExpression '<=', left, right
      conditionConsequent = new JS.BinaryExpression (if @isInclusive then '<=' else '<'), i, right
      conditionAlternate = new JS.BinaryExpression (if @isInclusive then '>=' else '>'), i, right
      condition = new JS.ConditionalExpression conditionTest, conditionConsequent, conditionAlternate

      update = new JS.ConditionalExpression conditionTest, (new JS.UpdateExpression '++', yes, i), new JS.UpdateExpression '--', yes, i

      body.push new JS.ForStatement vars, condition, update, stmt new JS.CallExpression (memberAccess accum, 'push'), [i]
      body.push new JS.ReturnStatement accum
      new JS.CallExpression (memberAccess (new JS.FunctionExpression null, [], new JS.BlockStatement body), 'apply'), [new JS.ThisExpression, new JS.Identifier 'arguments']
    ]
    [CS.ArrayInitialiser, do ->
      groupMembers = (members) ->
        if members.length is 0 then []
        else
          [ys, zs] = span members, (x) -> not x.spread
          if ys.length is 0
            sliced = helpers.slice zs[0].expression
            [ys, zs] = [sliced, zs[1..]]
          else ys = new JS.ArrayExpression map ys, expr
          [ys].concat groupMembers zs
      ({members, compile}) ->
        if any members, ((m) -> m.spread)
          grouped = groupMembers members
          new JS.CallExpression (memberAccess grouped[0], 'concat'), grouped[1..]
        else new JS.ArrayExpression map members, expr
    ]
    [CS.Spread, ({expression}) -> {spread: yes, expression}]
    [CS.ObjectInitialiser, ({members}) -> new JS.ObjectExpression members]
    [CS.ObjectInitialiserMember, ({key, expression}) -> new JS.Property key, expr expression]
    [CS.DefaultParam, ({param, default: d}) -> {param, default: d}]
    [CS.Function, CS.BoundFunction, do ->

      handleParam = (param, original, block) -> switch
        when original.instanceof CS.Identifier then param
        when original.instanceof CS.MemberAccessOps, CS.ObjectInitialiser, CS.ArrayInitialiser
          p = genSym 'param'
          block.body.unshift stmt assignment param, p
          p
        when original.instanceof CS.DefaultParam
          block.body.unshift new JS.IfStatement (new JS.BinaryExpression '==', (new JS.Literal null), param.param), stmt new JS.AssignmentExpression '=', param.param, param.default
          handleParam.call this, param.param, original.param, block

      ({parameters, body, ancestry}) ->
        unless ancestry[0]?.instanceof CS.Constructor
          body = makeReturn body
        block = forceBlock body
        last = block.body[-1..][0]
        if (last?.instanceof JS.ReturnStatement) and not last.argument?
          block.body = block.body[...-1]

        parameters_ =
          if parameters.length is 0 then []
          else
            pIndex = parameters.length
            while pIndex--
              handleParam.call this, parameters[pIndex], @parameters[pIndex], block
        parameters = parameters_.reverse()

        if parameters.length > 0
          if parameters[-1..][0].rest
            numParams = parameters.length
            paramName = parameters[numParams - 1] = parameters[numParams - 1].expression
            test = new JS.BinaryExpression '<=', (new JS.Literal numParams), memberAccess (new JS.Identifier 'arguments'), 'length'
            consequent = helpers.slice (new JS.Identifier 'arguments'), new JS.Literal (numParams - 1)
            alternate = new JS.ArrayExpression []
            block.body.unshift stmt new JS.AssignmentExpression '=', paramName, new JS.ConditionalExpression test, consequent, alternate
          else if any parameters, ((p) -> p.rest)
            paramName = index = null
            for p, i in parameters when p.rest
              paramName = p.expression
              index = i
              break
            parameters.splice index, 1
            numParams = parameters.length
            numArgs = genSym 'numArgs'
            reassignments = new JS.IfStatement (new JS.BinaryExpression '>', (new JS.AssignmentExpression '=', numArgs, memberAccess (new JS.Identifier 'arguments'), 'length'), new JS.Literal numParams), (new JS.BlockStatement [
              stmt new JS.AssignmentExpression '=', paramName, helpers.slice (new JS.Identifier 'arguments'), (new JS.Literal index), new JS.BinaryExpression '-', numArgs, new JS.Literal numParams - index
            ]), new JS.BlockStatement [stmt new JS.AssignmentExpression '=', paramName, new JS.ArrayExpression []]
            for p, i in parameters[index...]
              reassignments.consequent.body.push stmt new JS.AssignmentExpression '=', p, new JS.MemberExpression yes, (new JS.Identifier 'arguments'), new JS.BinaryExpression '-', numArgs, new JS.Literal numParams - index - i
            block.body.unshift reassignments
          if any parameters, ((p) -> p.rest)
            throw new Error 'Parameter lists may not have more than one rest operator'

        performedRewrite = no
        if @instanceof CS.BoundFunction
          newThis = genSym 'this'
          rewriteThis = generateMutatingWalker ->
            if @instanceof JS.ThisExpression
              performedRewrite = yes
              newThis
            else if @instanceof JS.FunctionExpression, JS.FunctionDeclaration then this
            else rewriteThis this
          rewriteThis block

        fn = new JS.FunctionExpression null, parameters, block
        if performedRewrite
          new JS.SequenceExpression [
            new JS.AssignmentExpression '=', newThis, new JS.ThisExpression
            fn
          ]
        else fn
    ]
    [CS.Rest, ({expression}) -> {rest: yes, expression, isExpression: yes, isStatement: yes}]

    [CS.Class, ({nameAssignee, parent, name, ctor, body, compile}) ->
      args = []
      params = []
      parentRef = genSym 'super'
      block = forceBlock body
      if (name.instanceof JS.Identifier) and name.name in jsReserved
        name = genSym name.name

      if ctor?
        for c, i in block.body when c.instanceof JS.FunctionDeclaration
          ctorIndex = i
          break
        block.body.splice ctorIndex, 1, ctor
      else
        ctor = new JS.FunctionDeclaration name, [], new JS.BlockStatement []
        ctorIndex = 0
        block.body.unshift ctor
      ctor.id = name
      if @ctor? and not @ctor.expression.instanceof CS.Functions
        ctorRef = genSym 'externalCtor'
        ctor.body.body.push makeReturn new JS.CallExpression (memberAccess ctorRef, 'apply'), [new JS.ThisExpression, new JS.Identifier 'arguments']
        block.body.splice ctorIndex, 0, stmt new JS.AssignmentExpression '=', ctorRef, expr compile @ctor.expression

      if @boundMembers.length > 0
        instance = genSym 'instance'
        for protoAssignOp in @boundMembers
          memberName = protoAssignOp.assignee.data.toString()
          ps = (genSym() for _ in protoAssignOp.expression.parameters)
          member = memberAccess new JS.ThisExpression, memberName
          protoMember = memberAccess (memberAccess name, 'prototype'), memberName
          fn = new JS.FunctionExpression null, ps, new JS.BlockStatement [
            makeReturn new JS.CallExpression (memberAccess protoMember, 'apply'), [instance, new JS.Identifier 'arguments']
          ]
          ctor.body.body.unshift stmt new JS.AssignmentExpression '=', member, fn
        ctor.body.body.unshift stmt new JS.AssignmentExpression '=', instance, new JS.ThisExpression

      if parent?
        params.push parentRef
        args.push parent
        block.body.unshift stmt helpers.extends name, parentRef
      block.body.push new JS.ReturnStatement new JS.ThisExpression

      rewriteThis = generateMutatingWalker ->
        if @instanceof JS.ThisExpression then name
        else if @instanceof JS.FunctionExpression, JS.FunctionDeclaration then this
        else rewriteThis this
      rewriteThis block

      iife = new JS.CallExpression (new JS.FunctionExpression null, params, block), args
      if nameAssignee? then assignment nameAssignee, iife else iife
    ]
    [CS.Constructor, ({expression}) ->
      tmpName = genSym 'class'
      if @expression.instanceof CS.Functions
        new JS.FunctionDeclaration tmpName, expression.params, forceBlock expression.body
      else
        new JS.FunctionDeclaration tmpName, [], new JS.BlockStatement []
    ]
    [CS.ClassProtoAssignOp, ({assignee, expression, compile}) ->
      if @expression.instanceof CS.BoundFunction
        compile new CS.ClassProtoAssignOp @assignee, new CS.Function @expression.parameters, @expression.body
      else
        protoMember = memberAccess (memberAccess new JS.ThisExpression, 'prototype'), @assignee.data
        new JS.AssignmentExpression '=', protoMember, expression
    ]

    [CS.AssignOp, ({assignee, expression, ancestry}) ->
      assignment assignee, expression, usedAsExpression this, ancestry
    ]
    [CS.CompoundAssignOp, ({assignee, expression}) ->
      op = switch @op
        when CS.LogicalAndOp         then '&&'
        when CS.LogicalOrOp          then '||'
        when CS.BitOrOp              then '|'
        when CS.BitXorOp             then '^'
        when CS.BitAndOp             then '&'
        when CS.LeftShiftOp          then '<<'
        when CS.SignedRightShiftOp   then '>>'
        when CS.UnsignedRightShiftOp then '>>>'
        when CS.PlusOp               then '+'
        when CS.SubtractOp           then '-'
        when CS.MultiplyOp           then '*'
        when CS.DivideOp             then '/'
        when CS.RemOp                then '%'
        when CS.ExpOp                then '**'
        else throw new Error 'Unrecognised compound assignment operator'
      if op in ['&&', '||']
        new JS.BinaryExpression op, assignee, new JS.AssignmentExpression '=', assignee, expr expression
      else if op is '**'
        new JS.AssignmentExpression '=', assignee, helpers.exp assignee, expr expression
    ]
    [CS.ExistsAssignOp, ({assignee, expression, inScope}) ->
      if (assignee.instanceof JS.Identifier) and assignee.name not in inScope
      condition = new JS.BinaryExpression '!=', (new JS.Literal null), assignee
      new JS.ConditionalExpression condition, assignee, new JS.AssignmentExpression '=', assignee, expr expression
    ]
    [CS.ChainedComparisonOp, ({expression, compile}) ->
      return expression unless @expression.left.instanceof CS.ComparisonOps
      left = expression.left.right
      lhs = compile new CS.ChainedComparisonOp @expression.left
      if needsCaching @expression.left.right
        left = genSym 'cache'
        if @expression.left.left.instanceof CS.ComparisonOps
          lhs.right.right = new JS.AssignmentExpression '=', left, lhs.right.right
        else lhs.right = new JS.AssignmentExpression '=', left, lhs.right
      new JS.BinaryExpression '&&', lhs, new JS.BinaryExpression expression.operator, left, expression.right
    ]
    [CS.FunctionApplication, ({function: fn, arguments: args, compile}) ->
      if any args, ((m) -> m.spread)
        lhs = @function
        context = new CS.Null
        if needsCaching @function
          context = new CS.GenSym 'cache'
          lhs = if @function.instanceof CS.StaticMemberAccessOps
            new @function.constructor (new CS.AssignOp context, lhs.expression), @function.memberName
          else if @function.instanceof CS.DynamicMemberAccessOps
            new @function.constructor (new CS.AssignOp context, lhs.expression), @function.indexingExpr
          else new CS.AssignOp context, lhs
        else if lhs.instanceof CS.MemberAccessOps
          context = lhs.expression
        if @function.instanceof CS.ProtoMemberAccessOp, CS.DynamicProtoMemberAccessOp
          context = new CS.MemberAccessOp context, 'prototype'
        else if @function.instanceof CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp
          context = new CS.SoakedMemberAccessOp context, 'prototype'
        compile new CS.FunctionApplication (new CS.MemberAccessOp lhs, 'apply'), [context, new CS.ArrayInitialiser @arguments]
      else new JS.CallExpression (expr fn), map args, expr
    ]
    [CS.NewOp, ({ctor, arguments: args, compile}) ->
      if any args, ((m) -> m.spread)
        helpers.construct ctor, compile new CS.ArrayInitialiser @arguments
      else new JS.NewExpression ctor, map args, expr
    ]
    [CS.HeregExp, ({expression}) ->
      args = [expression]
      if flags = (flag for flag in ['g', 'i', 'm', 'y'] when @flags[flag]).join ''
        args.push new JS.Literal flags
      new JS.NewExpression (new JS.Identifier 'RegExp'), args
    ]
    [CS.RegExp, ->
      flags = (flag for flag in ['g', 'i', 'm', 'y'] when @flags[flag]).join ''
      re = new RegExp @data, flags
      new JS.Literal re
    ]
    [CS.ConcatOp, ({left, right, ancestry}) ->
      plusOp = new JS.BinaryExpression '+', (expr left), expr right
      unless ancestry[0].instanceof CS.ConcatOp
        leftmost = plusOp
        leftmost = leftmost.left while leftmost.left?.left
        unless leftmost.left.instanceof JS.Literal
          leftmost.left = new JS.BinaryExpression '+', (new JS.Literal ''), leftmost.left
      plusOp
    ]
    [CS.MemberAccessOp, ({expression}) -> memberAccess expression, @memberName]
    [CS.ProtoMemberAccessOp, ({expression}) -> memberAccess (memberAccess expression, 'prototype'), @memberName]
    [CS.DynamicMemberAccessOp, ({expression, indexingExpr}) -> dynamicMemberAccess expression, indexingExpr]
    [CS.DynamicProtoMemberAccessOp, ({expression, indexingExpr}) -> dynamicMemberAccess (memberAccess expression, 'prototype'), indexingExpr]
    [CS.SoakedMemberAccessOp, CS.SoakedDynamicMemberAccessOp, CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp, ({expression, indexingExpr, inScope}) ->
      e = if needsCaching @expression then genSym 'cache' else expression
      condition = new JS.BinaryExpression '!=', (new JS.Literal null), e
      if (e.instanceof JS.Identifier) and e.name not in inScope
        condition = new JS.BinaryExpression '&&', (new JS.BinaryExpression '!==', (new JS.Literal 'undefined'), new JS.UnaryExpression 'typeof', e), condition
      target =
        if @instanceof CS.SoakedProtoMemberAccessOp, CS.SoakedDynamicProtoMemberAccessOp
          memberAccess e, 'prototype'
        else e
      index =
        if @instanceof CS.DynamicMemberAccessOps then new JS.MemberExpression yes, target, indexingExpr
        else memberAccess target, @memberName
      node = new JS.ConditionalExpression condition, index, helpers.undef()
      if e is expression then node
      else new JS.SequenceExpression [(new JS.AssignmentExpression '=', e, expression), node]
    ]
    [CS.Slice, ({expression, left, right}) ->
      args = if left? then [left] else if right? then [new JS.Literal 0] else []
      if right?
        args.push if @isInclusive
          if (right.instanceof JS.Literal) and typeof right.data is 'number'
          then new JS.Literal right.data + 1
          else new JS.BinaryExpression '+', (new JS.UnaryExpression '+', right), new JS.Literal 1
        else right
      new JS.CallExpression (memberAccess expression, 'slice'), args
    ]
    [CS.ExistsOp, ({left, right, inScope}) ->
      e = if needsCaching @left then genSym 'cache' else left
      condition = new JS.BinaryExpression '!=', (new JS.Literal null), e
      if (e.instanceof JS.Identifier) and e.name not in inScope
        condition = new JS.BinaryExpression '&&', (new JS.BinaryExpression '!==', (new JS.Literal 'undefined'), new JS.UnaryExpression 'typeof', e), condition
      node = new JS.ConditionalExpression condition, e, right
      if e is left then node
      else new JS.SequenceExpression [(new JS.AssignmentExpression '=', e, left), node]
    ]
    [CS.UnaryExistsOp, ({expression, inScope}) ->
      nullTest = new JS.BinaryExpression '!=', (new JS.Literal null), expression
      if (expression.instanceof JS.Identifier) and expression.name not in inScope
        typeofTest = new JS.BinaryExpression '!==', (new JS.Literal 'undefined'), new JS.UnaryExpression 'typeof', expression
        new JS.BinaryExpression '&&', typeofTest, nullTest
      else nullTest
    ]
    [CS.DoOp, ({expression, compile}) ->
      args = []
      if @expression.instanceof CS.Function
        args = for param, index in @expression.parameters
          switch
            when param.instanceof CS.DefaultParam
              @expression.parameters[index] = param.param
              param.default
            when param.instanceof CS.Identifier, CS.MemberAccessOp then param
            else helpers.undef()
      compile new CS.FunctionApplication @expression, args
    ]
    [CS.Return, ({expression: e}) -> new JS.ReturnStatement expr e]
    [CS.Break, -> new JS.BreakStatement]
    [CS.Continue, -> new JS.ContinueStatement]

    [CS.ExpOp, ({left, right}) ->
      helpers.exp (expr left), expr right
    ]
    [CS.DivideOp, ({left, right}) -> new JS.BinaryExpression '/', (expr left), expr right]
    [CS.MultiplyOp, ({left, right}) -> new JS.BinaryExpression '*', (expr left), expr right]
    [CS.RemOp, ({left, right}) -> new JS.BinaryExpression '%', (expr left), expr right]
    [CS.PlusOp, ({left, right}) -> new JS.BinaryExpression '+', (expr left), expr right]
    [CS.SubtractOp, ({left, right}) -> new JS.BinaryExpression '-', (expr left), expr right]

    [CS.OfOp, ({left, right}) -> new JS.BinaryExpression 'in', (expr left), expr right]
    [CS.InOp, ({left, right}) ->
      if (right.instanceof JS.ArrayExpression) and right.elements.length < 5
        switch right.elements.length
          when 0
            if needsCaching @left
              new JS.SequenceExpression [left, new JS.Literal false]
            else new JS.Literal false
          when 1
            new JS.BinaryExpression '===', left, right.elements[0]
          else
            if needsCaching @left
              helpers.in (expr left), expr right
            else
              comparisons = map right.elements, (e) -> new JS.BinaryExpression '===', left, e
              foldl1 comparisons, (l, r) -> new JS.BinaryExpression '||', l, r
      else
        helpers.in (expr left), expr right
    ]
    [CS.ExtendsOp, ({left, right}) -> helpers.extends (expr left), expr right]
    [CS.InstanceofOp, ({left, right}) -> new JS.BinaryExpression 'instanceof', (expr left), expr right]

    [CS.LogicalAndOp, ({left, right}) -> new JS.BinaryExpression '&&', (expr left), expr right]
    [CS.LogicalOrOp, ({left, right}) -> new JS.BinaryExpression '||', (expr left), expr right]

    [CS.EQOp , ({left, right}) -> new JS.BinaryExpression '===', (expr left), expr right]
    [CS.NEQOp , ({left, right}) -> new JS.BinaryExpression '!==', (expr left), expr right]
    [CS.GTEOp , ({left, right}) -> new JS.BinaryExpression '>=', (expr left), expr right]
    [CS.GTOp , ({left, right}) -> new JS.BinaryExpression '>', (expr left), expr right]
    [CS.LTEOp , ({left, right}) -> new JS.BinaryExpression '<=', (expr left), expr right]
    [CS.LTOp , ({left, right}) -> new JS.BinaryExpression '<', (expr left), expr right]

    [CS.BitAndOp , ({left, right}) -> new JS.BinaryExpression '&', (expr left), expr right]
    [CS.BitOrOp , ({left, right}) -> new JS.BinaryExpression '|', (expr left), expr right]
    [CS.BitXorOp , ({left, right}) -> new JS.BinaryExpression '^', (expr left), expr right]
    [CS.LeftShiftOp , ({left, right}) -> new JS.BinaryExpression '<<', (expr left), expr right]
    [CS.SignedRightShiftOp , ({left, right}) -> new JS.BinaryExpression '>>', (expr left), expr right]
    [CS.UnsignedRightShiftOp , ({left, right}) -> new JS.BinaryExpression '>>>', (expr left), expr right]

    [CS.PreDecrementOp, ({expression: e}) -> new JS.UpdateExpression '--', yes, expr e]
    [CS.PreIncrementOp, ({expression: e}) -> new JS.UpdateExpression '++', yes, expr e]
    [CS.PostDecrementOp, ({expression: e}) -> new JS.UpdateExpression '--', no, expr e]
    [CS.PostIncrementOp, ({expression: e}) -> new JS.UpdateExpression '++', no, expr e]
    [CS.UnaryPlusOp, ({expression: e}) -> new JS.UnaryExpression '+', expr e]
    [CS.UnaryNegateOp, ({expression: e}) -> new JS.UnaryExpression '-', expr e]
    [CS.LogicalNotOp, ({expression: e}) -> new JS.UnaryExpression '!', expr e]
    [CS.BitNotOp, ({expression: e}) -> new JS.UnaryExpression '~', expr e]
    [CS.TypeofOp, ({expression: e}) -> new JS.UnaryExpression 'typeof', expr e]
    [CS.DeleteOp, ({expression: e}) -> new JS.UnaryExpression 'delete', expr e]

    [CS.Identifier, -> new JS.Identifier @data]
    [CS.GenSym, do ->
      symbols = []
      memos = []
      ->
        if this in symbols then memos[symbols.indexOf this]
        else
          symbols.push this
          memos.push memo = genSym @data
          memo
    ]
    [CS.Bool, CS.Int, CS.Float, CS.String, -> new JS.Literal @data]
    [CS.Null, -> new JS.Literal null]
    [CS.Undefined, -> helpers.undef()]
    [CS.This, -> new JS.ThisExpression]
    [CS.JavaScript, -> new JS.CallExpression (new JS.Identifier 'eval'), [new JS.Literal @data]]
  ]

  constructor: ->
    @rules = {}
    for [ctors..., handler] in defaultRules
      for ctor in ctors
        @addRule ctor, handler

  addRule: (ctor, handler) ->
    @rules[ctor::className] = handler
    this

  compile: do ->
    walk = (fn, inScope, ancestry, options) ->

      if (ancestry[0]?.instanceof CS.Function, CS.BoundFunction) and this is ancestry[0].body
        inScope = union inScope, concatMap ancestry[0].parameters, beingDeclared

      ancestry.unshift this
      children = {}

      for childName in @childNodes when @[childName]?
        children[childName] =
          if childName in @listMembers
            for member in @[childName]
              jsNode = walk.call member, fn, inScope, ancestry
              inScope = union inScope, envEnrichments member, inScope
              jsNode
          else
            child = @[childName]
            jsNode = walk.call child, fn, inScope, ancestry
            inScope = union inScope, envEnrichments child, inScope
            jsNode

      children.inScope = inScope
      children.ancestry = ancestry
      children.options = options
      children.compile = (node) ->
        walk.call node.g(), fn, inScope, ancestry

      do ancestry.shift
      jsNode = fn.call this, children
      jsNode[p] = @[p] for p in ['raw', 'line', 'column', 'offset']
      jsNode

    generateSymbols = do ->

      generatedSymbols = {}
      format = (pre, counter) ->
        if pre
        else
          if counter < 26
            String.fromCharCode 0x61 + counter
          else
            [div, mod] = divMod counter, 26
            (format pre, div - 1) + format pre, mod

      generateName = (node, {usedSymbols, nsCounters}) ->
        if owns generatedSymbols, node.uniqueId
          generatedSymbols[node.uniqueId]
        else
          nsCounters[node.ns] = if owns nsCounters, node.ns then 1 + nsCounters[node.ns] else 0
          ++nsCounters[node.ns] while (formatted = format node.ns, nsCounters[node.ns]) in usedSymbols
          generatedSymbols[node.uniqueId] = formatted

      generateMutatingWalker (state) ->
        state.declaredSymbols = union state.declaredSymbols, map (declarationsNeeded this), (id) -> id.name
        {declaredSymbols, usedSymbols, nsCounters} = state
        newNode = if @instanceof JS.GenSym
          newNode = new JS.Identifier generateName this, state
          usedSymbols.push newNode.name
          newNode
        else if @instanceof JS.FunctionExpression, JS.FunctionDeclaration
          params = concatMap @params, collectIdentifiers
          nsCounters_ = {}
          nsCounters_[k] = v for own k, v of nsCounters
          newNode = generateSymbols this, {
            declaredSymbols
            usedSymbols: nub [usedSymbols..., params...]
            nsCounters: nsCounters_
          }
          newNode.body = forceBlock newNode.body
          declNames = nub difference (map (concatMap @body.body, declarationsNeededRecursive), (id) -> id.name), union declaredSymbols, params
          decls = map declNames, (name) -> new JS.Identifier name
          newNode.body.body.unshift makeVarDeclaration decls if decls.length > 0
          newNode
        else generateSymbols this, state
        state.declaredSymbols = union declaredSymbols, map (declarationsNeededRecursive newNode), (id) -> id.name
        newNode

    defaultRule = ->

    (ast, options = {}) ->
      options.bare ?= no
      rules = @rules
      jsAST = walk.call ast, (-> (rules[@className] ? defaultRule).apply this, arguments), [], [], options
      generateSymbols jsAST,
        declaredSymbols: []
        usedSymbols: union jsReserved[..], collectIdentifiers jsAST
        nsCounters: {}
@any = (list, fn) ->
  for e in list
    return yes if fn e
  no

@all = (list, fn) ->
  for e in list
    return no unless fn e
  yes

@foldl = foldl = (memo, list, fn) ->
  for i in list
    memo = fn memo, i
  memo

@foldl1 = (list, fn) -> foldl list[0], list[1..], fn

@map = map = (list, fn) -> fn e for e in list

@concat = concat = (list) -> [].concat list...

@concatMap = (list, fn) -> concat map list, fn

@intersect = (listA, listB) -> a for a in listA when a in listB

@difference = (listA, listB) -> a for a in listA when a not in listB

@nub = nub = (list) ->
  result = []
  result.push i for i in list when i not in result
  result

@union = (listA, listB) ->
  listA.concat (b for b in (nub listB) when b not in listA)

@flip = (fn) -> (b, a) -> fn.call this, a, b

@owns = do (hop = {}.hasOwnProperty) -> (a, b) -> hop.call a, b

@span = span = (list, f) ->
  if list.length is 0 then [[], []]
  else if f list[0]
    [ys, zs] = span list[1..], f
    [[list[0], ys...], zs]
  else [[], list]

@divMod = (a, b) ->
  c = a % b
  mod = if c < 0 then c + b else c
  div = Math.floor a / b
  [div, mod]
{concat, concatMap, difference, foldl, map, nub} = require './functional-helpers'
CS = require './nodes'


@numberLines = numberLines = (input, startLine = 1) ->
  lines = input.split '\n'
  padSize = ((lines.length + startLine - 1).toString 10).length
  numbered = for line, i in lines
    pad = ((Array padSize + 1).join '0')[currLine.length..]
  numbered.join '\n'

cleanMarkers = (str) -> str.replace /[\uEFEF\uEFFE\uEFFF]/g, ''

@humanReadable = humanReadable = (str) ->
  ((str.replace /\uEFEF/g, '(INDENT)').replace /\uEFFE/g, '(DEDENT)').replace /\uEFFF/g, '(TERM)'

@formatParserError = (input, e) ->
  numLinesOfContext = 3
  if e.found?
    lines = input.split '\n'
    currentLineOffset = e.line - 1
    startLine = currentLineOffset - numLinesOfContext
    if startLine < 0 then startLine = 0
    preLines = lines[startLine..currentLineOffset]
    postLines = lines[currentLineOffset + 1 .. currentLineOffset + numLinesOfContext]
    numberedLines = (numberLines (cleanMarkers [preLines..., postLines...].join '\n'), startLine + 1).split '\n'
    preLines = numberedLines[0...preLines.length]
    postLines = numberedLines[preLines.length...]
  found = if e.found?
  else 'end of input'
  if e.found?
    padSize = ((currentLineOffset + 1 + postLines.length).toString 10).length
    message = [
      message
      preLines...
      postLines...
    ].join '\n'
  message


@beingDeclared = beingDeclared = (assignment) -> switch
  when not assignment? then []
  when assignment.instanceof CS.Identifiers then [assignment.data]
  when assignment.instanceof CS.Rest then beingDeclared assignment.expression
  when assignment.instanceof CS.MemberAccessOps then []
  when assignment.instanceof CS.DefaultParam then beingDeclared assignment.param
  when assignment.instanceof CS.ArrayInitialiser then concatMap assignment.members, beingDeclared
  when assignment.instanceof CS.ObjectInitialiser then concatMap assignment.vals(), beingDeclared

@declarationsFor = (node, inScope) ->
  vars = envEnrichments node, inScope
  foldl (new CS.Undefined).g(), vars, (expr, v) ->
    (new CS.AssignOp (new CS.Identifier v).g(), expr).g()

usedAsExpression_ = (ancestors) ->
  parent = ancestors[0]
  grandparent = ancestors[1]
  switch
    when !parent? then yes
    when parent.instanceof CS.Program, CS.Class then no
    when parent.instanceof CS.SeqOp
      this is parent.right and
      usedAsExpression parent, ancestors[1..]
    when (parent.instanceof CS.Block) and
    (parent.statements.indexOf this) isnt parent.statements.length - 1
      no
    when (parent.instanceof CS.Functions) and
    parent.body is this and
    grandparent?.instanceof CS.Constructor
      no
    else yes

@usedAsExpression = usedAsExpression = (node, ancestors) ->
  usedAsExpression_.call node, ancestors

envEnrichments_ = (inScope = []) ->
  possibilities = switch
    when @instanceof CS.AssignOp then nub beingDeclared @assignee
    when @instanceof CS.Class
      nub concat [
        beingDeclared @nameAssignee
        envEnrichments @parent
        if name? then [name] else []
      ]
    when @instanceof CS.ForIn, CS.ForOf
      nub concat [
        concatMap @childNodes, (child) =>
          if child in @listMembers
          then concatMap @[child], (m) -> envEnrichments m, inScope
          else envEnrichments @[child], inScope
        beingDeclared @keyAssignee
        beingDeclared @valAssignee
      ]
    else
      nub concatMap @childNodes, (child) =>
        if child in @listMembers
        then concatMap @[child], (m) -> envEnrichments m, inScope
        else envEnrichments @[child], inScope
  difference possibilities, inScope

@envEnrichments = envEnrichments = (node, args...) ->
  if node? then envEnrichments_.apply node, args else []
{difference} = require './functional-helpers'
exports = module?.exports ? this

createNode = (type, props) ->
  class extends Nodes
    constructor: ->
      @[prop] = arguments[i] for prop, i in props
    type: type
    childNodes: props

@Nodes = class Nodes
  listMembers: []
  instanceof: (ctors...) ->
    for ctor in ctors when @type is ctor::type
      return yes
    no
  toJSON: ->
    json = {@type}
    json.leadingComments = @leadingComments if @leadingComments?
    for child in @childNodes
      if child in @listMembers
        json[child] = (p?.toJSON() for p in @[child])
      else
        json[child] = @[child]?.toJSON()
    if @line? and @column?
      json.loc = start: {@line, @column}
    if @offset?
      json.range = [
        @offset
        if @raw? then @offset + @raw.length else undefined
      ]
    json.raw = @raw if @raw?
    json

nodeData = [
  ['ArrayExpression'      , no , ['elements']]
  ['AssignmentExpression' , no , ['operator', 'left', 'right']]
  ['BinaryExpression'     , no , ['operator', 'left', 'right']]
  ['BlockStatement'       , yes, ['body']]
  ['BreakStatement'       , yes, ['label']]
  ['CallExpression'       , no , ['callee', 'arguments']]
  ['CatchClause'          , yes, ['param', 'body']]
  ['ConditionalExpression', no , ['test', 'consequent', 'alternate']]
  ['ContinueStatement'    , yes, ['label']]
  ['DebuggerStatement'    , yes, []]
  ['DoWhileStatement'     , yes, ['body', 'test']]
  ['EmptyStatement'       , yes, []]
  ['ExpressionStatement'  , yes, ['expression']]
  ['ForInStatement'       , yes, ['left', 'right', 'body']]
  ['ForStatement'         , yes, ['init', 'test', 'update', 'body']]
  ['FunctionDeclaration'  , yes, ['id', 'params', 'body']]
  ['FunctionExpression'   , no , ['id', 'params', 'body']]
  ['GenSym'               , no , ['ns', 'uniqueId']]
  ['Identifier'           , no , ['name']]
  ['IfStatement'          , yes, ['test', 'consequent', 'alternate']]
  ['LabeledStatement'     , yes, ['label', 'body']]
  ['Literal'              , no , ['value']]
  ['LogicalExpression'    , no , ['left', 'right']]
  ['MemberExpression'     , no , ['computed', 'object', 'property']]
  ['NewExpression'        , no , ['callee', 'arguments']]
  ['ObjectExpression'     , no , ['properties']]
  ['Program'              , yes, ['body']]
  ['Property'             , yes, ['key', 'value']]
  ['ReturnStatement'      , yes, ['argument']]
  ['SequenceExpression'   , no , ['expressions']]
  ['SwitchCase'           , yes, ['test', 'consequent']]
  ['SwitchStatement'      , yes, ['discriminant', 'cases']]
  ['ThisExpression'       , no , []]
  ['ThrowStatement'       , yes, ['argument']]
  ['TryStatement'         , yes, ['block', 'handlers', 'finalizer']]
  ['UnaryExpression'      , no , ['operator', 'argument']]
  ['UpdateExpression'     , no , ['operator', 'prefix', 'argument']]
  ['VariableDeclaration'  , yes, ['kind', 'declarations']]
  ['VariableDeclarator'   , yes, ['id', 'init']]
  ['WhileStatement'       , yes, ['test', 'body']]
  ['WithStatement'        , yes, ['object', 'body']]
]

for [node, isStatement, params] in nodeData
  exports[node] = ctor = createNode node, params
  ctor::isStatement = isStatement
  ctor::isExpression = not isStatement


{
  Program, BlockStatement, Literal, Identifier, FunctionExpression,
  CallExpression, SequenceExpression, ArrayExpression, BinaryExpression,
  UnaryExpression, NewExpression, VariableDeclaration, ObjectExpression,
  MemberExpression, UpdateExpression, AssignmentExpression, GenSym,
  FunctionDeclaration, VariableDeclaration, SwitchStatement, SwitchCase,
  TryStatement
} = exports


handlePrimitives = (ctor, primitives) ->
  ctor::childNodes = difference ctor::childNodes, primitives
  ctor::toJSON = ->
    json = Nodes::toJSON.call this
    for primitive in primitives
      json[primitive] = @[primitive]
    json

handlePrimitives AssignmentExpression, ['operator']
handlePrimitives BinaryExpression, ['operator']
handlePrimitives GenSym, ['ns', 'uniqueId']
handlePrimitives Identifier, ['name']
handlePrimitives Literal, ['value']
handlePrimitives MemberExpression, ['computed']
handlePrimitives UnaryExpression, ['operator']
handlePrimitives UpdateExpression, ['operator', 'prefix']
handlePrimitives VariableDeclaration, ['kind']


handleLists = (ctor, listProps) -> ctor::listMembers = listProps

handleLists ArrayExpression, ['elements']
handleLists BlockStatement, ['body']
handleLists CallExpression, ['arguments']
handleLists FunctionDeclaration, ['params']
handleLists FunctionExpression, ['params']
handleLists NewExpression, ['arguments']
handleLists ObjectExpression, ['properties']
handleLists Program, ['body']
handleLists SequenceExpression, ['expressions']
handleLists SwitchCase, ['consequent']
handleLists SwitchStatement, ['cases']
handleLists TryStatement, ['handlers']
handleLists VariableDeclaration, ['declarations']
fs = require 'fs'
path = require 'path'

{formatParserError} = require './helpers'
Nodes = require './nodes'
{Preprocessor} = require './preprocessor'
Parser = require './parser'
{Optimiser} = require './optimiser'
{Compiler} = require './compiler'
cscodegen = try require 'cscodegen'
escodegen = try require 'escodegen'
uglifyjs = try require 'uglify-js'


CoffeeScript = null
pkg = require path.join __dirname, '..', '..', 'package.json'

escodegenFormatDefaults =
  indent:
    style: '  '
    base: 0
  renumber: yes
  hexadecimal: yes
  quotes: 'auto'
  parentheses: no


module.exports =

  Compiler: Compiler
  Optimiser: Optimiser
  Parser: Parser
  Preprocessor: Preprocessor
  Nodes: Nodes

  VERSION: pkg.version

  parse: (coffee, options = {}) ->
    options.optimise ?= yes
    try
      preprocessed = Preprocessor.processSync coffee
      parsed = Parser.parse preprocessed
      if options.optimise then Optimiser.optimise parsed else parsed
    catch e
      throw e unless e instanceof Parser.SyntaxError
      throw new Error formatParserError preprocessed, e

  compile: (csAst, options) ->
    Compiler.compile csAst, options

  cs: (csAst, options) ->

  js: (jsAst, options = {}) ->
    throw new Error 'escodegen not found: run `npm install escodegen`' unless escodegen?
    escodegen.generate jsAst,
      comment: yes
      format: options.format ? escodegenFormatDefaults

  sourceMap: (jsAst, name = 'unknown', options = {}) ->
    throw new Error 'escodegen not found: run `npm install escodegen`' unless escodegen?
    escodegen.generate jsAst.toJSON(),
      comment: yes
      sourceMap: name
      format: options.format ? escodegenFormatDefaults

CoffeeScript = module.exports.CoffeeScript = module.exports


require.extensions['.coffee'] = (module, filename) ->
  input = fs.readFileSync filename, 'utf8'
  csAst = CoffeeScript.parse input
  jsAst = CoffeeScript.compile csAst
  js = CoffeeScript.js jsAst
  module._compile js, filename
{map, concat, concatMap, difference, nub, union} = require './functional-helpers'
exports = module?.exports ? this


createNodes = (subclasses, superclasses = []) ->
  for own className, specs of subclasses then do (className) ->

    superclass = superclasses[0] ? ->
    isCategory = specs? and specs.length is 2
    params =
      if specs?
        switch specs.length
          when 0 then []
          when 1, 2 then specs[0]
      else null
    params ?= superclass::childNodes ? []

    klass = class extends superclass
      constructor:
        if isCategory then ->
        else ->
          for param, i in params
            @[param] = arguments[i]
          @initialise?.apply this, arguments
          this
      className: className
      @superclasses = superclasses
    if specs?[0]? then klass::childNodes = specs[0]

    if isCategory then createNodes specs[1], [klass, superclasses...]
    exports[className] = klass

  return


createNodes
  Nodes: [
    []
    BinOps: [
      ['left', 'right']
      AssignOps: [
        ['assignee', 'expression']
      ]
      BitOps: [ null
      ]
      ComparisonOps: [ null
      ]
      LogicalOps: [ null
      ]
      MathsOps: [ null
      ]
    ]

    Statements: [
      []
    ]

    UnaryOps: [
      ['expression']
    ]

    MemberAccessOps: [ null
      StaticMemberAccessOps: [
        ['expression', 'memberName']
      ]
      DynamicMemberAccessOps: [
        ['expression', 'indexingExpr']
      ]
    ]


    FunctionApplications: [
      ['function', 'arguments']
    ]


    Functions: [
      ['parameters', 'body']
    ]
    Identifiers: [
      ['data']
    ]
    Primitives: [
      ['data']
      Numbers: [ null
      ]
    ]
    RegExps: [ null
    ]


  ]


{
  Nodes, Primitives, CompoundAssignOp, StaticMemberAccessOps, Range,
  ArrayInitialiser, ObjectInitialiser, NegatedConditional, Conditional,
  Identifier, ForOf, Functions, While, Class, Block, NewOp, Bool,
  FunctionApplications, RegExps, RegExp, HeregExp, Super, Slice, Switch,
  Identifiers, SwitchCase, GenSym
} = exports


Nodes.fromJSON = (json) -> exports[json.type].fromJSON json
Nodes::listMembers = []
Nodes::toJSON = ->
  json = {
    type: @className
    @line, @column
    range: [
      @offset
      if @raw? then @offset + @raw.length else undefined
    ]
    @raw
  }
  for child in @childNodes
    if child in @listMembers
      json[child] = (p.toJSON() for p in @[child])
    else
      json[child] = @[child]?.toJSON()
  json
Nodes::fold = (memo, fn) ->
  for child in @childNodes
    if child in @listMembers
      memo = (p.fold memo, fn for p in @[child])
    else
      memo = @[child].fold memo, fn
  fn memo, this
Nodes::clone = ->
  ctor = ->
  ctor.prototype = @constructor.prototype
  n = new ctor
  n[k] = v for own k, v of this
  n
Nodes::instanceof = (ctors...) ->
  superclasses = map @constructor.superclasses, (c) -> c::className
  for ctor in ctors when ctor::className in [@className, superclasses...]
    return yes
  no
Nodes::r = (@raw) -> this
Nodes::p = (@line, @column, @offset) -> this
Nodes::generated = no
Nodes::g = ->
  @generated = yes
  this



handlePrimitives = (ctor, primitives) ->
  ctor::childNodes = difference ctor::childNodes, primitives
  ctor::toJSON = ->
    json = Nodes::toJSON.call this
    for primitive in primitives
      json[primitive] = @[primitive]
    json

handlePrimitives Class, ['boundMembers']
handlePrimitives CompoundAssignOp, ['op']
handlePrimitives ForOf, ['isOwn']
handlePrimitives HeregExp, ['flags']
handlePrimitives Identifiers, ['data']
handlePrimitives Primitives, ['data']
handlePrimitives Range, ['isInclusive']
handlePrimitives RegExp, ['data', 'flags']
handlePrimitives Slice, ['isInclusive']
handlePrimitives StaticMemberAccessOps, ['memberName']



handleLists = (ctor, listProps) -> ctor::listMembers = listProps

handleLists ArrayInitialiser, ['members']
handleLists Block, ['statements']
handleLists Functions, ['parameters']
handleLists FunctionApplications, ['arguments']
handleLists NewOp, ['arguments']
handleLists ObjectInitialiser, ['members']
handleLists Super, ['arguments']
handleLists Switch, ['cases']
handleLists SwitchCase, ['conditions']



Block.wrap = (s) -> new Block(if s? then [s] else []).r(s.raw).p(s.line, s.column)

Class::initialise = ->
  @boundMembers ?= []
  @name = new GenSym 'class'
  if @nameAssignee?
    @name = switch
      when @nameAssignee.instanceof Identifier
        new Identifier @nameAssignee.data
      when @nameAssignee.instanceof StaticMemberAccessOps
        new Identifier @nameAssignee.memberName
      else @name
Class::childNodes.push 'name'

ObjectInitialiser::keys = -> map @members, (m) -> m.key
ObjectInitialiser::vals = -> map @members, (m) -> m.expression

RegExps::initialise = (_, flags) ->
  @flags = {}
  for flag in ['g', 'i', 'm', 'y']
    @flags[flag] = flag in flags



class exports.NegatedConditional extends Conditional

class exports.NegatedWhile extends While

class exports.Loop extends While
  constructor: (body) ->
    While.call this, (new Bool true).g(), body
{all, any, concat, concatMap, difference, foldl, foldl1, union} = require './functional-helpers'
{beingDeclared, declarationsFor, usedAsExpression, envEnrichments} = require './helpers'
CS = require './nodes'
exports = module?.exports ? this

makeDispatcher = (defaultValue, handlers, defaultHandler = (->)) ->
  handlers_ = {}
  for [ctors, handler] in handlers
    handlers_[ctor::className] = handler for ctor in ctors
  (node, args...) ->
    return defaultValue unless node?
    handler =
      if Object::hasOwnProperty.call handlers_, node.className
        handlers_[node.className]
      else defaultHandler
    handler.apply node, args


isTruthy =
  makeDispatcher no, [
    [[
      CS.ArrayInitialiser, CS.Class, CS.DeleteOp, CS.ForIn, CS.ForOf
      CS.Function, CS.BoundFunction, CS.HeregExp, CS.ObjectInitialiser, CS.Range
      CS.RegExp, CS.Slice, CS.TypeofOp, CS.While
    ], -> yes]
    [[CS.AssignOp], -> isTruthy @expression]
    [[CS.Block], ->
      if @statements.length is 0 then no
      else isTruthy @statements[@statements.length - 1]
    ]
    [[CS.Bool, CS.Float, CS.Int, CS.String], -> !!@data]
    [[CS.Conditional], ->
      (isTruthy @condition) and (isTruthy @consequent) or
      (isFalsey @condition) and isTruthy @alternate
    ]
    [[CS.LogicalAndOp], -> (isTruthy @left) and isTruthy @right]
    [[CS.LogicalNotOp], -> isFalsey @expression]
    [[CS.LogicalOrOp], -> (isTruthy @left) or isTruthy @right]
    [[CS.Program], -> isTruthy @body]
    [[CS.SeqOp], -> isTruthy @right]
    [[CS.Switch], ->
      (all @cases, isTruthy) and
      if @alternate? then isTruthy @alternate else yes
    ]
    [[CS.SwitchCase], -> isTruthy @consequent]
    [[CS.UnaryExistsOp], ->
      (isTruthy @expression) or
      @expression.instanceof CS.Int, CS.Float, CS.String, CS.UnaryPlusOp, CS.UnaryNegateOp, CS.LogicalNotOp
    ]
  ], -> no

isFalsey =
  makeDispatcher no, [
    [[CS.Null, CS.Undefined], -> yes]
    [[CS.AssignOp], -> isFalsey @expression]
    [[CS.Block], ->
      if @statements.length is 0 then yes
      else isFalsey @statements[@statements.length - 1]
    ]
    [[CS.Bool, CS.Float, CS.Int, CS.String], -> not @data]
    [[CS.Conditional], ->
      (isTruthy @condition) and (isFalsey @consequent) or
      (isFalsey @condition) and isFalsey @alternate
    ]
    [[CS.LogicalAndOp], -> (isFalsey @left) or isFalsey @right]
    [[CS.LogicalNotOp], -> isTruthy @expression]
    [[CS.LogicalOrOp], -> (isFalsey @left) and isFalsey @right]
    [[CS.Program], -> isFalsey @body]
    [[CS.SeqOp], -> isFalsey @right]
    [[CS.Switch], ->
      (all @cases, isFalsey) and
      if @alternate? then isFalsey @alternate else yes
    ]
    [[CS.SwitchCase], -> isFalsey @block]
    [[CS.UnaryExistsOp], -> @expression.instanceof CS.Null, CS.Undefined]
  ], -> no

mayHaveSideEffects =
  makeDispatcher no, [
    [[
      CS.Function, CS.BoundFunction, CS.Null, CS.RegExp, CS.This, CS.Undefined
    ], -> no]
    [[
      CS.Break, CS.Continue, CS.DeleteOp, CS.NewOp, CS.Return, CS.Super
      CS.PreDecrementOp, CS.PreIncrementOp, CS.PostDecrementOp, CS.PostIncrementOp
      CS.ClassProtoAssignOp, CS.Constructor
    ], -> yes]
    [[CS.Class], (inScope) ->
      (mayHaveSideEffects @parent, inScope) or
      @nameAssignee? and (@name or (beingDeclared @nameAssignee).length > 0)
    ]
    [[CS.Conditional], (inScope) ->
      (mayHaveSideEffects @condition, inScope) or
      (not isFalsey @condition) and (mayHaveSideEffects @consequent, inScope) or
      (not isTruthy @condition) and mayHaveSideEffects @alternate, inScope
    ]
    [[CS.DoOp], (inScope) ->
      return yes unless @expression.instanceof CS.Functions
      newScope = difference inScope, concatMap @expression.parameters, beingDeclared
      args = for p in @expression.parameters
        if p.instanceof CS.AssignOp then p.expression else p
      return yes if any args, (a) -> mayHaveSideEffects a, newScope
      mayHaveSideEffects @expression.body, newScope
    ]
    [[CS.ExistsOp], (inScope) ->
      return yes if mayHaveSideEffects @left, inScope
      return no if @left.instanceof CS.Undefined, CS.Null
      mayHaveSideEffects @right, inScope
    ]
    [[CS.FunctionApplication], (inScope) ->
      return yes unless @function.instanceof CS.Function, CS.BoundFunction
      newScope = difference inScope, concatMap @function.parameters, beingDeclared
      return yes if any @arguments, (a) -> mayHaveSideEffects a, newScope
      mayHaveSideEffects @function.body, newScope
    ]
    [[CS.LogicalAndOp], (inScope) ->
      return yes if mayHaveSideEffects @left, inScope
      return no if isFalsey @left
      mayHaveSideEffects @right, inScope
    ]
    [[CS.LogicalOrOp], (inScope) ->
      return yes if mayHaveSideEffects @left, inScope
      return no if isTruthy @left
      mayHaveSideEffects @right, inScope
    ]
    [[CS.While], (inScope) ->
      (mayHaveSideEffects @condition, inScope) or
      (not isFalsey @condition) and mayHaveSideEffects @body, inScope
    ]
    [[CS.AssignOp, CS.ClassProtoAssignOp, CS.CompoundAssignOp, CS.ExistsAssignOp], (inScope) ->
      yes
    ]
    [[CS.Bool, CS.Float, CS.Identifier, CS.Int, CS.JavaScript, CS.String], -> no]
  ], (inScope) ->
    any @childNodes, (child) =>
      if child in @listMembers
      then any @[child], (m) -> mayHaveSideEffects m, inScope
      else mayHaveSideEffects @[child], inScope



class exports.Optimiser

  @optimise = => (new this).optimise arguments...

  @isTruthy = isTruthy
  @isFalsey = isFalsey
  @mayHaveSideEffects = mayHaveSideEffects

  defaultRules = [

    [CS.Program, ->
      if @body? and mayHaveSideEffects @body, [] then this
      else new CS.Program null
    ]

    [CS.Block, (inScope, ancestors) ->
      foldl (new CS.Undefined).g(), @statements, (expr, s) ->
        new CS.SeqOp expr, s
    ]

    [CS.SeqOp, (inScope, ancestors) ->
      canDropLast = not usedAsExpression this, ancestors
      if mayHaveSideEffects @left, inScope
        if mayHaveSideEffects @right, inScope then this
        else if not canDropLast then this
        else if @right.instanceof CS.Undefined then @left
        else new CS.SeqOp @left, declarationsFor @right, inScope
      else if (@right.instanceof CS.Identifier) and @right.data is 'eval' and
      ((ancestors[0]?.instanceof CS.FunctionApplication) and ancestors[0].function is this or
      (ancestors[0]?.instanceof CS.DoOp) and ancestors[0].expression is this)
        return this if (@left.instanceof CS.Int) and @left.data is 0
        ref = new CS.SeqOp (new CS.Int 0).g(), @right
        if (envEnrichments @left, inScope).length is 0 then ref
        else new CS.SeqOp (declarationsFor @left), ref
      else
        if mayHaveSideEffects @right, inScope
          if @left.instanceof CS.Undefined then @right
          else new CS.SeqOp (declarationsFor @left, inScope), @right
        else if canDropLast
          declarationsFor this, inScope
        else @right
    ]


    [CS.AssignOp, ->
      return this unless @expression.instanceof CS.SeqOp
      new CS.SeqOp @expression.left, new CS.AssignOp @assignee, @expression.right
    ]

    [CS.While, (inScope) ->
      if isFalsey @condition
        new CS.Block [
          if mayHaveSideEffects @condition, inScope
            new CS.SeqOp @condition, declarationsFor @body
          else
            if @body? then declarationsFor @body, inScope else new CS.Undefined
          new CS.ArrayInitialiser []
        ]
      else if isTruthy @condition
        if mayHaveSideEffects @condition, inScope then this
        else if @body?
          if this instanceof CS.Loop then this else (new CS.Loop @body).g()
        else new CS.ArrayInitialiser []
      else this
    ]

    [CS.Conditional, (inScope) ->
      if isFalsey @condition
        block = @alternate
      else if isTruthy @condition
        block = @consequent
      else
        return this
      decls = declarationsFor block, inScope
      block = if block? then new CS.SeqOp decls, block else decls
      if mayHaveSideEffects @condition, inScope
        block = new CS.SeqOp @condition, block
      block
    ]

    [CS.ForIn, (inScope, ancestors) ->
      return this unless (@target.instanceof CS.ArrayInitialiser) and @target.members.length is 0
      new CS.SeqOp (declarationsFor this, inScope), (new CS.ArrayInitialiser []).g()
    ]

    [CS.ForOf, (inScope, ancestors) ->
      return this unless @isOwn and (@target.instanceof CS.ObjectInitialiser) and @target.members.length is 0
      new CS.SeqOp (declarationsFor this, inScope), (new CS.ArrayInitialiser []).g()
    ]

    [CS.ForIn, CS.ForOf, (inScope, ancestors) ->
      return this unless isFalsey @filter
      new CS.SeqOp (declarationsFor this, inScope), (new CS.ArrayInitialiser []).g()
    ]

    [CS.ForIn, ->
      return this unless isTruthy @filter
      new CS.ForIn @valAssignee, @keyAssignee, @target, @step, null, @body
    ]
    [CS.ForOf, ->
      return this unless isTruthy @filter
      new CS.ForOf @isOwn, @keyAssignee, @valAssignee, @target, null, @body
    ]

    [CS.ArrayInitialiser, (inScope, ancestors) ->
      if usedAsExpression this, ancestors then this
      else
        foldl (new CS.Undefined).g(), @members, (expr, m) ->
          new CS.SeqOp expr, m
    ]

    [CS.ExistsOp, -> if @left.instanceof CS.Null, CS.Undefined then @right else this]

    [CS.UnaryExistsOp, -> if @expression.instanceof CS.Null, CS.Undefined then (new CS.Bool false).g() else this]

    [CS.LogicalNotOp, (inScope) ->
      switch
        when @expression.instanceof CS.Int, CS.Float, CS.String, CS.Bool
          (new CS.Bool !@expression.data).g()
        when @expression.instanceof CS.Functions then (new CS.Bool false).g()
        when @expression.instanceof CS.Null, CS.Undefined then (new CS.Bool true).g()
        when @expression.instanceof CS.ArrayInitialiser, CS.ObjectInitialiser
          if mayHaveSideEffects @expression, inScope then this
          else new CS.SeqOp (declarationsFor @expression, inScope), (new CS.Bool false).g()
        when @expression.instanceof CS.LogicalNotOp
          if @expression.expression.instanceof CS.LogicalNotOp then @expression.expression
          else this
        else this
    ]

    [CS.TypeofOp, ->
      switch
        when @expression.instanceof CS.Int, CS.Float, CS.UnaryNegateOp, CS.UnaryPlusOp
          (new CS.String 'number').g()
        when @expression.instanceof CS.String then (new CS.String 'string').g()
        when @expression.instanceof CS.Functions then (new CS.String 'function').g()
        when @expression.instanceof CS.Undefined then (new CS.String 'undefined').g()
        else this
    ]

    [CS.SeqOp, (_, ancestors) ->
      return this unless (ancestors[0]?.instanceof CS.Functions) and ancestors[0].body is this
      if (@right.instanceof CS.Return) and @right.expression?
        new CS.SeqOp @left, @right.expression
      else if @right.instanceof CS.Undefined
        new CS.SeqOp @left, new CS.Return
      else this
    ]

    [CS.Function, CS.BoundFunction, ->
      return this unless @block? and (
        (@block.instanceof CS.Undefined) or
        (@block.instanceof CS.Return) and not @block.expression?
      )
      new @constructor @parameters, null
    ]

    [CS.Return, -> if @expression?.instanceof CS.Undefined then new CS.Return else this]

    [CS.Slice, ->
      if (@left?.instanceof CS.Int, CS.String) and +@left.data is 0
        new CS.Slice @expression, @isInclusive, null, @right
      else if @isInclusive and (@right?.instanceof CS.UnaryNegateOp) and (@right.expression.instanceof CS.Int) and @right.expression.data is 1
        new CS.Slice @expression, yes, @left, null
      else this
    ]
  ]

  constructor: ->
    @rules = {}
    for [ctors..., handler] in defaultRules
      for ctor in ctors
        @addRule ctor::className, handler

  addRule: (ctor, handler) ->
    (@rules[ctor] ?= []).push handler
    this

  optimise: do ->

    walk = (fn, inScope = [], ancestry = []) ->
      if not this? or this is global
        throw new Error 'Optimiser rules must produce a node. `null` is not a node.'
      return this if this in ancestry
      ancestry.unshift this
      for childName in @childNodes when @[childName]?
        @[childName] =
          if childName in @listMembers
            for member in @[childName]
              while member isnt walk.call (member = fn.call member, inScope, ancestry), fn, inScope, ancestry then
              inScope = union inScope, envEnrichments member, inScope
              member
          else
            child = @[childName]
            while child isnt walk.call (child = fn.call child, inScope, ancestry), fn, inScope, ancestry then
            inScope = union inScope, envEnrichments child, inScope
            child
      do ancestry.shift
      jsNode = fn.call this, inScope, ancestry
      jsNode[p] = @[p] for p in ['raw', 'line', 'column', 'offset']
      jsNode

    (ast) ->
      rules = @rules
      walk.call ast, ->
        memo = this
        oldClassName = null
        while oldClassName isnt memo.className
          for rule in rules[oldClassName = memo.className] ? []
            memo = rule.apply memo, arguments
            break unless oldClassName is memo.className
        memo
fs = require 'fs'
{EventEmitter} = require 'events'
StringScanner = require 'cjs-string-scanner'

inspect = (o) -> (require 'util').inspect o, no, 9e9, yes



@Preprocessor = class Preprocessor extends EventEmitter

  ws = '\\t\\x0B\\f \\xA0\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF'
  INDENT = '\uEFEF'
  DEDENT = '\uEFFE'
  TERM   = '\uEFFF'

  constructor: ->
    @base = @indent = null
    @context = []
    @context.peek = -> if @length then this[@length - 1] else null
    @context.err = (c) ->
      throw new Error "Unexpected " + inspect c
    @context.observe = (c) ->
      top = @peek()
      switch c
          if top is c then do @pop
          else @push c
          @push c
        when DEDENT
          (@err c) unless top is INDENT
          do @pop
        when '\n'
          do @pop
        when ']'
          (@err c) unless top in ['[', 'regexp-[', 'heregexp-[']
          do @pop
        when ')'
          (@err c) unless top in ['(', 'regexp-(', 'heregexp-(']
          do @pop
        when '}'
          do @pop
        when 'end-\\'
          (@err c) unless top is '\\'
          do @pop
        else throw new Error "undefined token observed: " + c
      this
    @ss = new StringScanner ''

  p: (s) ->
    if s? then @emit 'data', s
    s

  scan: (r) -> @p @ss.scan r

  processInput = (isEnd) -> (data) ->
    @ss.concat data unless isEnd

    until @ss.eos()
      switch @context.peek()



            if @base?
              unless (@scan @base)?
                throw new Error "inconsistent base indentation"
            else

            if @indent?
              level = (0 for c in @context when c is INDENT).length
                @context.observe INDENT
                @p INDENT
                newLevel = 0
                delta = level - newLevel
                while delta--
                  @context.observe DEDENT
              else
                throw new Error "invalid indentation"
              @context.observe INDENT
              @p INDENT

          tok = switch @context.peek()
            when '['
              @scan /\]/
            when '('
              @scan /\)/
              @scan /\}/
            else
              null
          if tok
            @context.observe tok
            continue

            @context.observe tok
          else if tok = @scan /\//
            pos = @ss.position()
            if pos > 1
              lastChar = @ss.string()[pos - 2]
              @context.observe '/'

        when '\\'
          if (@scan /[\s\S]/) then @context.observe 'end-\\'
        when '"""'
          @ss.scan /\\\n/
        when '"'
          @ss.scan /\\\n/
        when '\'\'\''
          @scan /(?:[^'\\]+|''?(?!')|\\.)+/
          @ss.scan /\\\n/
          if tok = @scan /'''/ then @context.observe tok
        when '\''
          @scan /(?:[^'\\]+|\\.)+/
          @ss.scan /\\\n/
          if tok = @scan /'/ then @context.observe tok
          @scan /[^\n]+/
          if tok = @scan /\n/ then @context.observe tok
        when '`'
          @scan /[^`]+/
          if tok = @scan /`/ then @context.observe tok
        when '///'
        when 'heregexp-['
          @scan /(?:[^\]\/\\]+|\/\/?(?!\/))+/
          @ss.scan /(?:[^\n/]+|\/\/?(?!\/))+/
          if tok = @scan /\n|\/\/\// then @context.observe tok
        when '/'
          @scan /[^[/\\]+/
          if tok = @scan /[\/\\]/ then @context.observe tok
        when 'regexp-['
          @scan /[^\]\\]+/
          if tok = @scan /[\]\\]/ then @context.observe tok

    if isEnd
      while @context.length and INDENT is @context.peek()
        @context.observe DEDENT
      if @context.length
        throw new Error 'Unclosed ' + (inspect @context.peek()) + ' at EOF'
      @emit 'end'
      return

    return

  processData: processInput no
  processEnd: processInput yes
  @processSync = (input) ->
    pre = new Preprocessor
    output = ''
    pre.emit = (type, data) -> output += data if type is 'data'
    pre.processData input
    do pre.processEnd
    output
suite 'Arrays', ->

  suite 'Basic Literals', ->

    test 'simple arrays', ->
      eq 0, [].length
      eq 0, [ ].length
      eq 1, [0].length
      eq 1, [ 0 ].length
      eq 2, [0,0].length
      eq 2, [0, 0].length
      eq 2, [0 ,0].length
      eq 2, [ 0 , 0 ].length
      eq 3, [0,0,0].length
      eq 3, [0, 0, 0].length
      eq 3, [ 0 , 0 , 0 ].length
      eq k, v for v, k in [0, 1, 2, 3]
      eq k, v for v, k in [0, 1, 2, 3,]
      return

    test 'arrays spread over many lines', ->
      eq 0, [
      ].length
      eq 1, [
        0
      ].length
      eq 1, [
        0,
      ].length
      eq 2, [
        0
        0
      ].length
      eq 2, [
        0,
        0
      ].length
      eq 2, [
        0,
        0,
      ].length
      eq k, v for v, k in [
        0
        1
        2
        3
      ]
      return

    test 'nested arrays', ->
      eq 1, [[]].length
      eq 0, [[]][0].length
      eq 1, [[0]].length
      eq 1, [[0]][0].length
      eq 2, [[0],[1]].length
      eq 0, [[0],[1]][0][0]
      eq 1, [[0],[1]][1][0]
      eq 3, [
        []
        [[], []]
        [ [[], []], [] ]
      ].length

    test 'mixed newline/comma separators', ->
      eq k, v for v, k in [
        0
        1, 2, 3,
        4, 5, 6
        7, 8, 9,
      ]
      return

    test 'listed functions', ->
      a = [
        (x) -> x * x
        ->
        (x) ->  x
      ]
      ok a.length is 3
      b = [(x) -> x * x, ->, (x) ->  x, ->]
      ok b.length is 4





  suite 'Splats', ->

    test 'basic splats', ->
      a = [1, 2, 3]
      arrayEq [1, 2, 3], [a...]
      arrayEq [0, 1, 2, 3], [0, a...]
      arrayEq [1, 2, 3, 4], [a..., 4]
      arrayEq [1, 2, 3, 1, 2, 3], [a..., a...]
      arrayEq [1, 2, 3, [1, 2, 3]], [a..., [a]...]
      arrayEq [[0], 1, 2, 3], [[0], a...]
      arrayEq [0, 1, 2, 3], [[0]..., a...]
      b = [1, [2], 3]
      arrayEq [1, [2], 3], [b...]
      arrayEq [[0], 1, [2], 3], [[0], b...]

    test 'splats and member access', ->
      arr = [0, 1, 2]
      a = 'a'
      obj = {a: arr, prototype: {a: arr}}
      arrayEq arr, [obj.a...]
      arrayEq arr, [obj::a...]
      arrayEq arr, [obj[a]...]
      arrayEq arr, [obj::[a]...]
      arrayEq arr, [obj?.a...]
      arrayEq arr, [obj?::a...]
      arrayEq arr, [obj?[a]...]
      arrayEq arr, [obj?::[a]...]

    test 'splats and function invocation', ->
      arr = [1, 2, 3]
      fn = -> arr
      obj = {fn: fn}
      arrayEq arr, [(do fn)...]
      arrayEq arr, [fn()...]
      arrayEq arr, [(fn 0)...]
      arrayEq arr, [fn(0)...]
      arrayEq arr, [(do obj.fn)...]
      arrayEq arr, [obj.fn()...]
      arrayEq arr, [(obj.fn 0)...]
      arrayEq arr, [obj.fn(0)...]

    test 'splats and array-like objects', ->
      obj = {0: 1, 1: 2, 2: 3, length: 3}
      fn = ->
        arrayEq ([].slice.call arguments), [arguments...]
        arguments
      arrayEq [1, 2, 3], [obj...]
      arrayEq [0, 1, 2, 3, 4], [0, obj..., 4]
      arrayEq [1, 2, 3], [(fn 1, 2, 3)...]
      arrayEq [0, 1, 2, 3, 4], [0, (fn 1, 2, 3)..., 4]

    test 'array splat expansions with assignments', ->
      nums = [1, 2, 3]
      list = [a = 0, nums..., b = 4]
      eq 0, a
      eq 4, b
      arrayEq [0,1,2,3,4], list

    test 'array splats with nested arrays', ->
      nonce = {}
      a = [nonce]
      list = [1, 2, a...]
      eq list[0], 1
      eq list[2], nonce

      a = [[nonce]]
      list = [1, 2, a...]
      arrayEq list, [1, 2, [nonce]]
suite 'Assignment', ->


  suite 'Regular Assignment', ->

    test "context property assignment (using @)", ->
      nonce = {}
      addMethod = ->
        @method = -> nonce
        this
      eq nonce, addMethod.call({}).method()


  suite 'Compound Assignment', ->

    test "boolean operators", ->
      nonce = {}

      a  = 0
      a or= nonce
      eq nonce, a

      b  = 1
      b or= nonce
      eq 1, b

      c = 0
      c and= nonce
      eq 0, c

      d = 1
      d and= nonce
      eq nonce, d

      e = f = false
      e and= f or true
      eq false, e

    test "compound assignment as a sub expression", ->
      [a, b, c] = [1, 2, 3]
      eq 6, a + (b += c)
      eq 1, a
      eq 5, b
      eq 3, c












    test "compound assignment (math operators)", ->
      num = 10
      num -= 5
      eq 5, num

      num *= 10
      eq 50, num

      num /= 10
      eq 5, num

      num %= 3
      eq 2, num

    test "more compound assignment", ->
      a = {}
      val = undefined
      val ||= a
      val ||= true
      eq a, val

      b = {}
      val &&= true
      eq val, true
      val &&= b
      eq b, val

      c = {}
      val = null
      val ?= c
      val ?= true
      eq c, val


  suite 'Destructuring Assignment', ->

    test "empty destructuring assignment", ->
      {} = [] = undefined

    test "chained destructuring assignments", ->
      [a] = {0: b} = {'0': c} = [nonce={}]
      eq nonce, a
      eq nonce, b
      eq nonce, c

    test "variable swapping to verify caching of RHS values when appropriate", ->
      a = nonceA = {}
      b = nonceB = {}
      c = nonceC = {}
      [a, b, c] = [b, c, a]
      eq nonceB, a
      eq nonceC, b
      eq nonceA, c
      [a, b, c] = [b, c, a]
      eq nonceC, a
      eq nonceA, b
      eq nonceB, c
      fn = ->
        [a, b, c] = [b, c, a]
      arrayEq [nonceA,nonceB,nonceC], fn()
      eq nonceA, a
      eq nonceB, b
      eq nonceC, c

      nonces = [nonceA={},nonceB={}]
      eq nonces, [a, b] = [c, d] = nonces
      eq nonceA, a
      eq nonceA, c
      eq nonceB, b
      eq nonceB, d

    test "destructuring assignment with splats", ->
      a = {}; b = {}; c = {}; d = {}; e = {}
      [x,y...,z] = [a,b,c,d,e]
      eq a, x
      arrayEq [b,c,d], y
      eq e, z

    test "deep destructuring assignment with splats", ->
      a={}; b={}; c={}; d={}; e={}; f={}; g={}; h={}; i={}
      [u, [v, w..., x], y..., z] = [a, [b, c, d, e], f, g, h, i]
      eq a, u
      eq b, v
      arrayEq [c,d], w
      eq e, x
      arrayEq [f,g,h], y
      eq i, z

    test "destructuring assignment with objects", ->
      a={}; b={}; c={}
      obj = {a,b,c}
      {a:x, b:y, c:z} = obj
      eq a, x
      eq b, y
      eq c, z

    test "deep destructuring assignment with objects", ->
      a={}; b={}; c={}; d={}
      obj = {a, b: {'c': {d: [b, {e: c, f: d}]}}}
      {a: w, 'b': {c: {d: [x, {'f': z, e: y}]}}} = obj
      eq a, w
      eq b, x
      eq c, y
      eq d, z

    test "destructuring assignment with objects and splats", ->
      a={}; b={}; c={}; d={}
      obj = a: b: [a, b, c, d]
      {a: {b: [y, z...]}} = obj
      eq a, y
      arrayEq [b,c,d], z

    test "destructuring assignment against an expression", ->
      a={}; b={}
      [y, z] = if true then [a, b] else [b, a]
      eq a, y
      eq b, z

    test "bracket insertion when necessary", ->
      [a] = [0] ? [1]
      eq a, 0


    test "destructuring assignment with context (@) properties", ->
      a={}; b={}; c={}; d={}; e={}
      obj =
        fn: ->
          local = [a, {b, c}, d, e]
          [@a, {b: @b, c: @c}, @d, @e] = local
      eq undefined, obj[key] for key in ['a','b','c','d','e']
      obj.fn()
      eq a, obj.a
      eq b, obj.b
      eq c, obj.c
      eq d, obj.d
      eq e, obj.e



      {length} = new Array
      eq 0, length


  suite 'Existential Assignment', ->

    test "existential assignment", ->
      nonce = {}
      a = false
      a ?= nonce
      eq false, a
      b = undefined
      b ?= nonce
      eq nonce, b
      c = null
      c ?= nonce
      eq nonce, c



    test "more existential assignment", ->
      obj = {}
      obj.temp ?= 0
      eq obj.temp, 0
      obj.temp or= 100
      eq obj.temp, 100

      nonce = {}
      a = nonce
      b = (a ?= 0)
      eq nonce, b
      eq a ?= b ?= 1, nonce

      if a then a ?= 2 else a = 3
      eq a, nonce



      name =
      'dave'

      eq name, 'dave'


suite 'Boolean Literals', ->


    toString = Boolean::toString

    eq toString, true['toString']
    eq toString, false['toString']
    eq toString, yes['toString']
    eq toString, no['toString']
    eq toString, on['toString']
    eq toString, off['toString']

    eq toString, true.toString
    eq toString, false.toString
    eq toString, yes.toString
    eq toString, no.toString
    eq toString, on.toString
    eq toString, off.toString
suite 'Classes', ->

  suite 'Class Definition', ->



    test 'static assignment via colon', ->
      nonce = {}
      class A then @b: nonce
      eq nonce, A.b

    test 'classes with JS-keyword properties', ->

      class Class
        class: 'class'
        name: -> @class

      instance = new Class
      ok instance.class is 'class'
      ok instance.name() is 'class'

    test 'nothing classes', ->

      c = class
      ok c instanceof Function

    test 'instance-bound methods and statically-bound methods', ->

      class Dog
        constructor: (name) ->
          @name = name

        bark: =>

        @static = =>
          new this('Dog')

      spark = new Dog('Spark')
      fido  = new Dog('Fido')
      fido.bark = spark.bark

      ok fido.bark() is 'Spark woofs!'

      obj = {func: Dog.static}

      ok obj.func().name is 'Dog'

    test 'anonymous classes', ->

      obj = klass: class
        method: -> 'value'

      instance = new obj.klass
      ok instance.method() is 'value'



    test 'external constructors', ->

      counter = 0
      classMaker = ->
        inner = ++counter
        ->
          @value = inner

      class One
        constructor: classMaker()

      class Two
        constructor: classMaker()

      eq (new One).value, 1
      eq (new Two).value, 2
      eq (new One).value, 1
      eq (new Two).value, 2


    test 'mild metaprogramming', ->

      class Base
        @attr = (name) ->
          @::[name] = (val) ->
            if arguments.length > 0
            else

      class Robot extends Base
        @attr 'power'
        @attr 'speed'

      robby = new Robot

      ok robby.power() is undefined

      robby.power 11
      robby.speed Infinity

      eq robby.power(), 11
      eq robby.speed(), Infinity

    test 'namespaced classes do not reserve their function name in outside scope', ->

      one = {}
      two = {}

      class one.Klass
        @label = "one"

      class two.Klass
        @label = "two"

      eq typeof Klass, 'undefined'
      eq one.Klass.label, 'one'
      eq two.Klass.label, 'two'

    test 'nested classes', ->

      class Outer
        constructor: ->
          @label = 'outer'

        class @Inner
          constructor: ->
            @label = 'inner'

      eq (new Outer).label, 'outer'
      eq (new Outer.Inner).label, 'inner'

    test 'variables in constructor bodies are correctly scoped', ->

      class A
        x = 1
        constructor: ->
          x = 10
          y = 20
        y = 2
        captured: ->
          {x, y}

      a = new A
      eq a.captured().x, 10
      eq a.captured().y, 2


      class A
        @B = class
          @c = -> 5

      eq A.B.c(), 5

      ctor = ->
        @val = 1
      class A
      class B extends A
        constructor: ctor
      eq (new B).val, 1

      ctor = ->
      class A
      class B extends A
        method: ->
        constructor: ctor
      ok B::method

      counter = 0
      makeFn = (n) -> eq n, ++counter; ->
      class B extends (makeFn 1)
        @B = makeFn 2
        constructor: makeFn 3

      fn = ->
        {one: 1}
        this
      class B
      class A
        constructor: fn
        method: => this instanceof A
      ok (new A).method.call(new B)

      class C
        delete: =>
      ok C::delete

      nonce  = {}
      class C
        constructor: (id) -> @id = id
        @boundStatic = => new this(nonce)
      eq nonce, C.boundStatic().id

      fn = ->
        eq 'function', typeof (class @for)
        ok not /\seval\s?\(/.test (class @eval).toString()
        ok not /\sarguments\s\(/.test (class @arguments).toString()
      fn.call {}


      class Store
        @bound = =>
          do =>
            eq this, Store

      Store.bound()


      class Store

        eq this, Store

        @bound = =>
          do =>
            eq this, Store

        @unbound = ->
          eq this, Store

        instance: =>
          ok this instanceof Store

      Store.bound()
      Store.unbound()
      (new Store).instance()

      ident = (x) -> x

      result = ident class A then x = 1

      eq result, A

      result = ident class B extends A
        x = 1

      eq result, B

      ctor = -> {}
      class A then constructor: ctor
      ok (new A) not instanceof A


      do ->
        'use strict'
        class A


  suite 'Class Instantiation', ->

    test '"@" referring to the current instance, and not being coerced into a call', ->

      class ClassName
        amI: ->
          @ instanceof ClassName

      obj = new ClassName
      ok obj.amI()

    test 'a bound function in a bound function', ->

      class Mini
        num: 10
        generate: =>
          for i in [0, 0, 0]
            => @num

      m = new Mini
      eq (func() for func in m.generate()).join(' '), '10 10 10'


    test 'classes wrapped in decorators', ->

      func = (klass) ->
        klass::prop = 'value'
        klass

      func class Test
        prop2: 'value2'

      ok (new Test).prop  is 'value'
      ok (new Test).prop2 is 'value2'


    test '`new` shouldn\'t add extra parens', ->

      ok new Date().constructor is Date



  suite 'Inheritance and Super', ->







      nonce = {}
      class A
      class B extends A
        prop: nonce
        constructor: ->
      eq nonce, B::prop


      id = (x) -> x
      nonce = {}
      class A then nonce: nonce
      class B extends id A
      eq nonce, (new B).nonce


      class A
      class @A extends A

      ok (new @A) instanceof A


      class A

      class B extends A
        @static = => 'value'

      eq B.static(), 'value'
suite 'Function Invocation', ->

  id = (_) -> if arguments.length is 1 then _ else [].slice.call arguments

  test "basic argument passing", ->
    a = {}
    b = {}
    c = {}
    eq 1, (id 1)
    eq 2, (id 1, 2)[1]
    eq a, (id a)
    eq c, (id a, b, c)[2]


  test "optional parens can be used in a nested fashion", ->
    call = (func) -> func()
    add = (a,b) -> a + b
    result = call ->
      inner = call ->
        add 5, 5
    ok result is 10

  test "hanging commas and semicolons in argument list", ->
    fn = -> arguments.length
    eq 2, fn(0, 1; 2)

  test "function invocation", ->
    func = ->
      return if true
    eq undefined, func()
    result = ("hello".slice) 3
    ok result is 'lo'

  test "And even with strange things like this:", ->
    funcs  = [((x) -> x), ((x) -> x * x)]
    result = funcs[1] 5
    eq 25, result

  test "More fun with optional parens.", ->
    fn = (arg) -> arg
    eq 101, fn(fn {prop: 101}).prop
    okFunc = (f) -> ok(f())
    okFunc -> true

  test "chained function calls", ->
    nonce = {}
    identityWrap = (x) ->
      -> x
    eq nonce, identityWrap(identityWrap(nonce))()()
    eq nonce, (identityWrap identityWrap nonce)()()


  test "method calls", ->
    fnId = (fn) -> -> fn.apply this, arguments
    obj = {}
    obj.add = (a, b) -> a + b
    obj.anonymousAdd = (a, b) -> a + b
    obj.fastAdd = fnId (a, b) -> a + b
    eq 10, obj.add(5, 5)
    eq 20, obj.anonymousAdd 10, 10
    eq 40, obj.fastAdd (20), 20


  test "`@` and `this` should both be able to invoke a function", ->
    nonce = {}
    fn          = (arg) -> eq nonce, arg
    fn.withAt   = -> @ nonce
    fn.withThis = -> this nonce
    fn.withAt()
    fn.withThis()




  test "Implicit call with a trailing if statement as a param.", ->
    func = -> arguments[1]
    result = func 'one', if false then 100 else 13
    ok result is 13



  test "TODO: find out what this test case is testing and rename it", ->
    x = (obj, func) -> func obj
    ident = (x) -> x
    result = x {one: ident 1}, (obj) ->
      inner = ident(obj)
      ident inner
    ok result.one is 1

  test "More paren compilation tests:", ->
    reverse = (obj) -> obj.reverse()
    ok reverse([1, 2].concat 3).join(' ') is '3 2 1'

  test "Test for inline functions with parentheses and implicit calls.", ->
    combine = (func, num) -> func() * num
    result  = combine (-> 1 + 2), 3
    ok result is 9






  test "Non-spaced unary and binary operators should cause a function call.", ->
    func = (val) -> val + 1
    ok (func +5) is 6
    ok (func -5) is -4

  test "Prefix unary assignment operators are allowed in parenless calls.", ->
    func = (val) -> val + 1
    val = 5
    ok (func --val) is 5

    contextTest = -> eq @, if window? then window else global
    array = []
    contextTest array
    contextTest.apply null, array
    contextTest array...



  test "caching base value", ->
    obj = {index: 0, 0: {method: -> this is obj[0]}}
    ok obj[obj.index++].method([]...)

  test "passing splats to functions", ->
    arrayEq [0..4], id id [0..4]...
    fn = (a, b, c..., d) -> [a, b, c, d]
    range = [0..3]
    [first, second, others, last] = fn range..., 4, [5...8]...
    eq 0, first
    eq 1, second
    arrayEq [2..6], others
    eq 7, last

  test "splat variables are local to the function", ->
    outer = "x"
    clobber = (avar, outer...) -> outer
    clobber "foo", "bar"
    eq "x", outer

  test "Issue 894: Splatting against constructor-chained functions.", ->
    x = null
    class Foo
      bar: (y) -> x = y
    new Foo().bar([101]...)
    eq x, 101

  test "Functions with splats being called with too few arguments.", ->
    method = (first, variable..., penultimate, ultimate) ->
      penultimate
    eq 8, method 1, 2, 3, 4, 5, 6, 7, 8, 9
    eq 2, method 1, 2, 3
    eq 2, method 1, 2


    eq '1011', 11.toString [2]...
    eq '1011', (31).toString [3]...
    eq '1011', 69.0.toString [4]...
    eq '1011', (131.0).toString [5]...

  test "splats and the `new` operator: functions that return `null` should construct their instance", ->
    args = []
    child = new (constructor = -> null) args...
    ok child instanceof constructor

  test "splats and the `new` operator: functions that return functions should construct their return value", ->
    args = []
    fn = ->
    child = new (constructor = -> fn) args...
    ok child not instanceof constructor
    eq fn, child

  test "implicit return", ->
    eq ok, new ->
      ok

  test "implicit returns with multiple branches", ->
    nonce = {}
    fn = ->
      if false
        for a in b
          return c if d
      else
        nonce
    eq nonce, fn()

  test "implicit returns with switches", ->
    nonce = {}
    fn = ->
      switch nonce
        when nonce then nonce
        else return undefined
    eq nonce, fn()

  test "preserve context when generating closure wrappers for expression conversions", ->
    nonce = {}
    obj = {property: nonce, method: ->
      this.result = if false
        10
      else
        "a"
        "b"
        this.property
    }
    eq nonce, obj.method()
    eq nonce, obj.property


  test "usage of `new` is careful about where the invocation parens end up", ->
    eq 'object', typeof new do -> ->

  test "implicit call against control structures", ->
    result = null
    save   = (obj) -> result = obj

    save switch id false
      when true
        'true'
      when false
        'false'
    eq result, 'false'

    save if id false
      'false'
    else
      'true'
    eq result, 'true'

    save unless id false
      'true'
    else
      'false'
    eq result, 'true'


    fn = -> (f) -> f()
    nonce = {}
    eq nonce, (fn() -> nonce)

    nonce = {}
    obj = new new -> -> {prop: nonce}
    eq obj.prop, nonce

    nonce = {}
    argNonceA = {}
    argNonceB = {}
    fn = (a) -> (b) -> {a, b, prop: nonce}
    obj = new new fn(argNonceA)(argNonceB)
    eq obj.prop, nonce
    eq obj.a, argNonceA
    eq obj.b, argNonceB

    nonce = {}
    obj = {prototype: {id: nonce}}
    dotAccess = -> obj.prototype
    protoAccess = -> obj
    eq dotAccess().id, nonce
    eq protoAccess()::id, nonce


    do (nonExistent = 'one') ->
      eq nonExistent, 'one'

    overridden = 1
    do (overridden = 2) ->
      eq overridden, 2

    two = 2
    do (one = 1, two, three = 3) ->
      eq one, 1
      eq two, 2
      eq three, 3

suite 'Function Literals', ->

  suite 'Function Definition', ->

    test 'basic functions', ->

      fn = -> 3
      eq 'function', typeof fn
      ok fn instanceof Function
      eq 3, fn()

    test 'empty functions', ->
      fn = ->
      eq 'function', typeof fn
      eq undefined, fn()
      fn = () ->
      eq 'function', typeof fn
      eq undefined, fn()

    test 'multiple nested single-line functions', ->
      func = (x) -> (x) -> (x) -> x
      eq 3, func(1)(2)(3)

    test 'multiple nested single-line functions mixed with implicit calls', ->
      fn = (one) -> (two) -> three four, (five) -> six seven, eight, (nine) ->
      eq 'function', typeof fn

    test "self-referencing functions", ->
      changeMe = ->
        changeMe = 2
      eq 'function', typeof changeMe
      eq 2, changeMe()
      eq 2, changeMe

      list = [1, 2, 3]
      ok true if list.some (x) -> x is 2


  suite 'Bound Function Definition', ->



      a = ((=>) for a in [0] for b in [0])
      eq 1, a.length


  suite 'Parameter List Features', ->



    test "@-parameters: automatically assign an argument's value to a property of the context", ->
      nonce = {}

      ((@prop) ->).call context = {}, nonce
      eq nonce, context.prop



      eq 0, ((@prop) -> @prop).call {}, 0
      eq 'undefined', ((@prop) -> typeof prop).call {}, 0



    test "default values", ->
      nonceA = {}
      nonceB = {}
      a = (_,_1,arg=nonceA) -> arg
      eq nonceA, a()
      eq nonceA, a(0)
      eq nonceB, a(0,0,nonceB)
      eq nonceA, a(0,0,undefined)
      eq nonceA, a(0,0,null)
      eq false , a(0,0,false)
      eq nonceB, a(undefined,undefined,nonceB,undefined)
      b = (_,arg=nonceA,_1,_2) -> arg
      eq nonceA, b()
      eq nonceA, b(0)
      eq nonceB, b(0,nonceB)
      eq nonceA, b(0,undefined)
      eq nonceA, b(0,null)
      eq false , b(0,false)
      eq nonceB, b(undefined,nonceB,undefined)
      c = (arg=nonceA,_,_1) -> arg
      eq nonceA, c()
      eq      0, c(0)
      eq nonceB, c(nonceB)
      eq nonceA, c(undefined)
      eq nonceA, c(null)
      eq false , c(false)
      eq nonceB, c(nonceB,undefined,undefined)

    test "default values with @-parameters", ->
      nonceA = {}
      nonceB = {}
      obj = {f: (q = nonceA, @p = nonceB) -> q}
      eq nonceA, obj.f()
      eq nonceB, obj.p
      eq nonceB, obj.f nonceB, nonceA
      eq nonceA, obj.p


    test "default values with function calls", ->
      counter = 0
      fn = -> ++counter
      eq 1, ((x = fn()) -> x)()
      eq fn, ((x = fn()) -> x) fn
      eq 0, ((x = fn) -> x()) -> 0
      eq 2, ((x = fn()) -> x)()

    test "arguments vs parameters", ->
      nonce = {}
      f = (x) -> x()
      eq nonce, f (x) -> nonce
      g = -> f
      eq nonce, g(f) -> nonce

suite 'Member Access', ->


  test 'various unsoaked member accesses', ->
    nonceA = {}
    nonceB = {}
    nil = null
    obj = {a: nonceA, prototype: {b: nonceB}}
    a = 'a'
    b = 'b'
    eq nonceA, obj.a
    throws -> nil.a
    eq undefined, nil?.a
    eq nonceA, obj[a]
    throws -> nil[a]
    eq undefined, nil?[a]
    eq nonceB, obj::b
    throws -> nil::b
    eq undefined, nil?::b
    eq nonceB, obj::[b]
    throws -> nil::[b]
    eq undefined, nil?::[b]

  test 'dynamically accessing non-identifierNames', ->
    nonceA = {}
    nonceB = {}
    obj = {'a-b': nonceA}
    eq nonceA, obj['a-b']
    obj['c-d'] = nonceB
    eq nonceB, obj['c-d']
suite 'Object Literals', ->


  suite 'Basic Objects', ->

    test 'basic literals', ->
      nonce = {}
      eq nonce, {a:nonce}.a
      eq nonce, {a: nonce}.a
      eq nonce, { a : nonce }.a
      eq nonce, {a: nonce,}.a
      eq nonce, {0: nonce}[0]
      eq nonce, {1e3: nonce}[1e3]
      eq nonce, {a:0,b:nonce,c:0}.b
      eq nonce, {a: 0, b: nonce, c: 0}.b
      eq nonce, {a: 0, b: nonce, c: 0, }.b
      eq nonce, { a : 0 , b : nonce, c : 0 }.b

    test 'reserved words as keys', ->
      obj = {is: yes, not: no}
      ok obj.is
      ok not obj.not

    test 'listed functions', ->
      nonce = {}
      ok nonce, { 0: -> nonce }[0]()
      ok nonce, { 0: -> 0, 1: -> nonce, 2: -> 0 }[1]()

    test 'function context', ->
      nonce = {}
      eq nonce, { nonce: nonce, fn: -> @nonce }.fn()
      eq nonce, { nonce: nonce, fn: -> @nonce }['fn']()

    test 'implicit member shorthand', ->
      nonce = {}
      eq nonce, { nonce }.nonce
      (-> eq nonce, { @nonce }.nonce).call { nonce }

    test 'function calls in object literals', ->
      fn = (a, b, c) -> c
      nonce = {}
      eq nonce, { a: fn 0, 1, nonce, 2 }.a
      eq nonce, { a: -> fn 0, 1, nonce, 2 }.a()

      a = false
      {f: -> a = true}.f() + 1
      ok a


      obj = {}
      ok 'for' not of obj
      obj.for = 'for' of obj
      ok 'for' of obj


  suite 'Implicit Objects', ->








suite 'Operators', ->



  test 'binary maths operators do not require spaces', ->
    a = 1
    b = -1
    eq 1, a*-b
    eq -1, a*b
    eq 1, a/-b
    eq -1, a/b

  test 'operators should respect new lines as spaced', ->
    a = 123 +
    456
    eq 579, a

    '456'
    eq '123456', b

  test 'multiple operators should space themselves', ->
    eq (+ +1), (- -1)

  test 'bitwise operators', ->
    eq  2, (10 &   3)
    eq 11, (10 |   3)
    eq  9, (10 ^   3)
    eq 80, (10 <<  3)
    eq  1, (10 >>  3)
    eq  1, (10 >>> 3)
    num = 10; eq  2, (num &=   3)
    num = 10; eq 11, (num |=   3)
    num = 10; eq  9, (num ^=   3)
    num = 10; eq 80, (num <<=  3)
    num = 10; eq  1, (num >>=  3)
    num = 10; eq  1, (num >>>= 3)

  test 'instanceof', ->
    ok new String instanceof String
    ok new Boolean instanceof Boolean

  test 'not instanceof', ->
    ok new Number not instanceof String
    ok new Array not instanceof Boolean

  test "use `::` operator on keywords `this` and `@`", ->
    obj = prototype: prop: nonce = {}
    eq nonce, (-> @::prop).call obj
    eq nonce, (-> this::prop).call obj


  suite 'Existential Operator (Binary)', ->

    test "binary existential operator", ->
      nonce = {}

      b = a ? nonce
      eq nonce, b

      a = null
      b = undefined
      b = a ? nonce
      eq nonce, b

      a = false
      b = a ? nonce
      eq false, b

      a = 0
      b = a ? nonce
      eq 0, b

    test "binary existential operator conditionally evaluates second operand", ->
      i = 1
      func = -> i -= 1
      result = func() ? func()
      eq result, 0

    test "binary existential operator with negative number", ->
      a = null ? - 1
      eq -1, a

      eq 27, 3 ** 3
      eq 55, 1 + 3 ** 3 * 2
      eq 2, 2 ** 1 ** 3
      eq 2 ** 8, 2 ** 2 ** 3
      a = 2
      a **= 2
      eq 4, a


  suite 'Existential Operator (Unary)', ->

    test "postfix existential operator", ->
      ok (if nonexistent? then false else true)
      defined = true
      ok defined?
      defined = false
      ok defined?

    test "postfix existential operator only evaluates its operand once", ->
      semaphore = 0
      fn = ->
        ok false if semaphore
        ++semaphore
      ok(if fn()? then true else false)

    test "negated postfix existential operator", ->
      ok !nothing?.value

    test "postfix existential operator on expressions", ->
      eq true, (1 or 0)?, true


  suite '`is`,`isnt`,`==`,`!=`', ->

    test "`==` and `is` should be interchangeable", ->
      a = b = 1
      ok a is 1 and b == 1
      ok a == b
      ok a is b

    test "`!=` and `isnt` should be interchangeable", ->
      a = 0
      b = 1
      ok a isnt 1 and b != 0
      ok a != b
      ok a isnt b


  suite '[not] in/of', ->

    test "in, of", ->
      arr = [1]
      ok 0 of arr
      ok 1 in arr

    test 'not in, not of', ->
      arr = [1]
      ok 1 not of arr
      ok 0 not in arr

    test "`in` should be able to operate on an array literal", ->
      ok 2 in [0, 1, 2, 3]
      ok 4 not in [0, 1, 2, 3]
      arr = [0, 1, 2, 3]
      ok 2 in arr
      ok 4 not in arr
      arr = [0]
      val = 0
      ok val++ in arr
      ok val++ not in arr
      val = 0
      ok val++ of arr
      ok val++ not of arr

    test "`in` with cache and `__indexOf` should work in argument lists", ->
      eq 1, [Object() in Array()].length

      eq 1, 1 in [1] and 1

      share = 0
      a = -> share++ if share is 0
      b = -> share++ if share is 1
      c = -> share++ if share is 2
      ok a() not in [b(),c()]
      eq 3, share

      eq 1, [5 in []].length
      eq false, do -> return 0 in []

      a = [6, 9]
      eq 9 in [3, a...], true

      ok 0 in [1 and 0]
      ok 0 in [1, 1 and 0]
      ok not (0 in [1, 0 or 1])

      ok undefined not in {length: 1}


      ok 0 not in []



  test "chainable operators", ->
    ok 100 > 10 > 1 > 0 > -1
    ok -1 < 0 < 1 < 10 < 100

  test "`is` and `isnt` may be chained", ->
    ok true is not false is true is not false
    ok 0 is 0 isnt 1 is 1

  test "different comparison operators (`>`,`<`,`is`,etc.) may be combined", ->
    ok 1 < 2 > 1
    ok 10 < 20 > 2+3 is 5

  test "some chainable operators can be negated by `unless`", ->
    ok (true unless 0==10!=100)

  test "operator precedence: `|` lower than `<`", ->
    eq 1, 1 | 2 < 3 < 4

  test "preserve references", ->
    a = b = c = 1
    ok a == b <= c

  test "chained operations should evaluate each value only once", ->
    a = 0
    ok 1 > a++ < 1


    nonce = {}
    class C
      method: -> @nonce
      nonce: nonce

    arr = []

    eq "': '", '' +
    "': '"

    x = 2
    eq (- --x), -1


    x = null
    func = -> x ?= (-> if true then 'hi')
    func()
    eq x(), 'hi'

    counter = 0
    func = -> counter++
    func()? ? 100
    eq counter, 1
suite 'Parser', ->

  setup ->
    @shouldParse = (input) -> doesNotThrow -> parse input
    @shouldNotParse = (input) -> throws -> parse input


  test 'empty program', -> @shouldParse ''
  test 'simple number', -> @shouldParse '0'

  test 'simple error', -> @shouldNotParse '0+'

  test 'deeply nested expressions', ->
    @shouldParse '((((((((((((((((((((0))))))))))))))))))))'
    @shouldParse '++++++++++++++++++++0'

  test 'multiline program', ->
    @shouldParse 'a\nb'
  test 'indented expressions', ->
    @shouldParse 'a or\n  b'
    @shouldParse 'a or\n\tb'
suite 'Edgar Allan Poe', ->

  test 'The Raven', ->
    CoffeeScript.parse '''
      Once upon a mignight dreary while I pondered, weak and weary,
      Over many quaint and curious volume of forgotten lore -
      While I nodded, nearly napping, suddenly there came a tapping,
      As of some one gently rapping, rapping at my chamber door
      "'Tis some visiter". I muttered, "tapping at my chamber door" -
      "only this and nothing more."

      Ah distinctly I remember it was in the bleak December;
      And each separate dying ember wrought its ghost upon the floor.
      Eagerly I wished the morrow - vainly I had sought to borrow,
      From my books surcease of sorrow - sorrow For the lost Lenore -
      For the rare and radiant maiden whom the angels name Lenore -
      Nameless here For evermore
    '''
suite 'Range Literals', ->


  test "basic inclusive ranges", ->
    arrayEq [1, 2, 3] , [1..3]
    arrayEq [0, 1, 2] , [0..2]
    arrayEq [0, 1]    , [0..1]
    arrayEq [0]       , [0..0]
    arrayEq [-1]      , [-1..-1]
    arrayEq [-1, 0]   , [-1..0]
    arrayEq [-1, 0, 1], [-1..1]

  test "basic exclusive ranges", ->
    arrayEq [1, 2, 3] , [1...4]
    arrayEq [0, 1, 2] , [0...3]
    arrayEq [0, 1]    , [0...2]
    arrayEq [0]       , [0...1]
    arrayEq [-1]      , [-1...0]
    arrayEq [-1, 0]   , [-1...1]
    arrayEq [-1, 0, 1], [-1...2]

    arrayEq [], [1...1]
    arrayEq [], [0...0]
    arrayEq [], [-1...-1]

  test "downward ranges", ->
    arrayEq [0..9], [9..0].reverse()
    arrayEq [5, 4, 3, 2] , [5..2]
    arrayEq [2, 1, 0, -1], [2..-1]

    arrayEq [3, 2, 1]  , [3..1]
    arrayEq [2, 1, 0]  , [2..0]
    arrayEq [1, 0]     , [1..0]
    arrayEq [0]        , [0..0]
    arrayEq [-1]       , [-1..-1]
    arrayEq [0, -1]    , [0..-1]
    arrayEq [1, 0, -1] , [1..-1]
    arrayEq [0, -1, -2], [0..-2]

    arrayEq [4, 3, 2], [4...1]
    arrayEq [3, 2, 1], [3...0]
    arrayEq [2, 1]   , [2...0]
    arrayEq [1]      , [1...0]
    arrayEq []       , [0...0]
    arrayEq []       , [-1...-1]
    arrayEq [0]      , [0...-1]
    arrayEq [0, -1]  , [0...-2]
    arrayEq [1, 0]   , [1...-1]
    arrayEq [2, 1, 0], [2...-1]

  test "ranges with variables as enpoints", ->
    [a, b] = [1, 3]
    arrayEq [1, 2, 3], [a..b]
    arrayEq [1, 2]   , [a...b]
    b = -2
    arrayEq [1, 0, -1, -2], [a..b]
    arrayEq [1, 0, -1]    , [a...b]

  test "ranges with expressions as endpoints", ->
    [a, b] = [1, 3]
    arrayEq [2, 3, 4, 5, 6], [(a+1)..2*b]
    arrayEq [2, 3, 4, 5]   , [(a+1)...2*b]

  test "large ranges are generated with looping constructs", ->
    down = [99..0]
    eq 100, (len = down.length)
    eq   0, down[len - 1]

    up = [0...100]
    eq 100, (len = up.length)
    eq  99, up[len - 1]

    expected = [0..9]
    argsAtStart = (-> [arguments[0]..9]) 0
    arrayEq expected, argsAtStart
    argsAtEnd = (-> [0..arguments[0]]) 9
    arrayEq expected, argsAtEnd
    argsAtBoth = (-> [arguments[0]..arguments[1]]) 0, 9
    arrayEq expected, argsAtBoth
suite 'Regular Expressions', ->

  test 'differentiate regexps from division', ->
    a = -> 0
    a.valueOf = -> 1
    b = i = 1

    eq 1, a / b
    eq 1, a/ b
    eq 1, a/b
    eq 1, a / b / i
    eq 1, a/ b / i
    eq 1, a / b/ i
    eq 1, a / b /i
    eq 1, a/b / i
    eq 1, a/ b/ i
    eq 1, a/ b /i
    eq 1, a/b/ i
    eq 1, a/ b/i
    eq 1, a/b/i
    eq 1, b /= a
    eq 1, b/=a/i
    eq 1, b /=a/i
    eq 1, b /=a
    i=/a/i
    a[/a/]

    eq 0, a /b/i
    eq 0, a(/b/i)
    eq 0, a /b /i

  test 'regexps can start with spaces and = when unambiguous', ->
    a = -> 0
    eq 0, a(/ b/i)
    eq 0, a(/= b/i)
    eq 0, a a[/ b/i]
    eq 0, a(/ /)
    eq 1, +/ /.test ' '
    eq 1, +/=/.test '='

  test 'regexps can be empty', ->
    ok //.test ''
util = require 'util'
inspect = (o) -> util.inspect o, no, 2, yes

global[name] = func for name, func of require 'assert'

egal = (a, b) ->
  if a is b
    a isnt 0 or 1/a is 1/b
  else
    a isnt a and b isnt b

arrayEgal = (a, b) ->
  if egal a, b then yes
  else if a instanceof Array and b instanceof Array
    return no unless a.length is b.length
    return no for el, idx in a when not arrayEgal el, b[idx]
    yes



libDir = if typeof _$jscoverage is 'undefined' then 'lib' else 'instrumented'
global.CoffeeScript = require '..'

global.parse = (input) -> Parser.parse Preprocessor.processSync input
optimiser = new Optimiser
global.optimise = (ast) -> optimiser.optimise ast
suite 'William Shakespeare', ->

  test 'Hamlet', ->
    CoffeeScript.parse '''
      To be or not to be, that is the question
      Whether tis Nobler in the mind to suffer
      The Slings and Arrows of outrageous Fortune,
      Or to take Arms against a Sea of troubles,
      And By opposing end them, to die, to sleep
      No more. and By a sleep, to say we end
      The heart-ache and the thousand Natural shocks
      That Flesh is heir to?
    '''
suite 'Slices', ->

  setup ->
    @shared = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

  test "basic slicing", ->
    arrayEq [7, 8, 9]   , @shared[7..9]
    arrayEq [2, 3]      , @shared[2...4]
    arrayEq [2, 3, 4, 5], @shared[2...6]

  test "slicing with variables as endpoints", ->
    [a, b] = [1, 4]
    arrayEq [1, 2, 3, 4], @shared[a..b]
    arrayEq [1, 2, 3]   , @shared[a...b]

  test "slicing with expressions as endpoints", ->
    [a, b] = [1, 3]
    arrayEq [2, 3, 4, 5, 6], @shared[(a+1)..2*b]
    arrayEq [2, 3, 4, 5]   , @shared[a+1...(2*b)]

  test "unbounded slicing", ->
    arrayEq [7, 8, 9]   , @shared[7..]
    arrayEq [8, 9]      , @shared[-2..]
    arrayEq [9]         , @shared[-1...]
    arrayEq [0, 1, 2]   , @shared[...3]
    arrayEq [0, 1, 2, 3], @shared[..-7]

    arrayEq @shared      , @shared[..-1]
    arrayEq @shared[0..8], @shared[...-1]


    arrayEq [1, 2, 3], [1, 2, 3][..]

    arrayEq @shared, @shared[0..-1]
    arrayEq @shared, @shared[..-1]
    arrayEq @shared.slice(1,@shared.length), @shared[1..-1]

  test "string slicing", ->
    str = "abcdefghijklmnopqrstuvwxyz"
    ok str[1...1] is ""
    ok str[1..1] is "b"
    ok str[1...5] is "bcde"
    ok str[0..4] is "abcde"
    ok str[-5..] is "vwxyz"


suite 'String Interpolation', ->

  test 'interpolate one string variable', ->
    b = 'b'

  test 'interpolate two string variables', ->
    b = 'b'
    c = 'c'

  test 'interpolate one numeric variable in the middle of the string', ->
    b = 0

  test 'interpolate one numeric variable at the start of the string', ->
    a = 0

  test 'interpolate one numeric variable at the end of the string', ->
    c = 0

  test 'interpolate a function call', ->
    b = -> 'b'

  test 'interpolate a math expression (add)', ->

  test 'interpolate a math expression (subtract)', ->

  test 'interpolate a math expression (multiply)', ->

  test 'interpolate a math expression (divide)', ->

  test 'nested interpolation with double quotes', ->
    b = 'b'
    c = 'c'

  test 'nested interpolation with single quotes (should not interpolate)', ->
    b = 'b'
    c = 'c'

  test 'multiline interpolation', ->
    b = 'b'

    eq "a
    b
    c
    ", "a
    c
    "
    eq """
      a
      b
      c
    """, """
      a
      c
    """
suite 'Truthiness', ->

  setup ->
    @truthy = (ast) ->
      ok Optimiser.isTruthy ast
      ok not Optimiser.isFalsey ast
    @falsey = (ast) ->
      ok Optimiser.isFalsey ast
      ok not Optimiser.isTruthy ast
    @neither = (ast) ->
      ok not Optimiser.isTruthy ast
      ok not Optimiser.isFalsey ast

  test 'ints', ->
    @falsey new CS.Int 0
    @truthy new CS.Int 1
    @truthy new CS.Int 9e9

  test 'floats', ->
    @falsey new CS.Float 0.0
    @truthy new CS.Float 0.1
    @truthy new CS.Float 1.1
    @truthy new CS.Float 1.2e+3

  test 'strings', ->
    @falsey new CS.String ''
    @truthy new CS.String '0'

  test 'assignment', ->
    @truthy new CS.AssignOp (new CS.Identifier 'a'), new CS.Int 1
    @falsey new CS.AssignOp (new CS.Identifier 'a'), new CS.Int 0

norm = (sigma, x) -> (x / Math.sqrt( 2 * Math.PI * sigma ))

f = (mu, sigma, x) -> norm( sigma, Math.exp( (-.5) * Math.pow(x-mu,2) / sigma ) )

console.log f(10,4,8)
dom = require('../dom')

assign_and_output = () ->
	document = dom.createDocument()
	document.body.innerHTML = "<div class='content' id='content'>Hello World.</div>"
	return document.toString()

output = () ->
	node = (name, attrs = {}, children) ->
		attrs = (' '+k+'="'+attrs[k]+'"' for k of attrs).join('')
		if children.join
			children = children.join('')
	html = (children = []) -> node('html', {}, children)
	head = (attrs = {}, children = []) -> node('head', attrs, children)
	body = (attrs = {}, children = []) -> node('body', attrs, children)
	div = (attrs = {}, children = []) -> node('div', attrs, children)
	p = (attrs = {}, children = []) -> node('p', attrs, children)
	span = (attrs = {}, children = []) -> node('span', attrs, children)

	html([head(), body(null, div({id:'content','class':'content'}, "Hello World."))])

measure = (f, n) ->
	start = Date.now()
	for i in [0..n]
		f()
	return (Date.now() - start)

run = (f, n, interval) ->
	for i in [0...n] by interval
		ms = measure(f, interval)
		rps = interval * 1000 / ms
		console.log "Requests per sec:", rps

console.log assign_and_output()
console.log output()
run assign_and_output, 1000,200

run output, 100000, 20000

Copyright (c) 2011 Jesse Dailey <jesse.dailey@gmail.com>
License: MIT License - http://www.opensource.org/licenses/mit-license.php
htmlparse = require("./html/parser").parse
matcher = require("./css/nwmatcher")

NotSupported = () ->
	throw Error "NOT_SUPPORTED"

repeat = (s, n) ->
	n = Math.max(0, n)
	switch n
		when 0 then ""
		when 1 then s
		else s + repeat(s, n-1)

extend = (o, p) ->
	o ?= {}
	for k of p
		o[k] = p[k]
	return o

class Event
	@CAPTURING_PHASE = 1
	@AT_TARGET = 2
	@BUBBLING_PHASE = 3
	constructor: () ->
		@type = null
		@target = null
		@currentTarget = null
		@eventPhase = 0
		@bubbles = false
		@cancelable = true
		@timeStamp = 0
	stopPropagation: () ->
	initEvent: (type, canBubble, cancelable) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@timeStamp = new Date().getTime()

class MutationEvent extends Event
	@MODIFICATION = 1
	@ADDITION = 2
	@REMOVAL = 3
	constructor: () ->
		@relatedNode = null
		@prevValue = null
		@newValue = null
		@attrName = null
		@attrChange = 0
	initMutationEvent: (type, canBubble, cancelable, relatedNode, prevValue, newValue, attrName, attrChange) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@relatedNode = relatedNode
		@prevValue = prevValue
		@newValue = newValue
		@attrName = attrName
		@attrChange = attrChange

class Node
	@ELEMENT_NODE = 1
	@ATTRIBUTE_NODE = 2
	@TEXT_NODE = 3
	@CDATA_SECTION_NODE = 4
	@ENTITY_REFERENCE_NODE = 5
	@ENTITY_NODE = 6
	@PROCESSING_INSTRUCTION_NODE = 7
	@COMMENT_NODE = 8
	@DOCUMENT_NODE = 9
	@DOCUMENT_TYPE_NODE = 10
	@DOCUMENT_FRAGMENT_NODE = 11
	@NOTATION_NODE = 12

	@DOCUMENT_POSITION_DISCONNECTED = 1
	@DOCUMENT_POSITION_PRECEDING = 2
	@DOCUMENT_POSITION_FOLLOWING = 4
	@DOCUMENT_POSITION_CONTAINS = 8
	@DOCUMENT_POSITION_CONTAINED_BY = 16
	@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32

	constructor: (name, value = null, type = 1, ownerDocument = null) ->
		@_private =
			nodeName: null
			parentNode: null
			childIndex: -1
			classes: []
		@nodeName = name
		@nodeValue = value
		@nodeType = type
		@ownerDocument = ownerDocument
		@childNodes = []
		@attributes = {}
		@listeners =
			true: {}
			false: {}

	addEventListener: (type, listener, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		if not listener in list
			list.push listener
	removeEventListener: (type, listener = null, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		i = list.indexOf listener
		list.splice(i,1)
	dispatchEvent: (evt) ->
		prevented = false
		stopped = false
		evt.preventDefault = () ->
			if evt.cancelable
				prevented = true
		evt.stopPropagation = () ->
			stopped = true
		evt.target = @
		evt.eventPhase = Event.CAPTURING_PHASE
		chain = [@]
		while chain[0].parentNode isnt @ownerDocument
			chain.unshift chain[0].parentNode
		chain.unshift @ownerDocument
		for ancestor in chain
			evt.currentTarget = ancestor
			list = ancestor.listeners[true][evt.type]
			handler(evt) for handler in list if list
			break if stopped

		evt.eventPhase = Event.AT_TARGET
		evt.currentTarget = evt.target
		list = @listeners[true][evt.type]
		handler(evt) for handler in list if list
		list = @listeners[false][evt.type]
		handler(evt) for handler in list if list

		if evt.bubbles
			for ancestor in chain.reverse()
				evt.currentTarget = ancestor
				list = ancestor.listeners[false][evt.type]
				handler(evt) for handler in list if list
	cloneNode: (deep = false) ->
		ret = new Node(@nodeName, @nodeValue, @nodeType, @ownerDocument)
		for a of @attributes
			ret.attributes[a] = @attributes[a]
		if deep
			for c in @childNodes
				ret.childNodes.push c.cloneNode(true)
	hasAttributes: () ->
		for a of @attributes
			return true
		return false
	isSameNode: (node) ->
		node is @
	hasChildNodes: () ->
		@childNodes.length > 0
	insertBefore: (newNode, refNode) ->
		if refNode.parentNode isnt @
			throw Error "Cannot insertBefore a non-child."
		if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in newNode.childNodes
				@insertBefore(c, refNode)
		else
			i = refNode._private.childIndex
			if i > -1
				@childNodes.splice(i, 0, newNode)
				newNode._private.childIndex = i
				newNode._private.parentNode = @
				refNode._private.childIndex = i + 1
				i = 0
				for c in @childNodes
					c._private.childIndex = i++
	appendChild: (node) ->
		if node.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in node.childNodes
				@appendChild(c)
		else
			node._private.parentNode = @
			node._private.childIndex = @childNodes.length
			@childNodes.push node
	removeChild: (node) ->
		i = node._private.childIndex
		if node.parentNode is @ and i > -1
			node._private.parentNode = null
			node._private.childIndex = -1
			@childNodes.splice(i, 1)
			i = 0
			for c in @childNodes
				c._private.childIndex = i++
		else
			throw Error "Cannot removeChild a non-child."
	replaceChild: (newNode, oldNode) ->
		if oldNode.parentNode isnt @
			throw Error "Cannot replaceChild a non-child."
		i = oldNode._private.childIndex
		if i > -1
			if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
				for c in @childNodes
					@insertBefore(c, oldNode)
				@removeChild(oldNode)
			else
				newNode._private.parentNode = @
				newNode._private.childIndex = i
				oldNode.parentNode = null
				@childNodes.splice(i, 1, newNode)
	toString: (pretty=false,deep=true,indentLevel=0) ->
		if pretty
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		switch @nodeType
			when Node.TEXT_NODE
			when Node.ELEMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.ATTRIBUTE_NODE
			when Node.CDATA_SECTION_NODE
			when Node.COMMENT_NODE
			when Node.DOCUMENT_TYPE_NODE
			when Node.DOCUMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.DOCUMENT_FRAGMENT_NODE


Node::__defineGetter__ 'nodeName', () -> @_private.nodeName
Node::__defineSetter__ 'nodeName', (v) -> @_private.nodeName = v?.toUpperCase()
Node::__defineGetter__ 'previousSibling', () -> @parentNode?.childNodes[@_private.childIndex-1]
Node::__defineSetter__ 'nextSibling', () -> @parentNode?.childNodes[@_private.childIndex+1]
Node::__defineGetter__ 'parentNode', () -> @_private.parentNode
Node::__defineSetter__ 'parentNode', (v) ->
	if v isnt null
		throw Error "Must use one of appendChild, insertBefore, etc. to give a Node a new parent."
	@_private.parentNode?.removeChild @
	@_private.parentNode = null
	@_private.childIndex = -1
Node::__defineGetter__ 'firstChild', () -> @childNodes[0]
Node::__defineGetter__ 'lastChild', () -> @childNodes[-1]
Node::__defineGetter__ 'id', () -> @attributes['id']
Node::__defineSetter__ 'id', (value) ->
	o = @ownerDocument?
	if o
		if @attributes.id?
			delete @ownerDocument._private.idMap[@attributes.id]
	if value in [null, undefined, "undefined"]
		delete @attributes.id
	else
		if o
			@ownerDocument._private.idMap[value] = @
		@attributes.id = value
Node::__defineGetter__ 'className', () -> @attributes['class']
Node::__defineSetter__ 'className', (value) ->
	if value in [null, undefined, "undefined"]
		delete @attributes.class
		@_private.classes.length = 0
	else
		@attributes['class'] = value
		@_private.classes = value.split(' ')

class Element extends Node
		_: class HTMLElement extends Element
			constructor: (a...) ->
				super a...
		a: class HTMLAnchorElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "A"
				super a...
		area: class HTMLAreaElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "AREA"
				super a...
		audio: class HTMLAudioElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "AUDIO"
				super a...
		base: class HTMLBaseElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "BASE"
				super a...
		blockquote: class HTMLBlockquoteElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "BLOCKQUOTE"
				super a...
		body: class HTMLBodyElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "BODY"
				super a...
		br: class HTMLBRElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "BR"
				super a...
		button: class HTMLButtonElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "BUTTON"
				super a...
		canvas: class HTMLCanvasElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "CANVAS"
				super a...
		caption: class HTMLTableCaptionElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "CAPTION"
				super a...
		col: class HTMLTableColElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "COL"
				super a...
		colgroup: class HTMLTableColElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "COLGROUP"
				super a...
		del: class HTMLDelElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "DEL"
				super a...
		details: class HTMLDetailsElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "DETAILS"
				super a...
		div: class HTMLDivElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "DIV"
				super a...
		dl: class HTMLDListElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "DL"
				super a...
		embed: class HTMLEmbedElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "EMBED"
				super a...
		fieldSet: class HTMLFieldSetElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "FIELDSET"
				super a...
		form: class HTMLFormElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "FORM"
				super a...
		h1: class HTMLHeadingElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "H1"
				super a...
		h2: class HTMLHeading2Element extends HTMLHeadingElement
			constructor: (a...) ->
				a[0] = "H1"
				super a...
		h3: class HTMLHeading3Element extends HTMLHeadingElement
			constructor: (a...) ->
				a[0] = "H1"
				super a...
		h4: class HTMLHeading4Element extends HTMLHeadingElement
			constructor: (a...) ->
				a[0] = "H1"
				super a...
		h5: class HTMLHeading5Element extends HTMLHeadingElement
			constructor: (a...) ->
				a[0] = "H1"
				super a...
		h6: class HTMLHeading6Element extends HTMLHeadingElement
			constructor: (a...) ->
				a[0] = "H6"
				super a...
		head: class HTMLHeadElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "HEAD"
				super a...
		hr: class HTMLHRElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "HR"
				super a...
		html: class HTMLHtmlElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "HTML"
				super a...
		iframe: class HTMLIFrameElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "IFRAME"
				super a...
		image: class HTMLImageElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "IMAGE"
				super a...
		input: class HTMLInputElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "INPUT"
				super a...
		ins: class HTMLInsElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "INS"
				super a...
		keygen: class HTMLKeygenElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "KEYGEN"
				super a...
		label: class HTMLLabelElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "LABEL"
				super a...
		legend: class HTMLLegendElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "LEGEND"
				super a...
		li: class HTMLLIElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "LI"
				super a...
		link: class HTMLLinkElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "LINK"
				super a...
		map: class HTMLMapElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "MAP"
				super a...
		menu: class HTMLMenuElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "MENU"
				super a...
		meta: class HTMLMetaElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "META"
				super a...
		meter: class HTMLMeterElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "METER"
				super a...
		object: class HTMLObjectElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "OBJECT"
				super a...
		ol: class HTMLOListElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "OL"
				super a...
		optgroup: class HTMLOptGroupElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "OPTGROUP"
				super a...
		option: class HTMLOptionElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "OPTION"
				super a...
		output: class HTMLOutputElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "OUTPUT"
				super a...
		p: class HTMLParagraphElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "P"
				super a...
		param: class HTMLParamElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "PARAM"
				super a...
		pre: class HTMLPreElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "PRE"
				super a...
		progress: class HTMLProgressElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "PROGRESS"
				super a...
		quote: class HTMLQuoteElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "QUOTE"
				super a...
		script: class HTMLScriptElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "SCRIPT"
				super a...
		select: class HTMLSelectElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "SELECT"
				super a...
		source: class HTMLSourceElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "SOURCE"
				super a...
		style: class HTMLStyleElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "STYLE"
				super a...
		table: class HTMLTableElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "TABLE"
				super a...
		thead: class HTMLTableHeadElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "THEAD"
				super a...
		tbody: class HTMLTableBodyElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "TBODY"
				super a...
		tfoot: class HTMLTableFootElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "TFOOT"
				super a...
		td: class HTMLTableCellElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "TD"
				super a...
		th: class HTMLTableHeadElement extends HTMLTableCellElement
			constructor: (a...) ->
				a[0] = "TH"
				super a...
		tr: class HTMLTableRowElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "TR"
				super a...
		textarea: class HTMLTextAreaElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "TEXTAREA"
				super a...
		title: class HTMLTitleElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "TITLE"
				super a...
		ul: class HTMLUListElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "UL"
				super a...
		video: class HTMLVideoElement extends HTMLElement
			constructor: (a...) ->
				a[0] = "VIDEO"
				super a...
	}
	constructor: (a...) ->
		a[2] ?= Node.ELEMENT_NODE
		super a...
	getElementsByClassName: (name) ->
		ret = []
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if name is "*" or name in c._private.classes
					ret.push c
				for i in c.getElementsByClassName(name)
					ret.push i
		return ret
	getElementsByTagName: (name) ->
		ret = []
		uname = name.toUpperCase()
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if uname in ["*", c.tagName]
					ret.push c
				for i in c.getElementsByTagName(uname)
					ret.push i
		return ret
	getAttribute: (name) ->
		@attributes[name] ? ""
	getAttributeNode: (name) ->
		n = new Attr(name, @getAttribute(name))
		n.ownerElement = @
		n.ownerDocument = @.ownerDocument
		n
	hasAttribute: (name) ->
		name of @attributes
	setAttribute: (name, value) ->
		if value == null
			@removeAttribute(name)
		switch name
			when "class"
				@className = value
			when "id"
				@id = value
			else
				@attributes[name] = value
	removeAttribute: (name) ->
		delete @attributes[name]
		switch name
			when "class"
				@_private.classes = []
			when "id"
				delete @ownerDocument?._private.idMap[@id]
	matchesSelector: (selector) ->
		@ownerDocument?._private.matcher.matches(selector, @)
	querySelector: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)[0]
	querySelectorAll: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)
	toString: (pretty=false, deep=true, indentLevel = 0) ->
		try
			name = @nodeName?.toLowerCase()
		catch err
			console.log @
			throw err
		if pretty and deep
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		len = @childNodes.length
		end = ""
		if len is 0
			end = "/"
		r = 1
		if deep
			for c in @childNodes
				ret[r++] = c.toString pretty, deep, indentLevel + 1
		else if len > 0
		if len > 0
		ret.join('')

Element::__defineGetter__ 'tagName', () -> @nodeName
Element::__defineGetter__ 'innerHTML', () ->
	h = []
	for c in @childNodes
		h.push c.toString()
	return h.join('')
Element::__defineSetter__ 'innerHTML', (v) ->
	fragment = htmlparse(v, @ownerDocument)
	for c in @childNodes
		c._private.parentNode = null
		c._private.childIndex = -1
	@childNodes.length = 0
	@appendChild fragment
Element::__defineGetter__ 'innerText', () ->
	t = []
	for c in @childNodes
		if c.nodeType in [Node.TEXT_NODE, Node.CDATA_SECTION_NODE]
			t.push c.toString(false, false)
		else if c.nodeType isnt Node.COMMENT_NODE
			t.push c.innerText
	return t.join('')

class Attr extends Node
	constructor: (name, value) ->
		super name, value, Node.ATTRIBUTE_NODE, null
		@name = @nodeName
		@value = @nodeValue
		@ownerElement = null

class CData extends Node
	constructor: (value, owner) ->

class Comment extends Node
	constructor: (value, owner) ->

class Text extends Node
	constructor: (value, owner) ->

class DocumentFragment extends Node
	constructor: (owner) ->
	toString: (pretty=false, deep=true) ->
		ret = []
		r = 0
		for c in @childNodes
			ret[r++] = c.toString pretty, deep
		return ret.join('')

DocumentFragment::__defineSetter__ 'parentNode', (v) ->
	throw Error "DocumentFragment cannot have a parentNode"

class Document extends Element
	constructor: (a...) ->
		a[2] = Node.DOCUMENT_NODE
		super a...
		@documentElement = @
		@documentURI = null
		@_private = extend @_private, {
			idMap: {}
		}
	createCDATASection: (value) ->
		new CData(value, @)
	createComment: (value) ->
		new Comment(value, @)
	createDocumentFragment: () ->
		new DocumentFragment(@)
	createElement: (name) ->
		nodeClass = Element.Map[name?.toLowerCase()]
		if not nodeClass?
			new Element.Map['_'](name.toUpperCase())
		else
			new nodeClass(null,null,null,@)
	createEvent: (type) ->
		switch type
			when "MutationEvents"
				new MutationEvent()
			else
				new Event()
	createTextNode: (text) ->
		new Text(text)
	getElementById: (id) ->
		@_private.idMap[id]

class HTMLDocument extends Document
	constructor: () ->
		super "HTML", null, Node.DOCUMENT_NODE, @
		Document::appendChild.call @,@createElement('head')
		Document::appendChild.call @,@createElement('body')
		@head = @childNodes[0]
		@body = @childNodes[1]
		@_private = extend @_private, {
			matcher: matcher.init(global, @)
		}
	hasChildNodes: () -> true
	insertBefore: NotSupported
	appendChild: NotSupported
	removeChild: NotSupported
	replaceChild: NotSupported
	write: NotSupported
	writeln: NotSupported

exports.createDocument = () ->
	new HTMLDocument()

clear = (a) -> a.length = 0
get = (a) -> a.join("")
parse = (input, document) ->
	i = 0
	mode = 0
	fragment = document.createDocumentFragment()
	cursor = fragment
	tagName = []
	attrName = []
	attrVal = []
	text = []
	attributes = {}
	emitNode = () ->
		node = document.createElement(get(tagName))
		for a of attributes
			node.setAttribute(a, attributes[a])
		cursor.appendChild(node)
		cursor = node
		clear(text)
		clear(tagName)
		clear(attrName)
		clear(attrVal)
		for a of attributes
			delete attributes[a]
		mode = 0
	closeNode = () -> cursor = cursor.parentNode
	emitAttr = () ->
		attributes[get(attrName)] = get(attrVal)
		clear(attrName)
		clear(attrVal)
		mode = 2
	emitText = () ->
		if text.length > 0
			cursor.appendChild(document.createTextNode(get(text)))
			clear(text)
	states = [
			"<": [emitText, 1]
			"": [text, 0]
		,
			"/": [9]
			"": [tagName, 2]
		,
			" ": [3]
			"/": [8]
			">": [emitNode]
			"": [tagName]
		,
			"=": [4]
			"/": [8]
			">": [emitNode]
			"": [attrName]
		,
			'"': [5]
			"'": [6]
			"": [attrVal, 7]
		,
			'"': [emitAttr]
			"": [attrVal]
		,
			"'": [emitAttr]
			"": [attrVal]
		,
			" ": [emitAttr, 2]
			">": [emitAttr, emitNode]
			"/": [emitAttr, 8]
		,
			">": [emitNode, closeNode]
		,
			">": [closeNode, 0]
	]
	while c = input[i++]
		m = states[mode]
		result = m[c] or m[""] or []
		for x in result
			if x.call
				x()
			else if /^\d+$/.test x
				mode = x
			else if x.push
				x.push c
	return cursor

if exports
	exports.parse = parse

assert = (c, msg) ->
	if not c
		throw Error msg

assertEqual = (a, b, label) ->
	if a isnt b

dom = require('../dom')
global.document = dom.createDocument()
global.window = global

assert(document?, "document should exist")
assert(document.body?, "document.body should exist")
assert(document.head?, "document.head should exist")
assertEqual(document.nodeType, 9, "document.nodeType")

div = document.createElement('div')
assertEqual(div.nodeType, 1, "div.nodeType")
assertEqual(div.nodeName, "DIV", "div.nodeName")

document.body.appendChild(div)
assertEqual(document.body.childNodes.length, 1, "document.body.childNodes.length")
nodesByTagName = document.body.getElementsByTagName('DIV')
assertEqual(nodesByTagName.length, 1, "nodesByTagName.length")
div = document.createElement("div")
div.id = "testId"
assertEqual(div.attributes['id'], div.id, "div.attributes.id")
document.body.appendChild(div)
assertEqual(document.body.childNodes.length, 2, "document.body.childNodes.length")
nodeById = document.getElementById("testId")
assertEqual(nodeById, div, "nodeById")

span = document.createElement("span")
div.appendChild(span)
assertEqual div.childNodes.length, 1, "div.childNodes.length"
nodesByTagName = div.getElementsByTagName("span")
assertEqual nodesByTagName.length, 1, "nodesByTagName"
assertEqual nodesByTagName[0], span, "nodesByTagName[0]"
p = document.createElement("p")
p.id = 'classTest'
p.className = "alpha beta"
div.appendChild(p)
assertEqual div.childNodes.length, 2, "div.childNodes.length"
assertEqual div.childNodes[0], span, "div.childNodes[0]"
assertEqual div.childNodes[1], p, "div.childNodes[1]"
alphaNodes = div.getElementsByClassName("alpha")
betaNodes = div.getElementsByClassName("beta")
assertEqual alphaNodes.length, 1, "alphaNodes.length"
assertEqual betaNodes.length, 1, "betaNodes.length"
assertEqual alphaNodes[0], p, "alphaNodes[0]"
assertEqual betaNodes[0], p, "betaNodes[0]"

fragment = document.createDocumentFragment()
fragment.appendChild(document.createElement("div"))
fragment.appendChild(document.createElement("p"))

assertEqual fragment.childNodes.length, 2, "fragment.childNodes.length"
assertEqual fragment.toString(), "<div/><p/>", "fragment.toString()"

div.appendChild(fragment)

text = document.createTextNode("Harro!")
div.appendChild(text)
div.setAttribute("name", "foo")
assertEqual div.getAttribute("name"), "foo", "div.getAttribute('foo')"

attr = div.getAttributeNode("name")
assertEqual attr.value, "foo", "attr.value"
assertEqual attr.nodeValue, "foo", "attr.nodeValue"

testSelector = (s, output) ->
	x = document.querySelectorAll(s)
	assertEqual x.toString(), output, s

testSelector "p.alpha.beta", '<p id="classTest" class="alpha beta"/>'
testSelector "p", '<p id="classTest" class="alpha beta"/>,<p/>'
testSelector "div *", '<span/>,<p id="classTest" class="alpha beta"/>,<div/>,<p/>'

console.log "All tests passed."


dom = require('../dom')
document = dom.createDocument()
html = require('../html/parser')

test = (input, output, debug = false) ->
	result = html.parse(input, document, debug).toString(false, true)
	output ?= input
	if result isnt output
		throw Error result+" !== "+output

test "<div/>"
test "<div>Harro?</div>"
test "<div><p>Hi.</p></div>"
test "<div><p><span>Bye.</span></p></div>"
test "<div />", "<div/>"
test "<div><p  /></div>","<div><p/></div>"
test "<div><p /></div>","<div><p/></div>"
test "<div><p/></div>","<div><p/></div>"
test "<div key='val'></div>", '<div key="val"/>'
test "<div key='val' ></div>", '<div key="val"/>'
test "<div key='val'/>", '<div key="val"/>'
test "<div key='val' />", '<div key="val"/>'
test '<div id="test"></div>', '<div id="test"/>'
test '<eval>CurrencyFormat(Application.User.balance)</eval>'
test '<p>','<p/>'
console.log "All tests passed."

document = require("../dom").createDocument()
assertEqual = (a, b, label) ->
	if a isnt b

document.body.innerHTML = "<div></div>"

assertEqual document.toString(false, true), "<html><head/><body><div/></body></html>"
console.log "All tests passed."

dom = require("../dom")
assert = (c, msg) ->
	if not c
		throw Error msg

assertEqual = (a, b, label) ->
	if a isnt b

document = dom.createDocument()
document.body.innerHTML = "<div><p id='pId' class='c'><span class='c'></span></p><input name='foo' /></div>"

nw = require("../css/nwmatcher")
matcher = nw.init(global, document)

p = matcher.byId('pId')
c = matcher.byClass('c')
f = matcher.byName('foo')
s = matcher.byTag('span')
x = matcher.select('p + input')
assertEqual p.constructor.name, "HTMLParagraphElement"
assertEqual c.constructor.name, "Array"
assertEqual c.length, 2
assertEqual f.constructor.name, "Array"
assertEqual f.length, 1
assertEqual s.constructor.name, "Array"
assertEqual s.length, 1
assertEqual x.constructor.name, "Array"
assertEqual x.length, 1
console.log "All tests passed."


class Expect
	@report = {pass: 0, fail: 0}
	@equal: (a,b) ->
		if a == b
			@report.pass += 1
			return true
		@report.fail += 1
	@identical: (a,b) ->
		if a is b
			@report.pass += 1
			return true
		@report.fail += 1
	@arrayEqual: (a,b) ->
		for i in [0...a.length]
			Expect.equal(a[i], b[i])
	@arrayIdentical: (a,b) ->
		for i in [0...a.length]
			Expect.identical(a[i], b[i])

exports.Expect = Expect
Object.keys ?= (o) -> (k for k of o)
Expect = require('./expect').Expect

Array::with = (x) -> @.push(x); @
Array::extend = (a) -> @push(i) for i in a; @

class Vector extends Array
	constructor: (a...) -> (@push(i) for i in a); @
	fromArray: (a) -> (@push(i) for i in a); @
	zero: (n) -> (@[i]=0 for i in [0...n]); @
	add: (b) -> new Vector().fromArray( (@[i]+b[i]) for i in [0...@length] )
	sub: (b) -> @add(b.scale(-1))
	scale: (f) -> new Vector().fromArray( (i*f) for i in @ )
		Math.sqrt @dot(@)
		(@[i]*b[i] for i in [0...Math.min(@.length,b.length)]).reduce (a,x) -> a+x
		a = @
		Expect.equal(a.length,3)
		Expect.equal(b.length,3)
		return new Vector().fromArray([
			a[1]*b[2] - a[2]*b[1],
			a[2]*b[0] - a[0]*b[2],
			a[0]*b[1] - a[2]*b[0]
		])
	sum: () -> @.reduce (a,x) -> a+x
	product: () -> @.reduce(((a,x) -> a*x), 1)
	angle: (b) -> Math.arccos( @dot(b) / (@mag()*b.mag()) )
	toString: () -> "[" + @join(",") + "]"
	toArray: () -> (i for i in @)

Object.defineProperty Vector.prototype, 'x',
	get: () -> @[0]
	set: (v) -> @[0] = v
Object.defineProperty Vector.prototype, 'y',
	get: () -> @[1]
	set: (v) -> @[1] = v
Object.defineProperty Vector.prototype, 'z',
	get: () -> @[2]
	set: (v) -> @[2] = v

class Matrix extends Vector
	constructor: (h, w) ->
		@h = h
		@w = w
	get: (r,c) -> @[(r*@w) + c]
	set: (r,c,v) -> @[(r*@w)+c] = v
	col: (c) -> new Vector().fromArray (@[(i*@w) + c] for i in [0...@h])
	row: (r) -> new Vector().fromArray (@[i] for i in [(r*@w)...((r+1)*@w)])
	add: (v) -> new Matrix(@h,@w).fromArray( (@[i]+v[i]) for i in [0...@length] )
	scale: (f) -> new Matrix(@h,@w).fromArray( (i*f) for i in @ )
	times: (m) ->
		if m.constructor.name is "Vector"
			return new Vector().fromArray( (@row(i).dot(m) for i in [0...@h]) )
		p = @w
		if not (p is m.h)
			throw new Error("Impossible operation.")
		n = new Matrix(p, p)
		for x in [0...p]
			for y in [0...p]
				n.set(x,y, @row(x).dot(@col(y)))
		n
	inverse2: () ->
		a = @get(0,0)
		b = @get(0,1)
		c = @get(1,0)
		d = @get(1,1)
		det = (a*d) - (b*c)
		if det is 0 then throw Error("cant invert a singular matrix")
		return new Matrix(@h,@w).fromArray([
			d, -b,
			-c, a
		]).scale(1/det)
	equals: (m) ->
		if m.constructor.name isnt "Matrix"
			return false
		for i in [0...@length]
			if @[i] isnt m[i]
				return false
		return true
	toString: () -> (("[" + @slice(i*@w,(i+1)*@w).join(",") + "]\n") for i in [0...@h]).join("").replace(/\n$/,"")
	@Identity: (n) ->
		m = new Matrix(n,n)
		m.zero(n * n)
		m.set(i,i, 1) for i in [0...n]
		m

class Transform2d
	@Rotation: (deg) -> new Matrix(2,2).fromArray([
		Math.cos(deg),-Math.sin(deg),
		Math.sin(deg),Math.cos(deg)
	])

class Graph
	constructor: () ->
		@nodes = []
		@edges = {}
	addNode: (node) ->
		node.id = @nodes.length
		@nodes.push node
		return node.id
	getNode: (id) -> @node[id]
	setEdge: (a, b, v = 1) ->
		@edges[a] ?= {}
		@edges[a][b] ?= {}
		@edges[a][b] = v
	getEdge: (a,b,v=0) ->
		if a of @edges and b of @edges[a]
			return @edges[a][b]
		return v
	getNeighbors: (a) ->
		if a of @edges
			return Object.keys(@edges[a])
		return []
		open_cache = {}
		score = (p) =>
			sum = 0
			for i in [0...p.length-1]
				a = p[i]
				b = p[i+1]
				sum += @getEdge(a,b)
			sum + heuristic(p[p.length-1], goal)
		cur = start
		while cur != goal
			for n in @getNeighbors(cur)
				if not (n of open_cache or n of closed)
					scores[n] ?= score( (i for i in path).with(n) )
					open_cache[n] = 1
					if open.length is 0 or scores[n] < scores[open[0]]
						open.unshift(n)
					else
						i = 0
						while scores[n] > scores[open[i]]
							i++
						open.splice(i,n,0)
			closed[cur] = scores[cur]
			cur = open.shift()
	toMatrix: () ->
		m = new Matrix(@nodes.length,@nodes.length)
		for i in [0...@nodes.length]
			for j in [0...@nodes.length]
				if i is j then continue
				m.set(i,j, @getEdge(i,j))
		m

Graph.toString = () -> "function Graph() { ... }"

publics =
	Vector: Vector
	Matrix: Matrix
	Graph: Graph
	Perceptron: Perceptron
if exports?
	console.log "using exports"
	exports = publics
else if global?
	console.log "using global"
	global.matrix = publics
else if window?
	console.log "using window"
	window.matrix = publics


publics = {}

if console?.log
	log = (a...) ->
		console.log.apply(console, a)
else
	log = (a...) ->
		alert a.join(", ")

OBJECT_RE = /\[object (\w+)\]/

	keys = []; j = 0
	for i of o
		if inherited or o.hasOwnProperty(i)
			keys[j++] = i
	keys

		for i of k
			a[k[i]] ?= b[k[i]] unless b[k[i]] is undefined
	else
		for i in (k = Object.Keys(b))
			a[i] ?= b[i]
	a

Object.Extend Object,
	Type: (o) ->
		switch true
			when o is undefined
				"undefined"
			when o is null
				"null"
			when Object.IsString o
				"string"
			when Object.IsArray o
				"array"
			when Object.IsNumber o
				"number"
			when Object.IsFunc o
				"function"
			when Object.IsType o, "RegExp"
				"regexp"
			when String(o) in ["true", "false"]
				"boolean"
			when Object.IsError o
				"error"
			when Object.IsWindow o
				"window"
			when Object.IsObject o
				"object"
		if o == null
			o is T
		else if o.constructor is T
			true
		else if typeof T is "string"
			o.constructor.name is T or Object::toString.apply(o).replace(OBJECT_RE, "$1") is T
		else
		o? and (typeof o is "string" or Object.IsType(o, String))
	IsNumber: (o) ->
		o? and Object.IsType o, Number
	IsBoolean: (o) ->
		typeof o is "boolean"
	IsSimple: (o) ->
		Object.IsString(o) or Object.IsNumber(o) or Object.IsBoolean(o)
		o? and (typeof o is "function" or Object.IsType(o, Function)) and o.call?
		o? and (Object.ToString(o) is "[object Array]" or Object.IsType(o, Array))
	IsError: (o) ->
		o? and o.constructor?.name is "Error"
		o? and typeof o is "object"
		o?
		if a? and Object.IsObject(a)
			return a.toString() if Object.IsString a
			return Number(a) if Object.IsNumber a
		a
	ToString: (x) ->
		Object::toString.apply(x)
	Get: (o, key, def) ->
		dot = key.indexOf '.'
		if dot isnt -1
			return Object.Get(Object.Get(o, key.substring(0,dot)), key.substring(dot+1), def)
		if key of o
			return o[key]
		return def

Object.Extend Function,
		if "bind" of f
			args.splice 0, 0, t
			r = f.bind.apply f, args
		else
			r = (a...) ->
				if args.length > 0
					a = args
				f.apply t, args
		r.toString = () ->
		r
		r = (a...) ->
			f.apply @, a
		r.toString = f.toString
		r
	NotNull: (x) -> x != null
	NotEmpty: (x) -> x not in ["", null]
	IndexFound: (x) -> x > -1
	ReduceAnd: (x) -> x and @
	UpperLimit: (x) -> (y) -> Math.min(x, y)
	LowerLimit: (x) -> (y) -> Math.max(x, y)
	Px: (d) -> () -> Number.Px(@,d)

Object.Extend String,
	Repeat: (s, n) -> (s for _ in [0...n]).join ""
		while s.length < n
			s = c + s
		s
		while s.length < n
			s = s + c
		s
		nn = s.length
		end = j
		if end < 0
			end += nn
		start = i
		if start < 0
			start += nn
		s.substring(0,start) + n + s.substring(end)
		a = 1; b = 0
		for i in [0...s.length]
			a = (a + s.charCodeAt(i)) % 65521
			b = (b + a) % 65521
		return (b << 16) | a
		if Object.IsWindow(@) then return new String.Builder()
		items = []
		@length   = 0
		@append   = (s) => items.push s; @length += s?.toString().length|0
		@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
		@clear    = ( ) => items = []; @length = 0
		@toString = ( ) => items.join("")
		@

Object.Extend Array,
		if Object.IsArray(a[0]) then return Array.Coalesce a[0]...
		for i in a
			return i if i?
		j = a.length
		for i in b
			a[j++] = i
		a
		if not Object.IsArray(a)
			return a
		for i in a
			switch true
				when not Object.IsDefined(i) then continue
				when Object.IsSimple(i) then buffer.append(i)
				when Object.IsArray(i) then Array.Compact(i, buffer, into, false)
				else
					into.push buffer.toString() if buffer.length > 0
					into.push i
					buffer.clear()
		if into.length is 0
			return buffer.toString()
		if buffer.length > 0 and topLevel
			into.push buffer.toString()
			buffer.clear()
		return into
		if not Object.IsArray(a)
			return
		n = a.length
		if from < 0 then from += n
		if to < 0 then to += n
		for i in [from..to]
			if f(a[i]) then return a[i]
		return null

Object.Extend Number,
		x? and (parseInt(x,10)+(d|0))+"px"
		(y) ->
			Math.max parseFloat(y or 0), x
		(y) ->
			Math.min parseFloat(y or 0), x


	Cancel: (evt) ->
		evt.stopPropagation()
		evt.preventDefault()
		evt.cancelBubble = true
		evt.returnValue = false
	Prevent: (evt) ->
		evt.preventDefault()
	Stop: (evt) ->
	 evt.stopPropagation()
	 evt.cancelBubble = true

try
	publics = global
catch e
	console.log "no global"

try
	publics = window
catch e
	console.log "no window"

`
// extracted from NodeJS internals, for browser
(function(publics) {
	var process = { EventEmitter: function() {} };
	
	if (typeof Array.isArray !== "function"){
		Array.isArray = function(obj){ return Object.prototype.toString.call(obj) === "[object Array]" };
	}
	
	if (!Array.prototype.indexOf){
		Array.prototype.indexOf = function(item){
				for ( var i = 0, length = this.length; i < length; i++ ) {
						if ( this[ i ] === item ) {
								return i;
						}
				}

				return -1;
		};
	}
	
	// Begin wrap of nodejs implementation of EventEmitter

	var EventEmitter = publics.EventEmitter = process.EventEmitter;

	var isArray = Array.isArray;

	EventEmitter.prototype.emit = function(type) {
		// If there is no 'error' event listener then throw.
		if (type === 'error') {
			if (!this._events || !this._events.error ||
					(isArray(this._events.error) && !this._events.error.length))
			{
				if (arguments[1] instanceof Error) {
					throw arguments[1]; // Unhandled 'error' event
				} else {
					throw new Error("Uncaught, unspecified 'error' event.");
				}
				return false;
			}
		}

		if (!this._events) return false;
		var handler = this._events[type];
		if (!handler) return false;

		if (typeof handler == 'function') {
			switch (arguments.length) {
				// fast cases
				case 1:
					handler.call(this);
					break;
				case 2:
					handler.call(this, arguments[1]);
					break;
				case 3:
					handler.call(this, arguments[1], arguments[2]);
					break;
				// slower
				default:
					var args = Array.prototype.slice.call(arguments, 1);
					handler.apply(this, args);
			}
			return true;

		} else if (isArray(handler)) {
			var args = Array.prototype.slice.call(arguments, 1);

			var listeners = handler.slice();
			for (var i = 0, l = listeners.length; i < l; i++) {
				listeners[i].apply(this, args);
			}
			return true;

		} else {
			return false;
		}
	};

	// EventEmitter is defined in src/node_events.cc
	// EventEmitter.prototype.emit() is also defined there.
	EventEmitter.prototype.addListener = function(type, listener) {
		if ('function' !== typeof listener) {
			throw new Error('addListener only takes instances of Function');
		}

		if (!this._events) this._events = {};

		// To avoid recursion in the case that type == "newListeners"! Before
		// adding it to the listeners, first emit "newListeners".
		this.emit('newListener', type, listener);

		if (!this._events[type]) {
			// Optimize the case of one listener. Don't need the extra array object.
			this._events[type] = listener;
		} else if (isArray(this._events[type])) {
			// If we've already got an array, just append.
			this._events[type].push(listener);
		} else {
			// Adding the second element, need to change to array.
			this._events[type] = [this._events[type], listener];
		}

		return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
		var self = this;
		self.on(type, function g() {
			self.removeListener(type, g);
			listener.apply(this, arguments);
		});
	};

	EventEmitter.prototype.removeListener = function(type, listener) {
		if ('function' !== typeof listener) {
			throw new Error('removeListener only takes instances of Function');
		}

		// does not use listeners(), so no side effect of creating _events[type]
		if (!this._events || !this._events[type]) return this;

		var list = this._events[type];

		if (isArray(list)) {
			var i = list.indexOf(listener);
			if (i < 0) return this;
			list.splice(i, 1);
			if (list.length == 0)
				delete this._events[type];
		} else if (this._events[type] === listener) {
			delete this._events[type];
		}

		return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
		// does not use listeners(), so no side effect of creating _events[type]
		if (type && this._events && this._events[type]) this._events[type] = null;
		return this;
	};

	EventEmitter.prototype.listeners = function(type) {
		if (!this._events) this._events = {};
		if (!this._events[type]) this._events[type] = [];
		if (!isArray(this._events[type])) {
			this._events[type] = [this._events[type]];
		}
		return this._events[type];
	};

	// End nodejs implementation
}( publics ))
`

`
//+ Jonas Raoni Soares Silva
(function(publics) {
	var BinaryParser = publics.BinaryParser = function(bigEndian, allowExceptions){
		this.bigEndian = bigEndian, this.allowExceptions = allowExceptions;
	};
	with({p: BinaryParser.prototype}){
		p.encodeFloat = function(number, precisionBits, exponentBits){
			var bias = Math.pow(2, exponentBits - 1) - 1, minExp = -bias + 1, maxExp = bias, minUnnormExp = minExp - precisionBits,
			status = isNaN(n = parseFloat(number)) || n == -Infinity || n == +Infinity ? n : 0,
			exp = 0, len = 2 * bias + 1 + precisionBits + 3, bin = new Array(len),
			signal = (n = status !== 0 ? 0 : n) < 0, n = Math.abs(n), intPart = Math.floor(n), floatPart = n - intPart,
			i, lastBit, rounded, j, result;
			for(i = len; i; bin[--i] = 0);
			for(i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2));
			for(i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart);
			for(i = -1; ++i < len && !bin[i];);
			if(bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]){
				if(!(rounded = bin[lastBit]))
					for(j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);
				for(j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0));
			}
			for(i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);

			(exp = bias + 1 - i) >= minExp && exp <= maxExp ? ++i : exp < minExp &&
				(exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow"), i = bias + 1 - (exp = minExp - 1));
			(intPart || status !== 0) && (this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status),
				exp = maxExp + 1, i = bias + 2, status == -Infinity ? signal = 1 : isNaN(status) && (bin[i] = 1));
			for(n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = (n % 2) + result, n = n >>= 1);
			for(n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = [];
				i; n += (1 << j) * result.charAt(--i), j == 7 && (r[r.length] = String.fromCharCode(n), n = 0), j = (j + 1) % 8);
			r[r.length] = n ? String.fromCharCode(n) : "";
			return (this.bigEndian ? r.reverse() : r).join("");
		};
		p.encodeInt = function(number, bits, signed){
			var max = Math.pow(2, bits), r = [];
			(number >= max || number < -(max >> 1)) && this.warn("encodeInt::overflow") && (number = 0);
			number < 0 && (number += max);
			for(; number; r[r.length] = String.fromCharCode(number % 256), number = Math.floor(number / 256));
			for(bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0");
			return (this.bigEndian ? r.reverse() : r).join("");
		};
		p.decodeFloat = function(data, precisionBits, exponentBits){
			var b = ((b = new this.Buffer(this.bigEndian, data)).checkBuffer(precisionBits + exponentBits + 1), b),
				bias = Math.pow(2, exponentBits - 1) - 1, signal = b.readBits(precisionBits + exponentBits, 1),
				exponent = b.readBits(precisionBits, exponentBits), significand = 0,
				divisor = 2, curByte = b.buffer.length + (-precisionBits >> 3) - 1,
				byteValue, startBit, mask;
			do
				for(byteValue = b.buffer[ ++curByte ], startBit = precisionBits % 8 || 8, mask = 1 << startBit;
					mask >>= 1; (byteValue & mask) && (significand += 1 / divisor), divisor *= 2);
			while(precisionBits -= startBit);
			return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity
				: (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand
				: Math.pow(2, exponent - bias) * (1 + significand) : 0);
		};
		p.decodeInt = function(data, bits, signed){
			var b = new this.Buffer(this.bigEndian, data), x = b.readBits(0, bits), max = Math.pow(2, bits);
			return signed && x >= max / 2 ? x - max : x;
		};
		with({p: (p.Buffer = function(bigEndian, buffer){
			this.bigEndian = bigEndian || 0, this.buffer = [], this.setBuffer(buffer);
		}).prototype}){
			p.readBits = function(start, length){
				//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
				function shl(a, b){
					for(++b; --b; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);
					return a;
				}
				if(start < 0 || length <= 0)
					return 0;
				this.checkBuffer(start + length);
				for(var offsetLeft, offsetRight = start % 8, curByte = this.buffer.length - (start >> 3) - 1,
					lastByte = this.buffer.length + (-(start + length) >> 3), diff = curByte - lastByte,
					sum = ((this.buffer[ curByte ] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1))
					+ (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[ lastByte++ ] & ((1 << offsetLeft) - 1))
					<< (diff-- << 3) - offsetRight : 0); diff; sum += shl(this.buffer[ lastByte++ ], (diff-- << 3) - offsetRight)
				);
				return sum;
			};
			p.setBuffer = function(data){
				if(data){
					for(var l, i = l = data.length, b = this.buffer = new Array(l); i; b[l - i] = data.charCodeAt(--i));
					this.bigEndian && b.reverse();
				}
			};
			p.hasNeededBits = function(neededBits){
				return this.buffer.length >= -(-neededBits >> 3);
			};
			p.checkBuffer = function(neededBits){
				if(!this.hasNeededBits(neededBits))
					throw new Error("checkBuffer::missing bytes");
			};
		}
		p.warn = function(msg){
			if(this.allowExceptions)
				throw new Error(msg);
			return 1;
		};
		p.toSmall = function(data){return this.decodeInt(data, 8, true);};
		p.fromSmall = function(number){return this.encodeInt(number, 8, true);};
		p.toByte = function(data){return this.decodeInt(data, 8, false);};
		p.fromByte = function(number){return this.encodeInt(number, 8, false);};
		p.toShort = function(data){return this.decodeInt(data, 16, true);};
		p.fromShort = function(number){return this.encodeInt(number, 16, true);};
		p.toWord = function(data){return this.decodeInt(data, 16, false);};
		p.fromWord = function(number){return this.encodeInt(number, 16, false);};
		p.toInt = function(data){return this.decodeInt(data, 32, true);};
		p.fromInt = function(number){return this.encodeInt(number, 32, true);};
		p.toDWord = function(data){return this.decodeInt(data, 32, false);};
		p.fromDWord = function(number){return this.encodeInt(number, 32, false);};
		p.toFloat = function(data){return this.decodeFloat(data, 23, 8);};
		p.fromFloat = function(number){return this.encodeFloat(number, 23, 8);};
		p.toDouble = function(data){return this.decodeFloat(data, 52, 11);};
		p.fromDouble = function(number){return this.encodeFloat(number, 52, 11);};
	}
}( publics ))
`

`
// https://raw.github.com/pgriess/node-websocket-client/master/lib/websocket.js
(function(publics) {
	console.log("WebSocket is undefined?");
	console.log( WebSocket == void 0 );
	if( WebSocket == void 0 ) {
		var assert = require('assert');
		var buffer = require('buffer');
		var crypto = require('crypto');
		var events = require('events');
		var http = require('http');
		var net = require('net');
		var urllib = require('url');
		var sys = require('util');

		var FRAME_NO = 0;
		var FRAME_LO = 1;
		var FRAME_HI = 2;

		// Values for readyState as per the W3C spec
		var CONNECTING = 0;
		var OPEN = 1;
		var CLOSING = 2;
		var CLOSED = 3;

		var debugLevel = parseInt(process.env.NODE_DEBUG, 16);
		var debug = (debugLevel & 0x4) ?
				function() { sys.error.apply(this, arguments); } :
				function() { };

		// Generate a Sec-WebSocket-* value
		var createSecretKey = function() {
				// How many spaces will we be inserting?
				var numSpaces = 1 + Math.floor(Math.random() * 12);
				assert.ok(1 <= numSpaces && numSpaces <= 12);

				// What is the numerical value of our key?
				var keyVal = (Math.floor(
						Math.random() * (4294967295 / numSpaces)
				) * numSpaces);

				// Our string starts with a string representation of our key
				var s = keyVal.toString();

				// Insert 'numChars' worth of noise in the character ranges
				// [0x21, 0x2f] (14 characters) and [0x3a, 0x7e] (68 characters)
				var numChars = 1 + Math.floor(Math.random() * 12);
				assert.ok(1 <= numChars && numChars <= 12);
				
				for (var i = 0; i < numChars; i++) {
						var pos = Math.floor(Math.random() * s.length + 1);

						var c = Math.floor(Math.random() * (14 + 68));
						c = (c <= 14) ?
								String.fromCharCode(c + 0x21) :
								String.fromCharCode((c - 14) + 0x3a);

						s = s.substring(0, pos) + c + s.substring(pos, s.length);
				}

				// We shoudln't have any spaces in our value until we insert them
				assert.equal(s.indexOf(' '), -1);

				// Insert 'numSpaces' worth of spaces
				for (var i = 0; i < numSpaces; i++) {
						var pos = Math.floor(Math.random() * (s.length - 1)) + 1;
						s = s.substring(0, pos) + ' ' + s.substring(pos, s.length);
				}

				assert.notEqual(s.charAt(0), ' ');
				assert.notEqual(s.charAt(s.length), ' ');

				return s;
		};

		// Generate a challenge sequence
		var createChallenge = function() {
				var c = ''; 
				for (var i = 0; i < 8; i++) {
						c += String.fromCharCode(Math.floor(Math.random() * 255));
				}

				return c;
		};

		// Get the value of a secret key string
		//
		// This strips non-digit values and divides the result by the number of
		// spaces found.
		var secretKeyValue = function(sk) {
				var ns = 0;
				var v = 0;

				for (var i = 0; i < sk.length; i++) {
						var cc = sk.charCodeAt(i);
						
						if (cc == 0x20) {
								ns++;
						} else if (0x30 <= cc && cc <= 0x39) {
								v = v * 10 + cc - 0x30;
						}
				}

				return Math.floor(v / ns);
		}

		// Get the to-be-hashed value of a secret key string
		//
		// This takes the result of secretKeyValue() and encodes it in a big-endian
		// byte string
		var secretKeyHashValue = function(sk) {
				var skv = secretKeyValue(sk);
			 
				var hv = '';
				hv += String.fromCharCode((skv >> 24) & 0xff);
				hv += String.fromCharCode((skv >> 16) & 0xff);
				hv += String.fromCharCode((skv >> 8) & 0xff);
				hv += String.fromCharCode((skv >> 0) & 0xff);

				return hv;
		};

		// Compute the secret key signature based on two secret key strings and some
		// handshaking data.
		var computeSecretKeySignature = function(s1, s2, hs) { 
				assert.equal(hs.length, 8);

				var hash = crypto.createHash('md5');

				hash.update(secretKeyHashValue(s1));
				hash.update(secretKeyHashValue(s2));
				hash.update(hs);

				return hash.digest('binary');
		};

		// Return a hex representation of the given binary string; used for debugging
		var str2hex = function(str) {
				var hexChars = [
						'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 
						'a', 'b', 'c', 'd', 'e', 'f'
				];

				var out = '';
				for (var i = 0; i < str.length; i++) {
						var c = str.charCodeAt(i);
						out += hexChars[(c & 0xf0) >>> 4];
						out += hexChars[c & 0x0f];
						out += ' ';
				}

				return out.trim();
		};

		// Get the scheme for a URL, undefined if none is found
		var getUrlScheme = function(url) {
				var i = url.indexOf(':');
				if (i == -1) {
						return undefined;
				}

				return url.substring(0, i);
		};

		// Set a constant on the given object
		var setConstant = function(obj, name, value) {
				Object.defineProperty(obj, name, {
						get : function() {
								return value;
						}
				});
		};

		// WebSocket object
		//
		// This is intended to conform (mostly) to http://dev.w3.org/html5/websockets/
		//
		// N.B. Arguments are parsed in the anonymous function at the bottom of the
		//      constructor.
		var WebSocket = function(url, proto, opts) {
				events.EventEmitter.call(this);

				// Retain a reference to our object
				var self = this;

				// State of our end of the connection
				var readyState = CONNECTING;

				// Whether or not the server has sent a close handshake
				var serverClosed = false;

				// Our underlying net.Stream instance
				var stream = undefined;

				opts = opts || {
						origin : 'http://www.example.com'
				};

				// Frame parsing functions
				//
				// These read data from the given buffer starting at the given offset,
				// looking for the end of the current frame. If found, the current frame is
				// emitted and the function returns. Only a single frame is processed at a
				// time.
				//
				// The number of bytes read to complete a frame is returned, which the
				// caller is to use to advance along its buffer. If 0 is returned, no
				// completed frame bytes were found, and the caller should probably enqueue
				// the buffer as a continuation of the current message. If a complete frame
				// is read, the function is responsible for resting 'frameType'.

				// Framing data
				var frameType = FRAME_NO;
				var bufs = [];
				var bufsBytes = 0;

				// Frame-parsing functions
				var frameFuncs = [
						// FRAME_NO
						function(buf, off) {
								if (buf[off] & 0x80) {
										frameType = FRAME_HI;
								} else {
										frameType = FRAME_LO;
								}

								return 1;
						},

						// FRAME_LO
						function(buf, off) {
								debug('frame_lo(' + sys.inspect(buf) + ', ' + off + ')');

								// Find the first instance of 0xff, our terminating byte
								for (var i = off; i < buf.length && buf[i] != 0xff; i++)
										;

								// We didn't find a terminating byte
								if (i >= buf.length) {
										return 0;
								}

								// We found a terminating byte; collect all bytes into a single buffer
								// and emit it
								var mb = null;
								if (bufs.length == 0) {
										mb = buf.slice(off, i);
								} else {
										mb = new buffer.Buffer(bufsBytes + i);

										var mbOff = 0;
										bufs.forEach(function(b) {
												b.copy(mb, mbOff, 0, b.length);
												mbOff += b.length;
										});

										assert.equal(mbOff, bufsBytes);

										// Don't call Buffer.copy() if we're coping 0 bytes. Rather
										// than being a no-op, this will trigger a range violation on
										// the destination.
										if (i > 0) {
												buf.copy(mb, mbOff, off, i);
										}

										// We consumed all of the buffers that we'd been saving; clear
										// things out
										bufs = [];
										bufsBytes = 0;
								}

								process.nextTick(function() {
										var b = mb;
										return function() {
												var m = b.toString('utf8');

												self.emit('data', b);
												self.emit('message', m);        // wss compat

												if (self.onmessage) {
														self.onmessage({data: m});
												}
										};
								}());

								frameType = FRAME_NO;
								return i - off + 1;
						},

						// FRAME_HI
						function(buf, off) {
								debug('frame_hi(' + sys.inspect(buf) + ', ' + off + ')');

								if (buf[off] !== 0) {
										throw new Error('High-byte framing not supported.');
								}

								serverClosed = true;
								return 1;
						}
				];

				// Handle data coming from our socket
				var dataListener = function(buf) {
						if (buf.length <= 0 || serverClosed) {
								return;
						}

						debug('dataListener(' + sys.inspect(buf) + ')');

						var off = 0;
						var consumed = 0;

						do {
								if (frameType < 0 || frameFuncs.length <= frameType) {
										throw new Error('Unexpected frame type: ' + frameType);
								}

								assert.equal(bufs.length === 0, bufsBytes === 0);
								assert.ok(off < buf.length);

								consumed = frameFuncs[frameType](buf, off);
								off += consumed;
						} while (!serverClosed && consumed > 0 && off < buf.length);

						if (serverClosed) {
								serverCloseHandler();
						}
						
						if (consumed == 0) {
								bufs.push(buf.slice(off, buf.length));
								bufsBytes += buf.length - off;
						}
				};

				// Handle incoming file descriptors
				var fdListener = function(fd) {
						self.emit('fd', fd);
				};

				// Handle errors from any source (HTTP client, stream, etc)
				var errorListener = function(e) {
						process.nextTick(function() {
								self.emit('wserror', e);

								if (self.onerror) {
										self.onerror(e);
								}
						});
				};

				// Finish the closing process; destroy the socket and tell the application
				// that we've closed.
				var finishClose = function() {
						readyState = CLOSED;

						if (stream) {
								stream.end();
								stream.destroy();
								stream = undefined;
						}

						process.nextTick(function() {
								self.emit('close');
								if (self.onclose) {
										self.onclose();
								}
						});
				};

				// Send a close frame to the server
				var sendClose = function() {
						assert.equal(OPEN, readyState);

						readyState = CLOSING;
						stream.write('\xff\x00', 'binary');
				};

				// Handle a close packet sent from the server
				var serverCloseHandler = function() {
						assert.ok(serverClosed);
						assert.ok(readyState === OPEN || readyState === CLOSING);

						bufs = [];
						bufsBytes = 0;

						// Handle state transitions asynchronously so that we don't change
						// readyState before the application has had a chance to process data
						// events which are already in the delivery pipeline. For example, a
						// 'data' event could be delivered with a readyState of CLOSING if we
						// received both frames in the same packet.
						process.nextTick(function() {
								if (readyState === OPEN) {
										sendClose();
								}

								finishClose();
						});
				};

				// External API
				self.close = function(timeout) {
						if (readyState === CONNECTING) {
								// If we're still in the process of connecting, the server is not
								// in a position to understand our close frame. Just nuke the
								// connection and call it a day.
								finishClose();
						} else if (readyState === OPEN) {
								sendClose();

								if (timeout) {
										setTimeout(finishClose, timeout * 1000);
								}
						}
				};

				self.send = function(str, fd) {
						if (readyState != OPEN) {
								return;
						}

						stream.write('\x00', 'binary');
						stream.write(str, 'utf8', fd);
						stream.write('\xff', 'binary');
				};

				// wss compat
				self.write = self.send;

				setConstant(self, 'url', url);

				Object.defineProperty(self, 'readyState',  {
						get : function() {
								return readyState;
						}
				});

				// Connect and perform handshaking with the server
				(function() {
						// Parse constructor arguments 
						if (!url) {
								throw new Error('Url and must be specified.');
						}

						// Secrets used for handshaking
						var key1 = createSecretKey();
						var key2 = createSecretKey();
						var challenge = createChallenge();

						debug(
								'key1=\'' + str2hex(key1) + '\'; ' +
								'key2=\'' + str2hex(key2) + '\'; ' +
								'challenge=\'' + str2hex(challenge) + '\''
						);

						var httpHeaders = {
								'Connection' : 'Upgrade',
								'Upgrade' : 'WebSocket',
								'Sec-WebSocket-Key1' : key1,
								'Sec-WebSocket-Key2' : key2
						};
						if (opts.origin) {
								httpHeaders['Origin'] = opts.origin;
						}
						if (proto) {
								httpHeaders['Sec-WebSocket-Protocol'] = proto;
						}

						var httpPath = '/';

						// Create the HTTP client that we'll use for handshaking. We'll cannabalize
						// its socket via the 'upgrade' event and leave it to rot.
						//
						// N.B. The ws+unix:// scheme makes use of the implementation detail
						//      that http.Client passes its constructor arguments through,
						//      un-inspected to net.Stream.connect(). The latter accepts a
						//      string as its first argument to connect to a UNIX socket.
						var httpClient = undefined;
						switch (getUrlScheme(url)) {
						case 'ws':
								var u = urllib.parse(url);
								httpClient = http.createClient(u.port || 80, u.hostname);
								httpPath = (u.pathname || '/') + (u.search || '');
								httpHeaders.Host = u.hostname + (u.port ? (":" + u.port) : "");
								break;

						case 'ws+unix':
								var sockPath = url.substring('ws+unix://'.length, url.length);
								httpClient = http.createClient(sockPath);
								httpHeaders.Host = 'localhost';
								break;

						default:
								throw new Error('Invalid URL scheme \'' + urlScheme + '\' specified.');
						}

						httpClient.on('upgrade', (function() {
								var data = undefined;

								return function(req, s, head) {
										stream = s;

										stream.on('data', function(d) {
												if (d.length <= 0) {
														return;
												}

												if (!data) {
														data = d;
												} else {
														var data2 = new buffer.Buffer(data.length + d.length);

														data.copy(data2, 0, 0, data.length);
														d.copy(data2, data.length, 0, d.length);

														data = data2;
												}

												if (data.length >= 16) {
														var expected = computeSecretKeySignature(key1, key2, challenge);
														var actual = data.slice(0, 16).toString('binary');

														// Handshaking fails; we're donezo
														if (actual != expected) {
																debug(
																		'expected=\'' + str2hex(expected) + '\'; ' +
																		'actual=\'' + str2hex(actual) + '\''
																);

																process.nextTick(function() {
																		// N.B. Emit 'wserror' here, as 'error' is a reserved word in the
																		//      EventEmitter world, and gets thrown.
																		self.emit(
																				'wserror',
																				new Error('Invalid handshake from server:' +
																						'expected \'' + str2hex(expected) + '\', ' +
																						'actual \'' + str2hex(actual) + '\''
																				)
																		);

																		if (self.onerror) {
																				self.onerror();
																		}

																		finishClose();
																});
														}

														// Un-register our data handler and add the one to be used
														// for the normal, non-handshaking case. If we have extra
														// data left over, manually fire off the handler on
														// whatever remains.
														//
														// XXX: This is lame. We should only remove the listeners
														//      that we added.
														httpClient.removeAllListeners('upgrade');
														stream.removeAllListeners('data');
														stream.on('data', dataListener);

														readyState = OPEN;

														process.nextTick(function() {
																self.emit('open');

																if (self.onopen) {
																		self.onopen();
																}
														});

														// Consume any leftover data
														if (data.length > 16) {
																stream.emit('data', data.slice(16, data.length));
														}
												}
										});
										stream.on('fd', fdListener);
										stream.on('error', errorListener);
										stream.on('close', function() {
												errorListener(new Error('Stream closed unexpectedly.'));
										});

										stream.emit('data', head);
								};
						})());
						httpClient.on('error', function(e) {
								httpClient.end();
								errorListener(e);
						});

						var httpReq = httpClient.request(httpPath, httpHeaders);

						httpReq.write(challenge, 'binary');
						httpReq.end();
				})();
		};
		sys.inherits(WebSocket, events.EventEmitter);
		publics.WebSocket = WebSocket;

		// Add some constants to the WebSocket object
		setConstant(WebSocket.prototype, 'CONNECTING', CONNECTING);
		setConstant(WebSocket.prototype, 'OPEN', OPEN);
		setConstant(WebSocket.prototype, 'CLOSING', CLOSING);
		setConstant(WebSocket.prototype, 'CLOSED', CLOSED);

		// vim:ts=4 sw=4 et
	}
}( publics ))
`


matrix = require('./matrix')
expect = require('./expect')


class Perceptron
	constructor: (bias = 0, threshold = 0.5, rate = 0.1) ->
		@bias = bias
		@threshold = threshold
		@rate = rate
		@sqerr = @n = 0
	getError: () -> (@sqerr / @n)
	resetError: () -> @sqerr = @n = 0
	train: (v, desired) ->
		if Array.isArray(v) then v = new Vector().fromArray(v)
		while @w.length < v.length
			@w.push Math.random()
		output = @test(v)
		delta = (desired - output)
		@sqerr += delta * delta
		@n += 1
		delta = v.scale(delta * @rate)
		@w = @w.add( delta )
		@
	trainAll: (examples) ->
		@resetError()
		for e in examples
			@train e[0...e.length-1], e[e.length-1]
		@getError()
	test: (v) ->
		return (@w.dot(v) + @bias) > @threshold

Perceptron.test = () ->
	p = new Perceptron()
	for i in [0...10]
		(p.trainAll [
			[1,0,1]
			[1,1,1]
			[0,1,1]
			[0,0,0]
		])
	q = new Perceptron()
	for i in [0...10]
		(q.trainAll [
			[1,0,0]
			[1,1,1]
			[0,1,0]
			[0,0,0]
		])
	r = new Perceptron()
	examples = []
	for i in [0...100]
		for j in [0...100]
			examples.push [i,j, i > j]
	for i in [0...10]
		console.log(r.trainAll(examples))
	r

if exports?
	exports.Perceptron = Perceptron

class BoundingBox
	constructor: (stream) ->
		xmin = stream.readDouble(false)
		ymin = stream.readDouble(false)
		xmax = stream.readDouble(false)
		ymax = stream.readDouble(false)
		@x = [xmin, xmax]
		@y = [ymin, ymax]

class BoundingBoxZ extends BoundingBox
	constructor: (stream) ->
		super(stream)
		zmin = stream.readDouble(false)
		zmax = stream.readDouble(false)
		mmin = stream.readDouble(false)
		mmax = stream.readDouble(false)
		@z = [zmin, zmax]
		@m = [mmin, mmax]


_readPartsAndPoints: (stream) ->
	numParts = stream.readInt()
	numPoints = stream.readInt()
	parts = (stream.readInt() for _ in [0...numParts])
	points = (new Point(stream) for _ in [0...numPoints])
	ret = []
	for i in [0...numParts]
		start = parts[i]
		end = parts[i+1] || points.length
		ret.push( points[j] for j in [start...end] )
	return ret
_readMs: (stream) ->
	@mrange = [stream.readDouble(), stream.readDouble()]
	@m = ( stream.readDouble() for _ in [0...@points.length] )
_readZs: (stream) ->
	@zrange = [stream.readDouble(), stream.readDouble()]
	@z = ( stream.readDouble() for _ in [0...@points.length] )

class Shape
	@Id = 0
	@Read: (stream) ->
		return switch stream.readInt()
			when Null.Id then new Shape(stream)
			when Point.Id then new Point(stream)
			when PolyLine.Id then new PolyLine(stream)
			when Polygon.Id then new Polygon(stream)
			when MultiPoint.Id then new MultiPoint(stream)
			when PointZ.Id then new PointZ(stream)
			when PolyLineZ.Id then new PolyLineZ(stream)
			when PolygonZ.Id then new PolygonZ(stream)
			when MultiPointZ.Id then new MultiPointZ(stream)
			when PointM.Id then new PointM(stream)
			when PolyLineM.Id then new PolyLineM(stream)
			when PolygonM.Id then new PolygonM(stream)
			when MultiPointM.Id then new MultiPointM(stream)
			when MultiPatch.Id then new MultiPatch(stream)

class Point extends Shape
	@Id = 1
	constructor: (stream) ->
		@x = stream.readDouble()
		@y = stream.readDouble()
class PointM extends Point
	@Id = 21
	constructor: (stream) ->
		super(stream)
		@m = stream.readDouble()
class PointZ extends Point
	@Id = 11
	constructor: (stream) ->
		super(stream)
		@z = stream.readDouble()
		@m = stream.readDouble()

class PolyLine extends Shape
	@Id = 3
	constructor: (stream) ->
		@bounds = new BoundingBox(stream)
		@parts = _readPartsAndPoints.call @, stream
class PolyLineM extends PolyLine
	@Id = 23
	constructor: (stream) ->
		super(stream)
		_readMs.call @, stream
class PolyLineZ extends PolyLine
	@Id = 13
	constructor: (stream) ->
		super(stream)
		_readZs.call @, stream
		_readMs.call @, stream

class Polygon extends Shape
	@Id = 5
	constructor: (stream) ->
		@bounds = new BoundingBox(stream)
		@parts = _readPartsAndPoints.call @,stream
class PolygonM extends Polygon
	@Id = 25
	constructor: (stream) ->
		super(stream)
		_readMs.call @, stream
class PolygonZ extends Polygon
	@Id = 15
	constructor:(stream) ->
		super(stream)
		_readZs.call @, stream
		_readMs.call @, stream

class MultiPoint extends Shape
	@Id = 8
	constructor: (stream) ->
		@bounds = new BoundingBox(stream)
		numPoints = stream.readInt()
		@points = (new Point(stream) for _ in [0...numPoints])
class MultiPointM extends MultiPoint
	@Id = 28
	constructor: (stream) ->
		super(stream)
		_readMs.call @, stream
class MultiPointZ extends MultiPoint
	@Id = 18
	constructor: (stream) ->
		super(stream)
		_readZs.call @,stream
		_readMs.call @,stream

class MultiPatch extends MultiPoint
	@Id = 31
	constructor: (stream) ->
		throw new Error("MultiPatch not yet implemented.")

class ShapeFile
	constructor: (baseName) ->
		baseName = ("" + baseName).replace /\.shp$/,""
		@mainFile = baseName + ".shp"
		@indexFile = baseName + ".shx"
		@dbaseFile = baseName + ".dbf"
		@shapes = []
		fs = require('fs')
		data = fs.readFileSync(@mainFile)
		Stream = require('../stream').Stream
		stream = new Stream(data)
		stream.skip(20)
		fileLength = stream.readInt()
		version = stream.readInt(false)
		shapeType = stream.readInt(false)
		bounds = new BoundingBoxZ(stream)
		while stream.avail() > 1
			recordNumber = stream.readInt()
			contentLength = stream.readInt()
			@shapes.push(Shape.Read(stream))
	


publics = {
	ShapeFile: ShapeFile
}
if exports?
	exports = publics
else if window?
	window.shape = publics
require("./matrix")

graph = new matrix.Graph()
num_points = 100
num_edges = 300
for i in [0...num_points]
	id = graph.addNode {
		general: new matrix.Perceptron()
		troops: Math.random() * 100
		mode: "defend"
	}
	generals[id] = graph.getNode(id).general
for i in [0...num_edges]
	a = Math.floor(Math.random() * num_points)
	b = Math.floor(Math.random() * num_points)
	graph.setEdge(a,b,Math.random())

while True
	for i in [0...num_points]
		node = graph.getNode(id)
		enemies = graph.getNeighbors(id).map((x) -> graph.getNode(x).troops)
		node.mode = "defend"
		if node.general.test(enemies)
			node.mode = "attack"
		node = graph.getNode(id)
		if node.mode is "attack"
			neighbors = graph.getNeighbors(id).map((x) -> graph.getNode(x))
			min = null
			for n in neighbors
				if min is null or n.troops < min.troops
					min = n
			edge = graph.getEdge(node.id, min.id)
			defenders = min.troops * Math.max(1.0,0.5 + edge)
			attackers = n.troops * edge
			defenders_lost = Math.max(0, defenders - attackers)
			attackers_lost = n.troops - attackers
			if attackers_lost > defenders_lost
				should_attack = 0
			else
				should_attack = 1
			n.general.train( graph.getNeighbors(n.id).map((x) -> graph.getNode(x).troops), should_attack)
			min.general.train( graph.getNeighbors(min.id).map((x) -> graph.getNode(x).troops), min.mode is "defend" and should_attack)
			min.lost = defenders_lost
			if min.troops is 0
				min.general = n.general
				min.troops = n.troops/2
				n.troops /= 2
			else



class DataSet extends Array
	constructor: () ->
		@sum = 0
		@count = {}
	extend: (a) -> (@push(i) for i in a); @
	push: (x) ->
		@sum += x
		i = 0
			i++
		@sorted.splice(i,x,0)
		@count[x] ?= 0
		@count[x] += 1
		Array::push.apply @, x
	freq: (x) ->
		@count[x] / @length
	stdev: () ->
		m = @mean
		sum = 0
		for i in [0...@length]
			sum += Math.pow(@[i]-m, 2)
		avg = sum / @length
		return Math.sqrt(avg)

DataSet::__defineGetter__ 'mean', () -> @sum / @length

require 'shim'

trace = (name, f) ->
	return (a...) ->
		console.log name
		return f.apply @, a

class StringBuffer
	constructor: (s = '') -> @s = s
	write: (a...) -> @s += a.join ""
	read: (n = 1) ->
		ret = @peek(n)
		@skip(n)
		return ret
	skip: (n = 1) -> @s = @s.substring n
	peek: (n = 1) -> @s.substring 0,n
	avail: () -> @s.length
	toString: () -> @s

class Stream
	@BYTE = 0
	@SHORT = 1
	@INT = 2
	@DOUBLE = 3
	@STRING = 4
	@ARRAY = 5
	@OBJECT = 6

	constructor: (stream = new StringBuffer()) ->
		@buf = stream
		@parser = {}
		@parser[true] = new BinaryParser(true, true)
		@parser[false] = new BinaryParser(false, true)
	writeByte: (b, bigEndian=false) -> @buf.write(@parser[bigEndian].fromByte(b))
	readByte: (bigEndian = false) -> @parser[bigEndian].toByte(@buf.read(1))
	writeShort: (b, bigEndian=false) -> @buf.write @parser[bigEndian].fromShort(b)
	readShort: (bigEndian = false) -> @parser[bigEndian].toShort(@buf.read(1))
	writeInt: (i, bigEndian=false) -> @buf.write @parser[bigEndian].fromInt(i)
	readInt: (bigEndian = false) -> @parser[bigEndian].toInt(@buf.read(4))
	writeDouble: (f, bigEndian=false) -> @buf.write @parser[bigEndian].fromDouble(f)
	readDouble: (bigEndian = false) -> @parser[bigEndian].toDouble(@buf.read(8))
	writeString: (s, bigEndian=false) -> ( @write(s.length, bigEndian); @buf.write s )
	readString: (bigEndian = false) -> @buf.read(@read(null, bigEndian))
	writeArray: (a, bigEndian=false) ->
		@writeInt(a.length, bigEndian)
		for o in a
			@write(o, bigEndian)
		@
	readArray: (bigEndian = false) ->
		len = @readInt(bigEndian)
		a = new Array(len)
		for i in [0...len]
			a[i] = @read(null, bigEndian)
		a
	writeObject: (o, bigEndian=false) ->
		keys = Object.Keys(o)
		@writeInt(keys.length, bigEndian)
		for k in keys
			@writeString k,bigEndian
			@write o[k],bigEndian
		@
	readObject: (bigEndian = false) ->
		keyCount = @readInt(bigEndian)
		o = {}
		for i in [0...keyCount]
			k = @readString(bigEndian)
			o[k] = @read(null, bigEndian)
		o
	write: (o, bigEndian=false) ->
		switch Object.Type o
			when "string"
				@writeByte(Stream.STRING, bigEndian)
				@writeString(o, bigEndian)
			when "number"
				if o == parseInt(o,10)
					if 0 <= o <= 255
						@writeByte(Stream.BYTE, bigEndian)
						@writeByte(o, bigEndian)
					else if 256 <= o <= 65534
						@writeByte(Stream.SHORT, bigEndian)
						@writeShort(o, bigEndian)
					else
						@writeByte(Stream.INT, bigEndian)
						@writeInt(o, bigEndian)
				else
					@writeByte(Stream.DOUBLE, bigEndian)
					@writeDouble(o, bigEndian)
			when "array"
				@writeByte(Stream.ARRAY, bigEndian)
				@writeArray(o, bigEndian)
			when "object"
				@writeByte(Stream.OBJECT, bigEndian)
				@writeObject(o, bigEndian)
		@
	read: (type = null, bigEndian=false) ->
		if not type?
			type = @readByte(bigEndian)
		ret = switch type
			when Stream.BYTE then @readByte(bigEndian)
			when Stream.SHORT then @readShort(bigEndian)
			when Stream.INT then @readInt(bigEndian)
			when Stream.DOUBLE then @readDouble(bigEndian)
			when Stream.STRING then @readString(bigEndian)
			when Stream.ARRAY then @readArray(bigEndian)
			when Stream.OBJECT then @readObject(bigEndian)
		ret
	avail: () -> @buf.avail()
	peek: (n = 1) -> @buf.peek(n)
	skip: (n = 1) -> @buf.skip(n)

class Connection extends EventEmitter
	constructor: (conn, server = null) ->
		@server = server
		@conn = conn
		@conn.onmessage = (msg) =>
			stream = new Stream(new StringBuffer(msg))
			while stream.avail() > 0
				o = stream.read()
		stream = new Stream()
		stream.write(obj)
		if @server?
			@server.send(@conn.id, stream.toString())
		else
			@conn.send(stream.toString())

publics =
	Stream: Stream,
	Connection: Connection
if exports?
	exports = publics
else if global?
	global.stream = publics
else if window?
	window.stream = publics

assertions = { pass: 0, fail: 0 }
assertEqual = (a,b) ->
	if a != b
		assertions.fail += 1
	assertions.pass += 1

(Stream.test = () ->
	stream = new Stream()
	testByte = (i) ->
		stream.writeByte i
		assertEqual(stream.readByte(), i)
	testInt = (i) ->
		stream.writeInt i
		assertEqual(stream.readInt(), i)
	testDouble = (f) ->
		stream.writeDouble f
		assertEqual(stream.readDouble(), f)
	testString = (s) ->
		stream.writeString s
		assertEqual(stream.readString(), s)
	testInt(42567)
	testByte(237)
	testDouble(42567.897654)
	testString("hello world")
	stream.writeInt(42)
	stream.writeDouble(37.5)
	stream.writeString("john")
	stream.writeInt(48)
	stream.writeString("paul")

	assertEqual(stream.readInt(), 42)
	assertEqual(stream.readDouble(), 37.5)
	assertEqual(stream.readString(), "john")
	assertEqual(stream.readInt(), 48)
	assertEqual(stream.readString(), "paul")

	attrCompare = (a,b,i) ->
		assertEqual Object.Type(a[i]), Object.Type(b[i])
		switch Object.Type(a[i])
			when "object" then objCompare a[i], b[i]
			when "array" then arrayCompare a[i], b[i]
			else assertEqual a[i], b[i]
	objCompare = (a,b) ->
		a_keys = Object.Keys(a)
		b_keys = Object.Keys(b)
		assertEqual a_keys.length, b_keys.length
		for i in a_keys
			attrCompare a,b,i
	arrayCompare = (a, b) ->
		assertEqual a.length, b.length
		for i in [0...a.length]
			attrCompare a,b,i

	testArray = (a) ->
		stream.writeArray a
		b = stream.readArray()
		arrayCompare(a, b)

	testObject = (o) ->
		stream.writeObject o
		objCompare(stream.readObject(), o)
	
	testAny = (a) ->
		stream.write a
		b = stream.read()
		assertEqual Object.Type(a), Object.Type(b)
		switch Object.Type a
			when "object" then objCompare(a, b)
			when "array" then arrayCompare(a, b)
			else assertEqual(a, b)
	
	testArray([3, 24, 42])
	testObject({foo: 'bar', baz: 42 })
	testAny('abc')
	testAny(123)
	testAny(3.14)
	testAny([1,2,3])
	testAny({a:'b'})
	testAny([{a:'b','b':['c','d']},42,3.14])
)()


echoServer = () ->
	ws = require('websocket-server')
	stream = require('../stream')
	srv = ws.createServer()

	srv.addListener "connection", (conn) ->
		c = new stream.Connection(conn, srv)
		c.addListener "message", (msg) ->
			c.send(msg)

	srv.listen(8181)

echoServer()

Expect.equal(new Vector(1,2,3).toString(), "[1,2,3]")
Expect.equal(new Vector(4,5,6).toString(), "[4,5,6]")
Expect.equal(new Vector(1,2,3).dot(new Vector(4,5,6)), 32)
m = new Matrix(2,3).fromArray([
 1, 2, 3,
 4, 5, 6
])
Expect.equal(m.constructor.name, "Matrix")
Expect.equal(m.toString(), "[1,2,3]\n[4,5,6]")
Expect.equal(m.row(0).toString(), "[1,2,3]")
Expect.equal(m.row(1).toString(), "[4,5,6]")
Expect.equal(m.col(0).toString(), "[1,4]")
Expect.equal(m.col(1).toString(), "[2,5]")
Expect.equal(m.col(2).toString(), "[3,6]")
i = new Matrix(2,2).fromArray([
 1, 0,
 0, 1
])
j = i.scale(2)
Expect.equal(j.toString(), "[2,0]\n[0,2]")
n = new Matrix(2,2).fromArray([
 1, 2,
 3, 4
])
o = n.times(i)
Expect.equal(n.toString(), "[1,2]\n[3,4]")
p = n.times(j)
Expect.equal(p.toString(), "[2,4]\n[6,8]")

Graph.test = () ->
	g = new Graph()
	num_points = 100
	num_edges = 300
	for i in [0...num_points]
		id = g.addNode({x: Math.random() * 100, y: Math.random() * 100})
	for i in [0...num_edges]
		a = Math.floor(Math.random() * num_points)
		b = Math.floor(Math.random() * num_points)
		g.setEdge(a,b,Math.random())

console.log JSON.stringify(Expect.report)
dom = require('../dom')

assign_and_output = () ->
	document = dom.createDocument()
	document.body.innerHTML = "<div class='content' id='content'>Hello World.</div>"
	return document.toString()

output = () ->
	node = (name, attrs = {}, children) ->
		attrs = (' '+k+'="'+attrs[k]+'"' for k of attrs).join('')
		if children.join
			children = children.join('')
	html = (children = []) -> node('html', {}, children)
	head = (attrs = {}, children = []) -> node('head', attrs, children)
	body = (attrs = {}, children = []) -> node('body', attrs, children)
	div = (attrs = {}, children = []) -> node('div', attrs, children)
	p = (attrs = {}, children = []) -> node('p', attrs, children)
	span = (attrs = {}, children = []) -> node('span', attrs, children)

	html([head(), body(null, div({id:'content','class':'content'}, "Hello World."))])

measure = (f, n) ->
	start = Date.now()
	for i in [0..n]
		f()
	return (Date.now() - start)

run = (f, n, interval) ->
	sum = 0
	sum_n = 0
	for i in [0...n] by interval
		ms = measure(f, interval)
		rps = interval * 1000 / ms
		sum += rps
		sum_n += 1
	console.log "Avg. requests per sec:", (sum/sum_n)

console.log "Using domjs"
console.log assign_and_output()
run assign_and_output, 1000,200

console.log "Using a raw tree"
console.log output()
run output, 100000, 20000

tag = (name, attrs = {}, children) ->
	attrs = (' '+k+'="'+attrs[k]+'"' for k of attrs).join('')
	if children.join
		children = children.join('')
a = (attrs = {}, children = []) -> tag('a', attrs, children)
area = (attrs = {}, children = []) -> tag('area', attrs, children)
audio = (attrs = {}, children = []) -> tag('audio', attrs, children)
base = (attrs = {}, children = []) -> tag('base', attrs, children)
blockquote = (attrs = {}, children = []) -> tag('blockquote', attrs, children)
body = (attrs = {}, children = []) -> tag('body', attrs, children)
br = (attrs = {}, children = []) -> tag('br', attrs, children)
button = (attrs = {}, children = []) -> tag('button', attrs, children)
canvas = (attrs = {}, children = []) -> tag('canvas', attrs, children)
caption = (attrs = {}, children = []) -> tag('caption', attrs, children)
col = (attrs = {}, children = []) -> tag('col', attrs, children)
colgroup = (attrs = {}, children = []) -> tag('colgroup', attrs, children)
del = (attrs = {}, children = []) -> tag('del', attrs, children)
details = (attrs = {}, children = []) -> tag('details', attrs, children)
div = (attrs = {}, children = []) -> tag('div', attrs, children)
dl = (attrs = {}, children = []) -> tag('dl', attrs, children)
embed = (attrs = {}, children = []) -> tag('embed', attrs, children)
fieldSet = (attrs = {}, children = []) -> tag('fieldSet', attrs, children)
form = (attrs = {}, children = []) -> tag('form', attrs, children)
h1 = (attrs = {}, children = []) -> tag('h1', attrs, children)
h2 = (attrs = {}, children = []) -> tag('h2', attrs, children)
h3 = (attrs = {}, children = []) -> tag('h3', attrs, children)
h4 = (attrs = {}, children = []) -> tag('h4', attrs, children)
h5 = (attrs = {}, children = []) -> tag('h5', attrs, children)
h6 = (attrs = {}, children = []) -> tag('h6', attrs, children)
head = (attrs = {}, children = []) -> tag('head', attrs, children)
hr = (attrs = {}, children = []) -> tag('hr', attrs, children)
html = (attrs = {}, children = []) -> tag('html', attrs, children)
iframe = (attrs = {}, children = []) -> tag('iframe', attrs, children)
image = (attrs = {}, children = []) -> tag('image', attrs, children)
input = (attrs = {}, children = []) -> tag('input', attrs, children)
ins = (attrs = {}, children = []) -> tag('ins', attrs, children)
keygen = (attrs = {}, children = []) -> tag('keygen', attrs, children)
label = (attrs = {}, children = []) -> tag('label', attrs, children)
legend = (attrs = {}, children = []) -> tag('legend', attrs, children)
li = (attrs = {}, children = []) -> tag('li', attrs, children)
link = (attrs = {}, children = []) -> tag('link', attrs, children)
map = (attrs = {}, children = []) -> tag('map', attrs, children)
menu = (attrs = {}, children = []) -> tag('menu', attrs, children)
meta = (attrs = {}, children = []) -> tag('meta', attrs, children)
meter = (attrs = {}, children = []) -> tag('meter', attrs, children)
object = (attrs = {}, children = []) -> tag('object', attrs, children)
ol = (attrs = {}, children = []) -> tag('ol', attrs, children)
optgroup = (attrs = {}, children = []) -> tag('optgroup', attrs, children)
option = (attrs = {}, children = []) -> tag('option', attrs, children)
output = (attrs = {}, children = []) -> tag('output', attrs, children)
p = (attrs = {}, children = []) -> tag('p', attrs, children)
param = (attrs = {}, children = []) -> tag('param', attrs, children)
pre = (attrs = {}, children = []) -> tag('pre', attrs, children)
progress = (attrs = {}, children = []) -> tag('progress', attrs, children)
quote = (attrs = {}, children = []) -> tag('quote', attrs, children)
script = (attrs = {}, children = []) -> tag('script', attrs, children)
select = (attrs = {}, children = []) -> tag('select', attrs, children)
source = (attrs = {}, children = []) -> tag('source', attrs, children)
style = (attrs = {}, children = []) -> tag('style', attrs, children)
table = (attrs = {}, children = []) -> tag('table', attrs, children)
thead = (attrs = {}, children = []) -> tag('thead', attrs, children)
tbody = (attrs = {}, children = []) -> tag('tbody', attrs, children)
tfoot = (attrs = {}, children = []) -> tag('tfoot', attrs, children)
td = (attrs = {}, children = []) -> tag('td', attrs, children)
th = (attrs = {}, children = []) -> tag('th', attrs, children)
tr = (attrs = {}, children = []) -> tag('tr', attrs, children)
textarea = (attrs = {}, children = []) -> tag('textarea', attrs, children)
title = (attrs = {}, children = []) -> tag('title', attrs, children)
ul = (attrs = {}, children = []) -> tag('ul', attrs, children)
video = (attrs = {}, children = []) -> tag('video', attrs, children)
Copyright (c) 2011 Jesse Dailey <jesse.dailey@gmail.com>
License: MIT License - http://www.opensource.org/licenses/mit-license.php
parser = require("./html/parser")
htmlparse = parser.parse
htmlescape = parser.escape
htmlunescape = parser.unescape
matcher = require("./css/nwmatcher")

NotSupported = ->
	throw Error "NOT_SUPPORTED"

repeat = (s, n) ->
	n = Math.max(0, n)
	switch n
		when 0 then ""
		when 1 then s
		else s + repeat(s, n-1)

extend = (o, p) ->
	o or= {}
	for k of p
		o[k] = p[k]
	return o

property = (o, k, props) ->
	Object.defineProperty o, k, extend({
		enumerable: true
		configurable: true
	}, props)

class Event
	@CAPTURING_PHASE = 1
	@AT_TARGET = 2
	@BUBBLING_PHASE = 3
	constructor: ->
		@type = null
		@target = null
		@currentTarget = null
		@eventPhase = 0
		@bubbles = false
		@cancelable = true
		@timeStamp = 0
	stopPropagation: ->
	preventDefault: ->
	initEvent: (type, canBubble, cancelable) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@timeStamp = new Date().getTime()

class MutationEvent extends Event
	@MODIFICATION = 1
	@ADDITION = 2
	@REMOVAL = 3
	constructor: ->
		@relatedNode = null
		@prevValue = null
		@newValue = null
		@attrName = null
		@attrChange = 0
	initMutationEvent: (type, canBubble, cancelable, relatedNode, prevValue, newValue, attrName, attrChange) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@relatedNode = relatedNode
		@prevValue = prevValue
		@newValue = newValue
		@attrName = attrName
		@attrChange = attrChange

class Node
	@ELEMENT_NODE = 1
	@ATTRIBUTE_NODE = 2
	@TEXT_NODE = 3
	@CDATA_SECTION_NODE = 4
	@ENTITY_REFERENCE_NODE = 5
	@ENTITY_NODE = 6
	@PROCESSING_INSTRUCTION_NODE = 7
	@COMMENT_NODE = 8
	@DOCUMENT_NODE = 9
	@DOCUMENT_TYPE_NODE = 10
	@DOCUMENT_FRAGMENT_NODE = 11
	@NOTATION_NODE = 12

	@DOCUMENT_POSITION_DISCONNECTED = 1
	@DOCUMENT_POSITION_PRECEDING = 2
	@DOCUMENT_POSITION_FOLLOWING = 4
	@DOCUMENT_POSITION_CONTAINS = 8
	@DOCUMENT_POSITION_CONTAINED_BY = 16
	@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32

	constructor: (name, value = null, type = 1, ownerDocument = null) ->
		@_private =
			nodeName: null
			parentNode: null
			childIndex: -1
			classes: []
		@nodeName = name
		@nodeValue = value
		@nodeType = type
		@ownerDocument = ownerDocument
		@childNodes = []
		@attributes = { }
		@listeners =
			true: {}
			false: {}

	addEventListener: (type, listener, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		if not listener in list
			list.push listener
	removeEventListener: (type, listener = null, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		i = list.indexOf listener
		list.splice(i,1)
	dispatchEvent: (evt) ->
		prevented = false
		stopped = false
		evt.preventDefault = ->
			if evt.cancelable
				prevented = true
		evt.stopPropagation = ->
			stopped = true
		evt.target = @
		evt.eventPhase = Event.CAPTURING_PHASE
		chain = [@]
		while chain[0].parentNode isnt @ownerDocument
			chain.unshift chain[0].parentNode
		chain.unshift @ownerDocument
		for ancestor in chain
			evt.currentTarget = ancestor
			list = ancestor.listeners[true][evt.type]
			handler(evt) for handler in list if list
			break if stopped

		evt.eventPhase = Event.AT_TARGET
		evt.currentTarget = evt.target
		list = @listeners[true][evt.type]
		handler(evt) for handler in list if list
		list = @listeners[false][evt.type]
		handler(evt) for handler in list if list

		if evt.bubbles
			for ancestor in chain.reverse()
				evt.currentTarget = ancestor
				list = ancestor.listeners[false][evt.type]
				handler(evt) for handler in list if list


	cloneNode: (deep = false) ->
		ret = switch @.constructor
			when Text,Comment,CData then new @constructor @nodeValue, @ownerDocument
			when Attr then new @constructor @nodeName, @nodeValue
			else new @constructor(@nodeName, @nodeValue, @nodeType, @ownerDocument)
		for a of @_private
			ret._private[a] = @_private[a]
		for a of @attributes
			ret.attributes[a] = @attributes[a]
		if deep
			for c in @childNodes
				ret.childNodes.push c.cloneNode(true)
		ret
	hasAttributes: ->
		for a of @attributes
			return true
		return false
	isSameNode: (node) ->
		node is @
	hasChildNodes: ->
		@childNodes.length > 0
	insertBefore: (newNode, refNode) ->
		if not refNode?
			return @appendChild(newNode)
		if refNode.parentNode isnt @
			throw Error "Cannot insertBefore a non-child."
		if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in newNode.childNodes
				@insertBefore(c, refNode)
		else
			i = refNode._private.childIndex
			if i > -1
				@childNodes.splice(i, 0, newNode)
				newNode._private.childIndex = i
				newNode._private.parentNode = @
				refNode._private.childIndex = i + 1
				i = 0
				for c in @childNodes
					c._private.childIndex = i++
		newNode
	appendChild: (node) ->
		if not node?
			return
		if node.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in node.childNodes
				@appendChild(c)
		else
			node._private.parentNode = @
			node._private.childIndex = @childNodes.length
			@childNodes.push node
	removeChild: (node) ->
		if( typeof node is "number" )
			node = @childNodes[node]
		i = node._private.childIndex
		if i > -1 and node.parentNode is @
			node._private.parentNode = null
			node._private.childIndex = -1
			@childNodes.splice(i, 1)
			i = 0
				c._private.childIndex = i++
		else
			throw Error "Cannot removeChild a non-child."
		node
	replaceChild: (newNode, oldNode) ->
		if oldNode.parentNode isnt @
			throw Error "Cannot replaceChild a non-child."
		i = oldNode._private.childIndex
		if i < 0
			throw Error "DOM tree corruption, childIndex is < 0"
		if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in @childNodes
				@insertBefore(c, oldNode)
			return @removeChild(oldNode)
		newNode._private.parentNode = @
		newNode._private.childIndex = i
		oldNode._private.parentNode = null
		oldNode._private.childIndex = -1
		@childNodes.splice(i, 1, newNode)
		oldNode
	toString: (pretty=false,deep=true,indentLevel=0) ->
		if pretty
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		switch @nodeType
			when Node.TEXT_NODE
			when Node.ELEMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.ATTRIBUTE_NODE
				if @nodeValue isnt ""
			when Node.CDATA_SECTION_NODE
			when Node.COMMENT_NODE
				body = ""
					body = '>'+newline+(c.toString(pretty, deep, indentLevel+1) for c in @childNodes).join('')
					body += indent+"<![endif]"
			when Node.DOCUMENT_TYPE_NODE
			when Node.DOCUMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.DOCUMENT_FRAGMENT_NODE

property Node::, 'nodeName',
	get: -> @_private.nodeName
	set: (v) -> @_private.nodeName = v?.toUpperCase()
property Node::, 'previousSibling',
	get: -> @parentNode?.childNodes[@_private.childIndex-1]
property Node::, 'nextSibling',
	get: -> @parentNode?.childNodes[@_private.childIndex+1]
property Node::, 'parentNode',
	get: -> @_private.parentNode
	set: (v) ->
		if v isnt null
			throw Error "Must use one of appendChild, insertBefore, etc. to give a Node a new parent."
		@_private.parentNode?.removeChild @
		@_private.parentNode = null
		@_private.childIndex = -1
property Node::, 'firstChild',
	get: -> @childNodes[0]
property Node::, 'lastChild',
	get: -> @childNodes[@childNodes.length-1]

class Entity extends Node
	constructor: (a...) ->
		a[2] ?= Node.ENTITY_NODE
		super a...

class Element extends Node
	constructor: (a...) ->
		a[2] ?= Node.ELEMENT_NODE
		super a...
		@style = {}
	getElementsByClassName: (name) ->
		ret = []
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if name is "*" or name in c._private.classes
					ret.push c
				for i in c.getElementsByClassName(name)
					ret.push i
		return ret
	getElementsByTagName: (name) ->
		ret = []
		uname = name.toUpperCase()
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if uname in ["*", c.tagName]
					ret.push c
				for i in c.getElementsByTagName(uname)
					ret.push i
		return ret
	getAttribute: (name) ->
		@attributes[name] or ""
	getAttributeNode: (name) ->
		n = new Attr(name, @getAttribute(name))
		n.ownerElement = @
		n.ownerDocument = @.ownerDocument
		n
	hasAttribute: (name) ->
		name of @attributes
	setAttribute: (name, value) ->
		if not value?
			@removeAttribute(name)
			when "class"
				@className = value
			when "id"
				@id = value
			else
				@attributes[name] = value
	removeAttribute: (name) ->
		delete @attributes[name]
		switch name
			when "class"
				@_private.classes = []
			when "id"
				delete @ownerDocument?._private.idMap[@id]
	matchesSelector: (selector) ->
		@ownerDocument?._private.matcher.match(@, selector)
	querySelector: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)[0]
	querySelectorAll: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)
	scrollByLines: NotSupported
	scrollByPages: NotSupported
	scrollIntoView: NotSupported
	scrollIntoViewIfNeeded: NotSupported
	getBoundingClientRect: NotSupported
	getClientRects: NotSupported
	focus: NotSupported
	blur: NotSupported
	toString: (pretty=false, deep=true, indentLevel = 0) ->
		name = @nodeName?.toLowerCase()
		if pretty and deep
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		len = @childNodes.length
		end = switch len
			when 0 then "/"
			else ""
		r = 1
		if deep
			for c in @childNodes
				ret[r++] = c.toString pretty, deep, indentLevel + 1
		else if len > 0
		if len > 0
		ret.join('')

	_: class HTMLElement extends Element
		constructor: (a...) ->
			super a...
	a: class HTMLAnchorElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "A"
			super a...
	area: class HTMLAreaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "AREA"
			super a...
	audio: class HTMLAudioElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "AUDIO"
			super a...
	base: class HTMLBaseElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BASE"
			super a...
	blockquote: class HTMLBlockquoteElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BLOCKQUOTE"
			super a...
	body: class HTMLBodyElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BODY"
			super a...
	br: class HTMLBRElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BR"
			super a...
	button: class HTMLButtonElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BUTTON"
			super a...
	canvas: class HTMLCanvasElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "CANVAS"
			super a...
	caption: class HTMLTableCaptionElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "CAPTION"
			super a...
	col: class HTMLTableColElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "COL"
			super a...
	colgroup: class HTMLTableColElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "COLGROUP"
			super a...
	del: class HTMLDelElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DEL"
			super a...
	details: class HTMLDetailsElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DETAILS"
			super a...
	div: class HTMLDivElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DIV"
			super a...
	dl: class HTMLDListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DL"
			super a...
	embed: class HTMLEmbedElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "EMBED"
			super a...
	fieldSet: class HTMLFieldSetElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "FIELDSET"
			super a...
	form: class HTMLFormElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "FORM"
			super a...
	h1: class HTMLHeadingElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h2: class HTMLHeading2Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h3: class HTMLHeading3Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h4: class HTMLHeading4Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h5: class HTMLHeading5Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h6: class HTMLHeading6Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H6"
			super a...
	head: class HTMLHeadElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HEAD"
			super a...
	hr: class HTMLHRElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HR"
			super a...
	html: class HTMLHtmlElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HTML"
			super a...
	iframe: class HTMLIFrameElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "IFRAME"
			super a...
	image: class HTMLImageElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "IMAGE"
			super a...
	input: class HTMLInputElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "INPUT"
			super a...
	ins: class HTMLInsElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "INS"
			super a...
	keygen: class HTMLKeygenElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "KEYGEN"
			super a...
	label: class HTMLLabelElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LABEL"
			super a...
	legend: class HTMLLegendElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LEGEND"
			super a...
	li: class HTMLLIElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LI"
			super a...
	link: class HTMLLinkElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LINK"
			super a...
	map: class HTMLMapElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "MAP"
			super a...
	menu: class HTMLMenuElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "MENU"
			super a...
	meta: class HTMLMetaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "META"
			super a...
	meter: class HTMLMeterElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "METER"
			super a...
	object: class HTMLObjectElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OBJECT"
			super a...
	ol: class HTMLOListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OL"
			super a...
	optgroup: class HTMLOptGroupElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OPTGROUP"
			super a...
	option: class HTMLOptionElement extends HTMLInputElement
		constructor: (a...) ->
			a[0] = "OPTION"
			super a...
	output: class HTMLOutputElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OUTPUT"
			super a...
	p: class HTMLParagraphElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "P"
			super a...
	param: class HTMLParamElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PARAM"
			super a...
	pre: class HTMLPreElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PRE"
			super a...
	progress: class HTMLProgressElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PROGRESS"
			super a...
	quote: class HTMLQuoteElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "QUOTE"
			super a...
	script: class HTMLScriptElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "SCRIPT"
			super a...
	select: class HTMLSelectElement extends HTMLInputElement
		constructor: (a...) ->
			a[0] = "SELECT"
			super a...
	source: class HTMLSourceElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "SOURCE"
			super a...
	style: class HTMLStyleElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "STYLE"
			super a...
	table: class HTMLTableElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TABLE"
			super a...
	thead: class HTMLTableHeadElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "THEAD"
			super a...
	tbody: class HTMLTableBodyElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TBODY"
			super a...
	tfoot: class HTMLTableFootElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TFOOT"
			super a...
	td: class HTMLTableCellElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TD"
			super a...
	th: class HTMLTableHeadElement extends HTMLTableCellElement
		constructor: (a...) ->
			a[0] = "TH"
			super a...
	tr: class HTMLTableRowElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TR"
			super a...
	textarea: class HTMLTextAreaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TEXTAREA"
			super a...
	title: class HTMLTitleElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TITLE"
			super a...
	ul: class HTMLUListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "UL"
			super a...
	video: class HTMLVideoElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "VIDEO"
			super a...
}

property Element::, 'tagName',
	get: -> @nodeName
property Element::, 'innerHTML',
	get: ->
		h = []
		for c in @childNodes
			h.push c.toString()
		return h.join('')
	set: (v) ->
		fragment = htmlparse(v, @ownerDocument)
		for c in @childNodes
			c._private.parentNode = null
			c._private.childIndex = -1
		@childNodes.length = 0
		@appendChild fragment

getInnerText = ->
	t = []
	for c in @childNodes
		if c.nodeType in [Node.TEXT_NODE, Node.CDATA_SECTION_NODE]
			t.push c.toString(false, false)
		else if c.nodeType isnt Node.COMMENT_NODE
			t.push getInnerText.apply c
	return t.join ''
setInnerText = (text) ->
	while @hasChildNodes()
		@removeChild(0)
	@appendChild(new Text(text, @))

property Element::, 'innerText',
	get: getInnerText
	set: setInnerText
property Element::, 'textContent',
	get: getInnerText
	set: setInnerText
property Element::, 'id',
	get: -> @attributes['id']
	set: (value) ->
		o = @ownerDocument?
		if o
			if @attributes.id?
				delete @ownerDocument._private.idMap[@attributes.id]
		if value in [null, undefined, "undefined"]
			delete @attributes.id
		else
			if o
				@ownerDocument._private.idMap[value] = @
			@attributes.id = value
property Element::, 'className',
	get: -> @attributes['class'] or ""
	set: (value) ->
		if value in [null, undefined, "undefined"]
			delete @attributes.class
			@_private.classes.length = 0
		else
			@attributes['class'] = value
			@_private.classes = value.split(' ')

property HTMLInputElement::, 'value',
	get: -> @attributes.value or (if @attributes.type in ['checkbox','radio'] then "on") or ""
	set: (v) -> @setAttribute('value',v)

property HTMLInputElement::, 'checked',
	get: -> @hasAttribute('checked')
	set: (v) ->
		if v? then @setAttribute('checked','checked')
		else @removeAttribute('checked')

property HTMLInputElement::, 'selected',
	get: -> @hasAttribute('selected')
	set: (v) ->
		if v? then @setAttribute('selected','selected')
		else @removeAttribute('selected')

property HTMLSelectElement::, 'selectedIndex',
	get: ->
		if not (@_private.selectedIndex? and @_private.selectedIndex < @childNodes.length)
			for index in [0...@childNodes.length]
				if @childNodes[index].hasAttribute 'selected'
					@_private.selectedIndex = index
		return @_private.selectedIndex or 0
	set: (v) ->
		if v < @childNodes.length
			for index in [0...@childNodes.length]
				if index is v
					@childNodes[index].setAttribute('selected','selected')
				else
					@childNodes[index].removeAttribute('selected')
			@_private.selectedIndex = v
		return @_private.selectedIndex or 0

property HTMLOptionElement::, 'value',
	get: -> if @hasAttribute('value') then @getAttribute('value') else @innerText
	set: (v) -> @setAttribute('value',v)

property HTMLSelectElement::, 'value',
	get: -> @childNodes[@selectedIndex]?.value
	set: (v) ->
		for index in [0...@childNodes.length]
			child = @childNodes[index]
			if child.value is v
				@selectedIndex = index

class Attr extends Node
	constructor: (name, value) ->
		super name, value, Node.ATTRIBUTE_NODE, null
		@name = @nodeName
		@value = @nodeValue
		@ownerElement = null

class CData extends Node
	constructor: (value, owner) ->

class Comment extends Node
	constructor: (value, owner) ->

class CComment extends Node
	constructor: (value, owner) ->

class Text extends Node
	constructor: (value, owner) ->
property Text::, 'data',
	set: (v) -> @nodeValue = htmlescape(v)

class DocumentFragment extends Node
	constructor: (owner) ->
	toString: (pretty=false, deep=true) ->
		ret = []; r = 0
		for c in @childNodes
			ret[r++] = c.toString pretty, deep
		return ret.join('')

property DocumentFragment::, 'parentNode',
	set: (v) -> throw Error "DocumentFragment cannot have a parentNode"

class Document extends Element
	constructor: (a...) ->
		a[2] = Node.DOCUMENT_NODE
		super a...
		@documentElement = @
		@documentURI = null
		@_private = extend @_private, {
			idMap: {}
		}
	createCDATASection: (value) -> new CData(value, @)
	createComment: (value) -> new Comment(value, @)
	createCComment: (value) -> new CComment(value, @)
	createDocumentFragment: -> new DocumentFragment(@)
	createElement: (name) ->
		nodeClass = ELEMENT_MAP[name?.toLowerCase()]
		if not nodeClass?
			new ELEMENT_MAP['_'](name.toUpperCase())
		else
			new nodeClass(name.toUpperCase(),null,null,@)
	createEntityReference: NotSupported
	createEvent: (type) ->
		switch type
			when "MutationEvents" then new MutationEvent()
			else new Event()
	createTextNode: (text) -> new Text(text, @)
	getElementById: (id) -> @_private.idMap[id]

class HTMLDocument extends Document
	constructor: ->
		super "HTML", null, Node.DOCUMENT_NODE, @
		Document::appendChild.call @,@createElement('head')
		Document::appendChild.call @,@createElement('body')
		@head = @childNodes[0]
		@body = @childNodes[1]
		@_private = extend @_private, {
			matcher: matcher.init(global, @)
		}
	hasChildNodes: -> true
	insertBefore: NotSupported
	appendChild: NotSupported
	removeChild: NotSupported
	replaceChild: NotSupported
	write: NotSupported
	writeln: NotSupported

exports.createDocument = ->
	new HTMLDocument()

exports.registerGlobals = (g) ->
	g.Element = Element
	g.Node = Node
	g.Document = Document
	g.DocumentFragment = DocumentFragment
	g.Event = Event
	for tagName of ELEMENT_MAP
		c = ELEMENT_MAP[tagName]
		g[c.name] = c


clear = (a...) ->
	for i in a
		i.length = 0
get = (a) -> a.join("")
void_elements = [ "AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"]
parse = (input, document) ->
	i = 0
	mode = 0
	fragment = document.createDocumentFragment()
	cursor = fragment
	tagName = []
	attrName = []
	attrVal = []
	text = []
	attributes = {}
	closeNode = () ->
		t = get(tagName).toUpperCase()
		clear(tagName)
		if t in void_elements
			return
		cursor = cursor.parentNode
	emitNode = (closing) -> () ->
		if tagName.length > 0
			node = document.createElement(get(tagName))
			for a of attributes
				node.setAttribute(a, attributes[a])
			cursor.appendChild(node)
			cursor = node
			clear(text, tagName, attrName, attrVal)
			for a of attributes
				delete attributes[a]
			if closing or node.nodeName in void_elements
				closeNode()
	emitAttr = () ->
		k = get(attrName)
		v = get(attrVal)
		if k?
			k = k.replace(/^\s+/,'')
		if k isnt ""
			attributes[k] = v or ""
		clear(attrName, attrVal)
	emitText = () ->
		if text.length > 0
			cursor.appendChild(document.createTextNode(get(text)))
			clear(text)
	emitComment = () ->
		if text.length > 0
			cursor.appendChild(document.createComment(get(text)))
			clear(text)
	states = [
			"<": [emitText, 1]
			"": [text, 0]
			" ": [3]
			"/": [8]
			">": [emitNode(false), 0]
			"": [tagName]
			"=": [4]
			" ": [emitAttr, 3]
			"/": [emitAttr, 8]
			">": [emitAttr, emitNode(false), 0]
			"": [attrName]
			'"': [5]
			"'": [6]
			"": [attrVal, 7]
			'"': [emitAttr, 2]
			"": [attrVal]
			"'": [emitAttr, 2]
			"": [attrVal]
			" ": [emitAttr, 2]
			">": [emitAttr, emitNode(false), 0]
			"/": [emitAttr, 8]
			"": [attrVal]
			">": [emitNode(true), 0]
			"": [parseError("state 8: failed to properly close a /> tag"), 0]
			">": [closeNode, 0]
			"": [tagName]
			"": [parseError("state 11: unknown <! tag"), 0]
			"-": [12]
			"": [parseError("state 12: invalid <!-- tag"), 0]
			"-": [ 13 ]
			"": [text, 12]
		}
	]
	while c = input[i++]
		m = states[mode]
		result = m[c] or m[""] or []
		for x in result
			if x.call
				x()
				mode = x
			else if x.push
				x.push c
	emitText()
	emitNode()
	return cursor

entity_table =
	"€": "&euro;"
	" ": "&nbsp;"
	'"': "&quot;"
	"<": "&lt;"
	">": "&gt;"
	"¡": "&iexcl;"
	"¢": "&cent;"
	"£": "&pound;"
	"¤": "&curren;"
	"¥": "&yen;"
	"¦": "&brvbar;"
	"§": "&sect;"
	"¨": "&uml;"
	"©": "&copy;"
	"ª": "&ordf;"
	"«": "&laquo;"
	"¬": "&not;"
	"¯": "&shy;"
	"®": "&reg;"
	"°": "&deg;"
	"±": "&plusmn;"
	"²": "&sup2;"
	"³": "&sup3;"
	"´": "&acute;"
	"µ": "&micro;"
	"¶": "&para;"
	"·": "&middot;"
	"¸": "&cedil;"
	"¹": "&sup1;"
	"º": "&ordm;"
	"»": "&raquo;"
	"¼": "&frac14;"
	"½": "&frac12;"
	"¾": "&frac34;"
	"¿": "&iquest;"
	"À": "&Agrave;"
	"Á": "&Aacute;"
	"Â": "&Acirc;"
	"Ã": "&Atilde;"
	"Ä": "&Auml;"
	"Å": "&Aring;"
	"Æ": "&AElig;"
	"Ç": "&Ccedil;"
	"È": "&Egrave;"
	"É": "&Eacute;"
	"Ê": "&Ecirc;"
	"Ë": "&Euml;"
	"Ì": "&Igrave;"
	"Í": "&Iacute;"
	"Î": "&Icirc;"
	"Ï": "&Iuml;"
	"Ð": "&ETH;"
	"Ñ": "&Ntilde;"
	"Ò": "&Ograve;"
	"Ó": "&Oacute;"
	"Ô": "&Ocirc;"
	"Õ": "&Otilde;"
	"Ö": "&Ouml;"
	"×": "&times;"
	"Ø": "&Oslash;"
	"Ù": "&Ugrave;"
	"Ú": "&Uacute;"
	"Û": "&Ucirc;"
	"Ü": "&Uuml;"
	"Ý": "&Yacute;"
	"Þ": "&THORN;"
	"ß": "&szlig;"
	"à": "&agrave;"
	"á": "&aacute;"
	"â": "&acirc;"
	"ã": "&atilde;"
	"ä": "&auml;"
	"å": "&aring;"
	"æ": "&aelig;"
	"ç": "&ccedil;"
	"è": "&egrave;"
	"é": "&eacute;"
	"ê": "&ecirc;"
	"ë": "&euml;"
	"ì": "&igrave;"
	"í": "&iacute;"
	"î": "&icirc;"
	"ï": "&iuml;"
	"ð": "&eth;"
	"ñ": "&ntilde;"
	"ò": "&ograve;"
	"ó": "&oacute;"
	"ô": "&ocirc;"
	"õ": "&otilde;"
	"ö": "&ouml;"
	"÷": "&divide;"
	"ø": "&oslash;"
	"ù": "&ugrave;"
	"ú": "&uacute;"
	"û": "&ucirc;"
	"ü": "&uuml;"
	"ý": "&yacute;"
	"þ": "&thorn;"

escape = (input) ->
	input = unescape input
	for c of entity_table
		input = input.replace(c, entity_table[c])
	input

unescape = (input) ->
	for c of entity_table
		input = input.replace entity_table[c], c
	input

if exports
	exports.parse = parse
	exports.escape = escape
	exports.unescape = unescape

assert = require 'assert'
dom = require "../lib/dom.js"
dom.registerGlobals global
global.document = dom.createDocument()
global.window = global

testSelector = (s, output) ->
	x = document.querySelectorAll(s)
	assert.equal x.toString(), output, s

describe 'document', ->
	it "should exist", ->
		assert document?
	it "has a head", ->
		assert document.head?
	it "has a body", ->
		assert document.body?
	it "has DOCUMENT_ELEMENT node type", ->
		assert.equal document.nodeType, 9, "document.nodeType"
	describe '.createElement()', ->
		div = document.createElement('div')
		it 'has node type', ->
			assert.equal div.nodeType, 1
		it 'has node name', ->
			assert.equal div.nodeName, "DIV"
		it 'has a style object', ->
			assert div.style
		describe 'appending new element to document', ->
			it 'appears in parent.childNodes', ->
				document.body.innerHTML = ""
				document.body.appendChild div
				assert.equal document.body.childNodes.length, 1
			it 'can be removed', ->
				document.body.innerHTML = ""
				document.body.appendChild div
				document.body.removeChild div
				assert.equal document.body.childNodes.length, 0
	describe '.getElementsByTagName()', ->
		it "should find a single element", ->
			document.body.innerHTML = "<div/>"
			assert.equal document.body.getElementsByTagName('DIV').length, 1
		it "should find nested elements", ->
			document.body.innerHTML = "<p><div><div/></div></p>"
			assert.equal document.body.getElementsByTagName('DIV').length, 2
		it "is not case sensitive", ->
			document.body.innerHTML = "<p><div><div/></div></p>"
			assert.equal document.body.getElementsByTagName('div').length, 2
	describe '.getElementById()', ->
		it 'finds a single element', ->
			div = document.createElement("div")
			div.id = "getElemId"
			document.body.appendChild(div)
			assert.equal document.getElementById("getElemId"), div
	describe ".attributes", ->
		it "is read/write", ->
			div = document.createElement 'div'
			div.attributes.foo = 'bar'
			assert.equal div.attributes.foo, 'bar'
		it "appears in a .toString()", ->
			div = document.createElement 'div'
			div.attributes.foo = 'bar'
			assert.equal div.toString(), '<div foo="bar"/>'
		it "treats .id as a special attribute", ->
			div = document.createElement 'div'
			div.id = 'testId'
			assert.equal div.attributes.id, div.id
		it "treats .className special", ->
			div = document.createElement 'div'
			div.className = 'foo'
			assert.equal div.attributes.class, 'foo'
		describe ".get/setAttribute()", ->
			it "reads/writes the .attributes map", ->
				div = document.createElement("div")
				div.setAttribute("name", "foo")
				assert.equal div.getAttribute("name"), "foo"
		describe ".hasAttribute()", ->
			it "is true if attr exists", ->
				div = document.createElement("div")
				div.setAttribute("name", "")
				assert.equal div.hasAttribute("name"), true
			it "is false if attr does not exist", ->
				div = document.createElement("div")
				assert.equal div.hasAttribute("name"), false
		describe ".getAttributeNode()", ->
			it "returns an attribute node with value and nodeValue", ->
				div = document.createElement("div")
				div.setAttribute("name", "foo")
				attr = div.getAttributeNode("name")
				assert.equal attr.value, "foo"
				assert.equal attr.nodeValue, "foo"
	describe ".childNodes", ->
		it "every node should have .childNodes", ->
			div = document.createElement("div")
			div.id = "subChildren_parent"
			document.body.appendChild(div)
			span = document.createElement("span")
			div.appendChild(span)
			assert.equal div.childNodes.length, 1
			nodesByTagName = div.getElementsByTagName("span")
			assert.equal nodesByTagName.length, 1
			assert.equal nodesByTagName[0], span
	describe ".getElementsByClassName()", ->
		it "should find elements by class name", ->
			div = document.createElement("div")
			div.id = "getElemClass_parent"
			document.body.appendChild(div)
			p = document.createElement("p")
			p.id = 'classTest'
			p.className = "alpha beta"
			div.appendChild(p)
			alphaNodes = div.getElementsByClassName("alpha")
			betaNodes = div.getElementsByClassName("beta")
			assert.equal alphaNodes.length, 1, "alphaNodes.length"
			assert.equal betaNodes.length, 1, "betaNodes.length"
			assert.equal alphaNodes[0], p, "alphaNodes[0]"
			assert.equal betaNodes[0], p, "betaNodes[0]"
	describe "fragments",  ->
		fragment_doc = fragment = null
		it "can be created", ->
			fragment_doc = global.dom.createDocument()
			fragment = fragment_doc.createDocumentFragment()
		it "can have children", ->
			fragment.appendChild(fragment_doc.createElement("div"))
			fragment.appendChild(fragment_doc.createElement("p"))
			assert.equal fragment.childNodes.length, 2, "fragment.childNodes.length"
		it "can render toString", ->
			assert.equal fragment.toString(), "<div/><p/>", "fragment.toString()"
		it "can be appended to a node and disappear", ->
			div = fragment_doc.createElement("div")
			div.id = "fragment_test"
			fragment_doc.body.appendChild(div)
			div.appendChild(fragment)
			assert.equal fragment_doc.toString(), '<html><head/><body><div id="fragment_test"><div/><p/></div></body></html>'
	describe "text nodes", ->
		it "can be created", ->
			text = document.createTextNode("&nbsp;")
		it "has nodeValue",  ->
			text = document.createTextNode("Harro!")
			assert.equal(text.nodeValue, "Harro!", "text.nodeValue")
		it "can set .data property",  ->
			text = document.createTextNode("Harro!")
			text.data = "BB"
			assert.equal(text.nodeValue, "BB", "text.nodeValue")
		it "can put html in .data",  ->
			text = document.createTextNode("Harro!")
			text.data = "<p>"
			assert.equal(text.nodeValue, "&lt;p&gt;", "text.nodeValue")
		it "can read .data back from .innerHTML (escaped)",  ->
			text = document.createTextNode("Harro!")
			text.data = "<p>"
			div = document.createElement("div")
			div.appendChild(text)
			assert.equal(div.innerHTML, "&lt;p&gt;")
			text.data = "Goodbye!"
			assert.equal(div.innerHTML, "Goodbye!")
		describe ".innerText", ->
			text = div = null
			it "includes direct text nodes", ->
				text = document.createTextNode("&nbsp;")
				div = document.createElement("div")
				div.appendChild(text)
				assert.equal div.innerHTML, "&nbsp;"
				assert.equal div.innerText, "&nbsp;"
			it "also includes deeply nested text nodes", ->
				span = document.createElement "span"
				text2 = document.createTextNode "hello"
				span.appendChild text2
				assert.equal span.innerText, "hello"
				div.appendChild(span)
				assert.equal(div.innerText, "&nbsp;hello")
	describe "input nodes", ->
		it "treats .value as an attribute-property", ->
			input = document.createElement("input")
			input.value = 'bar'
			input.setAttribute('value', 'foo')
			assert.equal input.value, 'foo', 'input.value'
			assert.equal input.value, input.getAttribute('value'), 'input.getAttribute("value")'
		describe "<select/option>", ->
			select = optionA = optionB = null
			it "can be created", ->
				select = document.createElement("select")
				optionA = document.createElement("option")
				optionB = document.createElement("option")
				assert.equal optionA.constructor.name, "HTMLOptionElement"
				assert.equal optionA.constructor.__super__.constructor.name, "HTMLInputElement"
			it "<option> can have value", ->
				optionA.value = '1'
				optionA.innerText = 'A'
				optionB.innerText = 'B'
				assert.equal optionA.value, '1', 'optionA.value'
				assert.equal optionB.value, 'B', 'optionB.value'
			it "<select> can have <option> children", ->
				select.appendChild(optionA)
				select.appendChild(optionB)
			it ".selectedIndex is populated", ->
				assert.equal select.selectedIndex, 0, 'select.selectedIndex'
			it ".value is populated", ->
				assert.equal select.value, '1', 'select.value'
			it ".selectedIndex is settable and updates .value", ->
				select.selectedIndex = 1
				assert.equal select.selectedIndex, 1, 'select.selectedIndex * 2'
				assert.equal select.value, 'B', 'select.value'
		describe "<input type='radio'>", ->
			test_doc = global.dom.createDocument()
			test_doc.body.innerHTML = "<input type='radio' selected>"
			input = test_doc.body.childNodes[0]
			it "should be an HTMLInputElement", ->
				assert.equal input.constructor.name, "HTMLInputElement"
			it "has a 'selected' attribute", ->
				assert.equal input.hasAttribute('selected'), true
			it "having selected attribute means selected is true", ->
				assert.equal input.getAttribute('selected'), ''
				assert.equal input.selected, true
				input.removeAttribute('selected')
				assert.equal input.selected, false
			it "should have a default value of 'on'", ->
				assert.equal input.value, "on"
		describe "<input type='checkbox'>", ->
			test_doc = global.dom.createDocument()
			test_doc.body.innerHTML = "<input type='checkbox' checked >"
			input = test_doc.body.childNodes[0]
			it "should have a special .checked property", ->
				assert.equal input.checked, true, 'input.checked'
			it "should have a default value of 'on'", ->
				assert.equal input.value, "on"
	it "can create/render comments",  ->
		comment_doc = global.dom.createDocument()
		comment = comment_doc.createComment("comment text")
		assert.equal comment.nodeValue, "comment text"
		comment_doc.body.appendChild(comment)
		assert.equal comment_doc.body.toString(), '<body><!--comment text--></body>'
	it "can create/render conditional comments",  ->
		doc = global.dom.createDocument()
		comment = doc.createCComment("if lt IE 9")
		script = doc.createElement('script')
		script.setAttribute('src', 'ie.js')
		comment.appendChild script
		doc.body.appendChild(comment)
		assert.equal doc.body.toString(), '<body><!--[if lt IE 9]><script src="ie.js"/><![endif]--></body>'
	describe ".querySelectorAll()", ->
		it "id",  ->
			document.body.innerHTML = '<div><span/><p id="classTest" class="alpha beta"/></div>'
		it "class",  ->
			document.body.innerHTML = '<div><span/><p id="classTest" class="alpha beta"/></div>'
			testSelector "p.alpha.beta", '<p id="classTest" class="alpha beta"/>'
		it "tag",  ->
			document.body.innerHTML = '<div><span/><p id="classTest" class="alpha beta"/></div>'
			testSelector "p", '<p id="classTest" class="alpha beta"/>'
		it "star",  ->
			document.body.innerHTML = '<div><span/><p id="classTest" class="alpha beta"/></div>'
			testSelector "div *", '<span/>,<p id="classTest" class="alpha beta"/>'

	test_parse = (input, output, debug = false) ->
		html = require('../html/parser')
		try
			result = html.parse(input, document, debug).toString(false, true)
			output ?= input
		catch err
			throw err
		if result isnt output
			throw Error result+" !== "+output
	
	describe ".innerHTML can parse", ->
		cases = [
			["text", "text"],
			["<p>","<p/>"],
			["<div/>"],
			["<div />", "<div/>"],
			["<div>Harro?</div>"],
			["<div>foo</div>"],
			["<div>1,2</div>"],
			["<div><p>Hi.</p></div>"],
			["<div><p><span>Bye.</span></p></div>"],
			["<div><p/></div>"],
			["<div><p /></div>", "<div><p/></div>"],
			["<div><p  /></div>", "<div><p/></div>"],
			["<div key='val'></div>", '<div key="val"/>'],
			["<div key='val' ></div>", '<div key="val"/>'],
			["<div key='val'/>", '<div key="val"/>'],
			["<div key='val' />", '<div key="val"/>'],
			["<div id='test_parse'></div>", '<div id="test_parse"/>'],
			["<input checked/>"],
			["<eval>CurrencyFormat(Application.User.balance)</eval>"],
			['<body><!-- comment --><span>foo</span></body>'],
			['<a>Hello<b>World</b></a>'],
			['<head><meta charset="utf-8"><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'],
			['<head><meta charset="utf-8"/><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'],
			['<head><meta charset="utf-8"></meta><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'],
		]
		for c in cases
			it c[0], -> test_parse c...

	test_escape = (input, output) ->
		html = require('../html/parser')
		result = html.escape(input)
		if result isnt output
			throw Error result+" !== "+output
	
	describe ".innerHTML does escape", ->
		it '<p>', -> test_escape '<p>', '&lt;p&gt;'
		it '&amp;', -> test_escape '&amp;', '&amp;'
		it '?input=foo&amp;bar&key=value', -> test_escape '?input=foo&amp;bar&key=value', '?input=foo&amp;bar&key=value',

	describe 'nwmatcher', ->
		nw_doc = global.dom.createDocument()
		nw_doc.body.innerHTML = "<div><p id='pId' class='c'><span class='c'>C</span></p><input name='foo' /></div>"
		nw = require("../css/nwmatcher")
		matcher = nw.init(global, nw_doc)

		describe '.byId', ->
			it 'find DOM nodes', ->
				assert.equal matcher.byId('pId').constructor.name, "HTMLParagraphElement"

		describe '.byClass()', ->
			c = matcher.byClass('c')
			it "is an Array", -> assert.equal c.constructor.name, "Array"
			it "finds the right elements", ->
				assert.equal c.length, 2
				assert matcher.match(c[0], '.c')
				assert matcher.match(c[1], '.c')
				assert !matcher.match(c[1], 'c')

		describe '.byName()', ->
			f = matcher.byName('foo')
			it "is an Array", -> assert.equal f.constructor.name, "Array"
			it "find the right elements", -> assert.equal f.length, 1

		describe '.byTag()', ->
			s = matcher.byTag('span')
			it "is an Array", -> assert.equal s.constructor.name, "Array"
			it "finds the right elements", -> assert.equal s.length, 1

		describe '.select()', ->
			it "supports the '+' selector", ->
				x = matcher.select('p + input')
				assert.equal x.constructor.name, "Array"
				assert.equal x.length, 1
			it "supports the '*' selector", ->
				a = matcher.select('*')
				assert.equal a.constructor.name, "Array"
				assert.equal a.length, 6

require 'bling'
express = require 'express'
coffeekup = require 'coffeekup'
Routes = require './routes'
Auth = require './auth'

app = module.exports = express.createServer()

app.configure ->
	app.set 'views', __dirname + '/views'
	app.set 'view engine', 'coffee'
	app.register '.coffee', coffeekup.adapters.express
	app.use express.logger "dev"
	app.use express.bodyParser()
	app.use express.cookieParser('CYPASQqRrvXvgdix')
	app.use express.methodOverride()
	app.use app.router
	app.use express.static(__dirname + '/public')
	app.use(express.favicon('public/img/favicon.ico'))

app.configure 'development', ->
	app.use express.errorHandler { dumpExceptions: true, showStack: true }

app.configure 'production', ->
	app.use express.errorHandler()

app.get '/', Routes.index
app.get '/:owner/login', Routes.login
app.post '/:owner/login', Routes.post_login
app.get '/:owner/agent-list', Auth.requireCookie Routes.agent_list
app.get '/:owner/agent-create', Auth.requireCookie Routes.agent_create
app.get '/:owner/manage-apikeys', Auth.requireCookie Routes.manage_apikeys
app.get '/:owner/manage-targeting', Auth.requireCookie Routes.manage_transforms
app.get '/:owner/manage-targeting/rule/:code', Auth.requireCookie Routes.manage_transforms_rule
app.get '/:owner/:agent/reporting-impact/:dateFrom?/:dateThru?', Auth.requireCookie Routes.reporting_impact
app.get '/:owner/:agent/reporting-testing/:dateFrom?/:dateThru?', Auth.requireCookie Routes.reporting_testing
app.get '/:owner/:agent/documentation/reporting-api', Auth.requireCookie Routes.doc_reporting_api

app.listen parseInt($.config.get("PORT", 3001), 10), ->
	$.log "Admin server listening on port %d in %s mode", app.address().port, app.settings.env

Auth = exports

Auth.requireCookie = (f) ->
	(req, res) ->
		owner = req.params.owner
		if not req.cookies?.mkey
		f(req, res)




log = (a...) ->
	try console.log.apply console, a
	catch err
		alert a.join(", ")
	return a[Math.max(0, a.length-1)]

Object.keys ?= (o) -> (k for k of o)

extend = (a, b) ->
	return a if not b
	for k of b
		v = b[k]
		if v? then a[k] = v
	a

defineProperty = (o,name,opts) ->
	Object.defineProperty o,name, extend({
		configurable: true
		enumerable: true
	}, opts)
	o



isType = (T, o) ->
	if not o? then T in [o,"null","undefined"]
	else o.constructor is T or
		o.constructor.name is T or

inherit = (parent, obj) ->
	if typeof parent is "function"
		parent = parent.prototype
	if parent.__proto__ is Object.prototype
		parent.__proto__ = obj.__proto__
	obj.__proto__ = parent
	obj

_type = do ->

	cache = {}

	base =
		name: 'unknown'
		match: (o) -> true

	order = []

	register = (name, data) ->
		order.unshift name if not (name of cache)
		cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
		cache[name][name] = (o) -> o

	_extend = (name, data) ->
		if typeof name is "string"
			cache[name] ?= register name, {}
			cache[name] = extend cache[name], data
		else if typeof name is "object"
			(_extend k, name[k]) for k of name

	lookup = (obj) ->
		for name in order
			if cache[name]?.match.call obj, obj
				return cache[name]

	register "unknown",   base
	register "object",    match: -> typeof @ is "object"
	register "error",     match: -> isType 'Error', @
	register "regexp",    match: -> isType 'RegExp', @
	register "string",    match: -> typeof @ is "string" or isType String, @
	register "number",    match: -> (isType Number, @) and @ isnt NaN
	register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
	register "array",     match: -> Array.isArray?(@) or isType Array, @
	register "function",  match: -> typeof @ is "function"
	register "undefined", match: (x) -> x is undefined
	register "null",      match: (x) -> x is null

	return extend ((o) -> lookup(o).name),
		register: register
		lookup: lookup
		extend: _extend
		is: (t, o) -> cache[t]?.match.call o, o
		as: (t, o) -> lookup(o)[t]?(o)




_pipe = do ->




	pipes = {}

	(name, args) ->
		p = (pipes[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args






class Bling

	default_context = if document? then document else {}

	constructor: (selector, context = default_context) ->
		return Bling.pipe "bling-init", [selector, context]

	@pipe: _pipe

	@pipe("bling-init").prepend (args) ->
		[selector, context] = args
		inherit Bling, inherit {
			selector: selector
			context: context
		}, _type.lookup(selector).array(selector, context)





	@plugin: (opts, constructor) ->
		if not constructor?
			constructor = opts; opts = {}

		if "depends" of opts
			return @depends opts.depends, =>
				@plugin { provides: opts.provides }, constructor
		try
			if (plugin = constructor?.call @,@)
				extend @, plugin?.$
				['$','name'].forEach (k) -> delete plugin[k]
				extend @::, plugin
				for key of plugin then do (key) =>
					@[key] or= (a...) => (@::[key].apply $(a[0]), a[1...])
				if opts.provides? then @provide opts.provides
		catch error
			throw error
		@

		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)

	@depends: (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else dep.q.push (need) ->
			(needs.splice i, 1) if (i = needs.indexOf need) > -1
			return (needs.length is 0 and f)
		f

	@provide: (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data

	@provides: (needs, f) ->
		(args...) ->
			Bling.provide needs, f args...

	_type.extend
		unknown:   { array: (o) -> [o] }

		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }

	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) ->
			o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"

Bling.prototype = []
Bling.prototype.constructor = Bling

do ($ = Bling) ->

	$.global = glob = if window? then window else global

	$.plugin
		provides: "type"
	, ->
		$:
			inherit: inherit
			extend: extend
			defineProperty: defineProperty
			isType: isType
			type: _type
			is: _type.is
			as: _type.as
			isSimple: (o) -> _type(o) in ["string", "number", "bool"]
			isEmpty: (o) -> o in ["", null, undefined]



	$.plugin
		provides: "symbol"
		depends: "type"
	, ->
		symbol = null
		cache = {}
		glob.Bling = Bling
		if module?
			module.exports = Bling
		$.type.extend "bling",
			string: (o) -> symbol + "(["+ o.map($.toString).join(", ") + "])"
		defineProperty $, "symbol",
			set: (v) ->
				glob[symbol] = cache[symbol]
				cache[symbol = v] = glob[v]
				glob[v] = Bling
			get: -> symbol
		return $:
			symbol: "$"
			noConflict: ->
				Bling.symbol = "Bling"
				return Bling

	$.plugin ->
		String::trimLeft or= -> @replace(/^\s+/, "")
		String::split or= (sep) ->
			a = []; i = 0
			while (j = @indexOf sep,i) > -1
				a.push @substring(i,j)
				i = j + 1
			a
		String::lastIndexOf or= (s, c, i = -1) ->
			j = -1
			j = i while (i = s.indexOf c, i+1) > -1
			j

		Array::join or= (sep = '') ->
			n = @length
			return "" if n is 0
			s = @[n-1]
			while --n > 0
				s = @[n-1] + sep + s
			s

		if Event?
			Event::preventAll = () ->
				@preventDefault()
				@stopPropagation()
				@cancelBubble = true

		if Element?
			Element::matchesSelector = Element::webkitMatchesSelector or
				Element::mozMatchesSelector or
				Element::matchesSelector
			if Element::cloneNode.length is 0
				oldClone = Element::cloneNode
				Element::cloneNode = (deep = false) ->
					n = oldClone.call(@)
					if deep
						for i in @childNodes
							n.appendChild i.cloneNode true
					return n

		return { }

	$.plugin
		provides: "core"
		depends: "string"
	, ->

		defineProperty $, "now",
			get: -> +new Date

		index = (i, o) ->
			i += o.length while i < 0
			Math.min i, o.length

		baseTime = $.now
		return {
			$:
				log: $.extend((a...) ->
					prefix = $.padLeft String($.now - baseTime), $.log.prefixSize, '0'
				, prefixSize: 5)
				coalesce: (a...) -> $(a).coalesce()

			eq: (i) -> $([@[index i, @]])

			each: (f) -> (f.call(t,t) for t in @); @

			map: (f) -> $(f.call(t,t) for t in @)

			reduce: (f, a) ->
				i = 0; n = @length
				a = @[i++] if not a?
				(a = f.call @[x], a, @[x]) for x in [i...n] by 1
				return a
			union: (other, strict = true) ->
				ret = $()
				ret.push(x) for x in @ when not ret.contains(x, strict)
				ret.push(x) for x in other when not ret.contains(x, strict)
				ret
			distinct: (strict = true) -> @union @, strict
			contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
			count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
			coalesce: ->
				for i in @
					if $.type(i) in ["array","bling"] then i = $(i).coalesce()
					if i? then return i
				null
			swap: (i,j) ->
				i = index i, @
				j = index j, @
				if i isnt j
					[@[i],@[j]] = [@[j],@[i]]
				@
			shuffle: ->
				i = @length-1
				while i >= 0
					@swap --i, Math.floor(Math.random() * i)
				@

			select: (->
				getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
				select = (p) ->
					if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
					else @map(getter p)
			)()

			or: (x) -> @[i] or= x for i in [0...@length]; @

			zap: (p, v) ->

				i = p.lastIndexOf "."

				if i > 0
					head = p.substr 0,i
					tail = p.substr i+1
					@select(head).zap tail, v
					return @

				switch $.type(v)
					when "array","bling" then @each -> @[p] = v[++i % v.length]
					when "function" then @zap p, @select(p).map(v)
					else @each -> @[p] = v
				@

			clean: (prop) -> @each -> delete @[prop]

			take: (n = 1) ->
				end = Math.min n, @length
				$( @[i] for i in [0...end] )

			skip: (n = 0) ->
				start = Math.max 0, n|0
				$( @[i] for i in [start...@length] )

			first: (n = 1) -> if n is 1 then @[0] else @take(n)

			last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)

			slice: (start=0, end=@length) ->
				start = index start, @
				end = index end, @
				$( @[i] for i in [start...end] )

			extend: (b) -> @.push(i) for i in b; @

			push: (b) -> Array::push.call(@, b); @

			filter: (f) ->
				g = switch $.type f
					when "string" then (x) -> x.matchesSelector(f)
					when "regexp" then (x) -> f.test(x)
					when "function" then f
					else
				$( it for it in @ when g.call(it,it) )

			matches: (expr) -> @select('matchesSelector').call(expr)

			querySelectorAll: (expr) ->
				@filter("*")
				.reduce (a, i) ->
					a.extend i.querySelectorAll expr
				, $()

			weave: (b) ->
				c = $()
				for i in [@length-1..0] by -1
					c[(i*2)+1] = @[i]
				for i in [0...b.length] by 1
					c[i*2] = b[i]
				c

			fold: (f) ->
				n = @length
				b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
				if (n%2) is 1
					b.push( f.call @, @[n-1], undefined )
				b

			flatten: ->
				b = $()
				(b.push(j) for j in i) for i in @
				b

			call: -> @apply(null, arguments)

			apply: (context, args) ->
				@map -> if $.is "function", @ then @apply(context, args) else @

			log: (label) ->
				if label
					$.log(label, @toString(), @length + " items")
				else
					$.log(@toString(), @length + " items")
				@

			toArray: ->
				@__proto__ = Array::
		}

	$.plugin
		provides: "math"
		depends: "core"
	, ->
		$.type.extend
			bool: { number: (o) -> if o then 1 else 0 }
			number: { bool: (o) -> not not o }

		$:
			range: (start, end, step = 1) ->
				if not end? then (end = start; start = 0)
				$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
			zeros: (n) -> $( 0 for i in [0...n] )
			ones: (n) -> $( 1 for i in [0...n] )
		floats: -> @map parseFloat
		ints: -> @map -> parseInt @, 10
		px: (delta) -> @ints().map -> $.px @,delta
		min: -> @filter( isFinite ).reduce Math.min
		max: -> @filter( isFinite ).reduce Math.max
		mean: -> @sum() / @length
		avg: -> @sum() / @length
		sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
		product: -> @filter( isFinite ).reduce (a) -> a * @
		squares: -> @map -> @ * @
		magnitude: -> Math.sqrt @floats().squares().sum()
		scale: (r) -> @map -> r * @
		add: (d) -> switch $.type(d)
			when "number" then @map -> d + @
			when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
		normalize: -> @scale(1/@magnitude())

	$.plugin
		provides: "string"
		depends: "function"
	, ->
		$.type.extend
			unknown:
				string: (o) -> o.toString?() ? String(o)
				repr: (o) -> $.type.lookup(o).string(o)
				number: (o) -> parseFloat String o
			null: { string: -> "null" }
			undefined: { string: -> "undefined" }
			string:
				number: parseFloat
			array:  { string: (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
			function:
				string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
			number:
				repr:   (n) -> String(n)
				string: (n) ->
					switch true
						when n.precision? then n.toPrecision(n.precision)
						when n.fixed? then n.toFixed(n.fixed)
						else String(n)

		return {
			$:
				toString: (x) ->
					if not x? then "function Bling(selector, context) { [ ... ] }"
					else $.type.lookup(x).string(x)

				toRepr: (x) -> $.type.lookup(x).repr(x)

				px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"



				capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")

				dashize: (name) ->
					ret = ""
					for i in [0...(name?.length|0)]
						c = name.charCodeAt i
						if 91 > c > 64
							c += 32
							ret += '-'
						ret += String.fromCharCode(c)
					ret

				camelize: (name) ->
					name.split('-')
					while (i = name?.indexOf('-')) > -1
						name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
					name

				padLeft: (s, n, c = " ") ->
					while s.length < n
						s = c + s
					s

				padRight: (s, n, c = " ") ->
					while s.length < n
						s = s + c
					s

				stringCount: (s, x, i = 0, n = 0) ->
					if (j = s.indexOf x,i) > i-1
						$.stringCount s, x, j+1, n+1
					else n

				stringSplice: (s, i, j, n) ->
					nn = s.length
					end = j
					if end < 0
						end += nn
					start = i
					if start < 0
						start += nn
					s.substring(0,start) + n + s.substring(end)

				checksum: (s) ->
					a = 1; b = 0
					for i in [0...s.length]
						a = (a + s.charCodeAt(i)) % 65521
						b = (b + a) % 65521
					(b << 16) | a

				repeat: (x, n=2) ->
					switch true
						when n is 1 then x
						when n < 1 then ""
						when $.is "string", x then x + $.repeat(x, n-1)
						else $(x).extend $.repeat(x, n-1)

				stringBuilder: ->
					if $.is("global", @) then return new $.stringBuilder()
					items = []
					@length   = 0
					@append   = (s) => items.push s; @length += s?.toString().length|0
					@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
					@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
					@toString = ( ) => items.join("")
					@
			toString: -> $.toString @
			toRepr: -> $.toRepr @
		}

	$.plugin
		provides: "function"
		depends: "hash"
	, ->
		$:
			identity: (o) -> o
			not: (f) -> -> not f.apply @, arguments
			compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
			and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
			once: (f, n=1) ->
				$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
					"exhausted",
						get: -> n <= 0
			cycle: (f...) ->
				i = -1
				-> f[i = ++i % f.length].apply @, arguments
			bound: (t, f, args = []) ->
				if $.is "function", f.bind
					args.splice 0, 0, t
					r = f.bind.apply f, args
				else
					r = (a...) -> f.apply t, (args if args.length else a)
			memoize: (f) ->
				cache = {}

	$.plugin
		provides: "hash"
		depends: "type"
	, ->
		$.type.extend
			unknown: { hash: (o) -> $.checksum $.toString o }
			object:  { hash: (o) ->
				$.hash(Object) +
					$($.hash(o[k]) for k of o).sum() +
					$.hash Object.keys o
			}
			array:   { hash: (o) ->
				$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
					(a*a)+(x|0)
				, 1
			}
			bool:    { hash: (o) -> parseInt(1 if o) }
		return {
			$:
				hash: (x) -> $.type.lookup(x).hash(x)
			hash: -> $.hash @
		}

	$.plugin
		provides: "pubsub"
	, ->
		return {
			$:
				publish: (e, args...) ->
					f.apply null, args for f in (subscribers[e] or= [])
					args
				publisher: (e, func) ->
					(args...) ->
						func.apply @, args
						$.publish e, args
				subscribe: (e, func) ->
					(subscribers[e] or= []).push func
					func
				unsubscribe: (e, func) ->
					if not func?
						subscribers[e] = []
					else
						a = (subscribers[e] or= [])
						if (i = a.indexOf func)  > -1
							a.splice(i,i)
		}

	$.plugin
		provides: "throttle"
		depends: "core"
	, ->
		$:
			throttle: (f,n=250,last=0) ->
				(a...) ->
					gap = $.now - last
					if gap > n
						last += gap
						return f.apply @,a
					null
				(a...) ->
					last += (gap = $.now - last)
					return f.apply @,a if gap > n else null

	$.plugin
		provides: "EventEmitter"
	, ->
		$: EventEmitter: $.pipe("bling-init").append (obj) ->
			listeners = {}
			list = (e) -> (listeners[e] or= [])
			inherit {
				emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
				addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
				on:                 (e, h) -> @addListener e, h
				removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
				removeAllListeners: (e) -> listeners[e] = []
				listeners:          (e) -> list(e).slice 0
			}, obj

log = (a...) ->
	try console.log.apply console, a
	catch err
		alert a.join(", ")
	return a[Math.max(0, a.length-1)]
Object.keys ?= (o) -> (k for k of o)
extend = (a, b) ->
	return a if not b
	for k of b
		v = b[k]
		if v? then a[k] = v
	a
defineProperty = (o,name,opts) ->
	Object.defineProperty o,name, extend({
		configurable: true
		enumerable: true
	}, opts)
	o
isType = (T, o) ->
	if not o? then T in [o,"null","undefined"]
	else o.constructor is T or
		o.constructor.name is T or
inherit = (parent, obj) ->
	if typeof parent is "function"
		parent = parent.prototype
	if parent.__proto__ is Object.prototype
		parent.__proto__ = obj.__proto__
	obj.__proto__ = parent
	obj
_type = do ->
	cache = {}
	base =
		name: 'unknown'
		match: (o) -> true
	order = []
	register = (name, data) ->
		order.unshift name if not (name of cache)
		cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
		cache[name][name] = (o) -> o
	_extend = (name, data) ->
		if typeof name is "string"
			cache[name] ?= register name, {}
			cache[name] = extend cache[name], data
		else if typeof name is "object"
			(_extend k, name[k]) for k of name
	lookup = (obj) ->
		for name in order
			if cache[name]?.match.call obj, obj
				return cache[name]
	register "unknown",   base
	register "object",    match: -> typeof @ is "object"
	register "error",     match: -> isType 'Error', @
	register "regexp",    match: -> isType 'RegExp', @
	register "string",    match: -> typeof @ is "string" or isType String, @
	register "number",    match: -> (isType Number, @) and @ isnt NaN
	register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
	register "array",     match: -> Array.isArray?(@) or isType Array, @
	register "function",  match: -> typeof @ is "function"
	register "undefined", match: (x) -> x is undefined
	register "null",      match: (x) -> x is null
	return extend ((o) -> lookup(o).name),
		register: register
		lookup: lookup
		extend: _extend
		is: (t, o) -> cache[t]?.match.call o, o
		as: (t, o) -> lookup(o)[t]?(o)
_pipe = do ->
	pipes = {}
	(name, args) ->
		p = (pipes[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args
class Bling
	default_context = if document? then document else {}
	constructor: (selector, context = default_context) ->
		return Bling.pipe "bling-init", [selector, context]
	@pipe: _pipe
	@pipe("bling-init").prepend (args) ->
		[selector, context] = args
		inherit Bling, inherit {
			selector: selector
			context: context
		}, _type.lookup(selector).array(selector, context)
	@plugin: (opts, constructor) ->
		if not constructor?
			constructor = opts; opts = {}
		if "depends" of opts
			return @depends opts.depends, =>
				@plugin { provides: opts.provides }, constructor
		try
			if (plugin = constructor?.call @,@)
				extend @, plugin?.$
				['$','name'].forEach (k) -> delete plugin[k]
				extend @::, plugin
				for key of plugin then do (key) =>
					@[key] or= (a...) => (@::[key].apply $(a[0]), a[1...])
				if opts.provides? then @provide opts.provides
		catch error
			throw error
		@
		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)
	@depends: (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else dep.q.push (need) ->
			(needs.splice i, 1) if (i = needs.indexOf need) > -1
			return (needs.length is 0 and f)
		f
	@provide: (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data
	@provides: (needs, f) ->
		(args...) ->
			Bling.provide needs, f args...
	_type.extend
		unknown:   { array: (o) -> [o] }
		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }
	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) ->
			o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"
Bling.prototype = []
Bling.prototype.constructor = Bling
do ($ = Bling) ->
	$.global = glob = if window? then window else global
	$.plugin
		provides: "type"
	, ->
		$:
			inherit: inherit
			extend: extend
			defineProperty: defineProperty
			isType: isType
			type: _type
			is: _type.is
			as: _type.as
			isSimple: (o) -> _type(o) in ["string", "number", "bool"]
			isEmpty: (o) -> o in ["", null, undefined]
	$.plugin
		provides: "symbol"
		depends: "type"
	, ->
		symbol = null
		cache = {}
		glob.Bling = Bling
		if module?
			module.exports = Bling
		$.type.extend "bling",
			string: (o) -> symbol + "(["+ o.map($.toString).join(", ") + "])"
		defineProperty $, "symbol",
			set: (v) ->
				glob[symbol] = cache[symbol]
				cache[symbol = v] = glob[v]
				glob[v] = Bling
			get: -> symbol
		return $:
			symbol: "$"
			noConflict: ->
				Bling.symbol = "Bling"
				return Bling
	$.plugin ->
		String::trimLeft or= -> @replace(/^\s+/, "")
		String::split or= (sep) ->
			a = []; i = 0
			while (j = @indexOf sep,i) > -1
				a.push @substring(i,j)
				i = j + 1
			a
		String::lastIndexOf or= (s, c, i = -1) ->
			j = -1
			j = i while (i = s.indexOf c, i+1) > -1
			j
		Array::join or= (sep = '') ->
			n = @length
			return "" if n is 0
			s = @[n-1]
			while --n > 0
				s = @[n-1] + sep + s
			s
		if Event?
			Event::preventAll = () ->
				@preventDefault()
				@stopPropagation()
				@cancelBubble = true
		if Element?
			Element::matchesSelector = Element::webkitMatchesSelector or
				Element::mozMatchesSelector or
				Element::matchesSelector
			if Element::cloneNode.length is 0
				oldClone = Element::cloneNode
				Element::cloneNode = (deep = false) ->
					n = oldClone.call(@)
					if deep
						for i in @childNodes
							n.appendChild i.cloneNode true
					return n
		return { }
	$.plugin
		provides: "core"
		depends: "string"
	, ->
		defineProperty $, "now",
			get: -> +new Date
		index = (i, o) ->
			i += o.length while i < 0
			Math.min i, o.length
		baseTime = $.now
		return {
			$:
				log: $.extend((a...) ->
					prefix = $.padLeft String($.now - baseTime), $.log.prefixSize, '0'
				, prefixSize: 5)
				coalesce: (a...) -> $(a).coalesce()
			eq: (i) -> $([@[index i, @]])
			each: (f) -> (f.call(t,t) for t in @); @
			map: (f) -> $(f.call(t,t) for t in @)
			reduce: (f, a) ->
				i = 0; n = @length
				a = @[i++] if not a?
				(a = f.call @[x], a, @[x]) for x in [i...n] by 1
				return a
			union: (other, strict = true) ->
				ret = $()
				ret.push(x) for x in @ when not ret.contains(x, strict)
				ret.push(x) for x in other when not ret.contains(x, strict)
				ret
			distinct: (strict = true) -> @union @, strict
			contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
			count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
			coalesce: ->
				for i in @
					if $.type(i) in ["array","bling"] then i = $(i).coalesce()
					if i? then return i
				null
			swap: (i,j) ->
				i = index i, @
				j = index j, @
				if i isnt j
					[@[i],@[j]] = [@[j],@[i]]
				@
			shuffle: ->
				i = @length-1
				while i >= 0
					@swap --i, Math.floor(Math.random() * i)
				@
			select: (->
				getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
				select = (p) ->
					if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
					else @map(getter p)
			)()
			or: (x) -> @[i] or= x for i in [0...@length]; @
			zap: (p, v) ->
				i = p.lastIndexOf "."
				if i > 0
					head = p.substr 0,i
					tail = p.substr i+1
					@select(head).zap tail, v
					return @
				switch $.type(v)
					when "array","bling" then @each -> @[p] = v[++i % v.length]
					when "function" then @zap p, @select(p).map(v)
					else @each -> @[p] = v
				@
			clean: (prop) -> @each -> delete @[prop]
			take: (n = 1) ->
				end = Math.min n, @length
				$( @[i] for i in [0...end] )
			skip: (n = 0) ->
				start = Math.max 0, n|0
				$( @[i] for i in [start...@length] )
			first: (n = 1) -> if n is 1 then @[0] else @take(n)
			last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)
			slice: (start=0, end=@length) ->
				start = index start, @
				end = index end, @
				$( @[i] for i in [start...end] )
			extend: (b) -> @.push(i) for i in b; @
			push: (b) -> Array::push.call(@, b); @
			filter: (f) ->
				g = switch $.type f
					when "string" then (x) -> x.matchesSelector(f)
					when "regexp" then (x) -> f.test(x)
					when "function" then f
					else
				$( it for it in @ when g.call(it,it) )
			matches: (expr) -> @select('matchesSelector').call(expr)
			querySelectorAll: (expr) ->
				@filter("*")
				.reduce (a, i) ->
					a.extend i.querySelectorAll expr
				, $()
			weave: (b) ->
				c = $()
				for i in [@length-1..0] by -1
					c[(i*2)+1] = @[i]
				for i in [0...b.length] by 1
					c[i*2] = b[i]
				c
			fold: (f) ->
				n = @length
				b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
				if (n%2) is 1
					b.push( f.call @, @[n-1], undefined )
				b
			flatten: ->
				b = $()
				(b.push(j) for j in i) for i in @
				b
			call: -> @apply(null, arguments)
			apply: (context, args) ->
				@map -> if $.is "function", @ then @apply(context, args) else @
			log: (label) ->
				if label
					$.log(label, @toString(), @length + " items")
				else
					$.log(@toString(), @length + " items")
				@
			toArray: ->
				@__proto__ = Array::
		}
	$.plugin
		provides: "math"
		depends: "core"
	, ->
		$.type.extend
			bool: { number: (o) -> if o then 1 else 0 }
			number: { bool: (o) -> not not o }
		$:
			range: (start, end, step = 1) ->
				if not end? then (end = start; start = 0)
				$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
			zeros: (n) -> $( 0 for i in [0...n] )
			ones: (n) -> $( 1 for i in [0...n] )
		floats: -> @map parseFloat
		ints: -> @map -> parseInt @, 10
		px: (delta) -> @ints().map -> $.px @,delta
		min: -> @filter( isFinite ).reduce Math.min
		max: -> @filter( isFinite ).reduce Math.max
		mean: -> @sum() / @length
		avg: -> @sum() / @length
		sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
		product: -> @filter( isFinite ).reduce (a) -> a * @
		squares: -> @map -> @ * @
		magnitude: -> Math.sqrt @floats().squares().sum()
		scale: (r) -> @map -> r * @
		add: (d) -> switch $.type(d)
			when "number" then @map -> d + @
			when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
		normalize: -> @scale(1/@magnitude())
	$.plugin
		provides: "string"
		depends: "function"
	, ->
		$.type.extend
			unknown:
				string: (o) -> o.toString?() ? String(o)
				repr: (o) -> $.type.lookup(o).string(o)
				number: (o) -> parseFloat String o
			null: { string: -> "null" }
			undefined: { string: -> "undefined" }
			string:
				number: parseFloat
			array:  { string: (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
			function:
				string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
			number:
				repr:   (n) -> String(n)
				string: (n) ->
					switch true
						when n.precision? then n.toPrecision(n.precision)
						when n.fixed? then n.toFixed(n.fixed)
						else String(n)
		return {
			$:
				toString: (x) ->
					if not x? then "function Bling(selector, context) { [ ... ] }"
					else $.type.lookup(x).string(x)
				toRepr: (x) -> $.type.lookup(x).repr(x)
				px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"
				capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")
				dashize: (name) ->
					ret = ""
					for i in [0...(name?.length|0)]
						c = name.charCodeAt i
						if 91 > c > 64
							c += 32
							ret += '-'
						ret += String.fromCharCode(c)
					ret
				camelize: (name) ->
					name.split('-')
					while (i = name?.indexOf('-')) > -1
						name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
					name
				padLeft: (s, n, c = " ") ->
					while s.length < n
						s = c + s
					s
				padRight: (s, n, c = " ") ->
					while s.length < n
						s = s + c
					s
				stringCount: (s, x, i = 0, n = 0) ->
					if (j = s.indexOf x,i) > i-1
						$.stringCount s, x, j+1, n+1
					else n
				stringSplice: (s, i, j, n) ->
					nn = s.length
					end = j
					if end < 0
						end += nn
					start = i
					if start < 0
						start += nn
					s.substring(0,start) + n + s.substring(end)
				checksum: (s) ->
					a = 1; b = 0
					for i in [0...s.length]
						a = (a + s.charCodeAt(i)) % 65521
						b = (b + a) % 65521
					(b << 16) | a
				repeat: (x, n=2) ->
					switch true
						when n is 1 then x
						when n < 1 then ""
						when $.is "string", x then x + $.repeat(x, n-1)
						else $(x).extend $.repeat(x, n-1)
				stringBuilder: ->
					if $.is("global", @) then return new $.stringBuilder()
					items = []
					@length   = 0
					@append   = (s) => items.push s; @length += s?.toString().length|0
					@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
					@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
					@toString = ( ) => items.join("")
					@
			toString: -> $.toString @
			toRepr: -> $.toRepr @
		}
	$.plugin
		provides: "function"
		depends: "hash"
	, ->
		$:
			identity: (o) -> o
			not: (f) -> -> not f.apply @, arguments
			compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
			and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
			once: (f, n=1) ->
				$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
					"exhausted",
						get: -> n <= 0
			cycle: (f...) ->
				i = -1
				-> f[i = ++i % f.length].apply @, arguments
			bound: (t, f, args = []) ->
				if $.is "function", f.bind
					args.splice 0, 0, t
					r = f.bind.apply f, args
				else
					r = (a...) -> f.apply t, (args if args.length else a)
			memoize: (f) ->
				cache = {}
	$.plugin
		provides: "hash"
		depends: "type"
	, ->
		$.type.extend
			unknown: { hash: (o) -> $.checksum $.toString o }
			object:  { hash: (o) ->
				$.hash(Object) +
					$($.hash(o[k]) for k of o).sum() +
					$.hash Object.keys o
			}
			array:   { hash: (o) ->
				$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
					(a*a)+(x|0)
				, 1
			}
			bool:    { hash: (o) -> parseInt(1 if o) }
		return {
			$:
				hash: (x) -> $.type.lookup(x).hash(x)
			hash: -> $.hash @
		}
	$.plugin
		provides: "pubsub"
	, ->
		return {
			$:
				publish: (e, args...) ->
					f.apply null, args for f in (subscribers[e] or= [])
					args
				publisher: (e, func) ->
					(args...) ->
						func.apply @, args
						$.publish e, args
				subscribe: (e, func) ->
					(subscribers[e] or= []).push func
					func
				unsubscribe: (e, func) ->
					if not func?
						subscribers[e] = []
					else
						a = (subscribers[e] or= [])
						if (i = a.indexOf func)  > -1
							a.splice(i,i)
		}
	$.plugin
		provides: "throttle"
		depends: "core"
	, ->
		$:
			throttle: (f,n=250,last=0) ->
				(a...) ->
					gap = $.now - last
					if gap > n
						last += gap
						return f.apply @,a
					null
				(a...) ->
					last += (gap = $.now - last)
					return f.apply @,a if gap > n else null
	$.plugin
		provides: "EventEmitter"
	, ->
		$: EventEmitter: $.pipe("bling-init").append (obj) ->
			listeners = {}
			list = (e) -> (listeners[e] or= [])
			inherit {
				emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
				addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
				on:                 (e, h) -> @addListener e, h
				removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
				removeAllListeners: (e) -> listeners[e] = []
				listeners:          (e) -> list(e).slice 0
			}, obj
(($) ->
	$.plugin
		provides: "cartesian"
	, ->
		$:
			cartesian: (sets...) ->
				n = sets.length
				ret = []
				helper = (cur, i) ->
					(return ret.push cur) if ++i >= n
					for x in sets[i]
						helper (cur.concat x), i
					null
				helper [], -1
				return $(ret)
)(Bling)
(($) ->
	$.plugin
		provides: 'config'
	, ->
		get = (name, def) -> process.env[name] ? def
		$: config: $.extend(get, get: get)
)(Bling)
(($) ->
	$.plugin
		provides: "date"
	, ->
		[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]
		units = {
			ms, s, m, h, d,
			sec: s
			second: s
			seconds: s
			min: m
			minute: m
			minutes: m
			hr: h
			hour: h
			hours: h
			day: d
			days: d
		}
		formats =
			yyyy: Date::getUTCFullYear
			mm: -> @getUTCMonth() + 1
			dd: Date::getUTCDate
			HH: Date::getUTCHours
			MM: Date::getUTCMinutes
			SS: Date::getUTCSeconds
			MS: Date::getUTCMilliseconds
		format_keys = Object.keys(formats).sort().reverse()
		parsers =
			yyyy: Date::setUTCFullYear
			mm: (x) -> @setUTCMonth(x - 1)
			dd: Date::setUTCDate
			HH: Date::setUTCHours
			MM: Date::setUTCMinutes
			SS: Date::setUTCSeconds
			MS: Date::setUTCMilliseconds
		parser_keys = Object.keys(parsers).sort().reverse()
		floor = Math.floor
		$.type.register "date",
			match: (o) -> $.isType Date, o
			array: (o) -> [o]
		adder = (key) ->
			(stamp, delta, stamp_unit = $.date.defaultUnit) ->
				date = $.date.unstamp(stamp, stamp_unit)
				parsers[key].call date, (formats[key].call date) + delta
				$.date.stamp date, stamp_unit
		$:
			date:
				defaultUnit: "s"
				defaultFormat: "yyyy-mm-dd HH:MM:SS"
				stamp: (date = new Date, unit = $.date.defaultUnit) ->
					floor (date / units[unit])
				unstamp: (stamp, unit = $.date.defaultUnit) ->
					new Date floor(stamp * units[unit])
				convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
					(floor stamp * units[from] / units[to])
				midnight: (stamp, unit = $.date.defaultUnit) ->
					$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
				format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
					date = $.date.unstamp stamp, unit
					for k in format_keys
						fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
					fmt
				parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
					date = new Date(0)
					for i in [0...fmt.length] by 1
						for k in parser_keys
							if fmt.indexOf(k, i) is i
								try
									parsers[k].call date,
										parseInt dateString[i...i+k.length], 10
								catch err
					$.date.stamp date, to
				addMilliseconds: adder("MS")
				addSeconds: adder("SS")
				addMinutes: adder("MM")
				addHours: adder("HH")
				addDays: adder("dd")
				addMonths: adder("mm")
				addYears: adder("yyyy")
				range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
					add = adder(interval_unit)
					ret = [from]
					while (cur = ret[ret.length-1]) < to
						ret.push add(cur, interval, stamp_unit)
					ret
	
		midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
		unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
		stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
		dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
		dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)
)(Bling)
(($) ->
	$.plugin
		provides: "delay"
		depends: "function"
	, ->
		$:
			delay: (->
				timeoutQueue = $.extend [], (->
					next = (a) -> -> a.shift()() if a.length
					add: (f, n) ->
						f.order = n + $.now
						for i in [0..@length] by 1
							if i is @length or @[i].order > f.order
								@splice i,0,f
								break
						setTimeout next(@), n
						@
					cancel: (f) ->
						for i in [0...@length] by 1
							if @[i] == f
								@splice i, 1
								break
						@
				)()
				(n, f) ->
					if $.is("function",f) then timeoutQueue.add(f, n)
					cancel: -> timeoutQueue.cancel(f)
			)()
		delay: (n, f, c=@) ->
			$.delay n, $.bound(c, f)
			@
)(Bling)
(($) ->
	if $.global.document?
		$.plugin
			depends: "function"
			provides: "dom"
		, ->
			$.type.register "nodelist",
				match:  (o) -> o? and $.isType "NodeList", o
				hash:   (o) -> $($.hash(i) for i in x).sum()
				array:  $.identity
				string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
				node:   (o) -> $(o).toFragment()
			$.type.register "node",
				match:  (o) -> o?.nodeType > 0
				hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "fragment",
				match:  (o) -> o?.nodeType is 11
				hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "html",
				match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
				node:   (h) ->
					(node = document.createElement('div')).innerHTML = h
					if n = (childNodes = node.childNodes).length is 1
						return node.removeChild(childNodes[0])
					df = document.createDocumentFragment()
					df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
					df
				array:  (o,c) -> $.type.lookup(h = Bling.HTML.parse o).array h, c
				repr:   (o) -> '"' + o + '"'
			$.type.extend
				unknown:  { node: -> null }
				bling:    { node: (o) -> o.toFragment() }
				node:     { html: (n) ->
					d = document.createElement "div"
					d.appendChild (n = n.cloneNode true)
					ret = d.innerHTML
					ret
				}
				string:
					node:  (o) -> $(o).toFragment()
					array: (o,c) -> c.querySelectorAll?(o)
				function: { node: (o) -> $(o.toString()).toFragment() }
			toFrag = (a) ->
				if not a.parentNode?
					df = document.createDocumentFragment()
					df.appendChild(a)
				a
			before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
			after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
			toNode = (x) -> $.type.lookup(x).node(x)
			escaper = false
			parser = false
			computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue(k)
			getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select(p)
			selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )
			return {
				$:
					HTML:
						parse: (h) -> $.type.lookup(h).node(h)
						stringify: (n) -> $.type.lookup(n).html(n)
						escape: (h) ->
							escaper or= $("<div>&nbsp;</div>").child(0)
							ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
							escaper.zap('data', '')
							ret
				html: (h) ->
					return switch $.type h
						when "undefined","null" then @select 'innerHTML'
						when "string" then @zap 'innerHTML', h
						when "bling" then @html h.toFragment()
						when "node"
								@replaceChild @childNodes[0], h
								while @childNodes.length > 1
									@removeChild @childNodes[1]
					@each -> @appendChild x.cloneNode true
					clones = @map( -> @cloneNode true)
					i = 0
					$(x).each -> @appendChild clones[i++]
					clones
					if x?
						x = toNode(x)
						@take(1).each ->
							before @childNodes[0], x
						@skip(1).each ->
							before @childNodes[0], x.cloneNode(true)
					@
					if x?
						$(x).prepend(@)
					@
					if x?
						x = toNode(x)
						@take(1).each -> before @, x
						@skip(1).each -> before @, x.cloneNode(true)
					@
					if x?
						x = toNode(x)
						@take(1).each -> after @, x
						@skip(1).each -> after @, x.cloneNode(true)
					@
					parent = toNode(parent)
					if $.is "fragment", parent
						throw new Error("cannot call .wrap() with a fragment as the parent")
					@each (child) ->
						if ($.is "fragment", child) or not child.parentNode
							return parent.appendChild child
						grandpa = child.parentNode
						marker = document.createElement "dummy"
						parent.appendChild grandpa.replaceChild marker, child
						grandpa.replaceChild parent, marker
					@each ->
						if @parentNode and @parentNode.parentNode
							@parentNode.parentNode.replaceChild(@, @parentNode)
						else if @parentNode
							@parentNode.removeChild(@)
					n = toNode(n)
					clones = @map(-> n.cloneNode true)
					for i in [0...clones.length] by 1
						@[i].parentNode?.replaceChild clones[i], @[i]
					clones
					return switch v
						when undefined then @select("getAttribute").call(a, v)
						when null then @select("removeAttribute").call(a, v)
						else
							@select("setAttribute").call(a, v)
							@
					notempty = (y) -> y isnt ""
					@removeClass(x).each ->
						c = @className.split(" ").filter notempty
						c.push(x)
						@className = c.join " "
					notx = (y) -> y != x
					@each ->
						c = @className.split(" ").filter(notx).join(" ")
						if c.length is 0
							@removeAttribute('class')
					notx = (y) -> y isnt x
					@each ->
						cls = @className.split(" ")
						filter = $.not $.isEmpty
						if( cls.indexOf(x) > -1 )
							filter = $.and notx, filter
						else
							cls.push(x)
						c = cls.filter(filter).join(" ")
						@className = c
						if c.length is 0
							@removeAttribute('class')
					@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1
					return @zap('textContent', t) if t?
					return @select('textContent')
					return @zap('value', v) if v?
					return @select('value')
				css: (k,v) ->
					if v? or $.is "object", k
						setter = @select 'style.setProperty'
						if $.is "object", k then setter.call i, k[i], "" for i of k
						else if $.is "string", v then setter.call k, v, ""
						else if $.is "array", v
							setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
						return @
					else
						cv = @map computeCSSProperty(k)
						ov = @select('style').select k
						ov.weave(cv).fold (x,y) -> x or y
				defaultCss: (k, v) ->
					sel = @selector
					style = ""
					if $.is "string", k
						if $.is "string", v
						else throw Error("defaultCss requires a value with a string key")
					else if $.is "object", k
						"} "
					$("<style></style>").text(style).appendTo("head")
					@
				rect: -> @select('getBoundingClientRect').call()
				width: getOrSetRect("width")
				height: getOrSetRect("height")
				top: getOrSetRect("top")
				left: getOrSetRect("left")
				bottom: getOrSetRect("bottom")
				right: getOrSetRect("right")
				position: (left, top) ->
					switch true
						when not left? then @rect()
						when not top? then @css("left", $.px(left))
						else @css({top: $.px(top), left: $.px(left)})
				scrollToCenter: ->
					document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
					@
				child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]
				parents: selectChain('parentNode')
				prev: selectChain('previousSibling')
				next: selectChain('nextSibling')
				remove: -> @each -> @parentNode?.removeChild(@)
				find: (css) ->
					@filter("*")
						.map( -> $(css, @) )
						.flatten()
				clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @
				toFragment: ->
					if @length > 1
						df = document.createDocumentFragment()
						(@map toNode).map $.bound df, df.appendChild
						return df
					return toNode @[0]
			}
)(Bling)
(($) ->
	$.plugin
		depends: "dom,function,core"
		provides: "event"
	, ->
		EVENTSEP_RE = /,* +/
		events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
			'load','unload','reset','submit','keyup','keydown','change',
			'abort','cut','copy','paste','selection','drag','drop','orientationchange',
			'touchstart','touchmove','touchend','touchcancel',
			'gesturestart','gestureend','gesturecancel',
			'hashchange'
		]
		binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)
		register_live = (selector, context, evt, f, h) ->
			$(context).bind(evt, h)
				.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h
		unregister_live = (selector, context, e, f) ->
			$c = $(context)
			$c.each ->
				a = (@__alive__ or= {})
				b = (a[selector] or= {})
				c = (b[e] or= {})
				$c.unbind(e, c[f])
				delete c[f]
		triggerReady = $.once ->
			$(document).trigger("ready").unbind("ready")
			document.removeEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.removeEventListener?("load", triggerReady, false)
		bindReady = $.once ->
			document.addEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.addEventListener?("load", triggerReady, false)
		bindReady()
		ret = {
			bind: (e, f) ->
				c = (e or "").split(EVENTSEP_RE)
				h = (evt) ->
					ret = f.apply @, arguments
					if ret is false
						evt.preventAll()
					ret
				@each -> (@addEventListener i, h, false) for i in c
			unbind: (e, f) ->
				c = (e or "").split EVENTSEP_RE
				@each -> (@removeEventListener i, f, null) for i in c
			trigger: (evt, args = {}) ->
				args = $.extend
					bubbles: true
					cancelable: true
				, args
				for evt_i in (evt or "").split(EVENTSEP_RE)
						e = document.createEvent "MouseEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							button: 0,
							relatedTarget: null
						, args
						e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.button, args.relatedTarget
						e = document.createEvent "UIEvents"
						e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1
						e = document.createEvent "TouchEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							touches: [],
							targetTouches: [],
							changedTouches: [],
							scale: 1.0,
							rotation: 0.0
						, args
						e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)
						e = document.createEvent "GestureEvents"
						args = $.extend {
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							target: null,
							scale: 1.0,
							rotation: 0.0
						}, args
						e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.target, args.scale, args.rotation
					else
						e = document.createEvent "Events"
						e.initEvent evt_i, args.bubbles, args.cancelable
						try
							e = $.extend e, args
						catch err
					if not e
						continue
					else
						try
							@each -> @dispatchEvent e
						catch err
							$.log "dispatchEvent error:", err
				@
			live: (e, f) ->
				selector = @selector
				context = @context
				handler = (evt) ->
					$(selector, context)
						.intersect($(evt.target).parents().first().union($(evt.target)))
						.each -> f.call(evt.target = @, evt)
				register_live selector, context, e, f, handler
				@
			die: (e, f) ->
				$(@context).unbind e, unregister_live(@selector, @context, e, f)
				@
			click: (f = {}) ->
				if @css("cursor") in ["auto",""]
					@css "cursor", "pointer"
				if $.is "function", f then @bind 'click', f
				else @trigger 'click', f
				@
			ready: (f) ->
				return (f.call @) if triggerReady.exhausted
				@bind "ready", f
		}
		events.forEach (x) -> ret[x] = binder(x)
		return ret
)(Bling)
(($) ->
	$.plugin ->
		$:
			histogram: (data, bucket_width=1, output_width=80) ->
				buckets = $()
				len = 0
				for x in data
					i = Math.floor( x / bucket_width )
					buckets[i] ?= 0
					buckets[i] += 1
					len = Math.max(len, i+1)
				buckets.length = len
				max = buckets.max()
				buckets = buckets.map((x) -> x or 0)
					.scale(1/max)
					.scale(output_width)
				sum = buckets.sum()
				ret = ""
				for n in [0...len] by 1
					end = (n+1) * bucket_width
					pct = (buckets[n]*100/sum).toFixed(0)
				ret
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->
		$.type.register "http",
			match: (o) -> $.isType 'XMLHttpRequest', o
			array: (o) -> [o]
		return {
			$:
				http: (url, opts = {}) ->
					xhr = new XMLHttpRequest()
					if $.is "function", opts
						opts = success: $.bound(xhr, opts)
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts
					opts.state = $.bound(xhr, opts.state)
					opts.success = $.bound(xhr, opts.success)
					opts.error = $.bound(xhr, opts.error)
					if opts.data and opts.method is "GET"
						url += "?" + formencode(opts.data)
					else if opts.data and opts.method is "POST"
						opts.data = formencode(opts.data)
					xhr.open(opts.method, url, opts.async)
					xhr = $.extend xhr,
						asBlob: opts.asBlob
						timeout: opts.timeout
						followRedirects: opts.followRedirects
						withCredentials: opts.withCredentials
						onreadystatechange: ->
							opts.state?()
							if xhr.readyState is 4
								if xhr.status is 200
									opts.success xhr.responseText
								else
									opts.error xhr.status, xhr.statusText
					xhr.send opts.data
					return $(xhr)
				post: (url, opts = {}) ->
					if $.is("function",opts)
						opts = success: opts
					opts.method = "POST"
					$.http(url, opts)
				get: (url, opts = {}) ->
					if( $.is("function",opts) )
						opts = success: opts
					opts.method = "GET"
					$.http(url, opts)
		}
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "lazy"
	, ->
		lazy_load = (elementName, props) ->
			$("head").append $.extend document.createElement(elementName), props
		$:
			script: (src) ->
				lazy_load "script", { src: src }
			style: (src) ->
				lazy_load "link", { href: src, rel: "stylesheet" }
)(Bling)
(($) ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""
		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615
		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)
			index = (index + 1) % 624
			(y + a) / b
		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()
		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
	)()
	$.plugin
		provides: "random"
	, ->
		$:
			random: random
)(Bling)
(($) ->
	$.plugin
		provides: "sendgrid"
		depends: "config"
	, ->
		try
			nodemailer = require 'nodemailer'
		catch err
			`return`
		transport = nodemailer.createTransport 'SMTP',
			service: 'SendGrid'
			auth:
				user: $.config.get 'SENDGRID_USERNAME'
		$:
			sendMail: (mail, callback) ->
				mail.transport ?= transport
				mail.from ?= $.config.get 'EMAILS_FROM'
				mail.bcc ?= $.config.get 'EMAILS_BCC'
				if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
					nodemailer.sendMail mail, callback
				else
)(Bling)
(($) ->
	$.plugin
		provides: "StateMachine"
	, ->
		$: StateMachine: class StateMachine
			constructor: (stateTable) ->
				@debug = false
				@reset()
				@table = stateTable
				Object.defineProperty @, "modeline",
					get: -> @table[@_mode]
				Object.defineProperty @, "mode",
					set: (m) ->
						@_lastMode = @_mode
						@_mode = m
						if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
							ret = @modeline['enter'].call @
							while $.is("function",ret)
								ret = ret.call @
						m
					get: -> @_mode
			reset: ->
				@_mode = null
				@_lastMode = null
			GO: (m) -> -> @mode = m
			@GO: (m) -> -> @mode = m
			
			tick: (c) ->
				row = @modeline
				if not row?
					ret = null
				else if c of row
					ret = row[c]
				else if 'def' of row
					ret = row['def']
				while $.is "function",ret
					ret = ret.call @, c
				ret
			run: (inputs) ->
				@mode = 0
				for c in inputs
					ret = @tick(c)
				if $.is "function",@modeline?.eof
					ret = @modeline.eof.call @
				while $.is "function",ret
					ret = ret.call @
				@reset()
				return @
	$.plugin
		provides: "synth"
		depends: "StateMachine"
	, ->
		class SynthMachine extends $.StateMachine
			basic =
				".": @GO 3
				"[": @GO 4
				'"': @GO 6
				"'": @GO 7
				" ": @GO 8
				",": @GO 10
				"+": @GO 11
				eof: @GO 13
			@STATE_TABLE = [
					enter: ->
						@tag = @id = @cls = @attr = @val = @text = ""
						@attrs = {}
						@GO 1
				},
					def: (c) -> @tag += c
				}, basic),
					def: (c) -> @id += c
				}, basic),
					enter: -> @cls += " " if @cls.length > 0
					def: (c) -> @cls += c
				}, basic),
					"=": @GO 5
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @attr += c
					eof: @GO 12
				},
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @val += c
					eof: @GO 12
				},
					'"': @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					"'": @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					enter: ->
						@emitNode() if @tag
						@emitText() if @text
						@GO 0
				},
					enter: ->
						@emitNode()
						@cursor = null
						@GO 0
				},
					enter: ->
						@emitNode()
						@cursor = @cursor?.parentNode
						@GO 0
				},
				},
					enter: ->
						@emitNode() if @tag
						@emitText() if @text
				}
			]
			constructor: ->
				super(SynthMachine.STATE_TABLE)
				@fragment = @cursor = document.createDocumentFragment()
			emitNode: ->
				if @tag
					node = document.createElement @tag
					node.id = @id or null
					node.className = @cls or null
					for k of @attrs
						node.setAttribute k, @attrs[k]
					@cursor.appendChild node
					@cursor = node
			emitText: ->
				@cursor.appendChild $.type.lookup("<html>").node(@text)
				@text = ""
		return {
			$:
				synth: (expr) ->
					s = new SynthMachine()
					s.run(expr)
					if s.fragment.childNodes.length == 1
						$(s.fragment.childNodes[0])
					else
						$(s.fragment)
		}
)(Bling)
(($) ->
		current_engine = null
		engines = {}
		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine
		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()
		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop]
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1
	$.template.register_engine 'pythonic', (() ->
		chunk_re = /%[\(\/]/
		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n]
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}
			if not cache?
			n = cache.length
			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""
		return render
	)()
		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
)(Bling)
(($) ->
		parseOne = (data) ->
			i = data.indexOf ":"
			if i > 0
				len = parseInt data[0...i], 10
				item = data[i+1...i+1+len]
				type = data[i+1+len]
				extra = data[i+len+2...]
				item = switch type
					when "'" then String(item)
					when "!" then (item is "true")
					when "~" then null
					when "]" then parseArray(item)
					when "}" then parseObject(item)
				return [item, extra]
			return undefined
		parseArray = (x) ->
			data = []
			while x.length > 0
				[one, x] = parseOne(x)
				data.push(one)
			data
		parseObject = (x) ->
			data = {}
			while x.length > 0
				[key, x] = parseOne(x)
				[value, x] = parseOne(x)
				data[key] = value
			data
		$:
			TNET:
				stringify: (x) ->
					[data, type] = switch $.type x
						when "string" then [x, "'"]
						when "function" then [String(x), "'"]
						when "boolean" then [String(not not x), "!"]
						when "null" then ["", "~"]
						when "undefined" then ["", "~"]
						when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
						when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
					return (data.length|0) + ":" + data + type
				parse: (x) ->
					parseOne(x)?[0]
)(Bling)
(($) ->
	$.plugin
		provides: "trace"
		depends: "function,type"
	, ->
		$.type.extend
			unknown: { trace: $.identity }
			function:
				trace: (label, f, tracer) ->
					label or= f.name
					r = (a...) ->
						f.apply @, a
					r
		return $: trace: (label, o, tracer) ->
			if not $.is "string", label
				[tracer, o] = [o, label]
			tracer or= $.log
			label or= ""
			$.type.lookup(o).trace(label, o, tracer)
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
	, ->
		COMMASEP = ", "
			"slow": 700
			"medium": 500
			"normal": 300
			"fast": 100
			"instant": 0
			"now": 0
		accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
		testStyle = document.createElement("div").style
		transformProperty = "transform"
		transitionProperty = "transition-property"
		transitionDuration = "transition-duration"
		transitionTiming = "transition-timing-function"
		if "WebkitTransform" of testStyle
			transformProperty = "-webkit-transform"
			transitionProperty = "-webkit-transition-property"
			transitionDuration = "-webkit-transition-duration"
			transitionTiming = "-webkit-transition-timing-function"
		else if "MozTransform" of testStyle
			transformProperty = "-moz-transform"
			transitionProperty = "-moz-transition-property"
			transitionDuration = "-moz-transition-duration"
			transitionTiming = "-moz-transition-timing-function"
		else if "OTransform" of testStyle
			transformProperty = "-o-transform"
			transitionProperty = "-o-transition-property"
			transitionDuration = "-o-transition-duration"
			transitionTiming = "-o-transition-timing-function"
		return {
			$:
				duration: (speed) ->
					d = speeds[speed]
					return d if d?
					return parseFloat speed
			transform: (end_css, speed, easing, callback) ->
				if $.is("function",speed)
					callback = speed
					speed = easing = null
				else if $.is("function",easing)
					callback = easing
					easing = null
				speed ?= "normal"
				easing or= "ease"
				duration = $.duration(speed) + "ms"
				props = []
				trans = ""
				css = {}
				for i of end_css
					if accel_props_re.test(i)
						ii = end_css[i]
						if ii.join
							ii = $(ii).px().join COMMASEP
						else if ii.toString
							ii = ii.toString()
						trans += " " + i + "(" + ii + ")"
					else css[i] = end_css[i]
				(props.push i) for i of css
				if trans
					props.push transformProperty
				css[transitionProperty] = props.join COMMASEP
				css[transitionDuration] = props.map(-> duration).join COMMASEP
				css[transitionTiming] = props.map(-> easing).join COMMASEP
				if trans
					css[transformProperty] = trans
				@css css
				@delay duration, callback
				@each ->
					if @style
						if @style.display is not "none"
							@_display = @syle.display
						@style.display = "none"
				.trigger "hide"
				.delay updateDelay, callback
				@each ->
					if @style
						@style.display = @_display
						delete @_display
				.trigger "show"
				.delay updateDelay, callback
				@weave(@css("display"))
					.fold (display, node) ->
						if display is "none"
							node.style.display = node._display or ""
							delete node._display
							$(node).trigger "show"
						else
							node._display = display
							node.style.display = "none"
							$(node).trigger "hide"
						node
					.delay(updateDelay, callback)
				@.css('opacity','0.0')
					.show ->
						@transform {
							opacity:"1.0",
							translate3d: [0,0,0]
						}, speed, callback
				@transform {
					opacity:"0.0",
					translate3d:[x,y,0.0]
				}, speed, -> @hide(callback)
			fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
			fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
			fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
			fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
		}
)(Bling)
(($) ->
	$.plugin
		provides: "unittest"
		depends: "core,function"
	, ->
		testCount = passCount = failCount = 0
		failed = []
		invokeTest = (group, name, func) ->
			return if not $.is "function", func
			shouldFail = name.toLowerCase().indexOf("fail") isnt -1
			done = $.once (err) ->
				testCount--
				if (!!err isnt shouldFail)
					failCount++
					failed.push name
				else
					_log "pass"
					passCount++
					$.provide name
			f = (done) ->
				try func(done)
				catch err then done(err)
				finally
					if name.toLowerCase().indexOf("async") is -1 then done()
			testCount++
			try f(done)
			catch err then done(err)
		testReport = $.once ->
		$:
			approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
			assertEqual: (a, b, label) ->
				if a isnt b
			assertArrayEqual: (a, b, label) ->
				for i in [0...a.length] by 1
					try
						$.assertEqual(a[i], b[i], label)
					catch err
			testGroup: (name, funcs) ->
				interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
				for k,func of funcs
					invokeTest(name, k, func)
		assertEqual: (args...) ->
					if $.is "function", x then x.call(@,@) else x
				a = args[0]
				for i in [1...args.length]
					$.assertEqual a, args[i]
			return @
)(Bling)
(($) ->
	$.plugin
		provides: "cartesian"
	, ->
		$:
			cartesian: (sets...) ->
				n = sets.length
				ret = []
				helper = (cur, i) ->
					(return ret.push cur) if ++i >= n
					for x in sets[i]
						helper (cur.concat x), i
					null
				helper [], -1
				return $(ret)

)(Bling)
(($) ->
	$.plugin
		provides: 'config'
	, ->
		get = (name, def) -> process.env[name] ? def
		$: config: $.extend(get, get: get)
)(Bling)

(($) ->
	$.plugin
		provides: "date"
	, ->
		[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]

		units = {
			ms, s, m, h, d,
			sec: s
			second: s
			seconds: s
			min: m
			minute: m
			minutes: m
			hr: h
			hour: h
			hours: h
			day: d
			days: d
		}

		formats =
			yyyy: Date::getUTCFullYear
			mm: -> @getUTCMonth() + 1
			dd: Date::getUTCDate
			HH: Date::getUTCHours
			MM: Date::getUTCMinutes
			SS: Date::getUTCSeconds
			MS: Date::getUTCMilliseconds
		format_keys = Object.keys(formats).sort().reverse()

		parsers =
			yyyy: Date::setUTCFullYear
			mm: (x) -> @setUTCMonth(x - 1)
			dd: Date::setUTCDate
			HH: Date::setUTCHours
			MM: Date::setUTCMinutes
			SS: Date::setUTCSeconds
			MS: Date::setUTCMilliseconds
		parser_keys = Object.keys(parsers).sort().reverse()

		floor = Math.floor

		$.type.register "date",
			match: (o) -> $.isType Date, o
			array: (o) -> [o]

		adder = (key) ->
			(stamp, delta, stamp_unit = $.date.defaultUnit) ->
				date = $.date.unstamp(stamp, stamp_unit)
				parsers[key].call date, (formats[key].call date) + delta
				$.date.stamp date, stamp_unit

		$:
			date:
				defaultUnit: "s"
				defaultFormat: "yyyy-mm-dd HH:MM:SS"
				stamp: (date = new Date, unit = $.date.defaultUnit) ->
					floor (date / units[unit])
				unstamp: (stamp, unit = $.date.defaultUnit) ->
					new Date floor(stamp * units[unit])
				convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
					(floor stamp * units[from] / units[to])
				midnight: (stamp, unit = $.date.defaultUnit) ->
					$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
				format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
					date = $.date.unstamp stamp, unit
					for k in format_keys
						fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
					fmt
				parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
					date = new Date(0)
					for i in [0...fmt.length] by 1
						for k in parser_keys
							if fmt.indexOf(k, i) is i
								try
									parsers[k].call date,
										parseInt dateString[i...i+k.length], 10
								catch err
					$.date.stamp date, to
				addMilliseconds: adder("MS")
				addSeconds: adder("SS")
				addMinutes: adder("MM")
				addHours: adder("HH")
				addDays: adder("dd")
				addMonths: adder("mm")
				addYears: adder("yyyy")
				range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
					add = adder(interval_unit)
					ret = [from]
					while (cur = ret[ret.length-1]) < to
						ret.push add(cur, interval, stamp_unit)
					ret
	
		midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
		unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
		stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
		dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
		dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)

)(Bling)

(($) ->

	$.plugin
		provides: "delay"
		depends: "function"
	, ->
		$:
			delay: (->
				timeoutQueue = $.extend [], (->
					next = (a) -> -> a.shift()() if a.length
					add: (f, n) ->
						f.order = n + $.now
						for i in [0..@length] by 1
							if i is @length or @[i].order > f.order
								@splice i,0,f
								break
						setTimeout next(@), n
						@
					cancel: (f) ->
						for i in [0...@length] by 1
							if @[i] == f
								@splice i, 1
								break
						@
				)()

				(n, f) ->
					if $.is("function",f) then timeoutQueue.add(f, n)
					cancel: -> timeoutQueue.cancel(f)

			)()

		delay: (n, f, c=@) ->
			$.delay n, $.bound(c, f)
			@

)(Bling)
(($) ->
	if $.global.document?
		$.plugin
			depends: "function"
			provides: "dom"
		, ->
			$.type.register "nodelist",
				match:  (o) -> o? and $.isType "NodeList", o
				hash:   (o) -> $($.hash(i) for i in x).sum()
				array:  $.identity
				string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
				node:   (o) -> $(o).toFragment()
			$.type.register "node",
				match:  (o) -> o?.nodeType > 0
				hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "fragment",
				match:  (o) -> o?.nodeType is 11
				hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "html",
				match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
				node:   (h) ->
					(node = document.createElement('div')).innerHTML = h
					if n = (childNodes = node.childNodes).length is 1
						return node.removeChild(childNodes[0])
					df = document.createDocumentFragment()
					df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
					df
				array:  (o,c) -> $.type.lookup(h = Bling.HTML.parse o).array h, c
				repr:   (o) -> '"' + o + '"'
			$.type.extend
				unknown:  { node: -> null }
				bling:    { node: (o) -> o.toFragment() }
				node:     { html: (n) ->
					d = document.createElement "div"
					d.appendChild (n = n.cloneNode true)
					ret = d.innerHTML
					ret
				}
				string:
					node:  (o) -> $(o).toFragment()
					array: (o,c) -> c.querySelectorAll?(o)
				function: { node: (o) -> $(o.toString()).toFragment() }

			toFrag = (a) ->
				if not a.parentNode?
					df = document.createDocumentFragment()
					df.appendChild(a)
				a
			before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
			after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
			toNode = (x) -> $.type.lookup(x).node(x)
			escaper = false
			parser = false

			computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue(k)

			getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select(p)

			selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )

			return {
				$:

					HTML:
						parse: (h) -> $.type.lookup(h).node(h)
						stringify: (n) -> $.type.lookup(n).html(n)
						escape: (h) ->
							escaper or= $("<div>&nbsp;</div>").child(0)
							ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
							escaper.zap('data', '')
							ret

				html: (h) ->
					return switch $.type h
						when "undefined","null" then @select 'innerHTML'
						when "string" then @zap 'innerHTML', h
						when "bling" then @html h.toFragment()
						when "node"
								@replaceChild @childNodes[0], h
								while @childNodes.length > 1
									@removeChild @childNodes[1]

					@each -> @appendChild x.cloneNode true

					clones = @map( -> @cloneNode true)
					i = 0
					$(x).each -> @appendChild clones[i++]
					clones

					if x?
						x = toNode(x)
						@take(1).each ->
							before @childNodes[0], x
						@skip(1).each ->
							before @childNodes[0], x.cloneNode(true)
					@

					if x?
						$(x).prepend(@)
					@

					if x?
						x = toNode(x)
						@take(1).each -> before @, x
						@skip(1).each -> before @, x.cloneNode(true)
					@

					if x?
						x = toNode(x)
						@take(1).each -> after @, x
						@skip(1).each -> after @, x.cloneNode(true)
					@

					parent = toNode(parent)
					if $.is "fragment", parent
						throw new Error("cannot call .wrap() with a fragment as the parent")
					@each (child) ->
						if ($.is "fragment", child) or not child.parentNode
							return parent.appendChild child
						grandpa = child.parentNode
						marker = document.createElement "dummy"
						parent.appendChild grandpa.replaceChild marker, child
						grandpa.replaceChild parent, marker

					@each ->
						if @parentNode and @parentNode.parentNode
							@parentNode.parentNode.replaceChild(@, @parentNode)
						else if @parentNode
							@parentNode.removeChild(@)

					n = toNode(n)
					clones = @map(-> n.cloneNode true)
					for i in [0...clones.length] by 1
						@[i].parentNode?.replaceChild clones[i], @[i]
					clones

					return switch v
						when undefined then @select("getAttribute").call(a, v)
						when null then @select("removeAttribute").call(a, v)
						else
							@select("setAttribute").call(a, v)
							@


					notempty = (y) -> y isnt ""
					@removeClass(x).each ->
						c = @className.split(" ").filter notempty
						c.push(x)
						@className = c.join " "

					notx = (y) -> y != x
					@each ->
						c = @className.split(" ").filter(notx).join(" ")
						if c.length is 0
							@removeAttribute('class')

					notx = (y) -> y isnt x
					@each ->
						cls = @className.split(" ")
						filter = $.not $.isEmpty
						if( cls.indexOf(x) > -1 )
							filter = $.and notx, filter
						else
							cls.push(x)
						c = cls.filter(filter).join(" ")
						@className = c
						if c.length is 0
							@removeAttribute('class')

					@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1

					return @zap('textContent', t) if t?
					return @select('textContent')

					return @zap('value', v) if v?
					return @select('value')

				css: (k,v) ->
					if v? or $.is "object", k
						setter = @select 'style.setProperty'
						if $.is "object", k then setter.call i, k[i], "" for i of k
						else if $.is "string", v then setter.call k, v, ""
						else if $.is "array", v
							setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
						return @
					else
						cv = @map computeCSSProperty(k)
						ov = @select('style').select k
						ov.weave(cv).fold (x,y) -> x or y

				defaultCss: (k, v) ->
					sel = @selector
					style = ""
					if $.is "string", k
						if $.is "string", v
						else throw Error("defaultCss requires a value with a string key")
					else if $.is "object", k
						"} "
					$("<style></style>").text(style).appendTo("head")
					@

				rect: -> @select('getBoundingClientRect').call()

				width: getOrSetRect("width")

				height: getOrSetRect("height")

				top: getOrSetRect("top")

				left: getOrSetRect("left")

				bottom: getOrSetRect("bottom")

				right: getOrSetRect("right")

				position: (left, top) ->
					switch true
						when not left? then @rect()
						when not top? then @css("left", $.px(left))
						else @css({top: $.px(top), left: $.px(left)})

				scrollToCenter: ->
					document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
					@

				child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]

				parents: selectChain('parentNode')

				prev: selectChain('previousSibling')

				next: selectChain('nextSibling')

				remove: -> @each -> @parentNode?.removeChild(@)

				find: (css) ->
					@filter("*")
						.map( -> $(css, @) )
						.flatten()

				clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @

				toFragment: ->
					if @length > 1
						df = document.createDocumentFragment()
						(@map toNode).map $.bound df, df.appendChild
						return df
					return toNode @[0]
			}
)(Bling)
(($) ->
	$.plugin
		depends: "dom,function,core"
		provides: "event"
	, ->
		EVENTSEP_RE = /,* +/
		events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
			'load','unload','reset','submit','keyup','keydown','change',
			'abort','cut','copy','paste','selection','drag','drop','orientationchange',
			'touchstart','touchmove','touchend','touchcancel',
			'gesturestart','gestureend','gesturecancel',
			'hashchange'
		]

		binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)

		register_live = (selector, context, evt, f, h) ->
			$(context).bind(evt, h)
				.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h

		unregister_live = (selector, context, e, f) ->
			$c = $(context)
			$c.each ->
				a = (@__alive__ or= {})
				b = (a[selector] or= {})
				c = (b[e] or= {})
				$c.unbind(e, c[f])
				delete c[f]

		triggerReady = $.once ->
			$(document).trigger("ready").unbind("ready")
			document.removeEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.removeEventListener?("load", triggerReady, false)
		bindReady = $.once ->
			document.addEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.addEventListener?("load", triggerReady, false)
		bindReady()

		ret = {
			bind: (e, f) ->
				c = (e or "").split(EVENTSEP_RE)
				h = (evt) ->
					ret = f.apply @, arguments
					if ret is false
						evt.preventAll()
					ret
				@each -> (@addEventListener i, h, false) for i in c

			unbind: (e, f) ->
				c = (e or "").split EVENTSEP_RE
				@each -> (@removeEventListener i, f, null) for i in c

			trigger: (evt, args = {}) ->
				args = $.extend
					bubbles: true
					cancelable: true
				, args

				for evt_i in (evt or "").split(EVENTSEP_RE)
						e = document.createEvent "MouseEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							button: 0,
							relatedTarget: null
						, args
						e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.button, args.relatedTarget

						e = document.createEvent "UIEvents"
						e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1

						e = document.createEvent "TouchEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							touches: [],
							targetTouches: [],
							changedTouches: [],
							scale: 1.0,
							rotation: 0.0
						, args
						e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)

						e = document.createEvent "GestureEvents"
						args = $.extend {
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							target: null,
							scale: 1.0,
							rotation: 0.0
						}, args
						e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.target, args.scale, args.rotation

					else
						e = document.createEvent "Events"
						e.initEvent evt_i, args.bubbles, args.cancelable
						try
							e = $.extend e, args
						catch err

					if not e
						continue
					else
						try
							@each -> @dispatchEvent e
						catch err
							$.log "dispatchEvent error:", err
				@

			live: (e, f) ->
				selector = @selector
				context = @context
				handler = (evt) ->
					$(selector, context)
						.intersect($(evt.target).parents().first().union($(evt.target)))
						.each -> f.call(evt.target = @, evt)
				register_live selector, context, e, f, handler
				@

			die: (e, f) ->
				$(@context).unbind e, unregister_live(@selector, @context, e, f)
				@

			click: (f = {}) ->
				if @css("cursor") in ["auto",""]
					@css "cursor", "pointer"
				if $.is "function", f then @bind 'click', f
				else @trigger 'click', f
				@

			ready: (f) ->
				return (f.call @) if triggerReady.exhausted
				@bind "ready", f
		}

		events.forEach (x) -> ret[x] = binder(x)
		return ret
)(Bling)

(($) ->
	$.plugin
		depends: "experimental"
	, ->
		pruners = {}
		register = (type, f) -> (pruners[type] = f)
		lookup = (obj) -> pruners[obj.t or obj.type]
		stack = []

		$.type.extend null,        { compact: (o) -> $.toString(o) }
		$.type.extend "undefined", { compact: (o) -> "" }
		$.type.extend "null",      { compact: (o) -> "" }
		$.type.extend "string",    { compact: $.identity }
		$.type.extend "array",     { compact: (o) -> (Object.Compact(x) for x in o).join("") }
		$.type.extend "bling",     { compact: (o) -> o.map(Object.Compact).join("") }
		$.type.extend "object",    { compact: (o) -> Object.Compact(lookup(o)?.call o, o) }

		Object.Compact = (o) ->
			stack.push(o)
			$.type.lookup(o)?.compact(o)
			stack.pop()
		$.extend Object.Compact,
			register: register
			lookup: lookup

		register 'page', -> [
			"<!DOCTYPE html><html><head>",
				@head,
			"</head><body>",
				@body,
			"</body></html>"
		]
		register 'text', -> @EN
		register 'link', ->
			a = $(["<a"])
			a.extend(" ",k,"='",@[k],"'") for k in ["href","name","target"] when k of @
			a.extend(">",node.content,"</a>")

		$.assert(Object.Compact({ t: "page", head: [], body: {type: "text", EN: "Hello World"} }) is
			"<!DOCTYPE html><html><head></head><body>Hello World</body></html>")

		return { name: "Compact" }
)(Bling)

(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'ClientRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts

				post: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "POST"
					$.http url, opts

				get: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "GET"
					$.http url, opts
		}
)(Bling)
(($) ->
		operatorHtml = "<span class='opr'>$&</span>"
		keywords = /\b[Ff]unction\b|\bvar\b|\.prototype\b|\.__proto__\b|\bString\b|\bArray\b|\bNumber\b|\bObject\b|\bbreak\b|\bcase\b|\bcontinue\b|\bdelete\b|\bdo\b|\bif\b|\belse\b|\bfinally\b|\binstanceof\b|\breturn\b|\bthrow\b|\btry\b|\btypeof\b|\btrue\b|\bfalse\b/g
		keywordHtml = "<span class='kwd'>$&</span>"
		allNumbers = /\d+\.*\d*/g
		numberHtml = "<span class='num'>$&</span>"
		blingSymbol = /\$(\(|\.)/g
		blingHtml = "<span class='bln'>$$</span>$1"
		tabs = /\t/g
		tabHtml = "&nbsp;&nbsp;"
		singlelineComment = /\/\/.*?(?:\n|$)/
		multilineComment = /\/\*(?:.|\n)*?\*\//
		commentHtml = (comment) ->
		quotedHtml = (quoted) ->

			a = s.indexOf('"', i)
			b = s.indexOf("'", i)
			a = s.length if a is -1
			b = s.length if b is -1
			return [null, -1] if a is b
			return ['"', a] if a < b
			return ["'", b]
			r = s.indexOf(q, i)
			while( s.charAt(r-1) is "\\" and 0 < r < s.length)
				r = s.indexOf(q, r+1)
			r
			i = 0
			n = s.length
			ret = []
			if not Object.IsString(s)
				if not Object.IsFunction(s.toString)
					throw TypeError("invalid string argument to split_quoted")
				else
					s = s.toString()
					n = s.length
			while( i < n )
				q = firstQuote(s, i)
				j = q[1]
				if( j is -1 )
					ret.push(s.substring(i))
					break
				ret.push(s.substring(i,j))
				k = closingQuote(s, j+1, q[0])
				if( k is -1 )
					throw Error("unclosed quote: "+q[0]+" starting at "+j)
				ret.push(s.substring(j, k+1))
				i = k+1
			ret

		firstComment = (s) ->
			a = s.match(singlelineComment)
			b = s.match(multilineComment)
			return [-1, null] if a is b
			return [b.index, b[0]] if a == null and b != null
			return [a.index, a[0]] if a != null && b == null
			return [b.index, b[0]] if b.index < a.index
			return [a.index, a[0]]

		splitComments = (s) ->
			ret = []
			i = 0
			n = s.length
			while( i < n )
				ss = s.substring(i)
				q = firstComment(ss)
				j = q[0]
				if( j > -1 )
					ret.push(ss.substring(0,j))
					ret.push(q[1])
					i += j + q[1].length
				else
					ret.push(ss)
					break
			ret

		foldCodeAndQuoted = (code, quoted) ->
			code.replace(operators, operatorHtml).replace(allNumbers, numberHtml).replace(keywords, keywordHtml).replace(blingSymbol, blingHtml).replace(tabs, tabHtml) + quotedHtml(quoted)

		foldTextAndComments = (text, comment) ->
			$(splitQuoted(text)).fold(foldCodeAndQuoted).join('') + commentHtml(comment)

		return {
			name: "PrettyPrint"
			$:
				prettyPrint: (js, colors) ->
					js = js.toString() if Object.IsFunction(js)
					if not Object.IsString(js)
						throw TypeError("prettyPrint requires a function or string to format, not '"+Object.Type(js)+"'")
						css = "code.pp .bln { font-size: 17px; } "
						colors = Object.Extend(
						, colors)
						for cls of colors
							.text(css)
							.appendTo("head")
					ret = "<code class='pp'>" + ($(splitComments(js)).fold(foldTextAndComments).join('')) + "</code>"
		}

)(Bling)
require "../../dist/bling"

do ($ = Bling) ->

	$.plugin
		provides: "text-analysis"
	, ->
		indices = $.memoize (str, substr) ->
			switch substr.length
				when 0 then $.range 0, str.length
				when 1
					i = -1
					i while (i = str.indexOf substr, i+1) > -1
				else
					subsub = substr[0...substr.length-1]
					indices(str, subsub).filter (x) -> str.indexOf(substr,x) is x

		ld = $.memoize (s, t) ->
			switch true
				when not s then t.length
				when not t then s.length
				when s is t then 0
				when s[0] is t[0] then ld s[1..],t[1..]
				else 1 + Math.min(
					ld(s, t[1..]),
					ld(s[1..], t),
					ld(s[1..], t[1..])
				)

		commonSubstrings = (a,b,min_length=1,limit=1) ->
			a = a.toLowerCase()
			b = b.toLowerCase()
			ret = {}
			for i in [0...b.length]
				for j in [0...b.length]
					if (j - i) < min_length-1 then continue
					c = b[i..j]
					if (indices a,c).length > 0
							ret[c] = 1
			$(Object.keys ret)
				.sort((x,y) -> y.length - x.length)
				.take(limit)

		$:
			stringDistance: ld
			stringsInCommon: commonSubstrings

(($) ->

	$.plugin () ->

		Dialog = (selector, opts) ->
			opts = $.extend({
				autoOpen: false
				draggable: true
			}, opts)
			dialog = $(selector)
				.addClass("dialog")
			if opts.draggable
				dialog.draggable()
			if opts.autoOpen
				dialog.show().center()
			dialog
				.find("button.close, .close-button")
				.bind "click touchstart", () ->
					dialog.hide()
					false
			dialog
		
		Draggable = (selector, opts) ->
			opts = $.extend({
				handleCSS: {}
			}, opts)

			opts.handleCSS = $.extend({
				position: "absolute"
				top: "0px"
				left: "0px"
				width: "100%"
				height: "6px"
			}, opts.handleCSS)

			dragObject = $(selector)
			moving = false
			oX = oY = 0
			handle = $
				.synth("div.handle")
				.defaultCss({
					height: "6px"
					"border-radius": "3px"
					cursor: "move"
				})
				.css(opts.handleCSS)
				.bind 'mousedown, touchstart', (evt) ->
					moving = true
					oX or= evt.pageX
					oY or= evt.pageY
					false
			$(document)
			.bind 'mousemove, touchmove', (evt) ->
				if moving
					dX = (evt.pageX - oX)
					dY = (evt.pageY - oY)
					dragObject.transform({
						translate: [ dX, dY ]
					}, 0)
					.trigger 'drag', {
						dragObject: dragObject
					}
					false
			.bind 'mouseup, touchend', (evt) ->
				if moving
					moving = false
					pos = handle.position()[0]
					$(document.elementFromPoint(pos.left, pos.top - 1))
					.trigger 'drop',
						dropObject: dragObject

			dragObject
				.addClass("draggable")
				.css {
					position: "relative"
					"padding-top": dragObject.css("padding-top")
						.map(Number.AtLeast(parseInt(opts.handleCSS.height,10)))
						.px().first()
				}
				.append(handle)

		ProgressBar = (selector, opts) ->
			opts = $.extend({
				change: null
				barColor: "rgba(0,128,0,0.5)"
				textColor: "white"
				reset: false
			}, opts)

			node = $(selector)
				.addClass('progress-bar')
				_bg = node.css("background").first()
				_color = node.css("color").first()

			node.zap 'updateProgress', (pct) ->
				while pct < 1.0
					pct *= 100.0
					node.css
						background: _bg
						color: _color
				else
					node.css
						background:"""
						"""
						color: opts.textColor
				if $.is "function", opts.change
					opts.change pct

		Accordion = (selector, opts) ->
			opts = $.extend({
				exclusive: false
				sticky: false
			}, opts)
			node = $(selector).addClass("accordion")
			selectedChild = null

			initRow = (n) ->
				t = $(n).children().first().filter("*")
				if( t.len() isnt 2 )
				title = t.eq(0).addClass("title")
				body = t.eq(1).addClass("body").hide()
				bodyVisible = false
				title.click () ->
					if opts.exclusive
						node.find(".body").hide()
					if bodyVisible
						if not opts.sticky
							body.hide().removeClass("visible")
							title.removeClass("selected").trigger("deselect")
							bodyVisible = false
						else
							body.show().addClass("visible")
							title.addClass("selected").trigger("select")
							bodyVisible = true
					else
						body.show().addClass("visible")
						title.addClass("selected").trigger("select")
						bodyVisible = true

			node.bind "DOMNodeInserted", (evt) ->
				directChildren = node.children().first().filter("*")
				parentsOfInserted = $(evt.target).parents().first()
				initRow(parentsOfInserted.intersect(directChildren))

			node.children().first()
				.map(initRow)

			return node

		ViewStack = (selector, opts) ->
			items = $(selector)
				.css {
					position: "relative"
					top: "0px"
					left: "0px"
				}
				.hide()
				.map($)
			active = 0
			items[active].show()
			items.next = () ->
				items[active].hide()
				active = (++active % items.length)
				items[active].show()
			items.activate = (k) ->
				items[active].hide()
				active = k
				items[k].show()
			for j in [0...items.len()]
				items[j]
				.zap("_viewIndex", j)
				.zap "activate", ->
					items.activate(this._viewIndex)
			items

		Tabs = (selector, views) ->
			tabs = $(selector)
			views = $(views).viewStack()
			nn = tabs.len()
			tabs._tabIndex = i for i in [0..nn]
			$(tabs[0]).addClass("active")
			tabs.click () ->
				tabs.removeClass("active")
				views.activate(this._tabIndex)
				$(this).addClass("active")

		return {
			$:
				UI:
					Draggable: Draggable
					ProgressBar: ProgressBar
					ViewStack: ViewStack
					Tabs: Tabs
					Accordion: Accordion

			dialog: (opts) -> Dialog(this, opts)
			progressBar: (opts) -> ProgressBar(this, opts)
			viewStack: (opts) -> ViewStack(this, opts)
			tabs: (views) -> Tabs(this, views)
			accordion: (opts) -> Accordion(this, opts)
			draggable: (opts) -> Draggable(this, opts)
		}

)(Bling)


	units = ["px","pt","pc","em","%","in","cm","mm","ex",""]
	UNIT_RE = /(\d+\.*\d*)(px|pt|pc|em|%|in|cm|mm|ex)/

	parseUnits = (s) -> UNIT_RE.exec(s)[2] if UNIT_RE.test(s) else ""

	conv = (a,b) -> conv[a][b]()
	for a in units
		for b in units
			(conv[a] or= {})[b] = trick +(a is b or a is "" or b is "")
	conv.in.pt = -> 72
	conv.in.px = -> 96
	conv.in.cm = -> 2.54
	conv.pc.pt = -> 12
	conv.cm.mm = -> 10
	conv.em.px = ->
		x = $("<span style='font-size:1em;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.px = ->
		x = $("<span style='font-size:1ex;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.em = -> 2
	fillIn = ->
		for a in units
			for b in units
				if not conv(a,b) and conv(b,a)
					conv[a][b] = trick 1.0/conv(b,a)
				for c in units
					if not conv(a,c) and conv(a,b) and conv(b,c)
						conv[a][c] = trick conv(a,b) * conv(b,c)
	fillIn(); fillIn()
	
	convertUnits = (number, unit) -> parseFloat(number) * conv[parseUnits(number)][unit]() + unit

	$.assert(convertUnits("300px", "cm") == "10cm")

	convertAll = (to, a) ->
		for i in [0...a.length]
			a[i] = convertTo(to, a[i])

	Object.Type.register "units",
		match: (x) -> UNIT_RE.test(x)

	unit_scalar = (f) ->
		(a...) ->
			convertAll( unit = parseUnits(@[0]), @)
			(f.apply @, a) + unit
	unit_vector = (f) ->
		(a...) ->
			u = @map parseUnits
			f.apply(@floats(), a).map ->

	{
		min: unit_scalar -> @reduce (a) -> Math.min parseFloat(@), a
		max: unit_scalar -> @reduce (a) -> Math.max parseFloat(@), a
		sum: unit_scalar -> @reduce (a) -> parseFloat(@) + a
		mean: unit_scalar -> parseFloat(@sum()) / @length
		magnitude: unit_scalar -> Math.sqrt @floats().squares().sum()
		squares: -> @map -> (x=parseFloat(@)) * x
		scale: (n) -> @map -> n * parseFloat(@)
		add: (d) -> @map -> d + @
		normalize: -> @scale(1/@magnitude())
	}


	EOF = -> "EOF"

	BackgroundQueue = (opts) ->
		opts = extend {
			item: -> EOF
			action: Function.Identity
			latency: 10
		}, opts

		return extend new $.EventEmitter(), {
			run: ->
				r = () =>
					if (item = opts.action(opts.item())) isnt EOF
						@emit("data", item)
						setTimeout r, opts.latency
				setTimeout r, opts.latency
		}

	data = x for x in [0...1000]
	i = 0
	BackgroundQueue
		item: ->
			return data[i++] if i < data.length else EOF
		action: (item) -> (item*item) - 1
		latency: 10
	.on "data", (x) -> console.log "data:", x
	.on "error", (x) -> console.log "error:", x
	
(($) ->
	$.plugin ->
		$:
			histogram: (data, bucket_width=1, output_width=80) ->
				buckets = $()
				len = 0
				for x in data
					i = Math.floor( x / bucket_width )
					buckets[i] ?= 0
					buckets[i] += 1
					len = Math.max(len, i+1)
				buckets.length = len

				max = buckets.max()
				buckets = buckets.map((x) -> x or 0)
					.scale(1/max)
					.scale(output_width)
				sum = buckets.sum()

				ret = ""
				for n in [0...len] by 1
					end = (n+1) * bucket_width
					pct = (buckets[n]*100/sum).toFixed(0)
				ret
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'XMLHttpRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					xhr = new XMLHttpRequest()
					if $.is "function", opts
						opts = success: $.bound(xhr, opts)
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts
					opts.state = $.bound(xhr, opts.state)
					opts.success = $.bound(xhr, opts.success)
					opts.error = $.bound(xhr, opts.error)
					if opts.data and opts.method is "GET"
						url += "?" + formencode(opts.data)
					else if opts.data and opts.method is "POST"
						opts.data = formencode(opts.data)
					xhr.open(opts.method, url, opts.async)
					xhr = $.extend xhr,
						asBlob: opts.asBlob
						timeout: opts.timeout
						followRedirects: opts.followRedirects
						withCredentials: opts.withCredentials
						onreadystatechange: ->
							opts.state?()
							if xhr.readyState is 4
								if xhr.status is 200
									opts.success xhr.responseText
								else
									opts.error xhr.status, xhr.statusText
					xhr.send opts.data
					return $(xhr)

				post: (url, opts = {}) ->
					if $.is("function",opts)
						opts = success: opts
					opts.method = "POST"
					$.http(url, opts)

				get: (url, opts = {}) ->
					if( $.is("function",opts) )
						opts = success: opts
					opts.method = "GET"
					$.http(url, opts)
		}
)(Bling)
(($) ->

	$.plugin
		depends: "dom"
		provides: "lazy"
	, ->
		lazy_load = (elementName, props) ->
			$("head").append $.extend document.createElement(elementName), props
		$:
			script: (src) ->
				lazy_load "script", { src: src }
			style: (src) ->
				lazy_load "link", { href: src, rel: "stylesheet" }

)(Bling)
(($) ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""

		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615

		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)

			index = (index + 1) % 624
			(y + a) / b

		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()

		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
	)()

	$.plugin
		provides: "random"
	, ->
		$:
			random: random

)(Bling)
(($) ->
	$.plugin
		provides: "sendgrid"
		depends: "config"
	, ->
		try
			nodemailer = require 'nodemailer'
		catch err
			`return`
		transport = nodemailer.createTransport 'SMTP',
			service: 'SendGrid'
			auth:
				user: $.config.get 'SENDGRID_USERNAME'

		$:
			sendMail: (mail, callback) ->
				mail.transport ?= transport
				mail.from ?= $.config.get 'EMAILS_FROM'
				mail.bcc ?= $.config.get 'EMAILS_BCC'

				if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
					nodemailer.sendMail mail, callback
				else
)(Bling)
(($) ->
	$.plugin
		provides: "StateMachine"
	, ->
		$: StateMachine: class StateMachine
			constructor: (stateTable) ->
				@debug = false
				@reset()
				@table = stateTable
				Object.defineProperty @, "modeline",
					get: -> @table[@_mode]
				Object.defineProperty @, "mode",
					set: (m) ->
						@_lastMode = @_mode
						@_mode = m
						if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
							ret = @modeline['enter'].call @
							while $.is("function",ret)
								ret = ret.call @
						m
					get: -> @_mode

			reset: ->
				@_mode = null
				@_lastMode = null

			GO: (m) -> -> @mode = m
			@GO: (m) -> -> @mode = m
			
			tick: (c) ->
				row = @modeline
				if not row?
					ret = null
				else if c of row
					ret = row[c]
				else if 'def' of row
					ret = row['def']
				while $.is "function",ret
					ret = ret.call @, c
				ret

			run: (inputs) ->
				@mode = 0
				for c in inputs
					ret = @tick(c)
				if $.is "function",@modeline?.eof
					ret = @modeline.eof.call @
				while $.is "function",ret
					ret = ret.call @
				@reset()
				return @

	$.plugin
		provides: "synth"
		depends: "StateMachine"
	, ->
		class SynthMachine extends $.StateMachine
			basic =
				".": @GO 3
				"[": @GO 4
				'"': @GO 6
				"'": @GO 7
				" ": @GO 8
				",": @GO 10
				"+": @GO 11
				eof: @GO 13

			@STATE_TABLE = [
					enter: ->
						@tag = @id = @cls = @attr = @val = @text = ""
						@attrs = {}
						@GO 1
				},
					def: (c) -> @tag += c
				}, basic),
					def: (c) -> @id += c
				}, basic),
					enter: -> @cls += " " if @cls.length > 0
					def: (c) -> @cls += c
				}, basic),
					"=": @GO 5
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @attr += c
					eof: @GO 12
				},
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @val += c
					eof: @GO 12
				},
					'"': @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					"'": @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					enter: ->
						@emitNode() if @tag
						@emitText() if @text
						@GO 0
				},
					enter: ->
						@emitNode()
						@cursor = null
						@GO 0
				},
					enter: ->
						@emitNode()
						@cursor = @cursor?.parentNode
						@GO 0
				},
				},
					enter: ->
						@emitNode() if @tag
						@emitText() if @text
				}
			]
			constructor: ->
				super(SynthMachine.STATE_TABLE)
				@fragment = @cursor = document.createDocumentFragment()
			emitNode: ->
				if @tag
					node = document.createElement @tag
					node.id = @id or null
					node.className = @cls or null
					for k of @attrs
						node.setAttribute k, @attrs[k]
					@cursor.appendChild node
					@cursor = node
			emitText: ->
				@cursor.appendChild $.type.lookup("<html>").node(@text)
				@text = ""

		return {
			$:
				synth: (expr) ->
					s = new SynthMachine()
					s.run(expr)
					if s.fragment.childNodes.length == 1
						$(s.fragment.childNodes[0])
					else
						$(s.fragment)
		}

)(Bling)
(($) ->


		current_engine = null
		engines = {}

		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine

		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()

		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop]
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1

	$.template.register_engine 'pythonic', (() ->

		chunk_re = /%[\(\/]/

		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n]
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}

			if not cache?
			n = cache.length

			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""

		return render
	)()

		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()


)(Bling)
(($) ->
		parseOne = (data) ->
			i = data.indexOf ":"
			if i > 0
				len = parseInt data[0...i], 10
				item = data[i+1...i+1+len]
				type = data[i+1+len]
				extra = data[i+len+2...]
				item = switch type
					when "'" then String(item)
					when "!" then (item is "true")
					when "~" then null
					when "]" then parseArray(item)
					when "}" then parseObject(item)
				return [item, extra]
			return undefined
		parseArray = (x) ->
			data = []
			while x.length > 0
				[one, x] = parseOne(x)
				data.push(one)
			data
		parseObject = (x) ->
			data = {}
			while x.length > 0
				[key, x] = parseOne(x)
				[value, x] = parseOne(x)
				data[key] = value
			data
		$:
			TNET:
				stringify: (x) ->
					[data, type] = switch $.type x
						when "string" then [x, "'"]
						when "function" then [String(x), "'"]
						when "boolean" then [String(not not x), "!"]
						when "null" then ["", "~"]
						when "undefined" then ["", "~"]
						when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
						when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
					return (data.length|0) + ":" + data + type
				parse: (x) ->
					parseOne(x)?[0]
)(Bling)
(($) ->

	$.plugin
		provides: "trace"
		depends: "function,type"
	, ->
		$.type.extend
			unknown: { trace: $.identity }
			function:
				trace: (label, f, tracer) ->
					label or= f.name
					r = (a...) ->
						f.apply @, a
					r
		return $: trace: (label, o, tracer) ->
			if not $.is "string", label
				[tracer, o] = [o, label]
			tracer or= $.log
			label or= ""
			$.type.lookup(o).trace(label, o, tracer)

)(Bling)
(($) ->
	$.plugin
		depends: "dom"
	, ->
		COMMASEP = ", "
			"slow": 700
			"medium": 500
			"normal": 300
			"fast": 100
			"instant": 0
			"now": 0
		accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
		testStyle = document.createElement("div").style

		transformProperty = "transform"
		transitionProperty = "transition-property"
		transitionDuration = "transition-duration"
		transitionTiming = "transition-timing-function"

		if "WebkitTransform" of testStyle
			transformProperty = "-webkit-transform"
			transitionProperty = "-webkit-transition-property"
			transitionDuration = "-webkit-transition-duration"
			transitionTiming = "-webkit-transition-timing-function"
		else if "MozTransform" of testStyle
			transformProperty = "-moz-transform"
			transitionProperty = "-moz-transition-property"
			transitionDuration = "-moz-transition-duration"
			transitionTiming = "-moz-transition-timing-function"
		else if "OTransform" of testStyle
			transformProperty = "-o-transform"
			transitionProperty = "-o-transition-property"
			transitionDuration = "-o-transition-duration"
			transitionTiming = "-o-transition-timing-function"

		return {
			$:
				duration: (speed) ->
					d = speeds[speed]
					return d if d?
					return parseFloat speed

			transform: (end_css, speed, easing, callback) ->

				if $.is("function",speed)
					callback = speed
					speed = easing = null
				else if $.is("function",easing)
					callback = easing
					easing = null
				speed ?= "normal"
				easing or= "ease"
				duration = $.duration(speed) + "ms"
				props = []
				trans = ""
				css = {}
				for i of end_css
					if accel_props_re.test(i)
						ii = end_css[i]
						if ii.join
							ii = $(ii).px().join COMMASEP
						else if ii.toString
							ii = ii.toString()
						trans += " " + i + "(" + ii + ")"
					else css[i] = end_css[i]
				(props.push i) for i of css
				if trans
					props.push transformProperty

				css[transitionProperty] = props.join COMMASEP
				css[transitionDuration] = props.map(-> duration).join COMMASEP
				css[transitionTiming] = props.map(-> easing).join COMMASEP

				if trans
					css[transformProperty] = trans
				@css css
				@delay duration, callback

				@each ->
					if @style
						if @style.display is not "none"
							@_display = @syle.display
						@style.display = "none"
				.trigger "hide"
				.delay updateDelay, callback

				@each ->
					if @style
						@style.display = @_display
						delete @_display
				.trigger "show"
				.delay updateDelay, callback

				@weave(@css("display"))
					.fold (display, node) ->
						if display is "none"
							node.style.display = node._display or ""
							delete node._display
							$(node).trigger "show"
						else
							node._display = display
							node.style.display = "none"
							$(node).trigger "hide"
						node
					.delay(updateDelay, callback)

				@.css('opacity','0.0')
					.show ->
						@transform {
							opacity:"1.0",
							translate3d: [0,0,0]
						}, speed, callback
				@transform {
					opacity:"0.0",
					translate3d:[x,y,0.0]
				}, speed, -> @hide(callback)
			fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
			fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
			fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
			fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
		}
)(Bling)
(($) ->
	$.plugin
		provides: "unittest"
		depends: "core,function"
	, ->
		testCount = passCount = failCount = 0
		failed = []
		invokeTest = (group, name, func) ->
			return if not $.is "function", func
			shouldFail = name.toLowerCase().indexOf("fail") isnt -1
			done = $.once (err) ->
				testCount--
				if (!!err isnt shouldFail)
					failCount++
					failed.push name
				else
					_log "pass"
					passCount++
					$.provide name
			f = (done) ->
				try func(done)
				catch err then done(err)
				finally
					if name.toLowerCase().indexOf("async") is -1 then done()
			testCount++
			try f(done)
			catch err then done(err)

		testReport = $.once ->

		$:
			approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
			assertEqual: (a, b, label) ->
				if a isnt b
			assertArrayEqual: (a, b, label) ->
				for i in [0...a.length] by 1
					try
						$.assertEqual(a[i], b[i], label)
					catch err
			testGroup: (name, funcs) ->
				interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
				for k,func of funcs
					invokeTest(name, k, func)
		assertEqual: (args...) ->
					if $.is "function", x then x.call(@,@) else x
				a = args[0]
				for i in [1...args.length]
					$.assertEqual a, args[i]
			return @
)(Bling)
require('./common')

$.testGroup "Object",
	keys: -> $.assertArrayEqual Object.keys({a: 1, b: 2}), ['a','b']

$.testGroup "Type",
	string: -> $.assertEqual $.type(""), "string"
	number:-> $.assertEqual $.type(42), "number"
	undef: -> $.assertEqual $.type(), "undefined"
	null: -> $.assertEqual $.type(null), "null"
	array: -> $.assertEqual $.type([]), "array"
	function: -> $.assertEqual $.type(() -> null), "function"
	bool: -> $.assertEqual $.type(true), "bool"
	regexp: -> $.assertEqual $.type(//), "regexp"
	window: -> $.assertEqual $.type(window), "global"
	is: ->
		$.assert($.is "function", ->)
		$.assert($.is "array", [])
	inherit: ->
		a = { a: 1 }
		b = { b: 2 }
		$.inherit a, b
		$.assertEqual(b.__proto__, a)
		$.assertEqual(b.a, 1)
		$.assert( not b.hasOwnProperty("a") )
	extend: -> $.assertArrayEqual Object.keys($.extend({A:1},{B:2})), ['A','B']
	defineProperty: ->
		a = {}
		$.defineProperty a, "b",
			get: -> 2
		$.assert( "b" of a )
	isType1: ->
		$.assert( $.isType(Array, []) )
	isType2: ->
		$.assert( $.isType('Array', []) )
	isType3: ->
		class Foo
		f = new Foo()
		$.assert( $.isType Foo, f )
	isSimple1: -> $.assert( $.isSimple "" )
	isSimple2: -> $.assert( $.isSimple 42.0 )
	isSimple3: -> $.assert( $.isSimple false )
	isSimple4: -> $.assert( not $.isSimple {} )
	isEmpty1: -> $.assert( $.isEmpty "" )
	isEmpty2: -> $.assert( $.isEmpty null )
	isEmpty3: -> $.assert( $.isEmpty undefined )
	toArray1: ->
		a = $([1,2,3])
		b = a.toArray()
		$.assert b.constructor.name is "Array", "constructor name is Array"
		$.assert b[1] is 2, "still has data"
		$.assert b.length is 3, "length is preserved"
		$.assert not b.zap, "has shed bling"
	as1: ->
		$.assert ($.as "number", "1234") is 1234

$.testGroup "Function",
	identity1: -> $.assertEqual $.type($.identity), "function"
	identity2: -> $.assertEqual( $.identity(a = {}), a)
	bound: ->
		f = -> @value
		a = { value: 'a' }
		b = { value: 'b' }
		g = $.bound(a, f)
		h = $.bound(b, f)
		$.assertEqual(g(), 'a')
		$.assertEqual(h(), 'b')
	trace: ->
		f = -> 42
		g = []
		h = $.trace "label", f, (a...) ->
			g.push a.join ''
		$.assertArrayEqual(g, [ "global.label('one','two')" ])

$.testGroup "String",
	Px1: -> $.assertEqual($.px(100), "100px")
	Px2: -> $.assertEqual($.px(-100.0), "-100px")
	Px3: -> $.assertEqual $.px("100.0px"), "100px"
	PadLeft1: -> $.assertEqual($.padLeft("foo", 5), "  foo")
	PadLeft2: -> $.assertEqual($.padLeft("foo", 3), "foo")
	PadLeft3: -> $.assertEqual($.padLeft("foo", 2), "foo")
	PadLeft4: -> $.assertEqual($.padLeft("foo", 5, "X"), "XXfoo")
	PadRight1: -> $.assertEqual($.padRight("foo", 5), "foo  ")
	PadRight2: -> $.assertEqual($.padRight("foo", 3), "foo")
	PadRight3: -> $.assertEqual($.padRight("foo", 2), "foo")
	PadRight4: -> $.assertEqual($.padRight("foo", 5, "X"), "fooXX")
	Splice1: -> $.assertEqual($.stringSplice("foobar",3,3,"baz"), "foobazbar")
	Splice2: -> $.assertEqual($.stringSplice("foobar",1,5,"baz"), "fbazr")
	Splice3: -> $.assertEqual($.stringSplice("foobar",0,6,"baz"), "baz")
	Splice4: -> $.assertEqual($.stringSplice("foobar",0,0,"baz"), "bazfoobar")
	Checksum2: -> $.assertEqual($.checksum("foobarbaz"), 310051767)
	ToString: -> $.assertEqual $([2,3,4]).toString(), "$([2, 3, 4])"
	ToString2: -> $.assertEqual $.toString(-> $.log), "function () { ... }"

$.testGroup "Plugins",
	new_plugin: ->
		$.plugin ->
			$:
				testGlobal: -> 9
			testOp: -> 42
		$.assertEqual $.testGlobal?(), 9
		$.assertEqual $().testOp?(), 42
		$.assertEqual $.testOp?(), 42

$.testGroup "Symbol",
	exists: -> $.assert( Bling?, "bling should exist")
	current: ->
		Bling.assertEqual( Bling.symbol, "$" )
		Bling.assertEqual( $, Bling )
	set: ->
		Bling.symbol = "_"
		Bling.assertEqual( _, Bling )
	preserve: ->
		Bling.global.$ = "before"
		Bling.symbol = "$"
		Bling.assertEqual(Bling.global.$, Bling)
		Bling.symbol = "_"
		Bling.assertEqual(Bling.global.$, "before")
	reset: ->
		Bling.symbol = "$"
		Bling.assertEqual($, Bling)
	noConflict: ->
		Bling.global.noConflictTest = "magic"
		Bling.symbol = "noConflictTest"
		Bling.assert Bling.global.noConflictTest is Bling, 1
		foo = Bling.noConflict()
		Bling.assert Bling.symbol = "Bling", 2
		Bling.assert Bling.global[Bling.symbol] is Bling, 3
		Bling.assert foo is Bling, 4
		Bling.assert Bling.global.noConflictTest is "magic", 5
		Bling.symbol = "$"

$.testGroup "Math",
	sum0: -> $.assertEqual($([]).sum(), 0)
	sum1: -> $.assertEqual($([1,2,3,4,5]).sum(), 15)
	sum2: -> $.assertEqual($([1,2,NaN,3]).sum(), 6)
	range1: -> $.assertEqual($.range(1,6).toRepr(), '$([1, 2, 3, 4, 5])')
	range2: -> $.assertEqual($.range(5).toRepr(), '$([0, 1, 2, 3, 4])')
	zeros1: -> $.assertEqual($.zeros(10).sum(), 0)
	zeros2: -> $.assertEqual($.zeros(5).toRepr(), '$([0, 0, 0, 0, 0])')
	ones: -> $.assertEqual($.ones(10).sum(), 10)
	floats: -> $.assertEqual($(["12.1","29.9"]).floats().sum(), 42)
	ints: -> $.assertEqual($(["12.1","29.9px"]).ints().sum(), 41)
	px: -> $.assertEqual( $(["12.1", "29.9"]).px(2).toRepr(), "$(['14px', '31px'])" )
	min1: -> $.assertEqual( $([12.1, 29.9]).min(), 12.1)
	min2: -> $.assertEqual( $([12.1, NaN, 29.9]).min(), 12.1)
	max1: -> $.assertEqual( $([12.1, 29.9]).max(), 29.9)
	max2: -> $.assertEqual( $([12.1, NaN, 29.9]).max(), 29.9)

$.testGroup "Random",
	random: ->
		$.assert 0.0 < $.random() < 1.0
	real: ->
		$.assert 10.0 < $.random.real(10,100) < 100.0
	integer: ->
		r = $.random.integer(3,9)
		$.assert 3 <= r <= 9, "r is in range"
		$.assert Math.floor(r) is r, "r is an integer"
	string: ->
		s = $.random.string(16)
		$.assert $.type(s) is "string", "s is a string"
		$.assert s.length is 16, "s has the right length"
	seed: ->
		$.random.seed = 42
		r = $.random.string(16)
		$.random.seed = 43
		s = $.random.string(16)
		$.random.seed = 42
		t = $.random.string(16)
		$.assert r is t, "same seed produces same output"
		$.assert r isnt s, "different seed produces different output"

$.testGroup "Hash",
	number: -> $.assert $.hash(42) isnt $.hash(43)
	string: -> $.assert $.hash("foo") isnt $.hash("bar")
	array:  -> $.assert $.hash("poop") isnt $.hash(["poop"])
	array_order: -> $.assert $.hash(["a","b"]) isnt $.hash(["b","a"])
	object: -> $.assert ($.hash a:1) isnt ($.hash a:2)
	object2: -> $.assert isFinite $.hash a:1
	object3: -> $.assert isFinite $.hash {}
	object4: -> $.assert ($.hash {}) isnt ($.hash [])
	bling:  -> $.assert ($.hash $)?
	bling_order: -> $.assert $.hash($(["a","b"])) isnt $.hash($(["b","a"]))

document.body.innerHTML = """
<table>
	<tr><td>1,1</td><td>1,2</td></tr>
	<tr><td>2,1</td><td>2,2</td></tr>
	<tr><td>3,1</td><td class='d'>3,2</td></tr>
	<tr><td>4,1</td><td>4,2</td></tr>
</table>
<div class='c'>C</div>
<p><span>foobar</span></p>
"""
$.testGroup "Core",
	new1: ->
		b = $([1,2,3])
		$.assertEqual(b[0], 1)
		$.assertEqual(b[1], 2)
		$.assertEqual(b[2], 3)
		$.assertEqual(b.constructor.name, "Bling")
	pipe1: ->
		$.pipe('unit-test').append (x) -> x += 2
		$.pipe('unit-test').prepend (x) -> x *= 2
		$.assertEqual( $.pipe('unit-test', 4), 10)
	eq: -> $.assertEqual($([1,2,3]).eq(1)[0], 2)
	each: ->
		sum = 0
		$([1,2,3,4]).each ->
			sum += @
		$.assertEqual(sum, 10)
	map: -> $.assertArrayEqual( $([1,2,3,4]).map( (x) -> x * x ), [1,4,9,16] )
	map2: ->
		d = [1,2,3,4,5]
		$.assertArrayEqual($(d).map(-> @ * 2), [2,4,6,8,10])
		$.assertArrayEqual($(d).map(-> @ * 2), [2,4,6,8,10])
	coalesce1: -> $.assertEqual($.coalesce(null, 42, 22), 42)
	coalesce2: -> $.assertEqual($.coalesce([null, 14, 42]), 14)
	coalesce3: -> $.assertEqual($.coalesce([null, [null, 14], 42]), 14)
	reduce: -> $.assertEqual( $([1,2,3,4]).reduce( (a,x) -> a + x ), 10)
	union: -> $.assertArrayEqual($([1,2,3,4]).union([2,3,4,5]), [1,2,3,4,5])
	intersect: -> $.assertArrayEqual($([1,2,3,4]).intersect([2,3,4,5]), [2,3,4])
	distinct: -> $.assertArrayEqual($([1,2,2,3,4,3]).distinct(), [1,2,3,4])
	contains1: -> $.assert $([1,2,3,4]).contains(3)
	contains2: -> $.assert $(["foo","bar","baz"]).contains("bar")
	count: -> $.assertEqual( $([1,2,2,3,4,3]).count(3), 2 )
	select: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).select('id'), [1,2,3])
	select1: -> $.assertArrayEqual($([
		{a:{b:2}},
		{a:{b:4}},
		{a:{b:6}}
	]).select("a.b"), [2,4,6])
	select2: -> $.assertArrayEqual($([
		{a:[{b:3}]},
		{a:[{b:6}]},
		{a:[{b:9}]}
	]).select("a.0.b"), [3,6,9])
	select3: -> $.assertArrayEqual($([
		{a:{b:{c:4}}},
		{a:{b:{c:5}}},
		{a:{b:{c:6}}}
	]).select("a.b.c"), [4,5,6])
	zap: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).zap('id', 13).select('id'), [13,13,13])
	zapf: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).zap('id', () -> @ * 2).select('id'), [2,4,6])
	zapf2: -> $.assertArrayEqual( $([ {sub:{id:1}}, {sub:{id:2}}, {sub:{id:3}} ]).zap('sub.id', -> @*2).select('sub.id'), [2,4,6])
	take3: -> $.assertArrayEqual($([1,2,3,4]).take(0), [])
	take4: -> $.assertArrayEqual($([1,2,3,4]).take(1), [1])
	take5: -> $.assertArrayEqual($([1,2,3,4]).take(2), [1,2])
	take6: -> $.assertArrayEqual($([1,2,3,4]).take(3), [1,2,3])
	take7: -> $.assertArrayEqual($([1,2,3,4]).take(4), [1,2,3,4])
	take8: -> $.assertArrayEqual($([1,2,3,4]).take(5), [1,2,3,4])
	skip2: -> $.assertArrayEqual($([1,2,3,4]).skip(0), [1,2,3,4])
	skip3: -> $.assertArrayEqual($([1,2,3,4]).skip(1), [2,3,4])
	skip4: -> $.assertArrayEqual($([1,2,3,4]).skip(2), [3,4])
	skip5: -> $.assertArrayEqual($([1,2,3,4]).skip(3), [4])
	skip6: -> $.assertArrayEqual($([1,2,3,4]).skip(4), [])
	skip7: -> $.assertArrayEqual($([1,2,3,4]).skip(5), [])
	first1: -> $.assertEqual($([1,2,3,4]).first(), 1)
	first2: -> $.assertArrayEqual($([1,2,3,4]).first(5), [1,2,3,4])
	first3: -> $.assertArrayEqual($([1,2,3,4]).first(2), [1,2])
	first4: -> $.assertArrayEqual($([1,2,3,4]).first(0), [])
	last1: -> $.assertEqual($([1,2,3,4]).last(), 4)
	last2: -> $.assertArrayEqual($([1,2,3,4]).last(5), [1,2,3,4])
	last3: -> $.assertArrayEqual($([1,2,3,4]).last(2), [3,4])
	last4: -> $.assertArrayEqual($([1,2,3,4]).last(0), [])
	slice1: -> $.assertArrayEqual($([1,2,3,4,5]).slice(0,5), [1,2,3,4,5])
	slice2: -> $.assertArrayEqual($([1,2,3,4,5]).slice(1,5), [2,3,4,5])
	slice3: -> $.assertArrayEqual($([1,2,3,4,5]).slice(2,5), [3,4,5])
	slice4: -> $.assertArrayEqual($([1,2,3,4,5]).slice(3,5), [4,5])
	slice5: -> $.assertArrayEqual($([1,2,3,4,5]).slice(4,5), [5])
	slice6: -> $.assertArrayEqual($([1,2,3,4,5]).slice(1,-2), [2,3])
	slice7: -> $.assertArrayEqual($([1,2,3,4,5]).slice(-1,-3), [5,4])
	slice8: -> $.assertArrayEqual($([1,2,3,4,5]).slice(-1,-4), [5,4,3])
	push: -> $.assertArrayEqual($([1,2,3]).push(4), [1,2,3,4])
	filter1: -> $.assertArrayEqual($([1,2,3,4,5]).filter((x) -> x % 2), [1,3,5])
	filter2: -> $.assertArrayEqual($(["foo","bar","baz"]).filter(/^ba/), ["bar","baz"])
	filter3: -> $.assertArrayEqual($("*").filter("td").length, 8)
	filter4: -> $.assertEqual($("*").filter("td").filter(".d").length, 1)
	filter5: -> $.assertEqual($("*").filter("td").filter(".none").length, 0)
	filter6: -> $.assertArrayEqual($(["one","two","three"]).filter(-> String(@) isnt "three"), ["one", "two"])
	matches: -> $.assertArrayEqual($("td").matches(".d"), [false,false,false,false,false,true,false,false])
	querySelectorAll: -> $.assertArrayEqual($("tr").querySelectorAll("td.d")[0].className, "d")
	weave1: -> $.assertArrayEqual($([1,1,1]).weave([2,2,2]), [2,1,2,1,2,1])
	weave2: -> $.assertArrayEqual($([1,1,1]).weave($([2,2,2])), [2,1,2,1,2,1])
	fold: -> $.assertArrayEqual($([1,1,1]).weave([2,2,2]).fold( (a,b) -> a+b ), [3,3,3])
	flatten: -> $.assertArrayEqual($([[1,2],[3,4]]).flatten(), [1,2,3,4])
	call: -> $.assertArrayEqual($([((x) -> x*2), ((x) -> x*x)]).call(4), [8, 16])
	apply: -> $.assertArrayEqual($([((x) -> @+x), ((x) -> @*x)]).apply(4,[2]), [6, 8])
	corrected_length: ->
		$.assertEqual(Array(10).length,10)
		$.assertEqual(Bling(10).length, 0)

$.testGroup "DOM",
	parse: ->
		d = $.HTML.parse "<div><a></a><b></b><c></c></div>"
		$.assertEqual $.type(d), "node"
		$.assertEqual d.nodeName, "DIV"
	stringify: -> $.assertEqual $.HTML.stringify($.HTML.parse(h = "<div><a/><b/><c/></div>")), h
	select_childNodes: -> $.assertEqual( $("<div><a></a><b></b><c></c></div>").select("childNodes").flatten().map($.type).toRepr(), "$(['node', 'node', 'node'])" )
	child: -> i = 0; d = $("<div><a></a><b></b><c></c></div>"); $.assertEqual( d.select('childNodes').flatten().map( () -> d.child(i++) ).toRepr(), "$([$([<a/>]), $([<b/>]), $([<c/>])])")
	child2: -> $.assertEqual($("tr").child(0).select('nodeName').toRepr(), "$(['TD', 'TD', 'TD', 'TD'])")
	textData: ->
		d = $("<div>&nbsp;</div>")
		$.assertEqual d.toRepr(), "$([<div>&nbsp;</div>])"
		t = d.child 0
		$.assertEqual t.toRepr(), "$([&nbsp;])"
		t.zap 'data', '<p>'
		$.assertEqual d.select('innerHTML').first(), '&lt;p&gt;'
	escape: -> $.assertEqual $.HTML.escape("<p>"), "&lt;p&gt;"
	dashName1: -> $.assertEqual $.dashize("fooBar"), "foo-bar"
	dashName2: -> $.assertEqual $.dashize("FooBar"), "-foo-bar"
	html: -> $.assertEqual $("tr").html().first(), "<td>1,1</td><td>1,2</td>"
	append: ->
		try
			$.assertEqual($("tr td.d").append("<span>Hi</span>").html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	appendTo1:-> $.assertEqual($("<span>Hi</span>").toRepr(), "$([<span>Hi</span>])")
	appendTo2:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").toRepr(), "$([<span>Hi</span>])")
		finally
			$("tr td.d span").remove()
	appendTo3:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').toRepr(), '$([<td class="d">3,2<span>Hi</span></td>])')
		finally
			$("tr td.d span").remove()
	appendTo4:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	prepend: ->
		try
			$.assertEqual($("tr td.d").prepend("<span>Hi</span>").html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	prependTo: ->
		try
			$.assertEqual($("<span>Hi</span>").prependTo("tr td.d").select('parentNode').html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	before: -> $.assertEqual($("<a><b></b></a>").find("b").before("<c></c>").select('parentNode').toRepr(), "$([<a><c/><b/></a>])")
	after1: -> $.assertEqual($("<a><b></b></a>").find("b").after("<c></c>").select('parentNode').toRepr(), "$([<a><b/><c/></a>])")
	after2: -> $.assertEqual($("<b></b>").after("<c></c>").select('parentNode').toRepr(), "$([<b/><c/>])")
	wrap: -> $.assertEqual($("<b></b>").wrap("<a></a>").select('parentNode').toRepr(), "$([<a><b/></a>])")
	unwrap: -> $.assertEqual($("<a><b/></a>").find("b").unwrap().first().parentNode, null)
	replace: -> $.assertEqual($("<a><b/><c/><b/></a>").find("b").replace("<p/>").eq(0).select('parentNode').toRepr(), "$([<a><p/><c/><p/></a>])")
	removeClass: -> $.assertEqual($("<a class='test'></a>").removeClass('test').toRepr(), "$([<a/>])")
	removeClass2: -> $.assertEqual($("<a></a>").removeClass('test').toRepr(), "$([<a/>])")
	addClass: -> $.assertEqual($("<a></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	addClass2: -> $.assertEqual($("<a class='test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	addClass3: -> $.assertEqual($("<a class='test test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	toggleClass: -> $.assertEqual($("<a class='on'></a>").toggleClass("on").toRepr(), "$([<a/>])")
	toggleClass2: -> $.assertEqual($("<a class='off'></a>").toggleClass("on").toRepr(), '$([<a class="off on"/>])')
	toggleClass3: -> $.assertEqual($("<a class=''></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	toggleClass4: -> $.assertEqual($("<a></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	hasClass: -> $.assertEqual($("<a class='foo'></a>").hasClass("foo").first(), true)
	hasClass2: -> $.assertEqual($("<a class='bar'></a>").hasClass("foo").first(), false)
	text1: -> $.assertEqual($("<a>Hello<b>World</b></a>").select('innerText').toRepr(), "$(['HelloWorld'])")
	text3: -> $.assertEqual($("<a>Hello<b>World</b></a>").text().toRepr(), "$(['HelloWorld'])")
	text2: -> $.assertEqual($("<a>Hello<b>World</b></a>").text("Goodbye").toRepr(), "$([<a>Goodbye</a>])")
	value1: -> $.assertEqual($("<input type='text' value='foo'/>").val().toRepr(), "$(['foo'])")
	value2: -> $.assertEqual($("<input />").val().toRepr(), "$([''])")
	value3: -> $.assertEqual($("<input type='checkbox' checked />").val().toRepr(), "$(['on'])")
	parents: -> $.assertEqual($("td.d").parents().first().select('nodeName').toRepr(), "$(['TR', 'TABLE', 'BODY', 'HTML'])")
	remove: ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
		b = a.find(".x")
			.assertEqual(2, -> @length)
			.assertEqual("$(['B', 'C'])", -> @select('nodeName').toRepr())
			.remove()
			.assertEqual("$([null, null])", -> @select('parentNode').toRepr() )
		$.assertEqual a.toRepr(), '$([<a><d/></a>])'
	find: ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
			.find(".x")
			.assertEqual(2, -> @length)
			.assertEqual("$(['B', 'C'])", -> @select('nodeName').toRepr())
	clone: ->
		c = $("div.c").clone()[0]
		d = $("div.c")[0]
		c.a = "magic"
		$.assertEqual( typeof d.a, "undefined")
		$.assertEqual( typeof c.a, "string")
	toFragment: ->
		$.assertEqual($("td").clone().toFragment().childNodes.length, 8)

$.testGroup "EventEmitter",
	basic: ->
		v = null
		$().on("change", (data) -> v = data)
			.emit("change", "foo")
		$.assertEqual v, "foo"

$.testGroup "Date",
	stamp: ->
		$.assert $.date.stamp(new Date(1000000), "ms") is 1000000
	stamp_sec: ->
		$.assert $.date.stamp(new Date(1000000), "s") is 1000
	unstamp: ->
		d1 = new Date(1000000)
		d2 = $.date.unstamp $.date.stamp d1
		$.assert d1.toString() is d2.toString()
	convert: ->
		$.assert $.date.convert(1000000, "ms", "s") is 1000
	midnight: ->
		d2 = $.date.unstamp $.date.midnight new Date 1000000000
		$.assert d2.toString().indexOf("19:00:00 GMT-0500") > -1
	format: ->
		d1 = new Date(1000000000)
		d2 = new Date(1000000)
		$.assertEqual $.date.format(d1, "yyyy-mm-dd HH:MM:SS"), "1970-01-12 13:46:40"
		$.assertEqual $.date.format(d2, "yyyy-mm-dd HH:MM:SS"), "1970-01-01 00:16:40"
	parse: ->
		$.assert $.date.parse("1970-01-12 13:46:40", "yyyy-mm-dd HH:MM:SS", "ms") is 1000000000
	range: ->
		$.assertEqual $($.date.range(1000, 1000000, 3))
			.unstamp()
			.select("getUTCDate").call()
	chain_format: ->
		$.assertEqual $($.date.range 1000, 1000000, 3)
			.dateFormat("dd")
			.ints().sum(), 35
	chain_midnight: ->
		$.assertEqual $($.date.range 1000, 1000000, 3)
			.midnight()
			.dateFormat("HHMMSS")
			.ints().sum(), 0

$.testGroup "TNET",
	basic: ->
		obj = $.TNET.parse $.TNET.stringify a:1,b:[2,"3"]
		$.assert obj.a is 1, "1"
		$.assert obj.b[0] is 2, "2"
		$.assert obj.b[1] is "3", "3"

$.testGroup "StateMachine",
	hello: ->
		class TestMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: ->
						@output = "<"
						@GO 1
				}
					def: (c) -> @output += c.toUpperCase()
					eof: @GO 2
				}
					enter: -> @output += ">"
				}
			]
			constructor: ->
				super(TestMachine.STATE_TABLE)
				@output = ""
		m = new TestMachine
		$.assertEqual m.run("hello").output, "<HELLO>"
		$.assertEqual m.run("hi").output, "<HI>"

$.testGroup "Synth",
	basic_node: -> $.assertEqual $.synth("style").toString(), "$([<style/>])"
	class_node: -> $.assertEqual $.synth('style.specClass').toString(), '$([<style class="specClass"/>])'
	attr_node: -> $.assertEqual $.synth('style[foo=bar]').toString(), '$([<style foo="bar"/>])'
	text: -> $.assertEqual $.synth("style 'text'").toString(), "$([<style>text</style>])"
	entity1: -> $.assertEqual $.synth("style 'text&amp;stuff'").toString(), "$([<style>text&amp;stuff</style>])"
	entity2: -> $.assertEqual $.synth("style 'text&stuff'").toString(), "$([<style>text&stuff</style>])"

$.testGroup "Delay",
	delayAsync: (callback) ->
		t = $.now
		ferry_errors = (callback, f) ->
			return (a...) ->
				try f(a...)
				catch err
					callback err
		$.delay 1000, ferry_errors callback, ->
			delta = Math.abs(($.now - t) - 1000)
			callback false

$.testGroup "Config",
	hasDefault: ->
		$.assertEqual $.config.get("does-not-exist","default"), "default"
	canCall: ->
		$.assertEqual $.config("foo","default"), $.config.get("foo","default")
		

require("coffee-script")
dom = require("jldom")
dom.registerGlobals(global)
global.document = dom.createDocument()
global.window = global
require("../dist/bling.js")

$.testGroup "Test Internals",
	true: -> true
	trueFail: (cb) -> cb true
	trueAsync: (cb) -> setTimeout (-> cb false), 100
	trueAsyncFail: (cb) -> setTimeout (-> cb true), 200
	assert: -> $.assert true, "this will not display"
	asyncFail: (callback) ->
		setTimeout (->callback new Error("delayed error")), 500
	assertFail: (cb) ->
		$.assert false, "this will throw an exception, but is expected"
	async1: (callback) ->
		setTimeout (-> callback false), 300
	asyncDepends: (callback) ->
		$.depends 'async1', -> callback false

require "./common"

$.depends "math, random, unittest", ->
	$.testGroup "random",
		coin: ->
			$.assert $.approx $($.random.coin() for _ in [0...1000]).mean(), .5, .05
		ints: ->
			$.assert $.approx $($.random.int(0,10) for _ in [0...20000]).mean(), 5, .7
		gauss: ->
			$.assert $.approx $($.random.gaussian() for _ in [0...1000]).mean(), .5

coffeekup = require './src/coffeekup'
jade = require 'jade'
ejs = require 'ejs'
eco = require 'eco'
haml = require 'haml'
log = console.log

data = 
  title: 'test'
  inspired: no
  users: [
    {email: 'house@gmail.com', name: 'house'}
    {email: 'cuddy@gmail.com', name: 'cuddy'}
    {email: 'wilson@gmail.com', name: 'wilson'}
  ]

coffeekup_template = ->
  doctype 5
  html lang: 'en', ->
    head ->
      meta charset: 'utf-8'
      title @title
      style '''
        body {font-family: "sans-serif"}
        section, header {display: block}
      '''
    body ->
      section ->
        header ->
          h1 @title
        if @inspired
          p 'Create a witty example'
        else
          p 'Go meta'
        ul ->
          for user in @users
            li user.name

coffeekup_string_template = """
  doctype 5
  html lang: 'en', ->
    head ->
      meta charset: 'utf-8'
      title @title
      style '''
        body {font-family: "sans-serif"}
        section, header {display: block}
      '''
    body ->
      section ->
        header ->
          h1 @title
        if @inspired
          p 'Create a witty example'
        else
          p 'Go meta'
        ul ->
          for user in @users
            li user.name
"""

coffeekup_compiled_template = coffeekup.compile coffeekup_template

jade_template = '''
  !!! 5
  html(lang="en")
    head
      meta(charset="utf-8")
      title= title
      style
        | body {font-family: "sans-serif"}
        | section, header {display: block}
    body
      section
        header
          h1= title
        - if (inspired)
          p Create a witty example
        - else
          p Go meta
        ul
          - each user in users
            li= user.name
            li
              a(href="mailto:"+user.email)= user.email
'''

jade_compiled_template = jade.compile jade_template

ejs_template = '''
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8">
      <title><%= title %></title>
      <style>
        body {font-family: "sans-serif"}
        section, header {display: block}
      </style>
    </head>
    <body>
      <section>
        <header>
          <h1><%= title %></h1>
        </header>
        <% if (inspired) { %>
          <p>Create a witty example</p>
        <% } else { %>
          <p>Go meta</p>
        <% } %>
        <ul>
          <% for (user in users) { %>
            <li><%= user.name %></li>
            <li><a href="mailto:<%= user.email %>"><%= user.email %></a></li>
          <% } %>
        </ul>
      </section>
    </body>
  </html>
'''

eco_template = '''
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8">
      <title><%= @title %></title>
      <style>
        body {font-family: "sans-serif"}
        section, header {display: block}
      </style>
    </head>
    <body>
      <section>
        <header>
          <h1><%= @title %></h1>
        </header>
        <% if @inspired: %>
          <p>Create a witty example</p>
        <% else: %>
          <p>Go meta</p>
        <% end %>
        <ul>
          <% for user in @users: %>
            <li><%= user.name %></li>
            <li><a href="mailto:<%= user.email %>"><%= user.email %></a></li>
          <% end %>
        </ul>
      </section>
    </body>
  </html>
'''

haml_template = '''
  !!! 5
  %html{lang: "en"}
    %head
      %meta{charset: "utf-8"}
      %title= title
      :css
        body {font-family: "sans-serif"}
        section, header {display: block}
    %body
      %section
        %header
          %h1= title
        :if inspired
          %p Create a witty example
        :if !inspired
          %p Go meta
        %ul
          :each user in users
            %li= user.name
            %li
'''

haml_template_compiled = haml(haml_template)

benchmark = (title, code) ->
  start = new Date
  for i in [1..5000]
    code()

@run = ->
  benchmark 'CoffeeKup (precompiled)', -> coffeekup_compiled_template data
  benchmark 'Jade (precompiled)', -> jade_compiled_template data
  benchmark 'haml-js (precompiled)', -> haml_template_compiled data
  benchmark 'Eco', -> eco.render eco_template, data

  console.log '\n'

  benchmark 'CoffeeKup (function, cache on)', -> coffeekup.render coffeekup_template, data, cache: on
  benchmark 'CoffeeKup (string, cache on)', -> coffeekup.render coffeekup_string_template, data, cache: on
  benchmark 'Jade (cache on)', -> jade.render jade_template, locals: data, cache: on, filename: 'test'
  benchmark 'ejs (cache on)', -> ejs.render ejs_template, locals: data, cache: on, filename: 'test'

  console.log '\n'

  benchmark 'CoffeeKup (function, cache off)', -> coffeekup.render coffeekup_template, data
  benchmark 'CoffeeKup (string, cache off)', -> coffeekup.render coffeekup_string_template, data, cache: off
  benchmark 'Jade (cache off)', -> jade.render jade_template, locals: data
  benchmark 'haml-js', -> haml.render haml_template, locals: data
  benchmark 'ejs (cache off)', -> ejs.render ejs_template, locals: data
ul ->
  for guy in @stooges
    li guy
$().ready ->
  $('body').append templates.template(stooges: ['moe', 'larry', 'curly'])
ul ->
  for guy in @stooges
    li guy
app = require('express').createServer()

coffeekup = require '../../src/coffeekup'

app.set 'view engine', 'coffee'
app.register '.coffee', coffeekup.adapters.express

app.get '/', (req, res) ->
  res.render 'index'

app.get '/login', (req, res) ->
  res.render 'login', foo: 'bar', locals: {ping: 'pong'}

app.get '/inline', (req, res) ->
  res.send coffeekup.render ->
    h1 'This is an inline template.'

app.listen 3000

console.log "Listening on 3000..."
@title = 'Chunky Bacon!'
@canonical = 'http://chunky.bacon'

h1 @title

p 'This is the home page.'

p "Let's count to 10: "


partial 'partial', [1..10]doctype 5
html ->
  head ->
    meta charset: 'utf-8'

    meta(name: 'description', content: @description) if @description?
    link(rel: 'canonical', href: @canonical) if @canonical?

    link rel: 'icon', href: '/favicon.png'
    link rel: 'stylesheet', href: '/app.css'

    script src: 'http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js'
    script src: '/app.js'

    coffeescript ->
      $(document).ready ->
        alert 'hi!'        

    style '''
      header, nav, section, article, aside, footer {display: block}
      nav li {display: inline}
      nav.sub {float: right}
    '''
  body ->
    header ->
      a href: '/', title: 'Home', -> 'Home'

      nav ->
        ul ->
          for item in ['About', 'Pricing', 'Contact']
            
          li -> a href: '/about', title: 'About', -> 'About'
          li -> a href: '/pricing', title: 'Pricing', -> 'Pricing'
          li -> a href: '/contact', title: 'Contact Us', -> 'Contact Us'

    div id: 'content', ->
      @body

    footer ->
      p -> a href: '/privacy', -> 'Privacy Policy'
@title = 'Log In'

h1 @title


form action: '/', method: 'post', ->
  div class: 'field', ->
    label for: 'username', -> 'Username: '
    input id: 'username', name: 'username'

  div class: 'field', ->
    label for: 'password', -> 'Password: '
    input id: 'password', name: 'password'
p 'Express partial'meryl = require 'meryl'
coffeekup = require '../../src/coffeekup'

meryl.h 'GET /', (req, resp) ->
  people = ['bob', 'alice', 'meryl']
  resp.render 'layout', content: 'index', context: {people: people}

meryl.run
  templateDir: 'templates'
  templateExt: '.coffee'
  templateFunc: coffeekup.adapters.meryl

console.log 'Listening on 3000...'
h1 'Meryl example'
ul ->
  for name in @people
    li name
doctype 5
html ->
  head ->
    title 'Meryl example'
  body ->
    @render @content, @context
require('zappa') ->
  enable 'default layout'
  
  get '/': ->
    @franks = ['miller', 'oz', 'sinatra', 'zappa']
    render 'index'

  view index: ->
    @title = 'Zappa example'
    h1 @title
    ul ->
      for f in @franks
        li f
coffeekup = require './coffeekup'
fs = require 'fs'
path = require 'path'
puts = console.log
{OptionParser} = require 'coffee-script/lib/optparse'

argv = process.argv[2..]
options = null

handle_error = (err) -> console.log err.stack if err

compile = (input_path, output_directory, js, namespace = 'templates') ->
  fs.readFile input_path, 'utf-8', (err, contents) ->
    handle_error err

    name = path.basename input_path, path.extname(input_path)

    if not js
      output = coffeekup.render contents, options
      ext = '.html'
    else
      func = coffeekup.compile contents, options
      output = """
        (function(){ 
        }).call(this);
      """
      ext = '.js'

    write input_path, name, output, output_directory, ext

write = (input_path, name, contents, output_directory, ext) ->
  filename = name + ext
  dir = output_directory or path.dirname input_path
  path.exists dir, (exists) ->
    unless exists then fs.mkdirSync dir, 0777
    
    output_path = path.join dir, filename
    contents = ' ' if contents.length <= 0
    fs.writeFile output_path, contents, (err) ->
      handle_error err
      puts contents if options.print

usage = '''
  Usage:
    coffeekup [options] path/to/template.coffee
'''

switches = [
  ['--js', 'compile template to js function']
  ['-n', '--namespace [name]', 'global object holding the templates (default: "templates")']
  ['-w', '--watch', 'watch templates for changes, and recompile']
  ['-o', '--output [dir]', 'set the directory for compiled html']
  ['-p', '--print', 'print the compiled html to stdout']
  ['-f', '--format', 'apply line breaks and indentation to html output']
  ['-u', '--utils', 'add helper locals (currently only "render")']
  ['-v', '--version', 'display CoffeeKup version']
  ['-h', '--help', 'display this help message']
]

@run = ->
  parser = new OptionParser switches, usage
  options = parser.parse argv
  args = options.arguments
  delete options.arguments

  puts parser.help() if options.help or argv.length is 0
  puts coffeekup.version if options.version
  if options.utils
    options.locals ?= {}
    options.locals.render = (file) ->
      contents = fs.readFileSync file, 'utf-8'
      coffeekup.render contents, options

  if args.length > 0
    file = args[0]

    if options.watch
      fs.watchFile file, {persistent: true, interval: 500}, (curr, prev) ->
        return if curr.size is prev.size and curr.mtime.getTime() is prev.mtime.getTime()
        compile file, options.output, options.js, options.namespace
    
    compile file, options.output, options.js, options.namespace

if window?
  coffeekup = window.CoffeeKup = {}
  coffee = if CoffeeScript? then CoffeeScript else null
else
  coffeekup = exports
  coffee = require 'coffee-script'

coffeekup.version = '0.3.1'

coffeekup.doctypes =
  'default': '<!DOCTYPE html>'
  '5': '<!DOCTYPE html>'
  'xml': '<?xml version="1.0" encoding="utf-8" ?>'
  'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
  'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'
  'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">'
  '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">',
  'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">'
  'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
  'ce': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "ce-html-1.0-transitional.dtd">'

coffeescript_helpers = """
  var __slice = Array.prototype.slice;
  var __hasProp = Object.prototype.hasOwnProperty;
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
  var __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype;
    return child; };
  var __indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === item) return i;
    } return -1; };
""".replace /\n/g, ''

elements =
  regular: 'a abbr address article aside audio b bdi bdo blockquote body button
 canvas caption cite code colgroup datalist dd del details dfn div dl dt em
 fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup
 html i iframe ins kbd label legend li map mark menu meter nav noscript object
 ol optgroup option output p pre progress q rp rt ruby s samp script section
 select small span strong style sub summary sup table tbody td textarea tfoot
 th thead time title tr u ul video'

  void: 'area base br col command embed hr img input keygen link meta param
 source track wbr'

  obsolete: 'applet acronym bgsound dir frameset noframes isindex listing
 nextid noembed plaintext rb strike xmp big blink center font marquee multicol
 nobr spacer tt'

  obsolete_void: 'basefont frame'

merge_elements = (args...) ->
  result = []
  for a in args
    for element in elements[a].split ' '
      result.push element unless element in result
  result

coffeekup.tags = merge_elements 'regular', 'obsolete', 'void', 'obsolete_void'

coffeekup.self_closing = merge_elements 'void', 'obsolete_void'

skeleton = (data = {}) ->
  data.format ?= off

  data.autoescape ?= off

  __ck =
    buffer: []
      
    esc: (txt) ->
      if data.autoescape then h(txt) else String(txt)

    tabs: 0

    repeat: (string, count) -> Array(count + 1).join string

    indent: -> text @repeat('  ', @tabs) if data.format

    tag: (name, args) ->
      combo = [name]
      combo.push i for i in args
      tag.apply data, combo

    render_idclass: (str) ->
      classes = []
        
      for i in str.split '.'
        else
          classes.push i unless i is ''
            
      
      if classes.length > 0
        text " class=\""
        for c in classes
          text ' ' unless c is classes[0]
          text c
        text '"'

    render_attrs: (obj, prefix = '') ->
      for k, v of obj
        v = k if typeof v is 'boolean' and v
        

        if typeof v is 'object' and v not instanceof Array
          @render_attrs(v, prefix + k + '-')
        else if v

    render_contents: (contents) ->
      switch typeof contents
        when 'string', 'number', 'boolean'
          text @esc(contents)
        when 'function'
          text '\n' if data.format
          @tabs++
          result = contents.call data
          if typeof result is 'string'
            @indent()
            text @esc(result)
            text '\n' if data.format
          @tabs--
          @indent()

    render_tag: (name, idclass, attrs, contents) ->
      @indent()
    
      @render_idclass(idclass) if idclass
      @render_attrs(attrs) if attrs
  
      if name in @self_closing
        text ' />'
        text '\n' if data.format
      else
        text '>'
  
        @render_contents(contents)

        text '\n' if data.format
  
      null

  tag = (name, args...) ->
    for a in args
      switch typeof a
        when 'function'
          contents = a
        when 'object'
          attrs = a
        when 'number', 'boolean'
          contents = a
        when 'string'
          if args.length is 1
            contents = a
          else
            if a is args[0]
              idclass = a
            else
              contents = a

    __ck.render_tag(name, idclass, attrs, contents)

  yield = (f) ->
    temp_buffer = []
    old_buffer = __ck.buffer
    __ck.buffer = temp_buffer
    f()
    __ck.buffer = old_buffer
    temp_buffer.join ''

  h = (txt) ->
    String(txt).replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
    
  doctype = (type = 'default') ->
    text __ck.doctypes[type]
    text '\n' if data.format
    
  text = (txt) ->
    __ck.buffer.push String(txt)
    null

  comment = (cmt) ->
    text '\n' if data.format
  
  coffeescript = (param) ->
    switch typeof param
      when 'function'
      when 'string'
        script type: 'text/coffeescript', -> param
      when 'object'
        param.type = 'text/coffeescript'
        script param
  
  ie = (condition, contents) ->
    __ck.indent()
    
    __ck.render_contents(contents)
    text "<![endif]-->"
    text '\n' if data.format

  null

skeleton = String(skeleton)
  .replace(/function\s*\(.*\)\s*\{/, '')
  .replace(/return null;\s*\}$/, '')

skeleton = coffeescript_helpers + skeleton

coffeekup.compile = (template, options = {}) ->
  if typeof template is 'function' then template = String(template)
  else if typeof template is 'string' and coffee?
    template = coffee.compile template, bare: yes

  hardcoded_locals = ''
  
  if options.hardcode
    for k, v of options.hardcode
      if typeof v is 'function'

  tag_functions = ''
  tags_used = []
  
  for t in coffeekup.tags
    if template.indexOf(t) > -1 or hardcoded_locals.indexOf(t) > -1
      tags_used.push t
      
  for t in tags_used

  code = tag_functions + hardcoded_locals + skeleton


  code += 'with(data.locals){' if options.locals
  code += '}' if options.locals
  code += "return __ck.buffer.join('');"
  
  new Function('data', code)

cache = {}

coffeekup.render = (template, data = {}, options = {}) ->
  data[k] = v for k, v of options
  data.cache ?= off

  if data.cache and cache[template]? then tpl = cache[template]
  else if data.cache then tpl = cache[template] = coffeekup.compile(template, data)
  else tpl = coffeekup.compile(template, data)
  tpl(data)

unless window?
  coffeekup.adapters =
    simple: coffeekup.render
    meryl: coffeekup.render
    
    express:
      TemplateError: class extends Error
        constructor: (@message) ->
          Error.call this, @message
          Error.captureStackTrace this, arguments.callee
        name: 'TemplateError'
        
      compile: (template, data) -> 
        data.hardcode ?= {}
        data.hardcode.partial = ->
          text @partial.apply @, arguments
        
        TemplateError = @TemplateError
        try tpl = coffeekup.compile(template, data)
        
        return ->
          try tpl arguments...
  'Literal text':
    template: "text 'Just text'"
    expected: 'Just text'

  'Default DOCTYPE':
    template: "doctype()"
    expected: '<!DOCTYPE html>'

  'DOCTYPE':
    template: "doctype 'xml'"
    expected: '<?xml version="1.0" encoding="utf-8" ?>'

  'Custom tag':
    template: "tag 'custom'"
    expected: '<custom></custom>'

  'Custom tag with attributes':
    template: "tag 'custom', foo: 'bar', ping: 'pong'"
    expected: '<custom foo="bar" ping="pong"></custom>'

  'Custom tag with attributes and inner content':
    template: "tag 'custom', foo: 'bar', ping: 'pong', -> 'zag'"
    expected: '<custom foo="bar" ping="pong">zag</custom>'

  'Self-closing tags':
    template: "img src: 'icon.png', alt: 'Icon'"
    expected: '<img src="icon.png" alt="Icon" />'

  'Common tag':
    template: "p 'hi'"
    expected: '<p>hi</p>'

  'Attributes':
    template: "a href: '/', title: 'Home'"
    expected: '<a href="/" title="Home"></a>'

  'HereDocs':
    template: '''
      script """
        $(document).ready(function(){
          alert('test');
        });
      """
    '''
    expected: "<script>$(document).ready(function(){\n  alert('test');\n});</script>"

  'CoffeeScript helper (function)':
    template: "coffeescript -> alert 'hi'"
    expected: "<script>var __slice = Array.prototype.slice;var __hasProp = Object.prototype.hasOwnProperty;var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };var __extends = function(child, parent) {  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }  function ctor() { this.constructor = child; }  ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype;  return child; };var __indexOf = Array.prototype.indexOf || function(item) {  for (var i = 0, l = this.length; i < l; i++) {    if (this[i] === item) return i;  } return -1; };(function () {\n  return alert('hi');\n}).call(this);</script>"

  'CoffeeScript helper (string)':
    template: "coffeescript \"alert 'hi'\""
    expected: "<script type=\"text/coffeescript\">alert 'hi'</script>"

  'CoffeeScript helper (object)':
    template: "coffeescript src: 'script.coffee'"
    expected: "<script src=\"script.coffee\" type=\"text/coffeescript\"></script>"

  'Context vars':
    template: "h1 @foo"
    expected: '<h1>bar</h1>'
    params: {foo: 'bar'}

  'Local vars, hardcoded':
    template: 'h1 "harcoded: " + obj.foo'
    run: ->
      obj = {foo: 'bar'}
      @compiled = ck.compile(@template, hardcode: {obj})
      @expected = '<h1>harcoded: bar</h1>'
      @result = @compiled()
      @success = @result is @expected
      if @success
        obj.foo = 'baz'
        @result = @compiled()
        @success = @result is @expected

  'Local vars, hard-coded (functions)':
    expected: '<h1>The sum is: 3</h1>'
    params: {hardcode: {sum: (a, b) -> a + b}}

  'Local vars, hard-coded ("helpers")':
    template: "textbox id: 'foo'"
    expected: '<input id="foo" name="foo" type="text" />'
    params:
      hardcode:
        textbox: (attrs) ->
          attrs.name = attrs.id
          attrs.type = 'text'
          tag 'input', attrs

  'Local vars':
    template: 'h1 "dynamic: " + obj.foo'
    run: ->
      obj = {foo: 'bar'}
      @expected = '<h1>dynamic: bar</h1>'
      @result = render(@template, locals: {obj: obj})
      @success = @result is @expected
      if @success
        obj.foo = 'baz'
        @expected = '<h1>dynamic: baz</h1>'
        @result = render(@template, locals: {obj: obj})
        @success = @result is @expected

  'Comments':
    template: "comment 'Comment'"
    expected: '<!--Comment-->'

  'Escaping':
    template: "h1 h(\"<script>alert('\\\"pwned\\\" by c&a &copy;')</script>\")"
    expected: "<h1>&lt;script&gt;alert('&quot;pwned&quot; by c&amp;a &amp;copy;')&lt;/script&gt;</h1>"

  'Autoescaping':
    template: "h1 \"<script>alert('\\\"pwned\\\" by c&a &copy;')</script>\""
    expected: "<h1>&lt;script&gt;alert('&quot;pwned&quot; by c&amp;a &amp;copy;')&lt;/script&gt;</h1>"
    params: {autoescape: yes}

  'ID/class shortcut (combo)':
    expected: '<div id="myid" class="myclass1 myclass2">foo</div>'

  'ID/class shortcut (ID only)':
    expected: '<div id="myid">foo</div>'

  'ID/class shortcut (one class only)':
    template: "div '.myclass', 'foo'"
    expected: '<div class="myclass">foo</div>'

  'ID/class shortcut (multiple classes)':
    template: "div '.myclass.myclass2.myclass3', 'foo'"
    expected: '<div class="myclass myclass2 myclass3">foo</div>'

  'ID/class shortcut (no string contents)':
    expected: '<img id="myid" class="myclass" src="/pic.png" />'
      
  'Attribute values':
    template: "br vrai: yes, faux: no, undef: @foo, nil: null, str: 'str', num: 42, arr: [1, 2, 3], obj: {foo: 'bar'}, func: ->"
    expected: '<br vrai="vrai" str="str" num="42" arr="1,2,3" obj-foo="bar" func="(function () {}).call(this);" />'
    
  'IE conditionals':
    template: """
      html ->
        head ->
          title 'test'
          ie 'gte IE8', ->
            link href: 'ie.css', rel: 'stylesheet'
    """
    expected: '''
      <html>
        <head>
          <title>test</title>
          <!--[if gte IE8]>
            <link href="ie.css" rel="stylesheet" />
          <![endif]-->
        </head>
      </html>
      
    '''
    params: {format: yes}
    
  'yield':
    expected: '<p>This text could use <strong><a href="/">a link</a></strong>.</p>'

ck = require './src/coffeekup'
render = ck.render

@run = ->
  {print} = require 'sys'
  colors = {red: "\033[31m", redder: "\033[91m", green: "\033[32m", normal: "\033[0m"}
  printc = (color, str) -> print colors[color] + str + colors.normal

  [total, passed, failed, errors] = [0, [], [], []]

  for name, test of tests
    total++
    try
      test.original_params = JSON.stringify test.params

      if test.run
        test.run()
      else
        test.result = ck.render(test.template, test.params)
        test.success = test.result is test.expected
        
      if test.success
        passed.push name
      else
        failed.push name
    catch ex
      test.result = ex
      errors.push name

  
  if failed.length > 0
    printc 'red', "FAILED:\n\n"

    for name in failed
      t = tests[name]
      print t.template + "\n"
      print t.original_params + "\n" if t.params
      printc 'green', t.expected + "\n"
      printc 'red', t.result + "\n\n"

  if errors.length > 0
    printc 'redder', "ERRORS:\n\n"

    for name in errors
      t = tests[name]
      print t.template + "\n"
      printc 'green', t.expected + "\n"
      printc 'redder', t.result.stack + "\n\n"require "bling"
request = require "request"

defaultHandler = (callback) ->
	(err, resp, body) ->
		return callback(err, null) if err
		try
			obj = JSON.parse(body)
			return callback obj.err, null if "err" of obj
			return callback obj.error, null if "error" of obj
			return callback null, obj
		catch err
			return callback(err, null)

exports.init = (baseUrl) ->
	getDecisions: (apikey, sessionCode, ownerCode, agentCode, pointCode, callback) ->
		request(
			method: "GET"
			url: [baseUrl, ownerCode, agentCode, "decision"].join "/"
			qs:
				point: pointCode
			headers:
				"x-mpath-apikey": apikey
				"x-mpath-session": sessionCode
		, defaultHandler callback)
	sendReward: (apikey, sessionCode, ownerCode, agentCode, goalCode, callback) ->
		request(
			method: "POST"
			url: [baseUrl, ownerCode, agentCode, "goal", goalCode].join "/"
			headers:
				"x-mpath-apikey": apikey
				"x-mpath-session": sessionCode
		, defaultHandler callback)
	expireSession: (apikey, ownerCode, sessionCode, callback) ->
		request(
			method: "GET"
			url: [baseUrl, ownerCode, agentCode, "expire"].join "/"
			headers:
				"x-mpath-apikey": apikey
				"x-mpath-session": sessionCode
		, defaultHandler callback)
	createAgent: (apikey, ownerCode, agentCode, agentJson, callback) ->
		request(
			method: "PUT"
			url: [baseUrl, ownerCode, agentCode].join "/"
			headers:
				"x-mpath-apikey": apikey
			json: agentJson
		, defaultHandler callback)
	createApiKey: (rootKey, rootOwner, email, ownerCode, callback) ->
		if not ownerCode
			ownerCode = "owner_" + $.random.string 9
		request(
			method: "PUT"
			url: [baseUrl,ownerCode,"create-key",email].join "/"
			headers:
				"x-mpath-apikey": rootKey
				"x-mpath-owner": rootOwner
		, defaultHandler callback)
	checkLogin: (ownerCode, email, password, callback) ->
		request(
			method: "GET"
			url: [baseUrl,ownerCode,"login"].join "/"
			headers:
				"x-mpath-email": email
				"x-mpath-password": password
		, defaultHandler callback)
		
global.assert = (c, msg) ->
	if not c
		throw Error msg
global.assertEqual = (a, b, label) ->
	if a != b
global.assertArrayEqual = (a, b, label) ->
	for i in [0...a.length]
		try
			assertEqual(a[i], b[i], label)
		catch err

UI =
		output: (a...) -> console.log.apply console, a
		red: ""
		green: ""
		yellow: ""
		normal: ""
		output: (a...) -> console.log.apply console, a
		red: "[0;31;40m"
		green: "[0;32;40m"
		yellow: "[0;33;40m"
		normal: "[0;37;40m"
		output: (a...) -> document.write a.join(' ')+"<br>"
		red: "<font color='red'>"
		green: "<font color='green'>"
		yellow: "<font color='yellow'>"
		normal: "</font>"

global.ui = switch process?.env.TERM
	when "dumb" then UI.dumb
	when undefined then UI.html
	else UI.cterm

argv = process?.argv
if argv and argv.length > 2
	test_to_run = argv[2]
else
	test_to_run = "*"

total = [0,0,0]
failures = []
global.testGroup = (name, tests) ->
	failed = passed = 0
	for test_name of tests
		if test_to_run in ["*", test_name, name]
			test = tests[test_name]
			total[0] += 1
			try
				if test_to_run isnt "*"
					console.log "Running test:"
					console.log test.toString()
				test()
				passed += 1
				total[1] += 1
			catch err
				failed += 1
				total[2] += 1
				failures.push(test_name)
				if test_to_run isnt "*"
					throw err
global.testReport = () ->

testGroup("Testing Framework"
	pass: () -> true
)
require "./common"
{config} = require("../../common")
baseUrl = config.get "MPATH_URL", "http://localhost:8080"

testGroup "Client",
	init: ->
		driver = require("../index").init baseUrl
		assert typeof driver.createApiKey is "function"
	api: ->
		driver = require("../index").init baseUrl
		assert typeof driver.createApiKey is "function"
		driver.createApiKey "jesse@conductrics.com", null, (err, json) ->
			throw err if err
			assert "key" of json
			assert "owner" of json
			apikey = json.key
			ownerCode = json.owner
			sessionCode = $.random.string(16)
			driver.getDecisions apikey, sessionCode, ownerCode, "agent-1", "point-1", (err, json) ->
				throw err if err
				
		
	
require 'bling'
MpathClient = require('mpath-client').init $.config "MPATH_URL", "http://localhost:5001"
$.assert "checkLogin" of MpathClient
Routes = exports

helpers =
	code: (str) -> div class:'row', ->	div class:'span9', ->
		pre str
	json: (str) -> div class:'row', -> div class:'span8', ->
		pre class:@pretty ? 'prettyprint', -> str
	ready: (str) -> script type:'text/javascript', ->

defaults = ->
	hardcode: helpers
	title: 'Conductrics'
	jquery: true
	bootstrap: true
	mpathBaseUrl: $.config.get('MPATH_URL', 'http://localhost:3000')

Routes.login = (req, res) ->
	renderView req, res, 'login-page', false,
		title: 'Login'
Routes.post_login = (req, res) ->
	email = req.body.email
	password = req.body.password
	ownerCode = req.params.owner
	MpathClient.checkLogin ownerCode, email, password, (err, data) ->
		if err
			return renderView req, res, 'login-page', false,
				title: 'Login Error'
				err: err

Routes.agent_list = (req, res) ->
	renderView req, res, 'agent-list', false,
		title: 'Agent List'
Routes.agent_create = (req, res) ->
	renderView req, res, 'agent-create', false,
		title: 'Create New Agent'

Routes.manage_apikeys = (req, res) ->
	renderView req, res, 'manage-apikeys', false,
		title: 'API Keys'

Routes.manage_transforms = (req, res) ->
	renderView req, res, 'manage-transforms', false,
		title: 'Targeting Rules'
Routes.manage_transforms_rule = (req, res) ->
	renderView req, res, 'manage-transforms-rule', false,
		title: 'Targeting Rule'
		code: req.params.code
		isNew: req.params.new?

Routes.reporting_testing = (req, res) ->
	renderView req, res, 'reporting-testing', true,
		title: 'Report: Test Confidence'

Routes.reporting_impact = (req, res) ->
	renderView req, res, 'reporting-impact', true,
		title: 'Report: Targeting Impact'

Routes.doc_reporting_api = (req, res) ->
	renderView req, res, 'doc/doc_reporting_api', false
		title: 'Reporting API'
		prettify: true

renderView = (req, res, view, parseDates, values) ->
	params = $.extend defaults(),
		apikey: req.cookies.mkey
		owner: req.params.owner
		agent: req.params.agent
	if parseDates
		params.dateFrom = req.params.dateFrom ? $.date.format($.date.stamp(), 'yyyy-mm-dd')
		params.dateThru = req.params.dateThru ? params.dateFrom
	res.render view, $.extend params, values
partial 'partials/script-reporting-api' 

coffeescript ->
	loadReportData = ->
	onReportDataLoaded = (response) ->

div '.container-fluid', -> 
	div '.row-fluid', -> 
		div '.span2', ->
			partial 'partials/nav'
		div '.span10', ->
			div '.row-fluid', ->
				div '.span5', ->
					h2 "New Page"
					p ""
				div '.span7', ->
			div 'page-header', ->
			div
partial 'partials/script-reporting-api' 

coffeescript ->
	loadReportData = ->
	onReportDataLoaded = (response) ->

div '.container-fluid', -> 
	div '.row-fluid', -> 
		div '.span2', ->
			partial 'partials/nav'
		div '.span10', ->
			div '.row-fluid', ->
				div '.span5', ->
					h2 "Create New Agent"
					p ""
				div '.span7', ->
			div 'page-header', ->
			div ->
				div '.alert alert-block alert-error', -> 
					h4 '.alert-heading', "Not Yet Implemented"
					p "This page will provide a form for creating new agents 'from scratch'."
				div '.alert alert-block alert-info', -> 
					h4 '.alert-heading', "But you can still create agents!"
					p "You can still create new agents by just making decisions using the normal decision API. (provide link here)"	
					p ->
						text "Each time you use a different agent code with the API, it is created for you and will appear in your "
						text "."	script src:'/js/bootstrap-tab.js'
script src:'/js/bootstrap-dropdown.js'
script src:'/js/bootstrap-button.js'
script src:'/js/bootstrap-tooltip.js'
script src:'/js/bootstrap-modal.js'
script src:'/js/bootstrap-transition.js'
script src:'/js/jquery.timeago.js'

partial 'partials/script-reporting-api' 

style "
	.thumbnails > li {margin-left:10px}
	.thumbnail > h5 {padding-top:5px}
	.agent-stats li {list-style-type:none}
	.sparkline {margin-left:20px; border:thin solid gray}
"

partial 'partials/datatable', 
	nosearch:true
	columns: [
		sTitle: 'Point'
		mDataProp: 'point'
	,
		sTitle: 'Decision'
		mDataProp: 'decision'
	,
		sTitle: 'Options'
		mDataProp: 'choices'
	]

coffeescript ->
	loadReportData = ->
		MPATH.loadAgentListData {sort:'created'}, (response) ->
			loadStatusReportData()
	loadStatusReportData = ->
		agentCodes = []
		agentCodes.push(agent.code) for agent in mpp.data.agents
		MPATH.loadStatusReportData {codes:agentCodes.join(',')}, (response) ->
			for agent in mpp.data.agents
				agent.status = response.data[agent.code]
			drawAgentRecords()

	drawAgentRecords = () ->
		timeAgoHelper = (val) ->
			return '' if not val?
			return new Date(val * 1000).toISOString() 
		markup = []
		for item in mpp.data.agents
			markup.push """
				<div>
					<div class="row-fluid">
						<div class='well lightwell span5'>
							<table class="table-condensed" width="100%">
								<tr>
									<td align="right"><img class="sparkline" src="http://placehold.it/100x30/ffffff/49AFCD&text=sparkline" alt="">
								</tr>
								<tr>
									<td align="right"><img class="sparkline" src="http://placehold.it/100x30/ffffff/49AFCD&text=sparkline" alt=""></td>
								</tr>
							</table>
						</div>
						<div class='span7'>
							<ul class='thumbnails'>
								<li>
									<div class='thumbnail'>
										<h6><small>Targeting Analysis</small></h6>
									</div>
								</li>
								<li>
									<div class='thumbnail'>
										<h6><small>Winners & Confidence</small></h6>
									</div>
								</li>
								<li>
									<div class='thumbnail'>
										<img class='thumbnail-report' src='http://placehold.it/140x100&text=Lift' alt=''>
										<h5><i class="icon-plane"></i> Lift Report</h5>
										<h6><small>Coming Soon</small></h6>
									</div>
								</li>
							</ul>
						</div>
					</div>
				</div>
			"""
		$('.timeago').timeago();
		$('.thumbnail-report').tooltip({title:'"Live Preview" of this report<br>(coming soon)'})

		$('.menu-placeholder').each ->
			clone = mpp.proto.clone()
			$('.a-remove', clone).click -> 
				agentCode = $(this).parents('.menu-placeholder').attr('data-agent').valueOf()
			$('.a-remove-data', clone).click -> 
				agentCode = $(this).parents('.menu-placeholder').attr('data-agent').valueOf()
			$('.a-settings', clone).click -> 
				agentCode = $(this).parents('.menu-placeholder').attr('data-agent').valueOf()
				showAgentSettings(agentCode)
			$(this).append clone
	showAgentSettings = (agentCode) ->
		MPATH.getAgent agentCode, (agent) ->
			dialog.data('agent', agent)
			dialog.find('.agent-code').text agent.code
			dialog.find('input.agent-code').val agent.name ? agent.code
			dialog.find('button').tooltip()
			items = []
			for point in agent.points
				for decision in point.decisions
					item = {point:point.code, decision:decision.code, choices:[]}
					item.choices = item.choices.join('\n')
					items.push item
			table.fnClearTable()
			table.fnAddData items

	sendDeleteAgent = (agentCode) ->
		MPATH.agentDelete agentCode, (response, status) ->
			return unless status is "success"
	sendDeleteAgentData = (agentCode) ->
		MPATH.agentDeleteData agentCode, (response, status) ->
			return unless status is "success"
	saveAgentSettings = (agent) ->
		MPATH.putAgent agent, (response, status) ->
			return unless status is "success"
	onChangeInCreateDialog = () ->
		createButton = dialog.find('.modal-confirm-btn')
		url = MPATH.constructAgentDecisionUrl(agentCode, optionCodes)
		if url then $(createButton).addClass('btn-primary').removeClass('btn-warning')
		if not url then $(createButton).addClass('btn-warning').removeClass('btn-primary')
		return true
	$(document).ready ->
			loadReportData()
			dialog = $(this).parents('.modal').first()
			agent = dialog.data('agent')
			oLearning = agent.learning ?= {}
			oLearning.explorationRate = 1 if testingMode
			oLearning.explorationRate = .2 if !testingMode and oLearning.explorationRate is 1
			oSettings = agent.settings?={}

			if isFinite controlGroupRate
				(agent.learning?={}).controlGroupRate = controlGroupRate / 100
			saveAgentSettings(agent)
			dialog.modal('hide')
			agentCode = $(this).parents('.modal').modal('hide').data('agent')
			sendDeleteAgent(agentCode)
			agentCode = $(this).parents('.modal').modal('hide').data('agent')
			sendDeleteAgentData(agentCode)
			onChangeInCreateDialog()
			return unless url?
			MPATH.sendCreateAgentViaDecisionCall url, (response, status) ->
				return unless status is "success"
				loadReportData()
		loadReportData()

div '.container-fluid', -> 
	div '.row-fluid', -> 
		div '.span2', ->
			partial 'partials/nav'
		div '.span10', ->
			div '.row-fluid', ->
				div '.span5', ->
					h2 "Your Learning Agents"
					p ""
				div '.span7', ->
			div '.page-header.row-fluid', ->
				div '.span8', ->
						i '.icon-plus icon-white', ""
						text " Create New Agent"
				div '.buttonGroup.span4', ->
						i class:"icon-refresh icon-white"
						text ' Refresh'

	li 'dropdown', ->
		a 'dropdown-toggle active', 'data-toggle':'dropdown', 'data-target':'agentMenu', ->
			i '.icon-wrench', ""
			b ".caret", ""
		ul ".dropdown-menu", ->
			li -> 
					i '.icon-cog', ""
					text " Settings"
			li ".divider", ""
			li -> 
					i '.icon-trash', ""
					text " Reset all Data"
					i '.icon-remove', ""
					text " Delete Agent"

	div '.modal-header', ->
		button '.close', 'data-dismiss':'modal', type:'button', "x"
		h3 "Create Agent"
	div '.modal-body', ->
		form 'form-horizontal alert alert-info alert-block', ->
			fieldset ->
				div '.control-group', ->
					label 'control-label', "Agent Code"
					div 'controls', ->
				div '.control-group', ->
					label 'control-label', "Options"
					div 'controls', ->
		div '.control-group', ->
			label 'control-label', "Resulting Decision URL"
			div 'controls', ->
	div '.modal-footer', ->
		button '.btn', 'data-dismiss':'modal', type:'button', "Cancel"
		button ".btn btn-primary modal-confirm-btn", type:'button', "Create Agent"

	div '.modal-header', ->
		button '.close', 'data-dismiss':'modal', type:'button', "x"
		h3 ->
			text "Settings "
			small ".agent-code", ""
	div '.modal-body', ->
		ul 'nav nav-tabs', ->
			li 'active', -> 
			li -> 

		div 'tab-content', ->
				form 'form-horizontal', ->
					fieldset ->
						p "&nbsp;"
						div '.control-group', ->
							label 'control-label', "Display Name"
							div 'controls', ->
						div '.control-group', ->
							label 'control-label', "Decision Policy"
							div 'controls', ->
								div '.btn-group', 'data-toggle':'buttons-radio', ->
										type:'button', 
										'data-title':'Agent should favor the best options, based on its own testing', -> 
											i '.icon-headphones icon-white', ""
											text " Adaptive"
										type:'button', 
										'data-title':'Agent should only make random selections and provide reports', ->
											i '.icon-random icon-white', ""
											text " Testing Only"
								p ->
									div '.input-append', ->
										span '.add-on', "%"
									text ' of visitors should see the default options'
									label '.radio', ->
										strong 'Adaptive'
										text ' - agent should favor the best options, testing sometimes automatically'
								p ->
									label '.radio', ->
										strong 'Testing Only'
					form 'form-horizontal', ->
						fieldset ->
								label 'control-label', "Decisions"
								div 'controls', ->
							div '.control-group', ->
								label 'control-label', "Visitor Sessions"
								div 'controls', ->
									p ->
										label '.checkbox', ->
											strong 'Sticky'
											text ' - decisions should "stick" to each visitor session'
									p ->
										label '.checkbox', ->
											strong 'Cookies'
											text " - allow agent to set a session cookie as needed"

	div '.modal-footer', ->
		button '.btn', 'data-dismiss':'modal', type:'button', "Cancel"
		button ".btn btn-primary modal-confirm-btn", type:'button', ->
			i 'icon-ok icon-white', ""
			text " Save Changes"

partial 'partials/modal-confirm', 
	id: 'modalConfirmDelete'
	title: 'Delete Agent Forever'
	confirmClass: 'btn-danger'
	messages: [
		"The agent will be permanently deleted, and its data will no longer be available in reports."
		"You will, however, be able to re-use the same agent code to create a new agent at the same URLs, which will begin its mission anew."
	]
partial 'partials/modal-confirm', 
	id: 'modalConfirmDeleteData'
	title: 'Reset all Learning and History'
	confirmClass: 'btn-warning'
	messages: [
		"All data about learning / testing will be discarded, as if your agent was just created."
		"All data currently showing in any of this agent's reports will also be discarded forever."
		"This is useful if you have been playing around with your agent for a little while, and want to \"clear it out\" while preserving its setup."
	]	div class:'container', ->

	div '.row', ->
		div '.span4', ->
			img src:'/img/conductrics-logo-horiz.png'

		h1 "Welcome"

	section ->
		div class:"page-header"
		h2 "First Section"
		p class:"lead", "Explanation of what the section is about"

		p "First paragraph"div class:'container', ->

	div '.row', ->
		div '.span4', ->
			img src:'/img/conductrics-logo-horiz.png'

		h1 "Reporting API"
		p "Conductrics provides reports on agent learning, hypothesis testing, and the like. Most people will access those reports via the web by logging in to our administrative/reporting pages with their username and password."
		p "We also provide a Reporting API, documented here, which can be used to access the report data programatically, so that it can be displayed in a different form elsewhere, or used for some other purpose."
		text "This is the same API that our web-based reporting pages use internally."

		p ->
			div class:'alert alert-info alert-block', ->
				strong "Providing Your API Key: "
				text "You must provide a valid API key to any of the methods in our Reporting API. You can provide it as a URL param called 'apikey' as shown above, or you can pass it in a HTTP Header called 'x-mpath-apikey' if you want to keep it out of the query string."

		p ->
			text "Contents:"
			ul ->


	section ->
		div class:"page-header", ->
		p class:"lead", "Data about which option we'll pick for different types of users, with corresponding impact scores"
		p "To get the data shown in the 'Impact Report' portion of the Conductrics reporting pages, issue a GET to a URL like the following:"
		p "The above URL requests data for October 1, 2012. You can also request data for a date range like October 1 through October 7, like so:"

		div class:'alert alert-info alert-block', ->
			strong "About Dates: "
			text "Dates must be specified in YYYY-MM-DD form."
			p "Providing one date (first example) is just shorthand for providing the same date for the 'start' and 'end' dates."

		p "Assuming your API key has the appropriate access, the server will respond with a JSON data structure like this (comments and newlines added for clarity):"
		json """
		{
		  agent: "agent-103",
		  dateFrom: "2012-07-03",
		  dateThru: "2012-07-03",
		  data: [
		    
		    // one top-level record like this for each date in the specified date range 
		    {
		      date: "2012-07-03",
		      data: {

		        // always one array like this (per date record)
		        byFeature: [
  
		          // one sub-object like this for each feature
		          {
		            feature: ["west-coast"],
		            actions: [
		              { choice:"decision-1:a", impact:20 },
		              { choice: "decision-1:b", impact:80 },
		              { choice: "decision-1:c", impact: 10 }
		            ],
		            winner: { choice: "decision-1:b", impact: 80 }
		          },
      
		          {
		            feature: ["east-coast"],
		            actions: [
		              { choice:"decision-1:a", impact:0 },
		              { choice: "decision-1:b", impact:0 },
		              { choice: "decision-1:c", impact:0 }
		            ],
		            winner: null // possible not to have a winner yet
		          }
		          ... 
		        ],
      
		        // always one array like this (per date record)
		        byChoice: [
		          ...
		          
		          // one object like this for each choice
		          {
		            choice: "decision-1:b",
		            features: [
		              // one record for each feature where this choice is current "winner"
		              {feature: ["west-coast"], impact: 80},
		              ...
		            ]
		          },
      
		          {
		            choice: "decision-1:c",
		            features: [] // may be empty for some choices, if not "winner" for anyone
		          }
		        ],

		        // Convenience 'range' item provides the min/max impact reported herein 
		        // (useful for chart axis scales, etc)
		        range: {
		          min:0,
		          max:80
		        }
		    } 

		  ]
		}
		"""

		h3 "Optional parameters"
		p "You can provide these optional parameters to this report. Each of these parameters can be provided as a query string parameter, or as a header with the prefix 'x-mpath-', such as 'x-mpath-point'."
		dl ->
			dt "point"
			dd "An optional 'decision point' code that you want report data for. Defaults to the first decision point in your agent. Many agents only have one point, so there is no need to pass this parameter unless you are working with a mulit-point agent."
			dt "temperature-measure"
			dd "An advanced, optional 'temperature' measure to be used in all of the 'impact' calculations. The default value if not provided is 2. We do not recommend changing the temperature unless specifically guided to do so by us for some kind of very specialized need. Because we generally discourage providing any value other than the default, we recommend that you do not provide this option unless truly needed."


	section ->
		div class:"page-header", ->
		p class:"lead", "Data about the estimated mean value of your agent's options, with confidence scores"

		p "To get the data shown in the 'Option Confidence' portion of the Conductrics reporting pages, issue a GET to a URL like the following:"
		p "The above URL requests data for October 1, 2012. You can also request data for a date range like October 1 through October 7, like so:"

		div class:'alert alert-info alert-block', ->
			strong "About Dates: "
			text "Dates must be specified in YYYY-MM-DD form."
			p "Providing one date (first example) is just shorthand for providing the same date for the 'start' and 'end' dates."

		p "Assuming your API key has the appropriate access, the server will respond with a JSON data structure like this (comments and newlines added for clarity):"
		json """
		{
		  dateFrom: "2012-10-01",
		  dateThru: "2012-10-07",

		  data: {
		    bLo: 0.01615007001786055,
		    bHi: 0.21812769810311980,

		    items: [

		      // one item like this for each combination of date/choice/segment
		      {
		        point: "point-1",

		        date: "2012-10-01",
		        choice: "decision-1:a",
		        seg: "(none)",
		        
		        count: 29025,
		        val: 434,
		        vMean: 0.01713888406049018,
		        bLo: 0.01615007001786055,
		        bHi: 0.01812769810311981,
		        vVari: 0.01712385378105195,
		        stdDev: 0.13085814373225668,
		        tScore: -2.0751947553348264,
		        dgFree: 57446,
		        pValue: 0.9810135371107048,
		        signif: true
		        ts: 1341522409717
		      },

		      // ... more items like the item above...
		    ]
		  }
		}
		"""

		h3 "Optional parameters"
		p "You can provide these optional parameters to this report. Each of these parameters can be provided as a query string parameter, or as a header with the prefix 'x-mpath-', such as 'x-mpath-confidence-measure'."
		dl ->
			dt "confidence-measure"
			dd "An optional confidence measure to be used in the report calculations, from 0 to 1. The default value if not provided is 0.8. This main purpose of this measure is to change when the 'signif' flag on each item changes to true; if the pValue for a given item is greater than the confidence measure then signif will be true."
			dt "point"
			dd "An optional 'decision point' code that you want report data for. Defaults to the first decision point in your agent. Many agents only have one point, so there is no need to pass this parameter unless you are working with a mulit-point agent."
			dt "comparison-decision"	
			dd "An optional 'comparison' code. When not provided, this parameter defaults to the 'default' option(s) at the decision point in question, which means that the report is conceptually reporting on each item's performance against the default option. Providing this parameter allows you to specify a different basis item that you want each item's performance compared to and reported on."		
			dt "use-bonferroni"	
			dd "Set this to 'false' to indicate that you do not want the <a href=\"http://en.wikipedia.org/wiki/Bonferroni_correction\">Bonferroni Correction</a> applied to the calculations. The default is 'true'."		

		h3 "Data item fields"
		p "Here is a brief description of the data fields you'll see for each item."
		dl ->
			dt "count"
			dd "The number of times this combination was served (total, during the day in question)."
			dt "val"
			dd "The total reward value from goal events (total, during the day in question). Used internally to compute the other statistics. Typically not terribly important to end users in bare forms."
			dt "bLo"
			dd "The lower bound for the estimate of this choice's value. Typically the lower and upper bounds are used to draw a horizontal bar that makes it easier to interpret the report data visually. The bar for each item is drawn from bLo to bHi, on a scale based on the overall bLo and bHi values (at the 'data' level)."
			dt "bHi"
			dd "The upper bound for the estimate of this choice's value (see bLo)."
			dt "vMean"
			dd "The estimated value of this choice, based on goal events attributed to the choice in question. Typically this value is displayed in the center of the bar for the lower/upper bounds. This value is the conceptual focus of the report for most users."
			dt "signif"
			dd "A Boolean flag that indicates whether there is evidence to support that the mean value has significance, based on the confidence measure in use. Will be true if the p-value is less than (1-confidence), where confidence is 0.8 (by default, or whatever confidence has been provided to the optional 'confidence-measure' parameter)."
			dt "vVari"
			dd "The statistical variance associated with the value of the goal events attributed to the choice in question."
			dt "stdDev"
			dd "Standard deviation calculation, used internally to compute some of the other calculations (typically not important to end users)."
			dt "tScore"
			dd "<a href=\"http://en.wikipedia.org/wiki/Student%27s_t-test\">Student's T calculation</a>, used internally to compute some of the other calculations (typically not important to end users)."
			dt "dgFree"
			dd "Degrees of freedom, used internally to compute some of the other calculations (typically not important to end users)."
			dt "pValue"
			dd "Statistical <a href=\"http://en.wikipedia.org/wiki/P-value\">P-Value</a>, used internally to compute some of the other calculations. Conceptually important to end users, but more typically displayed by simply indicating whether the P-Value exceeds the basis confidence measure. See the 'signif' flag in this list."
			dt "ts"
			dd "Timestamp of the last time this record was updated (typically not important to end users)."

	section ->
		div class:"page-header", ->
		p class:"lead", "Raw data about the accumulated value of options"
		p "You can get raw information about the current internal score for each option (per targeting feature and segment, if any) via a URL like the following:"
		p "The above URL requests data for October 1, 2012. You can also request data for a date range like October 1 through October 7, like so:"

		div class:'alert alert-block', ->
			strong "About This Data: "
			text "This raw data is not displayed in direct form in of our web-based report pages, because it is not necessarily illuminating for most people without further analysis and normalization to account for variance in scales and so on. While this API call is provided and supported for certain specialized integration use cases, do not recommend using it unless you are well-versed in statistics, or have gotten further instruction from us as to how to interpret the data and/or present it usefully to your own users."

		p "Assuming your API key has the appropriate access, the server will respond with a JSON data structure like this (comments and newlines added for clarity):"
		json """
		{
		  dateFrom: "2012-10-01",
		  dateThru: "2012-07-04",
		  data: [

		    // One record like this for each choice at each point, for each
		    // targeting segment and feature (default "(none)" segment/feature shown here)
		    {
		      date: "2012-07-01",
		      agent: "agent-103",
		      owner: "acme",
		      // targeting segment and feature
		      seg: "(none)", 
		      feature: "(none)",
		      // option selection
		      point: "point-1",
		      choice: "decision-1:a",
		      // actual data
		      count: 0, // number of times option was selected (rolling, accumulated total)
		      val: 0 // internal score for the option, based on goals achieved after selection
		             // NOT NECESSARILITY USEFUL without further analysis/normalization
		    }

		    ...
		  ]  
		}
		"""

		h3 "Optional parameters"
		p "You can provide this optional parameter to this report. A parameter can be provided as a query string parameter, or as a header with the prefix 'x-mpath-', such as 'x-mpath-point'."
		dl ->
			dt "point"
			dd "An optional 'decision point' code that you want report data for. Defaults to the first decision point in your agent. Many agents only have one point, so there is no need to pass this parameter unless you are working with a mulit-point agent."

doctype 5
text "\n"
html lang:'en', ->
	head ->
		link rel:'stylesheet', href:'/stylesheets/style.css'
		if @bootstrap
			link rel:'stylesheet', href:'/stylesheets/bootstrap.css'
			link rel:'stylesheet', href:'/stylesheets/bootstrap-responsive.css'
			link rel:'stylesheet', href:'/stylesheets/DT_bootstrap.css'
		if @prettify
			link rel:'stylesheet', href:'/js/google-code-prettify/prettify.css'
		if @lofty
			link rel:'stylesheet', href:'/stylesheets/lofty-core.css', media:'screen'
			link rel:'stylesheet', href:'/stylesheets/lofty-core.css', media:'print'

		if @jquery
			script type:'text/javascript', src:'/js/jquery.js' 
			script type:"text/javascript", src:'/js/jquery.dataTables.js'
		if @bootstrap
			script type:"text/javascript", src:'/js/DT_bootstrap.js'
		if @lofty
			script type:'text/javascript', src:'/js/lofty-global.js'
		if @prettify
			script type:'text/javascript', src:'/js/google-code-prettify/prettify.js'
			ready 'prettyPrint();'
	body ->
		@bodybuttonClass = unless @err then 'btn-info' else 'btn-warning'

style "
	.modal {position:auto !important; margin:100px 50px !important; top:auto; left:auto; width:auto}
	.modal-body {padding-right:100px}
	body {background:url(/img/hero-back.jpg) 0px 0px}
"

div '.container-fluid', -> 
	div '.row-fluid', -> 
		div '.span3', ->
			img src:'/img/conductrics-logo.png', alt:'Conductrics', ""
		div '.span9', ->
			form 'form-vertical', action: '', method: 'post', ->
				div "modal", ->
					div '.modal-header', ->
					div '.modal-body', ->
						fieldset ->
							div '.control-group', ->
								label 'control-label', for:'email', "Email"
								div 'controls', ->
									input 'input-xlarge', id: 'email', name: 'email', type:'email'
							div '.control-group', ->
								label 'control-label', for:'password', "Password"
								div 'controls', ->
									input 'input-xlarge', id: 'password', name: 'password', type:'password'
							if @err
								div '.control-group error', ->
									div 'controls', ->
										p @err
					div '.modal-footer', ->

partial 'partials/script-reporting-api' 

partial 'partials/datatable', 
	columns: [
		sTitle: 'API Key'
		mDataProp: 'code'
		sCellType: 'TH'
		sWidth: '50%'
	,
		sTitle: 'Active'
		mDataProp: 'active'
		sWidth: '5em'
	,
		sTitle: 'Account-Level Access'
		mDataProp: 'access.@'
	,
		sTitle: 'Agent-Level Access'
		mDataProp: 'access.*'
	]

coffeescript ->
	$(document).ready ->
		loadReportData()
		$('.disabled').tooltip({title:"Coming soon"})

	loadReportData = ->
		MPATH.loadApiKeysData {}, (response) ->
			for item in response.data.apikeys
				item.access = {}
				for code,mapping of item.mappings
					perms = []
					for perm,granted of mapping.access
						icon = if granted then 'icon-ok' else 'icon-remove'
						labelClass = if granted then 'label-info' else 'label-important'
					item.access[code] = perms.join '<br>'


div '.container-fluid', -> 
	div '.row-fluid', -> 
		div '.span2', ->
			partial 'partials/nav'
		div '.span10', ->
			div '.row-fluid', ->
				div '.span5', ->
					h2 "Your API Keys"
					p ""
				div '.span7', ->
			div '.alert', ->
				strong "Please Note "
				text "This page is display-only at this time. API key managemment functions such as adding new keys or deactivating existing keys will be added in an upcoming release."
			div ->
				div '.buttonGroup', ->
					button '.btn disabled', "Add Another API Key"
					text " "
					button '.btn disabled', "Deactivate Key"
script src:'/js/bootstrap-tooltip.js'
script src:'/js/bootstrap-transition.js'
script src:'/js/bootstrap-modal.js'
script src:'/js/bootstrap-button.js'
script src:'/js/bootstrap-typeahead.js'


partial 'partials/script-reporting-api' 

partial 'partials/datatable', 
	sZeroRecords: '<strong>No conditions yet.</strong><br/>You will need to add at least one to save this targeting rule.<br/>Click the New Condition button to add one.'
	columns: [
		sTitle: 'Condition'
	]

coffeescript ->
	mpp = 
		data:{}
		returnUrl: null
	loadOptionsData = ->
		MPATH.loadTransformsOptionsData {}, (response) ->
			loadReportData()
	loadReportData = ->
		code = getCode()
		MPATH.loadTransformsListData {codes:[code]}, (response) ->
			mpp.data.isNew = response.data.transforms.length is 0
			if mpp.data.isNew
			if response.data.transforms.length is 1
			return alert("Sorry, we have encountered an error") unless mpp.data.transform?
			for column in table.fnSettings().aoColumns
				column.fnRender = fnRenderConditionColumn
			redrawTableData()
	redrawTableData = () ->
		table.fnClearTable()
		table.fnAddData mpp.data.transform.when
	fnRenderConditionColumn = (o, val) ->
		parts = o.aData
	validateForm = ->
		valid = true
			valid = false
			valid = false
		unless mpp.data.transform.when.length > 0
			alert('You must specify at least one condition.')
			valid = false
			valid = false
		return valid
	getCode = () ->
	window.removeCondition = (rowNum) ->
		mpp.data.transform.when.splice(rowNum, 1)
		redrawTableData()
	editCondition = (condition) ->
			codes = []; codes.push item.code for item in mpp.data.options.providers
			content = []
			for item in mpp.data.options.operators
				valid = validateCondition()
				if valid
					cond = [
					]
					mpp.data.transform.when.push cond
					redrawTableData()
			validateCondition = () ->
				resetCondition()
				valid = true
				unless left?.length > 0
					valid  = false
				unless right?.length > 0
					valid = false
				unless valid
				return valid
			resetCondition = () ->

	$(document).ready ->
			editCondition(['', 'eq', ''])
			MPATH.transformDelete getCode(), {}, (val, status) ->
				if status is 'success'
					return window.location.href = window.returnUrl
				alert("Sorry, your rule could not be deleted.")

			valid = validateForm()
			if valid
				transform = mpp.data.transform
				else 
					delete transform.apply.segment
				else 
					delete transform.apply.feature
				MPATH.transformPut transform, {}, (val, status) ->
					if status is 'success'
						return window.location.href = window.returnUrl
					alert("Sorry, your rule could not be saved.")

		loadOptionsData()


style """
.control-label {font-weight:bold}
"""

div '.container-fluid', -> 
	div '.row-fluid', -> 
		div '.span2', ->
			partial 'partials/nav'
		div '.span10', ->
			div '.row-fluid', ->
				div '.span5', ->
					h2 ->
						text "Targeting Rule"
				div '.span7', ->
				li -> 
					span '.divider', ""
			section ->
				form '.form-horizontal form-search', ->
					fieldset ->
						div '.control-group', ->
							label 'control-label', for:'left', "Rule Name"
							div 'controls', ->
								span 'help-inline', "Letters, numbers, and dashes only, please"
						div '.control-group', ->
							label 'control-label', for:'left', "Enabled for Agents"
							div 'controls', ->
								span 'help-inline', "Type a * for all agents, or an agent code or codes"
						div '.control-group', ->
							label 'control-label', for:'left', "Trigger Conditions"
							div 'controls.well.lightwell', ->
								div '.buttonGroup', ->
										i '.icon-plus icon-white', ""
										text " New Condition"
						div '.control-group', ->
							label 'control-label', for:'apply-segment', "Targeting to Apply"
							div 'controls.well.lightwell', ->
								div '.alert', ->
									strong " Targeting Codes "
									text "Provide a segment and/or feature code below. If the code isn't in use yet, it will be added to your agents the first time this rule fires for a visitor."
								p ->
									div -> strong "Segment"
									span 'help-inline', "Segment code to place visitor sessions into"
								p ->
									div -> strong "Feature"
									span 'help-inline', "Feature code to 'tag' visitor sessions with"
						div '.control-group', ->
							div 'controls', ->
									i '.icon-ok.icon-white', ""
									text " Save Targeting Rule"
								span ->
									text " or "
										i '.icon-remove.icon-white', ""
										text " Remove Rule"
								text " or "

	div '.modal-header', ->
		button '.close', 'data-dismiss':'modal', type:'button', "x"
		h3 "Condition"
	div '.modal-body', ->
			fieldset ->
				div '.control-group', ->
					label 'control-label', for:'left', "Data"
					div 'controls', ->
				div '.control-group', ->
					label 'control-label', for:'operators', "Operator"
					div 'controls', ->
				div '.control-group', ->
					label 'control-label', for:'right', "Value"
					div 'controls', ->
	div '.modal-footer', ->
		button '.btn', 'data-dismiss':'modal', type:'button', "Cancel"

partial 'partials/modal-confirm', 
	id: 'confirmDeleteModal'
	title: 'Remove Targeting Rule'
	confirmClass: 'btn-danger'
	messages: [
		"Really delete this rule?"
partial 'partials/script-reporting-api' 

partial 'partials/datatable', 
	sZeroRecords: "<strong>No targeting rules yet.</strong><br/>You can create your first one with the button on this page."
	columns: [
		sTitle: 'Rule', 
		mDataProp: 'code'
		sWidth: '20%'
	,
		sTitle: 'For Agents', 
		mDataProp: 'agents',
		sWidth: '20%'
	,
		sTitle: 'Targeting', 
		mDataProp: 'apply'
	,
		sTitle: 'Conditions', 
		mDataProp: 'when'
	]

coffeescript ->
	$(document).ready ->
		loadReportData()
	loadReportData = ->
		MPATH.loadTransformsListData {}, (response) ->
			for column in table.fnSettings().aoColumns
				column.fnRender = fnRenderApplyColumn if column.mDataProp is "apply"
				column.fnRender = fnRenderAgentsColumn if column.mDataProp is "agents"
				column.fnRender = fnRenderWhenColumn if column.mDataProp is "when"
				column.fnRender = fnRenderCodeColumn if column.mDataProp is "code"
			table.fnAddData mpp.data.transforms
	fnRenderCodeColumn = (o, val) ->
	fnRenderAgentsColumn = (o, val) ->
		result = []
		for item in o.aData.agents
		return result.join('<br/>')	
	fnRenderApplyColumn = (o, val) ->
		result = []
		return result.join('<br/>')	
	fnRenderWhenColumn = (o, val) ->
		result = []
		return result.join('<br/>')	

div '.container-fluid', -> 
	div '.row-fluid', -> 
		div '.span2', ->
			partial 'partials/nav'
		div '.span10', ->
			div '.row-fluid', ->
				div '.span5', ->
					h2 "Targeting Rules"
					p ""
				div '.span7', ->
			div ->
			div '.buttonGroup', ->
					i '.icon-plus icon-white', ""
pass in:
	tableSelector - should select a <table> in the page's markup
	columns - array of objects with column properties, see http://datatables.net/usage/columns
sDomTop = unless @nosearch then "'row'<'span6'l><'span6'f>" else ""
sDomBot = if @paging then "<'row'<'span6'><'span6'p>" else ""

options = 
	aoColumns: @columns
	sPaginationType: "bootstrap"
	bPaginate: @paginate is true
	bLengthChange: false
	bFilter: true
	oLanguage: 
		sSearch: '<i class="icon-search"></i>'
		sZeroRecords: @sZeroRecords ? 'No data to show here yet.'
if @options?
	for k,v of @options
		options[k] = v


script type:"text/javascript", """
	$(document).ready(function() {
	})
"""div '.well lightwell', ->
	p ->
		small "Date Range"
	text " to "
	text " "
		i class:"icon-refresh icon-white"
		text ' Refresh'@id ?= "modalConfirm"
@title ?= "Please Confirm"
@messages ?= ["Are you sure?"]
@confirmLabel ?= @title
@confirmClass ?= 'btn-primary'

	div '.modal-header', ->
		button '.close', 'data-dismiss':'modal', type:'button', "x"
	div '.modal-body', ->
	div '.modal-footer', ->
		button '.btn', 'data-dismiss':'modal', type:'button', "Cancel"

img src:'/img/conductrics-logo-horiz.png', width:'200'
section ->
	div '.well.well-thin', ->
		ul class:'nav nav-list', ->
			li '.nav-header', style:'font-weight:normal', "Greetings"
			li '.nav-header', "Agents"
			li ->
					i ".icon-list-alt", ""
					text " Agent List "
					span '.badge badge-info', "8"
			li ->
					i ".icon-pencil", ""
					text " Create Agent"

			li '.nav-header', "Reports"
			li '', ->
					i ".icon-signal", ""
					text " Impact"
			li ->
					i ".icon-adjust", ""
					text " Confidence"
			li ->
					i ".icon-plane", ""
					text " Lift"

			li '.nav-header', "Manage"
			li ->
					i ".icon-flag", ""
					text " Targeting Rules"
			li ->
					i ".icon-cog", ""
					text " API Keys"
			li ->
					i ".icon-user", ""
					text " Logins"
			li ->
					i ".icon-user", ""
					text " Account"
			li '.divider', ""
			li ->
					i ".icon-off", ""
					text " Logout"script type:'text/javascript', src:'/js/mpath-reporting-api.js'
script """
"""link rel:'stylesheet', href:'/stylesheets/ui-lightness/jquery-ui-1.8.21.custom.css'

script src:'/js/jquery.sparkline.min.js'
script src:'/js/bootstrap-tooltip.js'
script src:'/js/bootstrap-popover.js'
script src:'/js/bootstrap-transition.js'
script src:'/js/bootstrap-collapse.js'
script src:'/js/jquery.timers.js'
script src:'/js/jquery-ui-1.8.21.custom.min.js'
script type:'text/javascript', src:'/js/jquery.makeDragGroups.js'

partial 'partials/script-reporting-api' 

script """
	var mpp = {
	  animate:true,
	  data: null, // will be set via ajax
	  features: null, // will be set after ajax
	  redraw:false
	}
"""

script type:'text/javascript', src:'/js/reporting-impact.js'

div '.container-fluid', -> 
	div '.row-fluid page-header', -> 

		div '.span2', ->
			partial 'partials/nav'

		div '.span10', ->


				div '.span5', ->
					h2 "Targeting Impact Report"
					p "Insight into the choices we're making for your visitors, and which visitor features matter most."
				
				

					div '.accordion-group', ->
						div '.accordion-heading', ->
								i '.icon-calendar', ""
								text " Date Range"
							div '.accordion-inner', ->
								partial 'partials/datepickers'
					div '.accordion-group', ->
						div '.accordion-heading', ->
								i '.icon-star-empty', ""
								" Consider Features Together"
							div '.accordion-inner', ->
								div '.row-fluid', ->
									div '.well.well-slim.span8', ->
										h4 -> small -> 'Visitor Features'
									div '.well.well-slim.span4', ->
										h4 -> small -> 'Drag here to group'
										ul '.sortableGroup.sortables', ""
						div '.accordion-heading', ->
								"Timeline"
							div '.accordion-inner', ->
									p ->
										small ->
											text "Timeline: "
			div ->
				div '.row-fluid', ->
					div 'span7', ->
						h3 "Impact By Feature"
							p "One moment..."

					div 'span5', ->
						h3 "Impact By Choice"
							p "One moment..."
script src:'/js/jquery.dataTables.js'
script src:'/js/jquery.sparkline.min.js'

script src:'/js/DT_bootstrap.js'
link rel:'stylesheet', href:'/stylesheets/DT_bootstrap.css'

script src:'https://ajax.googleapis.com/ajax/libs/jqueryui/1.8.18/jquery-ui.min.js'
link rel:'stylesheet', href:'/stylesheets/ui-lightness/jquery-ui-1.8.21.custom.css'

script """
	var mpp = {
	  bLo:0, bHi:0 // will be replaced when data loaded
	}
"""

partial 'partials/script-reporting-api' 

script type:'text/javascript', src:'/js/reporting-testing.js'

div class:'container', ->

	div '.row', ->
		div '.span4', ->
			img src:'/img/conductrics-logo-horiz.png'


		div ->
			p ->
				text " to "
				i class:"icon-refresh icon-white"
				text ' Refresh'


	section ->
		div '.row', ->
			div '.span10', ->
				h2 "Option Confidence"
				p class:"lead", "Looking at the results from an A/B Testing perspective"

			div 'span2', style:'padding:10px !important', ->
				p ->
					small ->
						text "Confidence measure: "

			i class:'icon-time'
request = require "request"

defaultHandler = (callback) ->
	(err, resp, body) ->
		return callback(err, null) if err
		try
			obj = JSON.parse(body)
			return callback obj.err, null if "err" of obj
			return callback obj.error, null if "error" of obj
			return callback null, obj
		catch err
			return callback(err, null)

exports.init = (baseUrl) ->
	getDecisions: (apikey, sessionCode, ownerCode, agentCode, pointCode, callback) ->
		request(
			method: "GET"
			url: [baseUrl, ownerCode, agentCode, "decision"].join "/"
			qs:
				point: pointCode
			headers:
				"x-mpath-apikey": apikey
				"x-mpath-session": sessionCode
		, defaultHandler callback)
	sendReward: (apikey, sessionCode, ownerCode, agentCode, goalCode, callback) ->
		request(
			method: "POST"
			url: [baseUrl, ownerCode, agentCode, "goal", goalCode].join "/"
			headers:
				"x-mpath-apikey": apikey
				"x-mpath-session": sessionCode
		, defaultHandler callback)
	expireSession: (apikey, ownerCode, sessionCode, callback) ->
		request(
			method: "GET"
			url: [baseUrl, ownerCode, agentCode, "expire"].join "/"
			headers:
				"x-mpath-apikey": apikey
				"x-mpath-session": sessionCode
		, defaultHandler callback)
	createAgent: (apikey, ownerCode, agentCode, agentJson, callback) ->
		request(
			method: "PUT"
			url: [baseUrl, ownerCode, agentCode].join "/"
			headers:
				"x-mpath-apikey": apikey
			json: agentJson
		, defaultHandler callback)
	createApiKey: (rootKey, rootOwner, email, ownerCode, callback) ->
		if not ownerCode
			ownerCode = "owner_" + $.random.string 9
		request(
			method: "PUT"
			url: [baseUrl,ownerCode,"create-key",email].join "/"
			headers:
				"x-mpath-apikey": rootKey
				"x-mpath-owner": rootOwner
		, defaultHandler callback)
	checkLogin: (ownerCode, email, password, callback) ->
		request(
			method: "GET"
			url: [baseUrl,ownerCode,"login"].join "/"
			headers:
				"x-mpath-email": email
				"x-mpath-password": password
		, defaultHandler callback)
		



log = (a...) ->
	try return console.log.apply console, a
	alert a.join(", ")

Object.keys ?= (o) -> (k for k of o)

extend = (a, b) ->
	return a if not b
	for k of b
		v = b[k]
		if v? then a[k] = v
	a

defineProperty = (o,name,opts) ->
	Object.defineProperty o,name, extend({
		configurable: true
		enumerable: true
	}, opts)
	o



isType = (T, o) ->
	if not o? then T in [o,"null","undefined"]
	else o.constructor is T or
		o.constructor.name is T or

inherit = (parent, obj) ->
	if typeof parent is "function"
	obj.__proto__ = parent
	obj

_type = (->

	cache = {}

	base =
		name: 'unknown'
		match: (o) -> true

	order = []

	register = (name, data) ->
		order.unshift name if not (name of cache)
		cache[data.name = name] = if (base isnt data) then (inherit base, data) else data

	_extend = (name, data) ->
		if typeof name is "string"
			cache[name] ?= register name, {}
			cache[name] = extend cache[name], data
		else if typeof name is "object"
			(_extend k, name[k]) for k of name

	lookup = (obj) ->
		for name in order
			if cache[name]?.match.call obj, obj
				return cache[name]

	register "unknown",   base
	register "object",    match: -> typeof @ is "object"
	register "error",     match: -> isType 'Error', @
	register "regexp",    match: -> isType 'RegExp', @
	register "string",    match: -> typeof @ is "string" or isType String, @
	register "number",    match: -> isType Number, @
	register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
	register "array",     match: -> Array.isArray?(@) or isType Array, @
	register "function",  match: -> typeof @ is "function"
	register "undefined", match: (x) -> x is undefined
	register "null",      match: (x) -> x is null

	return extend ((o) -> lookup(o).name),
		register: register
		lookup: lookup
		extend: _extend
		is: (t, o) -> cache[t]?.match.call o, o




)()







class Bling





	pipes = {}
	@pipe: (name, args) ->
		p = (pipes[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args

	@pipe("bling-init").prepend (args) ->
		[selector, context] = args
		inherit Bling, inherit {
			selector: selector
			context: context
		}, _type.lookup(selector).array(selector, context)

	default_context = if document? then document else {}

	constructor: (selector, context = default_context) ->
		return Bling.pipe("bling-init", [selector, context])





	@plugin: (opts, constructor) ->
		if not constructor?
			constructor = opts; opts = {}

		if "depends" of opts
			return @depends opts.depends, =>
				@plugin { provides: opts.provides }, constructor
		try
			if (plugin = constructor?.call @,@)
				extend @, plugin?.$
				['$','name'].forEach (k) -> delete plugin[k]
				extend @::, plugin
				for key of plugin then do (key) =>
					@[key] or= (a...) => (@::[key].apply $(a[0]), a[1...])
				if opts.provides? then @provide opts.provides
		catch error
			throw error
		@

	qu = []
	done = {}
	filt = (n) ->
		(if (typeof n) is "string" then n.split /, */ else n)
		.filter (x) -> not (x of done)

	@depends: (needs, f) ->
		if (needs = filt(needs)).length is 0 then f()
		else qu.push (need) ->
			((needs.splice i, 1) if ( i = needs.indexOf need ) > -1) and
			needs.length is 0 and
			f
		f

	@provide: (needs) ->
		for need in filt(needs)
			done[need] = i = 0
			while i < qu.length
				if (f = qu[i](need)) then (qu.splice i,1; f())
				else i++
		null

	@provides: (needs, f) -> (a...) -> r=f(a...); Bling.provide(needs); r

	_type.extend
		unknown:   { array: (o) -> [o] }

		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }

	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) -> o.map(Bling.hash).sum()
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"

Bling.prototype = []
Bling.prototype.constructor = Bling


(($) ->

	$.global = glob = if window? then window else global

	$.plugin
		provides: "type"
	, ->
		$:
			inherit: inherit
			extend: extend
			defineProperty: defineProperty
			isType: isType
			type: _type
			is: _type.is
			isSimple: (o) -> _type(o) in ["string", "number", "bool"]
			isEmpty: (o) -> o in ["", null, undefined]



	$.plugin
		provides: "symbol"
		depends: "type"
	, ->
		symbol = null
		cache = {}
		glob.Bling = $
		if module?
			module.exports =
				$: Bling
				Bling: Bling
		$.type.extend "bling",
			string: (o) -> symbol + "(["+ o.map($.toString).join(", ") + "])"
		defineProperty $, "symbol",
			set: (v) ->
				glob[symbol] = cache[symbol]
				cache[symbol = v] = glob[v]
				glob[v] = Bling
			get: -> symbol
		return $: symbol: "$"

	$.plugin ->
		String::trimLeft or= -> @replace(/^\s+/, "")
		String::split or= (sep) ->
			a = []; i = 0
			while (j = @indexOf sep,i) > -1
				a.push @substring(i,j)
				i = j + 1
			a
		String::lastIndexOf or= (s, c, i = -1) ->
			j = -1
			j = i while (i = s.indexOf c, i+1) > -1
			j

		Array::join or= (sep = '') ->
			n = @length
			return "" if n is 0
			s = @[n-1]
			while --n > 0
				s = @[n-1] + sep + s
			s

		if Event?
			Event::preventAll = () ->
				@preventDefault()
				@stopPropagation()
				@cancelBubble = true

		if Element?
			Element::matchesSelector = Element::webkitMatchesSelector or
				Element::mozMatchesSelector or
				Element::matchesSelector
			if Element::cloneNode.length is 0
				oldClone = Element::cloneNode
				Element::cloneNode = (deep = false) ->
					n = oldClone.call(@)
					if deep
						for i in @childNodes
							n.appendChild i.cloneNode true
					return n

		return { }

	$.plugin
		provides: "core"
		depends: "type"
	, ->

		defineProperty $, "now",
			get: -> +new Date

		index = (i, o) ->
			i += o.length while i < 0
			Math.min i, o.length

		return {
			$:
				log: log
				coalesce: (a...) -> $(a).coalesce()

			eq: (i) -> $([@[index i, @]])

			each: (f) -> (f.call(t,t) for t in @); @

			map: (f) -> $(f.call(t,t) for t in @)

			reduce: (f, a) ->
				i = 0; n = @length
				a = @[i++] if not a?
				(a = f.call @[x], a, @[x]) for x in [i...n] by 1
				return a
			union: (other, strict = true) ->
				ret = $()
				ret.push(x) for x in @ when not ret.contains(x, strict)
				ret.push(x) for x in other when not ret.contains(x, strict)
				ret
			distinct: (strict = true) -> @union @, strict
			contains: (item, strict = true) -> ((strict and t is item) or (not strict and t == item) for t in @).reduce ((a,x) -> a or x), false
			count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and t == item)).sum()
			coalesce: ->
				for i in @
					if $.type(i) in ["array","bling"] then i = $(i).coalesce()
					if i? then return i
				null
			swap: (i,j) ->
				i = index i, @
				j = index j, @
				if i isnt j
					[@[i],@[j]] = [@[j],@[i]]
				@
			shuffle: ->
				i = @length-1
				while i >= 0
					@swap --i, Math.floor(Math.random() * i)
				@

			select: (->
				getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
				select = (p) ->
					if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
					else @map(getter p)
			)()

			or: (x) -> @[i] or= x for i in [0...@length]; @

			zap: (p, v) ->

				i = p.lastIndexOf "."

				if i > 0
					head = p.substr 0,i
					tail = p.substr i+1
					@select(head).zap tail, v
					return @

				switch $.type(v)
					when "array","bling" then @each -> @[p] = v[++i % v.length]
					when "function" then @zap p, @select(p).map(v)
					else @each -> @[p] = v
				@

			clean: (prop) -> @each -> delete @[prop]

			take: (n = 1) ->
				end = Math.min n, @length
				$( @[i] for i in [0...end] )

			skip: (n = 0) ->
				start = Math.max 0, n|0
				$( @[i] for i in [start...@length] )

			first: (n = 1) -> if n is 1 then @[0] else @take(n)

			last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)

			slice: (start=0, end=@length) ->
				start = index start, @
				end = index end, @
				$( @[i] for i in [start...end] )

			extend: (b) -> @.push(i) for i in b; @

			push: (b) -> Array::push.call(@, b); @

			filter: (f) ->
				g = switch $.type f
					when "string" then (x) -> x.matchesSelector(f)
					when "regexp" then (x) -> f.test(x)
					when "function" then f
					else
				$( Array::filter.call @, g )

			matches: (expr) -> @select('matchesSelector').call(expr)

			querySelectorAll: (expr) ->
				@filter("*")
				.reduce (a, i) ->
					a.extend i.querySelectorAll expr
				, $()

			weave: (b) ->
				c = $()
				for i in [@length-1..0] by -1
					c[(i*2)+1] = @[i]
				for i in [0...b.length] by 1
					c[i*2] = b[i]
				c

			fold: (f) ->
				n = @length
				b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
				if (n%2) is 1
					b.push( f.call @, @[n-1], undefined )
				b

			flatten: ->
				b = $()
				(b.push(j) for j in i) for i in @
				b

			call: -> @apply(null, arguments)

			apply: (context, args) ->
				@map -> if $.is "function", @ then @apply(context, args) else @

			log: (label) ->
				if label
					$.log(label, @toString(), @length + " items")
				else
					$.log(@toString(), @length + " items")
				@

			toArray: ->
				@__proto__ = Array::
		}

	$.plugin
		provides: "math"
		depends: "core"
	, ->
		$:
			range: (start, end, step = 1) ->
				if not end? then (end = start; start = 0)
				$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
			zeros: (n) -> $( 0 for i in [0...n] )
			ones: (n) -> $( 1 for i in [0...n] )
		floats: -> @map parseFloat
		ints: -> @map -> parseInt @, 10
		px: (delta) -> @ints().map -> $.px @,delta
		min: -> @filter( isFinite ).reduce Math.min
		max: -> @filter( isFinite ).reduce Math.max
		mean: -> @sum() / @length
		avg: -> @sum() / @length
		sum: -> @filter( isFinite ).reduce (a) -> a + @
		product: -> @filter( isFinite ).reduce (a) -> a * @
		squares: -> @map -> @ * @
		magnitude: -> Math.sqrt @floats().squares().sum()
		scale: (r) -> @map -> r * @
		add: (d) -> switch $.type(d)
			when "number" then @map -> d + @
			when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
		normalize: -> @scale(1/@magnitude())

	$.plugin
		provides: "string"
		depends: "function"
	, ->
		$.type.extend
			unknown:
				string: (o) -> o.toString?() ? String(o)
				repr: (o) -> $.type.lookup(o).string(o)
			null: { string: -> "null" }
			undefined: { string: -> "undefined" }
			string:
				string: $.identity
			array:  { string: (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
			number:
				repr:   (n) -> String(n)
				string: (n) ->
					switch true
						when n.precision? then n.toPrecision(n.precision)
						when n.fixed? then n.toFixed(n.fixed)
						else String(n)

		return {
			$:
				toString: (x) ->
					if not x? then "function Bling(selector, context) { [ ... ] }"
					else $.type.lookup(x).string(x)

				toRepr: (x) -> $.type.lookup(x).repr(x)

				px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"



				capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")

				dashize: (name) ->
					ret = ""
					for i in [0...(name?.length|0)]
						c = name.charCodeAt i
						if 91 > c > 64
							c += 32
							ret += '-'
						ret += String.fromCharCode(c)
					ret

				camelize: (name) ->
					name.split('-')
					while (i = name?.indexOf('-')) > -1
						name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
					name

				padLeft: (s, n, c = " ") ->
					while s.length < n
						s = c + s
					s

				padRight: (s, n, c = " ") ->
					while s.length < n
						s = s + c
					s

				stringCount: (s, x, i = 0, n = 0) ->
					if (j = s.indexOf x,i) > i-1
						$.stringCount s, x, j+1, n+1
					else n

				stringSplice: (s, i, j, n) ->
					nn = s.length
					end = j
					if end < 0
						end += nn
					start = i
					if start < 0
						start += nn
					s.substring(0,start) + n + s.substring(end)

				checksum: (s) ->
					a = 1; b = 0
					for i in [0...s.length]
						a = (a + s.charCodeAt(i)) % 65521
						b = (b + a) % 65521
					(b << 16) | a

				repeat: (x, n=2) ->
					switch true
						when n is 1 then x
						when n < 1 then ""
						when $.is "string", x then x + $.repeat(x, n-1)
						else $(x).extend $.repeat(x, n-1)

				stringBuilder: ->
					if $.is("global", @) then return new $.stringBuilder()
					items = []
					@length   = 0
					@append   = (s) => items.push s; @length += s?.toString().length|0
					@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
					@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
					@toString = ( ) => items.join("")
					@
			toString: -> $.toString @
			toRepr: -> $.toRepr @
		}

	$.plugin
		provides: "function"
		depends: "hash"
	, ->
		$:
			identity: (o) -> o
			not: (f) -> -> not f.apply @, arguments
			compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
			and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
			once: (f, n=1) ->
				$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
					"exhausted",
						get: -> n <= 0
			cycle: (f...) ->
				i = -1
				-> f[i = ++i % f.length].apply @, arguments
			bound: (t, f, args = []) ->
				if $.is "function", f.bind
					args.splice 0, 0, t
					r = f.bind.apply f, args
				else
					r = (a...) -> f.apply t, (args if args.length else a)
			memoize: (f) ->
				cache = {}

	$.plugin
		provides: "hash"
		depends: "type"
	, ->
		$.type.extend
			unknown: { hash: (o) -> $.checksum $.toString(o) }
			object:  { hash: (o) -> ($.hash(o[k]) for k of o) + $.hash(Object.keys(o)) }
			array:   { hash: (o) -> ($.hash(i) for i in x).reduce (a,x) -> a+x }
			bool:    { hash: (o) -> parseInt(1 if o) }
		return {
			$:
				hash: (x) -> $.type.lookup(x).hash(x)
			hash: () -> $.hash @
		}

	$.plugin
		provides: "pubsub"
	, ->
		return {
			$:
				publish: (e, args...) ->
					f.apply null, args for f in (subscribers[e] or= [])
					args
				publisher: (e, func) ->
					(args...) ->
						func.apply @, args
						$.publish e, args
				subscribe: (e, func) ->
					(subscribers[e] or= []).push func
					func
				unsubscribe: (e, func) ->
					if not func?
						subscribers[e] = []
					else
						a = (subscribers[e] or= [])
						if (i = a.indexOf func)  > -1
							a.splice(i,i)
		}

	$.plugin
		provides: "throttle"
		depends: "core"
	, ->
		$:
			throttle: (f,n=250,last=0) ->
				(a...) ->
					gap = $.now - last
					if gap > n
						last += gap
						return f.apply @,a
					null
				(a...) ->
					last += (gap = $.now - last)
					return f.apply @,a if gap > n else null

	$.plugin
		provides: "EventEmitter"
	, ->
		$: EventEmitter: $.pipe("bling-init").append (obj) ->
			listeners = {}
			list = (e) -> (listeners[e] or= [])
			obj.__proto__ = {
				emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
				addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
				on:                 (e, h) -> @addListener e, h
				removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
				removeAllListeners: (e) -> listeners[e] = []
				listeners:          (e) -> list(e).slice 0
				__proto__: obj.__proto__
			}
			obj


)(Bling, @)
log = (a...) ->
	try return console.log.apply console, a
	alert a.join(", ")
Object.keys ?= (o) -> (k for k of o)
extend = (a, b) ->
	return a if not b
	for k of b
		v = b[k]
		if v? then a[k] = v
	a
defineProperty = (o,name,opts) ->
	Object.defineProperty o,name, extend({
		configurable: true
		enumerable: true
	}, opts)
	o
isType = (T, o) ->
	if not o? then T in [o,"null","undefined"]
	else o.constructor is T or
		o.constructor.name is T or
inherit = (parent, obj) ->
	if typeof parent is "function"
	obj.__proto__ = parent
	obj
_type = (->
	cache = {}
	base =
		name: 'unknown'
		match: (o) -> true
	order = []
	register = (name, data) ->
		order.unshift name if not (name of cache)
		cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
	_extend = (name, data) ->
		if typeof name is "string"
			cache[name] ?= register name, {}
			cache[name] = extend cache[name], data
		else if typeof name is "object"
			(_extend k, name[k]) for k of name
	lookup = (obj) ->
		for name in order
			if cache[name]?.match.call obj, obj
				return cache[name]
	register "unknown",   base
	register "object",    match: -> typeof @ is "object"
	register "error",     match: -> isType 'Error', @
	register "regexp",    match: -> isType 'RegExp', @
	register "string",    match: -> typeof @ is "string" or isType String, @
	register "number",    match: -> isType Number, @
	register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
	register "array",     match: -> Array.isArray?(@) or isType Array, @
	register "function",  match: -> typeof @ is "function"
	register "undefined", match: (x) -> x is undefined
	register "null",      match: (x) -> x is null
	return extend ((o) -> lookup(o).name),
		register: register
		lookup: lookup
		extend: _extend
		is: (t, o) -> cache[t]?.match.call o, o
)()
class Bling
	pipes = {}
	@pipe: (name, args) ->
		p = (pipes[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args
	@pipe("bling-init").prepend (args) ->
		[selector, context] = args
		inherit Bling, inherit {
			selector: selector
			context: context
		}, _type.lookup(selector).array(selector, context)
	default_context = if document? then document else {}
	constructor: (selector, context = default_context) ->
		return Bling.pipe("bling-init", [selector, context])
	@plugin: (opts, constructor) ->
		if not constructor?
			constructor = opts; opts = {}
		if "depends" of opts
			return @depends opts.depends, =>
				@plugin { provides: opts.provides }, constructor
		try
			if (plugin = constructor?.call @,@)
				extend @, plugin?.$
				['$','name'].forEach (k) -> delete plugin[k]
				extend @::, plugin
				for key of plugin then do (key) =>
					@[key] or= (a...) => (@::[key].apply $(a[0]), a[1...])
				if opts.provides? then @provide opts.provides
		catch error
			throw error
		@
	qu = []
	done = {}
	filt = (n) ->
		(if (typeof n) is "string" then n.split /, */ else n)
		.filter (x) -> not (x of done)
	@depends: (needs, f) ->
		if (needs = filt(needs)).length is 0 then f()
		else qu.push (need) ->
			((needs.splice i, 1) if ( i = needs.indexOf need ) > -1) and
			needs.length is 0 and
			f
		f
	@provide: (needs) ->
		for need in filt(needs)
			done[need] = i = 0
			while i < qu.length
				if (f = qu[i](need)) then (qu.splice i,1; f())
				else i++
		null
	@provides: (needs, f) -> (a...) -> r=f(a...); Bling.provide(needs); r
	_type.extend
		unknown:   { array: (o) -> [o] }
		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }
	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) -> o.map(Bling.hash).sum()
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"
Bling.prototype = []
Bling.prototype.constructor = Bling
(($) ->
	$.global = glob = if window? then window else global
	$.plugin
		provides: "type"
	, ->
		$:
			inherit: inherit
			extend: extend
			defineProperty: defineProperty
			isType: isType
			type: _type
			is: _type.is
			isSimple: (o) -> _type(o) in ["string", "number", "bool"]
			isEmpty: (o) -> o in ["", null, undefined]
	$.plugin
		provides: "symbol"
		depends: "type"
	, ->
		symbol = null
		cache = {}
		glob.Bling = $
		if module?
			module.exports =
				$: Bling
				Bling: Bling
		$.type.extend "bling",
			string: (o) -> symbol + "(["+ o.map($.toString).join(", ") + "])"
		defineProperty $, "symbol",
			set: (v) ->
				glob[symbol] = cache[symbol]
				cache[symbol = v] = glob[v]
				glob[v] = Bling
			get: -> symbol
		return $: symbol: "$"
	$.plugin ->
		String::trimLeft or= -> @replace(/^\s+/, "")
		String::split or= (sep) ->
			a = []; i = 0
			while (j = @indexOf sep,i) > -1
				a.push @substring(i,j)
				i = j + 1
			a
		String::lastIndexOf or= (s, c, i = -1) ->
			j = -1
			j = i while (i = s.indexOf c, i+1) > -1
			j
		Array::join or= (sep = '') ->
			n = @length
			return "" if n is 0
			s = @[n-1]
			while --n > 0
				s = @[n-1] + sep + s
			s
		if Event?
			Event::preventAll = () ->
				@preventDefault()
				@stopPropagation()
				@cancelBubble = true
		if Element?
			Element::matchesSelector = Element::webkitMatchesSelector or
				Element::mozMatchesSelector or
				Element::matchesSelector
			if Element::cloneNode.length is 0
				oldClone = Element::cloneNode
				Element::cloneNode = (deep = false) ->
					n = oldClone.call(@)
					if deep
						for i in @childNodes
							n.appendChild i.cloneNode true
					return n
		return { }
	$.plugin
		provides: "core"
		depends: "type"
	, ->
		defineProperty $, "now",
			get: -> +new Date
		index = (i, o) ->
			i += o.length while i < 0
			Math.min i, o.length
		return {
			$:
				log: log
				coalesce: (a...) -> $(a).coalesce()
			eq: (i) -> $([@[index i, @]])
			each: (f) -> (f.call(t,t) for t in @); @
			map: (f) -> $(f.call(t,t) for t in @)
			reduce: (f, a) ->
				i = 0; n = @length
				a = @[i++] if not a?
				(a = f.call @[x], a, @[x]) for x in [i...n] by 1
				return a
			union: (other, strict = true) ->
				ret = $()
				ret.push(x) for x in @ when not ret.contains(x, strict)
				ret.push(x) for x in other when not ret.contains(x, strict)
				ret
			distinct: (strict = true) -> @union @, strict
			contains: (item, strict = true) -> ((strict and t is item) or (not strict and t == item) for t in @).reduce ((a,x) -> a or x), false
			count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and t == item)).sum()
			coalesce: ->
				for i in @
					if $.type(i) in ["array","bling"] then i = $(i).coalesce()
					if i? then return i
				null
			swap: (i,j) ->
				i = index i, @
				j = index j, @
				if i isnt j
					[@[i],@[j]] = [@[j],@[i]]
				@
			shuffle: ->
				i = @length-1
				while i >= 0
					@swap --i, Math.floor(Math.random() * i)
				@
			select: (->
				getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
				select = (p) ->
					if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
					else @map(getter p)
			)()
			or: (x) -> @[i] or= x for i in [0...@length]; @
			zap: (p, v) ->
				i = p.lastIndexOf "."
				if i > 0
					head = p.substr 0,i
					tail = p.substr i+1
					@select(head).zap tail, v
					return @
				switch $.type(v)
					when "array","bling" then @each -> @[p] = v[++i % v.length]
					when "function" then @zap p, @select(p).map(v)
					else @each -> @[p] = v
				@
			clean: (prop) -> @each -> delete @[prop]
			take: (n = 1) ->
				end = Math.min n, @length
				$( @[i] for i in [0...end] )
			skip: (n = 0) ->
				start = Math.max 0, n|0
				$( @[i] for i in [start...@length] )
			first: (n = 1) -> if n is 1 then @[0] else @take(n)
			last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)
			slice: (start=0, end=@length) ->
				start = index start, @
				end = index end, @
				$( @[i] for i in [start...end] )
			extend: (b) -> @.push(i) for i in b; @
			push: (b) -> Array::push.call(@, b); @
			filter: (f) ->
				g = switch $.type f
					when "string" then (x) -> x.matchesSelector(f)
					when "regexp" then (x) -> f.test(x)
					when "function" then f
					else
				$( Array::filter.call @, g )
			matches: (expr) -> @select('matchesSelector').call(expr)
			querySelectorAll: (expr) ->
				@filter("*")
				.reduce (a, i) ->
					a.extend i.querySelectorAll expr
				, $()
			weave: (b) ->
				c = $()
				for i in [@length-1..0] by -1
					c[(i*2)+1] = @[i]
				for i in [0...b.length] by 1
					c[i*2] = b[i]
				c
			fold: (f) ->
				n = @length
				b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
				if (n%2) is 1
					b.push( f.call @, @[n-1], undefined )
				b
			flatten: ->
				b = $()
				(b.push(j) for j in i) for i in @
				b
			call: -> @apply(null, arguments)
			apply: (context, args) ->
				@map -> if $.is "function", @ then @apply(context, args) else @
			log: (label) ->
				if label
					$.log(label, @toString(), @length + " items")
				else
					$.log(@toString(), @length + " items")
				@
			toArray: ->
				@__proto__ = Array::
		}
	$.plugin
		provides: "math"
		depends: "core"
	, ->
		$:
			range: (start, end, step = 1) ->
				if not end? then (end = start; start = 0)
				$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
			zeros: (n) -> $( 0 for i in [0...n] )
			ones: (n) -> $( 1 for i in [0...n] )
		floats: -> @map parseFloat
		ints: -> @map -> parseInt @, 10
		px: (delta) -> @ints().map -> $.px @,delta
		min: -> @filter( isFinite ).reduce Math.min
		max: -> @filter( isFinite ).reduce Math.max
		mean: -> @sum() / @length
		avg: -> @sum() / @length
		sum: -> @filter( isFinite ).reduce (a) -> a + @
		product: -> @filter( isFinite ).reduce (a) -> a * @
		squares: -> @map -> @ * @
		magnitude: -> Math.sqrt @floats().squares().sum()
		scale: (r) -> @map -> r * @
		add: (d) -> switch $.type(d)
			when "number" then @map -> d + @
			when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
		normalize: -> @scale(1/@magnitude())
	$.plugin
		provides: "string"
		depends: "function"
	, ->
		$.type.extend
			unknown:
				string: (o) -> o.toString?() ? String(o)
				repr: (o) -> $.type.lookup(o).string(o)
			null: { string: -> "null" }
			undefined: { string: -> "undefined" }
			string:
				string: $.identity
			array:  { string: (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
			number:
				repr:   (n) -> String(n)
				string: (n) ->
					switch true
						when n.precision? then n.toPrecision(n.precision)
						when n.fixed? then n.toFixed(n.fixed)
						else String(n)
		return {
			$:
				toString: (x) ->
					if not x? then "function Bling(selector, context) { [ ... ] }"
					else $.type.lookup(x).string(x)
				toRepr: (x) -> $.type.lookup(x).repr(x)
				px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"
				capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")
				dashize: (name) ->
					ret = ""
					for i in [0...(name?.length|0)]
						c = name.charCodeAt i
						if 91 > c > 64
							c += 32
							ret += '-'
						ret += String.fromCharCode(c)
					ret
				camelize: (name) ->
					name.split('-')
					while (i = name?.indexOf('-')) > -1
						name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
					name
				padLeft: (s, n, c = " ") ->
					while s.length < n
						s = c + s
					s
				padRight: (s, n, c = " ") ->
					while s.length < n
						s = s + c
					s
				stringCount: (s, x, i = 0, n = 0) ->
					if (j = s.indexOf x,i) > i-1
						$.stringCount s, x, j+1, n+1
					else n
				stringSplice: (s, i, j, n) ->
					nn = s.length
					end = j
					if end < 0
						end += nn
					start = i
					if start < 0
						start += nn
					s.substring(0,start) + n + s.substring(end)
				checksum: (s) ->
					a = 1; b = 0
					for i in [0...s.length]
						a = (a + s.charCodeAt(i)) % 65521
						b = (b + a) % 65521
					(b << 16) | a
				repeat: (x, n=2) ->
					switch true
						when n is 1 then x
						when n < 1 then ""
						when $.is "string", x then x + $.repeat(x, n-1)
						else $(x).extend $.repeat(x, n-1)
				stringBuilder: ->
					if $.is("global", @) then return new $.stringBuilder()
					items = []
					@length   = 0
					@append   = (s) => items.push s; @length += s?.toString().length|0
					@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
					@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
					@toString = ( ) => items.join("")
					@
			toString: -> $.toString @
			toRepr: -> $.toRepr @
		}
	$.plugin
		provides: "function"
		depends: "hash"
	, ->
		$:
			identity: (o) -> o
			not: (f) -> -> not f.apply @, arguments
			compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
			and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
			once: (f, n=1) ->
				$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
					"exhausted",
						get: -> n <= 0
			cycle: (f...) ->
				i = -1
				-> f[i = ++i % f.length].apply @, arguments
			bound: (t, f, args = []) ->
				if $.is "function", f.bind
					args.splice 0, 0, t
					r = f.bind.apply f, args
				else
					r = (a...) -> f.apply t, (args if args.length else a)
			memoize: (f) ->
				cache = {}
	$.plugin
		provides: "hash"
		depends: "type"
	, ->
		$.type.extend
			unknown: { hash: (o) -> $.checksum $.toString(o) }
			object:  { hash: (o) -> ($.hash(o[k]) for k of o) + $.hash(Object.keys(o)) }
			array:   { hash: (o) -> ($.hash(i) for i in x).reduce (a,x) -> a+x }
			bool:    { hash: (o) -> parseInt(1 if o) }
		return {
			$:
				hash: (x) -> $.type.lookup(x).hash(x)
			hash: () -> $.hash @
		}
	$.plugin
		provides: "pubsub"
	, ->
		return {
			$:
				publish: (e, args...) ->
					f.apply null, args for f in (subscribers[e] or= [])
					args
				publisher: (e, func) ->
					(args...) ->
						func.apply @, args
						$.publish e, args
				subscribe: (e, func) ->
					(subscribers[e] or= []).push func
					func
				unsubscribe: (e, func) ->
					if not func?
						subscribers[e] = []
					else
						a = (subscribers[e] or= [])
						if (i = a.indexOf func)  > -1
							a.splice(i,i)
		}
	$.plugin
		provides: "throttle"
		depends: "core"
	, ->
		$:
			throttle: (f,n=250,last=0) ->
				(a...) ->
					gap = $.now - last
					if gap > n
						last += gap
						return f.apply @,a
					null
				(a...) ->
					last += (gap = $.now - last)
					return f.apply @,a if gap > n else null
	$.plugin
		provides: "EventEmitter"
	, ->
		$: EventEmitter: $.pipe("bling-init").append (obj) ->
			listeners = {}
			list = (e) -> (listeners[e] or= [])
			obj.__proto__ = {
				emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
				addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
				on:                 (e, h) -> @addListener e, h
				removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
				removeAllListeners: (e) -> listeners[e] = []
				listeners:          (e) -> list(e).slice 0
				__proto__: obj.__proto__
			}
			obj
)(Bling, @)
(($) ->
	$.plugin
		provides: "cartesian"
	, ->
		$:
			cartesian: (sets...) ->
				n = sets.length
				ret = []
				helper = (cur, i) ->
					(return ret.push cur) if ++i >= n
					for x in sets[i]
						helper (cur.concat x), i
					null
				helper [], -1
				return $(ret)
)(Bling)
(($) ->
	$.plugin
		provides: 'config'
	, ->
		$: config: get: (name, def) -> process.env[name] ? def
)(Bling)
(($) ->
	$.plugin
		provides: "date"
	, ->
		[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]
		units = {
			ms, s, m, h, d,
			sec: s
			second: s
			seconds: s
			min: m
			minute: m
			minutes: m
			hr: h
			hour: h
			hours: h
			day: d
			days: d
		}
		formats =
			yyyy: Date::getUTCFullYear
			mm: -> @getUTCMonth() + 1
			dd: Date::getUTCDate
			HH: Date::getUTCHours
			MM: Date::getUTCMinutes
			SS: Date::getUTCSeconds
			MS: Date::getUTCMilliseconds
		format_keys = Object.keys(formats).sort().reverse()
		parsers =
			yyyy: Date::setUTCFullYear
			mm: (x) -> @setUTCMonth(x - 1)
			dd: Date::setUTCDate
			HH: Date::setUTCHours
			MM: Date::setUTCMinutes
			SS: Date::setUTCSeconds
			MS: Date::setUTCMilliseconds
		parser_keys = Object.keys(parsers).sort().reverse()
		floor = Math.floor
		$.type.register "date",
			match: (o) -> $.isType Date, o
			array: (o) -> [o]
		adder = (key) ->
			(stamp, delta, stamp_unit = $.date.defaultUnit) ->
				date = $.date.unstamp(stamp, stamp_unit)
				parsers[key].call date, (formats[key].call date) + delta
				$.date.stamp date, stamp_unit
		$:
			date:
				defaultUnit: "ms"
				defaultFormat: "yyyy-mm-dd HH:MM:SS"
				stamp: (date = new Date, unit = $.date.defaultUnit) ->
					floor (date / units[unit])
				unstamp: (stamp, unit = $.date.defaultUnit) ->
					new Date floor(stamp * units[unit])
				convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
					(floor stamp * units[from] / units[to])
				midnight: (stamp, unit = $.date.defaultUnit) ->
					$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
				format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
					date = $.date.unstamp(stamp, unit)
					for k in format_keys
						fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
					fmt
				parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
					date = new Date(0)
					for i in [0...fmt.length] by 1
						for k in parser_keys
							if fmt.indexOf(k, i) is i
								try
									parsers[k].call date,
										parseInt dateString[i...i+k.length], 10
								catch err
					$.date.stamp date, to
				addMilliseconds: adder("MS")
				addSeconds: adder("SS")
				addMinutes: adder("MM")
				addHours: adder("HH")
				addDays: adder("dd")
				addMonths: adder("mm")
				addYears: adder("yyyy")
				range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
					add = adder(interval_unit)
					ret = [from]
					while (cur = ret[ret.length-1]) < to
						ret.push add(cur, interval, stamp_unit)
					ret
	
		midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
		unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
		stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
		dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
		dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)
)(Bling)
(($) ->
	$.plugin
		provides: "delay"
		depends: "function"
	, ->
		$:
			delay: (->
				timeoutQueue = $.extend [], (->
					next = (a) -> -> a.shift()() if a.length
					add: (f, n) ->
						f.order = n + $.now
						for i in [0..@length]
							if i is @length or @[i].order > f.order
								@splice i,0,f
								break
						setTimeout next(@), n
						@
					cancel: (f) ->
						for i in [0...@length]
							if @[i] == f
								@splice i, 1
								break
						@
				)()
				(n, f) ->
					if $.is("function",f) then timeoutQueue.add(f, n)
					cancel: -> timeoutQueue.cancel(f)
			)()
		delay: (n, f, c=@) ->
			inherit @, $.delay n, $.bound(c, f)
)(Bling)
(($) ->
	if $.global.document?
		$.plugin
			depends: "function"
			provides: "dom"
		, ->
			$.type.register "nodelist",
				match:  (o) -> o? and $.isType "NodeList", o
				hash:   (o) -> $($.hash(i) for i in x).sum()
				array:  $.identity
				string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
				node:   (o) -> $(o).toFragment()
			$.type.register "node",
				match:  (o) -> o?.nodeType > 0
				hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "fragment",
				match:  (o) -> o?.nodeType is 11
				hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "html",
				match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
				node:   (h) ->
					(node = document.createElement('div')).innerHTML = h
					if n = (childNodes = node.childNodes).length is 1
						return node.removeChild(childNodes[0])
					df = document.createDocumentFragment()
					df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
					df
				array:  (o,c) -> $.type.lookup(h = Bling.HTML.parse o).array h, c
				repr:   (o) -> '"' + o + '"'
			$.type.extend
				unknown:  { node: -> null }
				bling:    { node: (o) -> o.toFragment() }
				node:     { html: (n) ->
					d = document.createElement "div"
					d.appendChild (n = n.cloneNode true)
					ret = d.innerHTML
					ret
				}
				string:
					node:  (o) -> $(o).toFragment()
					array: (o,c) -> c.querySelectorAll?(o)
				function: { node: (o) -> $(o.toString()).toFragment() }
			toFrag = (a) ->
				if not a.parentNode?
					df = document.createDocumentFragment()
					df.appendChild(a)
				a
			before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
			after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
			toNode = (x) -> $.type.lookup(x).node(x)
			escaper = false
			parser = false
			computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue(k)
			getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select(p)
			selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )
			return {
				$:
					HTML:
						parse: (h) -> $.type.lookup(h).node(h)
						stringify: (n) -> $.type.lookup(n).html(n)
						escape: (h) ->
							escaper or= $("<div>&nbsp;</div>").child(0)
							ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
							escaper.zap('data', '')
							ret
				html: (h) ->
					return switch $.type h
						when "undefined","null" then @select 'innerHTML'
						when "string" then @zap 'innerHTML', h
						when "bling" then @html h.toFragment()
						when "node"
								@replaceChild @childNodes[0], h
								while @childNodes.length > 1
									@removeChild @childNodes[1]
					@each -> @appendChild x.cloneNode true
					clones = @map( -> @cloneNode true)
					i = 0
					$(x).each -> @appendChild clones[i++]
					clones
					if x?
						x = toNode(x)
						@take(1).each ->
							before @childNodes[0], x
						@skip(1).each ->
							before @childNodes[0], x.cloneNode(true)
					@
					if x?
						$(x).prepend(@)
					@
					if x?
						x = toNode(x)
						@take(1).each -> before @, x
						@skip(1).each -> before @, x.cloneNode(true)
					@
					if x?
						x = toNode(x)
						@take(1).each -> after @, x
						@skip(1).each -> after @, x.cloneNode(true)
					@
					parent = toNode(parent)
					if $.is "fragment", parent
						throw new Error("cannot call .wrap() with a fragment as the parent")
					@each (child) ->
						if ($.is "fragment", child) or not child.parentNode
							return parent.appendChild child
						grandpa = child.parentNode
						marker = document.createElement "dummy"
						parent.appendChild grandpa.replaceChild marker, child
						grandpa.replaceChild parent, marker
					@each ->
						if @parentNode and @parentNode.parentNode
							@parentNode.parentNode.replaceChild(@, @parentNode)
						else if @parentNode
							@parentNode.removeChild(@)
					n = toNode(n)
					clones = @map(-> n.cloneNode true)
					for i in [0...clones.length] by 1
						@[i].parentNode?.replaceChild clones[i], @[i]
					clones
					return switch v
						when undefined then @select("getAttribute").call(a, v)
						when null then @select("removeAttribute").call(a, v)
						else
							@select("setAttribute").call(a, v)
							@
					notempty = (y) -> y isnt ""
					@removeClass(x).each ->
						c = @className.split(" ").filter notempty
						c.push(x)
						@className = c.join " "
					notx = (y) -> y != x
					@each ->
						c = @className.split(" ").filter(notx).join(" ")
						if c.length is 0
							@removeAttribute('class')
					notx = (y) -> y isnt x
					@each ->
						cls = @className.split(" ")
						filter = $.not $.isEmpty
						if( cls.indexOf(x) > -1 )
							filter = $.and notx, filter
						else
							cls.push(x)
						c = cls.filter(filter).join(" ")
						@className = c
						if c.length is 0
							@removeAttribute('class')
					@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1
					return @zap('textContent', t) if t?
					return @select('textContent')
					return @zap('value', v) if v?
					return @select('value')
				css: (k,v) ->
					if v? or $.is "object", k
						setter = @select 'style.setProperty'
						if $.is "object", k then setter.call i, k[i], "" for i of k
						else if $.is "string", v then setter.call k, v, ""
						else if $.is "array", v
							setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
						return @
					else
						cv = @map computeCSSProperty(k)
						ov = @select('style').select k
						ov.weave(cv).fold (x,y) -> x or y
				defaultCss: (k, v) ->
					sel = @selector
					style = ""
					if $.is "string", k
						if $.is "string", v
						else throw Error("defaultCss requires a value with a string key")
					else if $.is "object", k
						"} "
					$("<style></style>").text(style).appendTo("head")
					@
				rect: -> @select('getBoundingClientRect').call()
				width: getOrSetRect("width")
				height: getOrSetRect("height")
				top: getOrSetRect("top")
				left: getOrSetRect("left")
				bottom: getOrSetRect("bottom")
				right: getOrSetRect("right")
				position: (left, top) ->
					switch true
						when not left? then @rect()
						when not top? then @css("left", $.px(left))
						else @css({top: $.px(top), left: $.px(left)})
				scrollToCenter: ->
					document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
					@
				child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]
				parents: selectChain('parentNode')
				prev: selectChain('previousSibling')
				next: selectChain('nextSibling')
				remove: -> @each -> @parentNode?.removeChild(@)
				find: (css) ->
					@filter("*")
						.map( -> $(css, @) )
						.flatten()
				clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @
				toFragment: ->
					if @length > 1
						df = document.createDocumentFragment()
						(@map toNode).map $.bound df, df.appendChild
						return df
					return toNode @[0]
			}
)(Bling)
(($) ->
	$.plugin
		depends: "dom,function,core"
		provides: "event"
	, ->
		EVENTSEP_RE = /,* +/
		events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
			'load','unload','reset','submit','keyup','keydown','change',
			'abort','cut','copy','paste','selection','drag','drop','orientationchange',
			'touchstart','touchmove','touchend','touchcancel',
			'gesturestart','gestureend','gesturecancel',
			'hashchange'
		]
		binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)
		register_live = (selector, context, evt, f, h) ->
			$(context).bind(evt, h)
				.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h
		unregister_live = (selector, context, e, f) ->
			$c = $(context)
			$c.each ->
				a = (@__alive__ or= {})
				b = (a[selector] or= {})
				c = (b[e] or= {})
				$c.unbind(e, c[f])
				delete c[f]
		triggerReady = $.once ->
			$(document).trigger("ready").unbind("ready")
			document.removeEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.removeEventListener?("load", triggerReady, false)
		bindReady = $.once ->
			document.addEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.addEventListener?("load", triggerReady, false)
		bindReady()
		ret = {
			bind: (e, f) ->
				c = (e or "").split(EVENTSEP_RE)
				h = (evt) ->
					ret = f.apply @, arguments
					if ret is false
						evt.preventAll()
					ret
				@each -> (@addEventListener i, h, false) for i in c
			unbind: (e, f) ->
				c = (e or "").split EVENTSEP_RE
				@each -> (@removeEventListener i, f, null) for i in c
			trigger: (evt, args = {}) ->
				args = $.extend
					bubbles: true
					cancelable: true
				, args
				for evt_i in (evt or "").split(EVENTSEP_RE)
						e = document.createEvent "MouseEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							button: 0,
							relatedTarget: null
						, args
						e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.button, args.relatedTarget
						e = document.createEvent "UIEvents"
						e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1
						e = document.createEvent "TouchEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							touches: [],
							targetTouches: [],
							changedTouches: [],
							scale: 1.0,
							rotation: 0.0
						, args
						e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)
						e = document.createEvent "GestureEvents"
						args = $.extend {
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							target: null,
							scale: 1.0,
							rotation: 0.0
						}, args
						e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.target, args.scale, args.rotation
					else
						e = document.createEvent "Events"
						e.initEvent evt_i, args.bubbles, args.cancelable
						try
							e = $.extend e, args
						catch err
					if not e
						continue
					else
						try
							@each -> @dispatchEvent e
						catch err
							$.log "dispatchEvent error:", err
				@
			live: (e, f) ->
				selector = @selector
				context = @context
				handler = (evt) ->
					$(selector, context)
						.intersect($(evt.target).parents().first().union($(evt.target)))
						.each -> f.call(evt.target = @, evt)
				register_live selector, context, e, f, handler
				@
			die: (e, f) ->
				$(@context).unbind e, unregister_live(@selector, @context, e, f)
				@
			click: (f = {}) ->
				if @css("cursor") in ["auto",""]
					@css "cursor", "pointer"
				if $.is "function", f then @bind 'click', f
				else @trigger 'click', f
				@
			ready: (f) ->
				return (f.call @) if triggerReady.exhausted
				@bind "ready", f
		}
		events.forEach (x) -> ret[x] = binder(x)
		return ret
)(Bling)
(($) ->
	$.plugin ->
		$:
			histogram: (data, bucket_width=1, output_width=80) ->
				buckets = $()
				len = 0
				for x in data
					i = Math.floor( x / bucket_width )
					buckets[i] ?= 0
					buckets[i] += 1
					len = Math.max(len, i+1)
				buckets.length = len
				max = buckets.max()
				buckets = buckets.map((x) -> x or 0)
					.scale(1/max)
					.scale(output_width)
				sum = buckets.sum()
				ret = ""
				for n in [0...len] by 1
					end = (n+1) * bucket_width
					pct = (buckets[n]*100/sum).toFixed(0)
				ret
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->
		$.type.register "http",
			match: (o) -> $.isType 'XMLHttpRequest', o
			array: (o) -> [o]
		return {
			$:
				http: (url, opts = {}) ->
					xhr = new XMLHttpRequest()
					if $.is "function", opts
						opts = success: $.bound(xhr, opts)
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts
					opts.state = $.bound(xhr, opts.state)
					opts.success = $.bound(xhr, opts.success)
					opts.error = $.bound(xhr, opts.error)
					if opts.data and opts.method is "GET"
						url += "?" + formencode(opts.data)
					else if opts.data and opts.method is "POST"
						opts.data = formencode(opts.data)
					xhr.open(opts.method, url, opts.async)
					xhr = $.extend xhr,
						asBlob: opts.asBlob
						timeout: opts.timeout
						followRedirects: opts.followRedirects
						withCredentials: opts.withCredentials
						onreadystatechange: ->
							opts.state?()
							if xhr.readyState is 4
								if xhr.status is 200
									opts.success xhr.responseText
								else
									opts.error xhr.status, xhr.statusText
					xhr.send opts.data
					return $(xhr)
				post: (url, opts = {}) ->
					if $.is("function",opts)
						opts = success: opts
					opts.method = "POST"
					$.http(url, opts)
				get: (url, opts = {}) ->
					if( $.is("function",opts) )
						opts = success: opts
					opts.method = "GET"
					$.http(url, opts)
		}
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "lazy"
	, ->
		lazy_load = (elementName, props) ->
			$("head").append $.extend document.createElement(elementName), props
		$:
			script: (src) ->
				lazy_load "script", { src: src }
			style: (src) ->
				lazy_load "link", { href: src, rel: "stylesheet" }
)(Bling)
(($) ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""
		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615
		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)
			index = (index + 1) % 624
			(y + a) / b
		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()
		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
	)()
	$.plugin
		provides: "random"
	, ->
		$:
			random: random
)(Bling)
(($) ->
	$.plugin
		provides: "sendgrid"
		depends: "config"
	, ->
		try
			nodemailer = require 'nodemailer'
		catch err
			`return`
		transport = nodemailer.createTransport 'SMTP',
			service: 'SendGrid'
			auth:
				user: $.config.get 'SENDGRID_USERNAME'
		$:
			sendMail: (mail, callback) ->
				mail.transport ?= transport
				mail.from ?= $.config.get 'EMAILS_FROM'
				mail.bcc ?= $.config.get 'EMAILS_BCC'
				if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
					nodemailer.sendMail mail, callback
				else
)(Bling)
(($) ->
	$.plugin
		provides: "StateMachine"
	, ->
		$: StateMachine: class StateMachine
			constructor: (stateTable) ->
				@reset()
				@table = stateTable
				Object.defineProperty @, "modeline",
					get: -> @table[@_mode]
				Object.defineProperty @, "mode",
					set: (m) ->
						@_lastMode = @_mode
						@_mode = m
						if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
							ret = @modeline['enter'].call @
							while $.is("function",ret)
								ret = ret.call @
						m
					get: -> @_mode
			reset: ->
				@_mode = null
				@_lastMode = null
			GO: (m) -> -> @mode = m
			@GO: (m) -> -> @mode = m
			
			tick: (c) ->
				row = @modeline
				if not row?
					ret = null
				else if c of row
					ret = row[c]
				else if 'def' of row
					ret = row['def']
				while $.is "function",ret
					ret = ret.call @, c
				ret
			run: (inputs) ->
				@mode = 0
				for c in inputs
					ret = @tick(c)
				if $.is "function",@modeline?.eof
					ret = @modeline.eof.call @
				while $.is "function",ret
					ret = ret.call @
				@reset()
				return @
	$.plugin
		provides: "synth"
		depends: "StateMachine"
	, ->
		class SynthMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: ->
						@tag = @id = @cls = @attr = @val = @text = ""
						@attrs = {}
						@GO 1
				},
					def: (c) -> @tag += c
					eof: @GO 13
				},
					".": @GO(3), "[": @GO(4), " ": @GO(9), "+": @GO(11), ",": @GO(10),
					def: (c) -> @id += c
					eof: @GO 13
				},
					enter: -> @cls += " " if @cls.length > 0
					def: (c) -> @cls += c
					eof: @GO 13
				},
					"=": @GO 5
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @attr += c
					eof: @GO 12
				},
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @val += c
					eof: @GO 12
				},
					'"': @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					"'": @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					enter: ->
						@emitText()
						@GO 0
				},
					enter: ->
						@emitNode()
						@GO 0
				},
					enter: ->
						@emitNode()
						@parent = null
						@GO 0
				},
					enter: ->
						@emitNode()
						@parent = @parent?.parentNode
						@GO 0
				},
				},
					enter: ->
						@emitNode() if @tag.length
						@emitText() if @text.length
				}
			]
			constructor: ->
				super(SynthMachine.STATE_TABLE)
				@fragment = @parent = document.createDocumentFragment()
			emitNode: ->
				node = document.createElement(@tag)
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@parent.appendChild node
				@parent = node
			emitText: ->
				@parent.appendChild $.HTML.parse(@text)
				@text = ""
		return {
			$:
				synth: (expr) ->
					s = new SynthMachine()
					s.run(expr)
					if s.fragment.childNodes.length == 1
						$(s.fragment.childNodes[0])
					else
						$(s.fragment)
		}
)(Bling)
(($) ->
		current_engine = null
		engines = {}
		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine
		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()
		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop]
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1
	$.template.register_engine 'pythonic', (() ->
		chunk_re = /%[\(\/]/
		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n]
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}
			if not cache?
			n = cache.length
			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""
		return render
	)()
		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
)(Bling)
(($) ->
		parseOne = (data) ->
			i = data.indexOf ":"
			if i > 0
				len = parseInt data[0...i], 10
				item = data[i+1...i+1+len]
				type = data[i+1+len]
				extra = data[i+len+2...]
				item = switch type
					when "'" then String(item)
					when "!" then (item is "true")
					when "~" then null
					when "]" then parseArray(item)
					when "}" then parseObject(item)
				return [item, extra]
			return undefined
		parseArray = (x) ->
			data = []
			while x.length > 0
				[one, x] = parseOne(x)
				data.push(one)
			data
		parseObject = (x) ->
			data = {}
			while x.length > 0
				[key, x] = parseOne(x)
				[value, x] = parseOne(x)
				data[key] = value
			data
		$:
			TNET:
				stringify: (x) ->
					[data, type] = switch $.type x
						when "string" then [x, "'"]
						when "function" then [String(x), "'"]
						when "boolean" then [String(not not x), "!"]
						when "null" then ["", "~"]
						when "undefined" then ["", "~"]
						when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
						when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
					return (data.length|0) + ":" + data + type
				parse: (x) ->
					parseOne(x)?[0]
)(Bling)
(($) ->
	$.plugin
		provides: "trace"
		depends: "function,type"
	, ->
		$.type.extend
			unknown: { trace: $.identity }
			function:
				trace: (f, label, tracer) ->
					r = (a...) ->
						f.apply @, a
					r.toString = f.toString
					r
		return $: trace: (o, label, tracer = $.log) -> $.type.lookup(o).trace(o, label, tracer)
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
	, ->
		COMMASEP = ", "
			"slow": 700
			"medium": 500
			"normal": 300
			"fast": 100
			"instant": 0
			"now": 0
		accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
		testStyle = document.createElement("div").style
		transformProperty = "transform"
		transitionProperty = "transition-property"
		transitionDuration = "transition-duration"
		transitionTiming = "transition-timing-function"
		if "WebkitTransform" of testStyle
			transformProperty = "-webkit-transform"
			transitionProperty = "-webkit-transition-property"
			transitionDuration = "-webkit-transition-duration"
			transitionTiming = "-webkit-transition-timing-function"
		else if "MozTransform" of testStyle
			transformProperty = "-moz-transform"
			transitionProperty = "-moz-transition-property"
			transitionDuration = "-moz-transition-duration"
			transitionTiming = "-moz-transition-timing-function"
		else if "OTransform" of testStyle
			transformProperty = "-o-transform"
			transitionProperty = "-o-transition-property"
			transitionDuration = "-o-transition-duration"
			transitionTiming = "-o-transition-timing-function"
		return {
			$:
				duration: (speed) ->
					d = speeds[speed]
					return d if d?
					return parseFloat speed
			transform: (end_css, speed, easing, callback) ->
				if $.is("function",speed)
					callback = speed
					speed = easing = null
				else if $.is("function",easing)
					callback = easing
					easing = null
				speed ?= "normal"
				easing or= "ease"
				duration = $.duration(speed) + "ms"
				props = []
				trans = ""
				css = {}
				for i of end_css
					if accel_props_re.test(i)
						ii = end_css[i]
						if ii.join
							ii = $(ii).px().join COMMASEP
						else if ii.toString
							ii = ii.toString()
						trans += " " + i + "(" + ii + ")"
					else css[i] = end_css[i]
				(props.push i) for i of css
				if trans
					props.push transformProperty
				css[transitionProperty] = props.join COMMASEP
				css[transitionDuration] = props.map(-> duration).join COMMASEP
				css[transitionTiming] = props.map(-> easing).join COMMASEP
				if trans
					css[transformProperty] = trans
				@css css
				@delay duration, callback
				@each ->
					if @style
						if @style.display is not "none"
							@_display = @syle.display
						@style.display = "none"
				.trigger "hide"
				.delay updateDelay, callback
				@each ->
					if @style
						@style.display = @_display
						delete @_display
				.trigger "show"
				.delay updateDelay, callback
				@weave(@css("display"))
					.fold (display, node) ->
						if display is "none"
							node.style.display = node._display or ""
							delete node._display
							$(node).trigger "show"
						else
							node._display = display
							node.style.display = "none"
							$(node).trigger "hide"
						node
					.delay(updateDelay, callback)
				@.css('opacity','0.0')
					.show ->
						@transform {
							opacity:"1.0",
							translate3d: [0,0,0]
						}, speed, callback
				@transform {
					opacity:"0.0",
					translate3d:[x,y,0.0]
				}, speed, -> @hide(callback)
			fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
			fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
			fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
			fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
		}
)(Bling)
(($) ->
	$.plugin
		provides: "unittest"
		depends: "core"
	, ->
		testCount = passCount = failCount = 0
		failed = []
		invokeTest = (group, name, func) ->
			return if not $.is "function", func
			shouldFail = name.toLowerCase().indexOf("fail") isnt -1
			done = $.once (err) ->
				testCount--
				if (!!err isnt shouldFail)
					failCount++
					failed.push name
				else
					_log "pass"
					passCount++
					$.provide name
			f = (done) ->
				try func(done)
				catch err then done(err)
				finally
					if name.toLowerCase().indexOf("async") is -1 then done()
			testCount++
			try f(done)
			catch err then done(err)
		testReport = $.once ->
		$:
			approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
			assertEqual: (a, b, label) ->
				if a != b
			assertArrayEqual: (a, b, label) ->
				for i in [0...a.length]
					try
						$.assertEqual(a[i], b[i], label)
					catch err
			testGroup: (name, funcs) ->
				interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
				for k,func of funcs
					invokeTest(name, k, func)
		assertEqual: (args...) ->
					if $.is "function", x then x.call(@,@) else x
				a = args[0]
				for i in [1...args.length]
					$.assertEqual a, args[i]
			return @
)(Bling)
(($) ->
	$.plugin
		provides: "cartesian"
	, ->
		$:
			cartesian: (sets...) ->
				n = sets.length
				ret = []
				helper = (cur, i) ->
					(return ret.push cur) if ++i >= n
					for x in sets[i]
						helper (cur.concat x), i
					null
				helper [], -1
				return $(ret)

)(Bling)
(($) ->
	$.plugin
		provides: 'config'
	, ->
		$: config: get: (name, def) -> process.env[name] ? def
)(Bling)

(($) ->
	$.plugin
		provides: "date"
	, ->
		[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]

		units = {
			ms, s, m, h, d,
			sec: s
			second: s
			seconds: s
			min: m
			minute: m
			minutes: m
			hr: h
			hour: h
			hours: h
			day: d
			days: d
		}

		formats =
			yyyy: Date::getUTCFullYear
			mm: -> @getUTCMonth() + 1
			dd: Date::getUTCDate
			HH: Date::getUTCHours
			MM: Date::getUTCMinutes
			SS: Date::getUTCSeconds
			MS: Date::getUTCMilliseconds
		format_keys = Object.keys(formats).sort().reverse()

		parsers =
			yyyy: Date::setUTCFullYear
			mm: (x) -> @setUTCMonth(x - 1)
			dd: Date::setUTCDate
			HH: Date::setUTCHours
			MM: Date::setUTCMinutes
			SS: Date::setUTCSeconds
			MS: Date::setUTCMilliseconds
		parser_keys = Object.keys(parsers).sort().reverse()

		floor = Math.floor

		$.type.register "date",
			match: (o) -> $.isType Date, o
			array: (o) -> [o]

		adder = (key) ->
			(stamp, delta, stamp_unit = $.date.defaultUnit) ->
				date = $.date.unstamp(stamp, stamp_unit)
				parsers[key].call date, (formats[key].call date) + delta
				$.date.stamp date, stamp_unit

		$:
			date:
				defaultUnit: "ms"
				defaultFormat: "yyyy-mm-dd HH:MM:SS"
				stamp: (date = new Date, unit = $.date.defaultUnit) ->
					floor (date / units[unit])
				unstamp: (stamp, unit = $.date.defaultUnit) ->
					new Date floor(stamp * units[unit])
				convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
					(floor stamp * units[from] / units[to])
				midnight: (stamp, unit = $.date.defaultUnit) ->
					$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
				format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
					date = $.date.unstamp(stamp, unit)
					for k in format_keys
						fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
					fmt
				parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
					date = new Date(0)
					for i in [0...fmt.length] by 1
						for k in parser_keys
							if fmt.indexOf(k, i) is i
								try
									parsers[k].call date,
										parseInt dateString[i...i+k.length], 10
								catch err
					$.date.stamp date, to
				addMilliseconds: adder("MS")
				addSeconds: adder("SS")
				addMinutes: adder("MM")
				addHours: adder("HH")
				addDays: adder("dd")
				addMonths: adder("mm")
				addYears: adder("yyyy")
				range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
					add = adder(interval_unit)
					ret = [from]
					while (cur = ret[ret.length-1]) < to
						ret.push add(cur, interval, stamp_unit)
					ret
	
		midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
		unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
		stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
		dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
		dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)

)(Bling)

(($) ->

	$.plugin
		provides: "delay"
		depends: "function"
	, ->
		$:
			delay: (->
				timeoutQueue = $.extend [], (->
					next = (a) -> -> a.shift()() if a.length
					add: (f, n) ->
						f.order = n + $.now
						for i in [0..@length]
							if i is @length or @[i].order > f.order
								@splice i,0,f
								break
						setTimeout next(@), n
						@
					cancel: (f) ->
						for i in [0...@length]
							if @[i] == f
								@splice i, 1
								break
						@
				)()

				(n, f) ->
					if $.is("function",f) then timeoutQueue.add(f, n)
					cancel: -> timeoutQueue.cancel(f)

			)()

		delay: (n, f, c=@) ->
			inherit @, $.delay n, $.bound(c, f)

)(Bling)
(($) ->
	if $.global.document?
		$.plugin
			depends: "function"
			provides: "dom"
		, ->
			$.type.register "nodelist",
				match:  (o) -> o? and $.isType "NodeList", o
				hash:   (o) -> $($.hash(i) for i in x).sum()
				array:  $.identity
				string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
				node:   (o) -> $(o).toFragment()
			$.type.register "node",
				match:  (o) -> o?.nodeType > 0
				hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "fragment",
				match:  (o) -> o?.nodeType is 11
				hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "html",
				match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
				node:   (h) ->
					(node = document.createElement('div')).innerHTML = h
					if n = (childNodes = node.childNodes).length is 1
						return node.removeChild(childNodes[0])
					df = document.createDocumentFragment()
					df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
					df
				array:  (o,c) -> $.type.lookup(h = Bling.HTML.parse o).array h, c
				repr:   (o) -> '"' + o + '"'
			$.type.extend
				unknown:  { node: -> null }
				bling:    { node: (o) -> o.toFragment() }
				node:     { html: (n) ->
					d = document.createElement "div"
					d.appendChild (n = n.cloneNode true)
					ret = d.innerHTML
					ret
				}
				string:
					node:  (o) -> $(o).toFragment()
					array: (o,c) -> c.querySelectorAll?(o)
				function: { node: (o) -> $(o.toString()).toFragment() }

			toFrag = (a) ->
				if not a.parentNode?
					df = document.createDocumentFragment()
					df.appendChild(a)
				a
			before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
			after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
			toNode = (x) -> $.type.lookup(x).node(x)
			escaper = false
			parser = false

			computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue(k)

			getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select(p)

			selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )

			return {
				$:

					HTML:
						parse: (h) -> $.type.lookup(h).node(h)
						stringify: (n) -> $.type.lookup(n).html(n)
						escape: (h) ->
							escaper or= $("<div>&nbsp;</div>").child(0)
							ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
							escaper.zap('data', '')
							ret

				html: (h) ->
					return switch $.type h
						when "undefined","null" then @select 'innerHTML'
						when "string" then @zap 'innerHTML', h
						when "bling" then @html h.toFragment()
						when "node"
								@replaceChild @childNodes[0], h
								while @childNodes.length > 1
									@removeChild @childNodes[1]

					@each -> @appendChild x.cloneNode true

					clones = @map( -> @cloneNode true)
					i = 0
					$(x).each -> @appendChild clones[i++]
					clones

					if x?
						x = toNode(x)
						@take(1).each ->
							before @childNodes[0], x
						@skip(1).each ->
							before @childNodes[0], x.cloneNode(true)
					@

					if x?
						$(x).prepend(@)
					@

					if x?
						x = toNode(x)
						@take(1).each -> before @, x
						@skip(1).each -> before @, x.cloneNode(true)
					@

					if x?
						x = toNode(x)
						@take(1).each -> after @, x
						@skip(1).each -> after @, x.cloneNode(true)
					@

					parent = toNode(parent)
					if $.is "fragment", parent
						throw new Error("cannot call .wrap() with a fragment as the parent")
					@each (child) ->
						if ($.is "fragment", child) or not child.parentNode
							return parent.appendChild child
						grandpa = child.parentNode
						marker = document.createElement "dummy"
						parent.appendChild grandpa.replaceChild marker, child
						grandpa.replaceChild parent, marker

					@each ->
						if @parentNode and @parentNode.parentNode
							@parentNode.parentNode.replaceChild(@, @parentNode)
						else if @parentNode
							@parentNode.removeChild(@)

					n = toNode(n)
					clones = @map(-> n.cloneNode true)
					for i in [0...clones.length] by 1
						@[i].parentNode?.replaceChild clones[i], @[i]
					clones

					return switch v
						when undefined then @select("getAttribute").call(a, v)
						when null then @select("removeAttribute").call(a, v)
						else
							@select("setAttribute").call(a, v)
							@


					notempty = (y) -> y isnt ""
					@removeClass(x).each ->
						c = @className.split(" ").filter notempty
						c.push(x)
						@className = c.join " "

					notx = (y) -> y != x
					@each ->
						c = @className.split(" ").filter(notx).join(" ")
						if c.length is 0
							@removeAttribute('class')

					notx = (y) -> y isnt x
					@each ->
						cls = @className.split(" ")
						filter = $.not $.isEmpty
						if( cls.indexOf(x) > -1 )
							filter = $.and notx, filter
						else
							cls.push(x)
						c = cls.filter(filter).join(" ")
						@className = c
						if c.length is 0
							@removeAttribute('class')

					@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1

					return @zap('textContent', t) if t?
					return @select('textContent')

					return @zap('value', v) if v?
					return @select('value')

				css: (k,v) ->
					if v? or $.is "object", k
						setter = @select 'style.setProperty'
						if $.is "object", k then setter.call i, k[i], "" for i of k
						else if $.is "string", v then setter.call k, v, ""
						else if $.is "array", v
							setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
						return @
					else
						cv = @map computeCSSProperty(k)
						ov = @select('style').select k
						ov.weave(cv).fold (x,y) -> x or y

				defaultCss: (k, v) ->
					sel = @selector
					style = ""
					if $.is "string", k
						if $.is "string", v
						else throw Error("defaultCss requires a value with a string key")
					else if $.is "object", k
						"} "
					$("<style></style>").text(style).appendTo("head")
					@

				rect: -> @select('getBoundingClientRect').call()

				width: getOrSetRect("width")

				height: getOrSetRect("height")

				top: getOrSetRect("top")

				left: getOrSetRect("left")

				bottom: getOrSetRect("bottom")

				right: getOrSetRect("right")

				position: (left, top) ->
					switch true
						when not left? then @rect()
						when not top? then @css("left", $.px(left))
						else @css({top: $.px(top), left: $.px(left)})

				scrollToCenter: ->
					document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
					@

				child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]

				parents: selectChain('parentNode')

				prev: selectChain('previousSibling')

				next: selectChain('nextSibling')

				remove: -> @each -> @parentNode?.removeChild(@)

				find: (css) ->
					@filter("*")
						.map( -> $(css, @) )
						.flatten()

				clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @

				toFragment: ->
					if @length > 1
						df = document.createDocumentFragment()
						(@map toNode).map $.bound df, df.appendChild
						return df
					return toNode @[0]
			}
)(Bling)
(($) ->
	$.plugin
		depends: "dom,function,core"
		provides: "event"
	, ->
		EVENTSEP_RE = /,* +/
		events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
			'load','unload','reset','submit','keyup','keydown','change',
			'abort','cut','copy','paste','selection','drag','drop','orientationchange',
			'touchstart','touchmove','touchend','touchcancel',
			'gesturestart','gestureend','gesturecancel',
			'hashchange'
		]

		binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)

		register_live = (selector, context, evt, f, h) ->
			$(context).bind(evt, h)
				.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h

		unregister_live = (selector, context, e, f) ->
			$c = $(context)
			$c.each ->
				a = (@__alive__ or= {})
				b = (a[selector] or= {})
				c = (b[e] or= {})
				$c.unbind(e, c[f])
				delete c[f]

		triggerReady = $.once ->
			$(document).trigger("ready").unbind("ready")
			document.removeEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.removeEventListener?("load", triggerReady, false)
		bindReady = $.once ->
			document.addEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.addEventListener?("load", triggerReady, false)
		bindReady()

		ret = {
			bind: (e, f) ->
				c = (e or "").split(EVENTSEP_RE)
				h = (evt) ->
					ret = f.apply @, arguments
					if ret is false
						evt.preventAll()
					ret
				@each -> (@addEventListener i, h, false) for i in c

			unbind: (e, f) ->
				c = (e or "").split EVENTSEP_RE
				@each -> (@removeEventListener i, f, null) for i in c

			trigger: (evt, args = {}) ->
				args = $.extend
					bubbles: true
					cancelable: true
				, args

				for evt_i in (evt or "").split(EVENTSEP_RE)
						e = document.createEvent "MouseEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							button: 0,
							relatedTarget: null
						, args
						e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.button, args.relatedTarget

						e = document.createEvent "UIEvents"
						e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1

						e = document.createEvent "TouchEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							touches: [],
							targetTouches: [],
							changedTouches: [],
							scale: 1.0,
							rotation: 0.0
						, args
						e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)

						e = document.createEvent "GestureEvents"
						args = $.extend {
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							target: null,
							scale: 1.0,
							rotation: 0.0
						}, args
						e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.target, args.scale, args.rotation

					else
						e = document.createEvent "Events"
						e.initEvent evt_i, args.bubbles, args.cancelable
						try
							e = $.extend e, args
						catch err

					if not e
						continue
					else
						try
							@each -> @dispatchEvent e
						catch err
							$.log "dispatchEvent error:", err
				@

			live: (e, f) ->
				selector = @selector
				context = @context
				handler = (evt) ->
					$(selector, context)
						.intersect($(evt.target).parents().first().union($(evt.target)))
						.each -> f.call(evt.target = @, evt)
				register_live selector, context, e, f, handler
				@

			die: (e, f) ->
				$(@context).unbind e, unregister_live(@selector, @context, e, f)
				@

			click: (f = {}) ->
				if @css("cursor") in ["auto",""]
					@css "cursor", "pointer"
				if $.is "function", f then @bind 'click', f
				else @trigger 'click', f
				@

			ready: (f) ->
				return (f.call @) if triggerReady.exhausted
				@bind "ready", f
		}

		events.forEach (x) -> ret[x] = binder(x)
		return ret
)(Bling)

(($) ->
	$.plugin
		depends: "experimental"
	, ->
		pruners = {}
		register = (type, f) -> (pruners[type] = f)
		lookup = (obj) -> pruners[obj.t or obj.type]
		stack = []

		$.type.extend null,        { compact: (o) -> $.toString(o) }
		$.type.extend "undefined", { compact: (o) -> "" }
		$.type.extend "null",      { compact: (o) -> "" }
		$.type.extend "string",    { compact: $.identity }
		$.type.extend "array",     { compact: (o) -> (Object.Compact(x) for x in o).join("") }
		$.type.extend "bling",     { compact: (o) -> o.map(Object.Compact).join("") }
		$.type.extend "object",    { compact: (o) -> Object.Compact(lookup(o)?.call o, o) }

		Object.Compact = (o) ->
			stack.push(o)
			$.type.lookup(o)?.compact(o)
			stack.pop()
		$.extend Object.Compact,
			register: register
			lookup: lookup

		register 'page', -> [
			"<!DOCTYPE html><html><head>",
				@head,
			"</head><body>",
				@body,
			"</body></html>"
		]
		register 'text', -> @EN
		register 'link', ->
			a = $(["<a"])
			a.extend(" ",k,"='",@[k],"'") for k in ["href","name","target"] when k of @
			a.extend(">",node.content,"</a>")

		$.assert(Object.Compact({ t: "page", head: [], body: {type: "text", EN: "Hello World"} }) is
			"<!DOCTYPE html><html><head></head><body>Hello World</body></html>")

		return { name: "Compact" }
)(Bling)

(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'ClientRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts

				post: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "POST"
					$.http url, opts

				get: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "GET"
					$.http url, opts
		}
)(Bling)
(($) ->
		operatorHtml = "<span class='opr'>$&</span>"
		keywords = /\b[Ff]unction\b|\bvar\b|\.prototype\b|\.__proto__\b|\bString\b|\bArray\b|\bNumber\b|\bObject\b|\bbreak\b|\bcase\b|\bcontinue\b|\bdelete\b|\bdo\b|\bif\b|\belse\b|\bfinally\b|\binstanceof\b|\breturn\b|\bthrow\b|\btry\b|\btypeof\b|\btrue\b|\bfalse\b/g
		keywordHtml = "<span class='kwd'>$&</span>"
		allNumbers = /\d+\.*\d*/g
		numberHtml = "<span class='num'>$&</span>"
		blingSymbol = /\$(\(|\.)/g
		blingHtml = "<span class='bln'>$$</span>$1"
		tabs = /\t/g
		tabHtml = "&nbsp;&nbsp;"
		singlelineComment = /\/\/.*?(?:\n|$)/
		multilineComment = /\/\*(?:.|\n)*?\*\//
		commentHtml = (comment) ->
		quotedHtml = (quoted) ->

			a = s.indexOf('"', i)
			b = s.indexOf("'", i)
			a = s.length if a is -1
			b = s.length if b is -1
			return [null, -1] if a is b
			return ['"', a] if a < b
			return ["'", b]
			r = s.indexOf(q, i)
			while( s.charAt(r-1) is "\\" and 0 < r < s.length)
				r = s.indexOf(q, r+1)
			r
			i = 0
			n = s.length
			ret = []
			if not Object.IsString(s)
				if not Object.IsFunction(s.toString)
					throw TypeError("invalid string argument to split_quoted")
				else
					s = s.toString()
					n = s.length
			while( i < n )
				q = firstQuote(s, i)
				j = q[1]
				if( j is -1 )
					ret.push(s.substring(i))
					break
				ret.push(s.substring(i,j))
				k = closingQuote(s, j+1, q[0])
				if( k is -1 )
					throw Error("unclosed quote: "+q[0]+" starting at "+j)
				ret.push(s.substring(j, k+1))
				i = k+1
			ret

		firstComment = (s) ->
			a = s.match(singlelineComment)
			b = s.match(multilineComment)
			return [-1, null] if a is b
			return [b.index, b[0]] if a == null and b != null
			return [a.index, a[0]] if a != null && b == null
			return [b.index, b[0]] if b.index < a.index
			return [a.index, a[0]]

		splitComments = (s) ->
			ret = []
			i = 0
			n = s.length
			while( i < n )
				ss = s.substring(i)
				q = firstComment(ss)
				j = q[0]
				if( j > -1 )
					ret.push(ss.substring(0,j))
					ret.push(q[1])
					i += j + q[1].length
				else
					ret.push(ss)
					break
			ret

		foldCodeAndQuoted = (code, quoted) ->
			code.replace(operators, operatorHtml).replace(allNumbers, numberHtml).replace(keywords, keywordHtml).replace(blingSymbol, blingHtml).replace(tabs, tabHtml) + quotedHtml(quoted)

		foldTextAndComments = (text, comment) ->
			$(splitQuoted(text)).fold(foldCodeAndQuoted).join('') + commentHtml(comment)

		return {
			name: "PrettyPrint"
			$:
				prettyPrint: (js, colors) ->
					js = js.toString() if Object.IsFunction(js)
					if not Object.IsString(js)
						throw TypeError("prettyPrint requires a function or string to format, not '"+Object.Type(js)+"'")
						css = "code.pp .bln { font-size: 17px; } "
						colors = Object.Extend(
						, colors)
						for cls of colors
							.text(css)
							.appendTo("head")
					ret = "<code class='pp'>" + ($(splitComments(js)).fold(foldTextAndComments).join('')) + "</code>"
		}

)(Bling)
(($) ->

	$.plugin () ->

		Dialog = (selector, opts) ->
			opts = $.extend({
				autoOpen: false
				draggable: true
			}, opts)
			dialog = $(selector)
				.addClass("dialog")
			if opts.draggable
				dialog.draggable()
			if opts.autoOpen
				dialog.show().center()
			dialog
				.find("button.close, .close-button")
				.bind "click touchstart", () ->
					dialog.hide()
					false
			dialog
		
		Draggable = (selector, opts) ->
			opts = $.extend({
				handleCSS: {}
			}, opts)

			opts.handleCSS = $.extend({
				position: "absolute"
				top: "0px"
				left: "0px"
				width: "100%"
				height: "6px"
			}, opts.handleCSS)

			dragObject = $(selector)
			moving = false
			oX = oY = 0
			handle = $
				.synth("div.handle")
				.defaultCss({
					height: "6px"
					"border-radius": "3px"
					cursor: "move"
				})
				.css(opts.handleCSS)
				.bind 'mousedown, touchstart', (evt) ->
					moving = true
					oX or= evt.pageX
					oY or= evt.pageY
					false
			$(document)
			.bind 'mousemove, touchmove', (evt) ->
				if moving
					dX = (evt.pageX - oX)
					dY = (evt.pageY - oY)
					dragObject.transform({
						translate: [ dX, dY ]
					}, 0)
					.trigger 'drag', {
						dragObject: dragObject
					}
					false
			.bind 'mouseup, touchend', (evt) ->
				if moving
					moving = false
					pos = handle.position()[0]
					$(document.elementFromPoint(pos.left, pos.top - 1))
					.trigger 'drop',
						dropObject: dragObject

			dragObject
				.addClass("draggable")
				.css {
					position: "relative"
					"padding-top": dragObject.css("padding-top")
						.map(Number.AtLeast(parseInt(opts.handleCSS.height,10)))
						.px().first()
				}
				.append(handle)

		ProgressBar = (selector, opts) ->
			opts = $.extend({
				change: null
				barColor: "rgba(0,128,0,0.5)"
				textColor: "white"
				reset: false
			}, opts)

			node = $(selector)
				.addClass('progress-bar')
				_bg = node.css("background").first()
				_color = node.css("color").first()

			node.zap 'updateProgress', (pct) ->
				while pct < 1.0
					pct *= 100.0
					node.css
						background: _bg
						color: _color
				else
					node.css
						background:"""
						"""
						color: opts.textColor
				if $.is "function", opts.change
					opts.change pct

		Accordion = (selector, opts) ->
			opts = $.extend({
				exclusive: false
				sticky: false
			}, opts)
			node = $(selector).addClass("accordion")
			selectedChild = null

			initRow = (n) ->
				t = $(n).children().first().filter("*")
				if( t.len() isnt 2 )
				title = t.eq(0).addClass("title")
				body = t.eq(1).addClass("body").hide()
				bodyVisible = false
				title.click () ->
					if opts.exclusive
						node.find(".body").hide()
					if bodyVisible
						if not opts.sticky
							body.hide().removeClass("visible")
							title.removeClass("selected").trigger("deselect")
							bodyVisible = false
						else
							body.show().addClass("visible")
							title.addClass("selected").trigger("select")
							bodyVisible = true
					else
						body.show().addClass("visible")
						title.addClass("selected").trigger("select")
						bodyVisible = true

			node.bind "DOMNodeInserted", (evt) ->
				directChildren = node.children().first().filter("*")
				parentsOfInserted = $(evt.target).parents().first()
				initRow(parentsOfInserted.intersect(directChildren))

			node.children().first()
				.map(initRow)

			return node

		ViewStack = (selector, opts) ->
			items = $(selector)
				.css {
					position: "relative"
					top: "0px"
					left: "0px"
				}
				.hide()
				.map($)
			active = 0
			items[active].show()
			items.next = () ->
				items[active].hide()
				active = (++active % items.length)
				items[active].show()
			items.activate = (k) ->
				items[active].hide()
				active = k
				items[k].show()
			for j in [0...items.len()]
				items[j]
				.zap("_viewIndex", j)
				.zap "activate", ->
					items.activate(this._viewIndex)
			items

		Tabs = (selector, views) ->
			tabs = $(selector)
			views = $(views).viewStack()
			nn = tabs.len()
			tabs._tabIndex = i for i in [0..nn]
			$(tabs[0]).addClass("active")
			tabs.click () ->
				tabs.removeClass("active")
				views.activate(this._tabIndex)
				$(this).addClass("active")

		return {
			$:
				UI:
					Draggable: Draggable
					ProgressBar: ProgressBar
					ViewStack: ViewStack
					Tabs: Tabs
					Accordion: Accordion

			dialog: (opts) -> Dialog(this, opts)
			progressBar: (opts) -> ProgressBar(this, opts)
			viewStack: (opts) -> ViewStack(this, opts)
			tabs: (views) -> Tabs(this, views)
			accordion: (opts) -> Accordion(this, opts)
			draggable: (opts) -> Draggable(this, opts)
		}

)(Bling)


	units = ["px","pt","pc","em","%","in","cm","mm","ex",""]
	UNIT_RE = /(\d+\.*\d*)(px|pt|pc|em|%|in|cm|mm|ex)/

	parseUnits = (s) -> UNIT_RE.exec(s)[2] if UNIT_RE.test(s) else ""

	conv = (a,b) -> conv[a][b]()
	for a in units
		for b in units
			(conv[a] or= {})[b] = trick +(a is b or a is "" or b is "")
	conv.in.pt = -> 72
	conv.in.px = -> 96
	conv.in.cm = -> 2.54
	conv.pc.pt = -> 12
	conv.cm.mm = -> 10
	conv.em.px = ->
		x = $("<span style='font-size:1em;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.px = ->
		x = $("<span style='font-size:1ex;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.em = -> 2
	fillIn = ->
		for a in units
			for b in units
				if not conv(a,b) and conv(b,a)
					conv[a][b] = trick 1.0/conv(b,a)
				for c in units
					if not conv(a,c) and conv(a,b) and conv(b,c)
						conv[a][c] = trick conv(a,b) * conv(b,c)
	fillIn(); fillIn()
	
	convertUnits = (number, unit) -> parseFloat(number) * conv[parseUnits(number)][unit]() + unit

	$.assert(convertUnits("300px", "cm") == "10cm")

	convertAll = (to, a) ->
		for i in [0...a.length]
			a[i] = convertTo(to, a[i])

	Object.Type.register "units",
		match: (x) -> UNIT_RE.test(x)

	unit_scalar = (f) ->
		(a...) ->
			convertAll( unit = parseUnits(@[0]), @)
			(f.apply @, a) + unit
	unit_vector = (f) ->
		(a...) ->
			u = @map parseUnits
			f.apply(@floats(), a).map ->

	{
		min: unit_scalar -> @reduce (a) -> Math.min parseFloat(@), a
		max: unit_scalar -> @reduce (a) -> Math.max parseFloat(@), a
		sum: unit_scalar -> @reduce (a) -> parseFloat(@) + a
		mean: unit_scalar -> parseFloat(@sum()) / @length
		magnitude: unit_scalar -> Math.sqrt @floats().squares().sum()
		squares: -> @map -> (x=parseFloat(@)) * x
		scale: (n) -> @map -> n * parseFloat(@)
		add: (d) -> @map -> d + @
		normalize: -> @scale(1/@magnitude())
	}


	EOF = -> "EOF"

	BackgroundQueue = (opts) ->
		opts = extend {
			item: -> EOF
			action: Function.Identity
			latency: 10
		}, opts

		return extend new $.EventEmitter(), {
			run: ->
				r = () =>
					if (item = opts.action(opts.item())) isnt EOF
						@emit("data", item)
						setTimeout r, opts.latency
				setTimeout r, opts.latency
		}

	data = x for x in [0...1000]
	i = 0
	BackgroundQueue
		item: ->
			return data[i++] if i < data.length else EOF
		action: (item) -> (item*item) - 1
		latency: 10
	.on "data", (x) -> console.log "data:", x
	.on "error", (x) -> console.log "error:", x
	
(($) ->
	$.plugin ->
		$:
			histogram: (data, bucket_width=1, output_width=80) ->
				buckets = $()
				len = 0
				for x in data
					i = Math.floor( x / bucket_width )
					buckets[i] ?= 0
					buckets[i] += 1
					len = Math.max(len, i+1)
				buckets.length = len

				max = buckets.max()
				buckets = buckets.map((x) -> x or 0)
					.scale(1/max)
					.scale(output_width)
				sum = buckets.sum()

				ret = ""
				for n in [0...len] by 1
					end = (n+1) * bucket_width
					pct = (buckets[n]*100/sum).toFixed(0)
				ret
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'XMLHttpRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					xhr = new XMLHttpRequest()
					if $.is "function", opts
						opts = success: $.bound(xhr, opts)
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts
					opts.state = $.bound(xhr, opts.state)
					opts.success = $.bound(xhr, opts.success)
					opts.error = $.bound(xhr, opts.error)
					if opts.data and opts.method is "GET"
						url += "?" + formencode(opts.data)
					else if opts.data and opts.method is "POST"
						opts.data = formencode(opts.data)
					xhr.open(opts.method, url, opts.async)
					xhr = $.extend xhr,
						asBlob: opts.asBlob
						timeout: opts.timeout
						followRedirects: opts.followRedirects
						withCredentials: opts.withCredentials
						onreadystatechange: ->
							opts.state?()
							if xhr.readyState is 4
								if xhr.status is 200
									opts.success xhr.responseText
								else
									opts.error xhr.status, xhr.statusText
					xhr.send opts.data
					return $(xhr)

				post: (url, opts = {}) ->
					if $.is("function",opts)
						opts = success: opts
					opts.method = "POST"
					$.http(url, opts)

				get: (url, opts = {}) ->
					if( $.is("function",opts) )
						opts = success: opts
					opts.method = "GET"
					$.http(url, opts)
		}
)(Bling)
(($) ->

	$.plugin
		depends: "dom"
		provides: "lazy"
	, ->
		lazy_load = (elementName, props) ->
			$("head").append $.extend document.createElement(elementName), props
		$:
			script: (src) ->
				lazy_load "script", { src: src }
			style: (src) ->
				lazy_load "link", { href: src, rel: "stylesheet" }

)(Bling)
(($) ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""

		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615

		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)

			index = (index + 1) % 624
			(y + a) / b

		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()

		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
	)()

	$.plugin
		provides: "random"
	, ->
		$:
			random: random

)(Bling)
(($) ->
	$.plugin
		provides: "sendgrid"
		depends: "config"
	, ->
		try
			nodemailer = require 'nodemailer'
		catch err
			`return`
		transport = nodemailer.createTransport 'SMTP',
			service: 'SendGrid'
			auth:
				user: $.config.get 'SENDGRID_USERNAME'

		$:
			sendMail: (mail, callback) ->
				mail.transport ?= transport
				mail.from ?= $.config.get 'EMAILS_FROM'
				mail.bcc ?= $.config.get 'EMAILS_BCC'

				if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
					nodemailer.sendMail mail, callback
				else
)(Bling)
(($) ->
	$.plugin
		provides: "StateMachine"
	, ->
		$: StateMachine: class StateMachine
			constructor: (stateTable) ->
				@reset()
				@table = stateTable
				Object.defineProperty @, "modeline",
					get: -> @table[@_mode]
				Object.defineProperty @, "mode",
					set: (m) ->
						@_lastMode = @_mode
						@_mode = m
						if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
							ret = @modeline['enter'].call @
							while $.is("function",ret)
								ret = ret.call @
						m
					get: -> @_mode

			reset: ->
				@_mode = null
				@_lastMode = null

			GO: (m) -> -> @mode = m
			@GO: (m) -> -> @mode = m
			
			tick: (c) ->
				row = @modeline
				if not row?
					ret = null
				else if c of row
					ret = row[c]
				else if 'def' of row
					ret = row['def']
				while $.is "function",ret
					ret = ret.call @, c
				ret

			run: (inputs) ->
				@mode = 0
				for c in inputs
					ret = @tick(c)
				if $.is "function",@modeline?.eof
					ret = @modeline.eof.call @
				while $.is "function",ret
					ret = ret.call @
				@reset()
				return @

	$.plugin
		provides: "synth"
		depends: "StateMachine"
	, ->
		class SynthMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: ->
						@tag = @id = @cls = @attr = @val = @text = ""
						@attrs = {}
						@GO 1
				},
					def: (c) -> @tag += c
					eof: @GO 13
				},
					".": @GO(3), "[": @GO(4), " ": @GO(9), "+": @GO(11), ",": @GO(10),
					def: (c) -> @id += c
					eof: @GO 13
				},
					enter: -> @cls += " " if @cls.length > 0
					def: (c) -> @cls += c
					eof: @GO 13
				},
					"=": @GO 5
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @attr += c
					eof: @GO 12
				},
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @val += c
					eof: @GO 12
				},
					'"': @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					"'": @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					enter: ->
						@emitText()
						@GO 0
				},
					enter: ->
						@emitNode()
						@GO 0
				},
					enter: ->
						@emitNode()
						@parent = null
						@GO 0
				},
					enter: ->
						@emitNode()
						@parent = @parent?.parentNode
						@GO 0
				},
				},
					enter: ->
						@emitNode() if @tag.length
						@emitText() if @text.length
				}
			]
			constructor: ->
				super(SynthMachine.STATE_TABLE)
				@fragment = @parent = document.createDocumentFragment()
			emitNode: ->
				node = document.createElement(@tag)
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@parent.appendChild node
				@parent = node
			emitText: ->
				@parent.appendChild $.HTML.parse(@text)
				@text = ""

		return {
			$:
				synth: (expr) ->
					s = new SynthMachine()
					s.run(expr)
					if s.fragment.childNodes.length == 1
						$(s.fragment.childNodes[0])
					else
						$(s.fragment)
		}

)(Bling)
(($) ->


		current_engine = null
		engines = {}

		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine

		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()

		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop]
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1

	$.template.register_engine 'pythonic', (() ->

		chunk_re = /%[\(\/]/

		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n]
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}

			if not cache?
			n = cache.length

			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""

		return render
	)()

		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()


)(Bling)
(($) ->
		parseOne = (data) ->
			i = data.indexOf ":"
			if i > 0
				len = parseInt data[0...i], 10
				item = data[i+1...i+1+len]
				type = data[i+1+len]
				extra = data[i+len+2...]
				item = switch type
					when "'" then String(item)
					when "!" then (item is "true")
					when "~" then null
					when "]" then parseArray(item)
					when "}" then parseObject(item)
				return [item, extra]
			return undefined
		parseArray = (x) ->
			data = []
			while x.length > 0
				[one, x] = parseOne(x)
				data.push(one)
			data
		parseObject = (x) ->
			data = {}
			while x.length > 0
				[key, x] = parseOne(x)
				[value, x] = parseOne(x)
				data[key] = value
			data
		$:
			TNET:
				stringify: (x) ->
					[data, type] = switch $.type x
						when "string" then [x, "'"]
						when "function" then [String(x), "'"]
						when "boolean" then [String(not not x), "!"]
						when "null" then ["", "~"]
						when "undefined" then ["", "~"]
						when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
						when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
					return (data.length|0) + ":" + data + type
				parse: (x) ->
					parseOne(x)?[0]
)(Bling)
(($) ->

	$.plugin
		provides: "trace"
		depends: "function,type"
	, ->
		$.type.extend
			unknown: { trace: $.identity }
			function:
				trace: (f, label, tracer) ->
					r = (a...) ->
						f.apply @, a
					r.toString = f.toString
					r
		return $: trace: (o, label, tracer = $.log) -> $.type.lookup(o).trace(o, label, tracer)

)(Bling)
(($) ->
	$.plugin
		depends: "dom"
	, ->
		COMMASEP = ", "
			"slow": 700
			"medium": 500
			"normal": 300
			"fast": 100
			"instant": 0
			"now": 0
		accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
		testStyle = document.createElement("div").style

		transformProperty = "transform"
		transitionProperty = "transition-property"
		transitionDuration = "transition-duration"
		transitionTiming = "transition-timing-function"

		if "WebkitTransform" of testStyle
			transformProperty = "-webkit-transform"
			transitionProperty = "-webkit-transition-property"
			transitionDuration = "-webkit-transition-duration"
			transitionTiming = "-webkit-transition-timing-function"
		else if "MozTransform" of testStyle
			transformProperty = "-moz-transform"
			transitionProperty = "-moz-transition-property"
			transitionDuration = "-moz-transition-duration"
			transitionTiming = "-moz-transition-timing-function"
		else if "OTransform" of testStyle
			transformProperty = "-o-transform"
			transitionProperty = "-o-transition-property"
			transitionDuration = "-o-transition-duration"
			transitionTiming = "-o-transition-timing-function"

		return {
			$:
				duration: (speed) ->
					d = speeds[speed]
					return d if d?
					return parseFloat speed

			transform: (end_css, speed, easing, callback) ->

				if $.is("function",speed)
					callback = speed
					speed = easing = null
				else if $.is("function",easing)
					callback = easing
					easing = null
				speed ?= "normal"
				easing or= "ease"
				duration = $.duration(speed) + "ms"
				props = []
				trans = ""
				css = {}
				for i of end_css
					if accel_props_re.test(i)
						ii = end_css[i]
						if ii.join
							ii = $(ii).px().join COMMASEP
						else if ii.toString
							ii = ii.toString()
						trans += " " + i + "(" + ii + ")"
					else css[i] = end_css[i]
				(props.push i) for i of css
				if trans
					props.push transformProperty

				css[transitionProperty] = props.join COMMASEP
				css[transitionDuration] = props.map(-> duration).join COMMASEP
				css[transitionTiming] = props.map(-> easing).join COMMASEP

				if trans
					css[transformProperty] = trans
				@css css
				@delay duration, callback

				@each ->
					if @style
						if @style.display is not "none"
							@_display = @syle.display
						@style.display = "none"
				.trigger "hide"
				.delay updateDelay, callback

				@each ->
					if @style
						@style.display = @_display
						delete @_display
				.trigger "show"
				.delay updateDelay, callback

				@weave(@css("display"))
					.fold (display, node) ->
						if display is "none"
							node.style.display = node._display or ""
							delete node._display
							$(node).trigger "show"
						else
							node._display = display
							node.style.display = "none"
							$(node).trigger "hide"
						node
					.delay(updateDelay, callback)

				@.css('opacity','0.0')
					.show ->
						@transform {
							opacity:"1.0",
							translate3d: [0,0,0]
						}, speed, callback
				@transform {
					opacity:"0.0",
					translate3d:[x,y,0.0]
				}, speed, -> @hide(callback)
			fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
			fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
			fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
			fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
		}
)(Bling)
(($) ->
	$.plugin
		provides: "unittest"
		depends: "core"
	, ->
		testCount = passCount = failCount = 0
		failed = []
		invokeTest = (group, name, func) ->
			return if not $.is "function", func
			shouldFail = name.toLowerCase().indexOf("fail") isnt -1
			done = $.once (err) ->
				testCount--
				if (!!err isnt shouldFail)
					failCount++
					failed.push name
				else
					_log "pass"
					passCount++
					$.provide name
			f = (done) ->
				try func(done)
				catch err then done(err)
				finally
					if name.toLowerCase().indexOf("async") is -1 then done()
			testCount++
			try f(done)
			catch err then done(err)

		testReport = $.once ->

		$:
			approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
			assertEqual: (a, b, label) ->
				if a != b
			assertArrayEqual: (a, b, label) ->
				for i in [0...a.length]
					try
						$.assertEqual(a[i], b[i], label)
					catch err
			testGroup: (name, funcs) ->
				interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
				for k,func of funcs
					invokeTest(name, k, func)
		assertEqual: (args...) ->
					if $.is "function", x then x.call(@,@) else x
				a = args[0]
				for i in [1...args.length]
					$.assertEqual a, args[i]
			return @
)(Bling)
require('./common')

$.testGroup("Object",
	keys: -> $.assertArrayEqual Object.keys({a: 1, b: 2}), ['a','b']
)

$.testGroup("Type",
	string: -> $.assertEqual $.type(""), "string"
	number:-> $.assertEqual $.type(42), "number"
	undef: -> $.assertEqual $.type(), "undefined"
	null: -> $.assertEqual $.type(null), "null"
	array: -> $.assertEqual $.type([]), "array"
	function: -> $.assertEqual $.type(() -> null), "function"
	bool: -> $.assertEqual $.type(true), "bool"
	regexp: -> $.assertEqual $.type(//), "regexp"
	window: -> $.assertEqual $.type(window), "global"
	is: ->
		$.assert($.is "function", ->)
		$.assert($.is "array", [])
	inherit: ->
		a = { a: 1 }
		b = { b: 2 }
		$.inherit a, b
		$.assertEqual(b.__proto__, a)
		$.assertEqual(b.a, 1)
		$.assert( not b.hasOwnProperty("a") )
	extend: -> $.assertArrayEqual Object.keys($.extend({A:1},{B:2})), ['A','B']
	defineProperty: ->
		a = {}
		$.defineProperty a, "b",
			get: -> 2
		$.assert( "b" of a )
	isType1: ->
		$.assert( $.isType(Array, []) )
	isType2: ->
		$.assert( $.isType('Array', []) )
	isType3: ->
		class Foo
		f = new Foo()
		$.assert( $.isType Foo, f )
	isSimple1: -> $.assert( $.isSimple "" )
	isSimple2: -> $.assert( $.isSimple 42.0 )
	isSimple3: -> $.assert( $.isSimple false )
	isSimple4: -> $.assert( not $.isSimple {} )
	isEmpty1: -> $.assert( $.isEmpty "" )
	isEmpty2: -> $.assert( $.isEmpty null )
	isEmpty3: -> $.assert( $.isEmpty undefined )
	toArray1: ->
		a = $([1,2,3])
		b = a.toArray()
		$.assert b.constructor.name is "Array", "constructor name is Array"
		$.assert b[1] is 2, "still has data"
		$.assert b.length is 3, "length is preserved"
		$.assert not b.zap, "has shed bling"
)

$.testGroup("Function",
	identity1: -> $.assertEqual $.type($.identity), "function"
	identity2: -> $.assertEqual( $.identity(a = {}), a)
	bound: ->
		f = -> @value
		a = { value: 'a' }
		b = { value: 'b' }
		g = $.bound(a, f)
		h = $.bound(b, f)
		$.assertEqual(g(), 'a')
		$.assertEqual(h(), 'b')
	trace: ->
		f = -> 42
		g = []
		h = $.trace f, "label", (a...) ->
			g.push a.join ''
		$.assertArrayEqual(g, [ 'Trace: label created.', 'global.label()' ])
)

$.testGroup("String",
	Px1: -> $.assertEqual($.px(100), "100px")
	Px2: -> $.assertEqual($.px(-100.0), "-100px")
	PadLeft1: -> $.assertEqual($.padLeft("foo", 5), "  foo")
	PadLeft2: -> $.assertEqual($.padLeft("foo", 3), "foo")
	PadLeft3: -> $.assertEqual($.padLeft("foo", 2), "foo")
	PadLeft4: -> $.assertEqual($.padLeft("foo", 5, "X"), "XXfoo")
	PadRight1: -> $.assertEqual($.padRight("foo", 5), "foo  ")
	PadRight2: -> $.assertEqual($.padRight("foo", 3), "foo")
	PadRight3: -> $.assertEqual($.padRight("foo", 2), "foo")
	PadRight4: -> $.assertEqual($.padRight("foo", 5, "X"), "fooXX")
	Splice1: -> $.assertEqual($.stringSplice("foobar",3,3,"baz"), "foobazbar")
	Splice2: -> $.assertEqual($.stringSplice("foobar",1,5,"baz"), "fbazr")
	Splice3: -> $.assertEqual($.stringSplice("foobar",0,6,"baz"), "baz")
	Splice4: -> $.assertEqual($.stringSplice("foobar",0,0,"baz"), "bazfoobar")
	Checksum2: -> $.assertEqual($.checksum("foobarbaz"), 310051767)
	ToString: -> $.assertEqual($([2,3,4]).toString(), "$([2, 3, 4])")
)

$.testGroup("Plugins",
	new_plugin: ->
		$.plugin ->
			$:
				testGlobal: -> 9
			testOp: -> 42
		$.assertEqual $.testGlobal?(), 9
		$.assertEqual $().testOp?(), 42
		$.assertEqual $.testOp?(), 42
)

$.testGroup("Symbol",
	exists: -> $.assert( Bling?, "bling should exist")
	current: ->
		Bling.assertEqual( Bling.symbol, "$" )
		Bling.assertEqual( $, Bling )
	set: ->
		Bling.symbol = "_"
		Bling.assertEqual( _, Bling )
	preserve: ->
		global.$ = "before"
		Bling.symbol = "$"
		Bling.assertEqual($, Bling)
		Bling.symbol = "_"
		Bling.assertEqual($, "before")
	reset: ->
		Bling.symbol = "$"
		Bling.assertEqual($, Bling)
)

$.testGroup("Math",
	sum1: -> $.assertEqual($([1,2,3,4,5]).sum(), 15)
	sum2: -> $.assertEqual($([1,2,NaN,3]).sum(), 6)
	range1: -> $.assertEqual($.range(1,6).toRepr(), '$([1, 2, 3, 4, 5])')
	range2: -> $.assertEqual($.range(5).toRepr(), '$([0, 1, 2, 3, 4])')
	zeros1: -> $.assertEqual($.zeros(10).sum(), 0)
	zeros2: -> $.assertEqual($.zeros(5).toRepr(), '$([0, 0, 0, 0, 0])')
	ones: -> $.assertEqual($.ones(10).sum(), 10)
	floats: -> $.assertEqual($(["12.1","29.9"]).floats().sum(), 42)
	ints: -> $.assertEqual($(["12.1","29.9px"]).ints().sum(), 41)
	px: -> $.assertEqual( $(["12.1", "29.9"]).px(2).toRepr(), "$(['14px', '31px'])" )
	min1: -> $.assertEqual( $([12.1, 29.9]).min(), 12.1)
	min2: -> $.assertEqual( $([12.1, NaN, 29.9]).min(), 12.1)
	max1: -> $.assertEqual( $([12.1, 29.9]).max(), 29.9)
	max2: -> $.assertEqual( $([12.1, NaN, 29.9]).max(), 29.9)
)

$.testGroup("Random",
	random: ->
		$.assert 0.0 < $.random() < 1.0
	real: ->
		$.assert 10.0 < $.random.real(10,100) < 100.0
	integer: ->
		r = $.random.integer(3,9)
		$.assert 3 <= r <= 9, "r is in range"
		$.assert Math.floor(r) is r, "r is an integer"
	string: ->
		s = $.random.string(16)
		$.assert $.type(s) is "string", "s is a string"
		$.assert s.length is 16, "s has the right length"
	seed: ->
		$.random.seed = 42
		r = $.random.string(16)
		$.random.seed = 43
		s = $.random.string(16)
		$.random.seed = 42
		t = $.random.string(16)
		$.assert r is t, "same seed produces same output"
		$.assert r isnt s, "different seed produces different output"
)

document.body.innerHTML = "
<table>
	<tr><td>1,1</td><td>1,2</td></tr>
	<tr><td>2,1</td><td>2,2</td></tr>
	<tr><td>3,1</td><td class='d'>3,2</td></tr>
	<tr><td>4,1</td><td>4,2</td></tr>
</table>
<div class='c'>C</div>
<p><span>foobar</span></p>
"
$.testGroup("Core",
	new1: ->
		b = $([1,2,3])
		$.assertEqual(b[0], 1)
		$.assertEqual(b[1], 2)
		$.assertEqual(b[2], 3)
		$.assertEqual(b.constructor.name, "Bling")
	pipe1: ->
		$.pipe('unit-test').append (x) -> x += 2
		$.pipe('unit-test').prepend (x) -> x *= 2
		$.assertEqual( $.pipe('unit-test', 4), 10)
	eq: -> $.assertEqual($([1,2,3]).eq(1)[0], 2)
	each: ->
		sum = 0
		$([1,2,3,4]).each ->
			sum += @
		$.assertEqual(sum, 10)
	map: -> $.assertArrayEqual( $([1,2,3,4]).map( (x) -> x * x ), [1,4,9,16] )
	map2: ->
		d = [1,2,3,4,5]
		$.assertArrayEqual($(d).map(-> @ * 2), [2,4,6,8,10])
		$.assertArrayEqual($(d).map(-> @ * 2), [2,4,6,8,10])
	coalesce1: -> $.assertEqual($.coalesce(null, 42, 22), 42)
	coalesce2: -> $.assertEqual($.coalesce([null, 14, 42]), 14)
	coalesce3: -> $.assertEqual($.coalesce([null, [null, 14], 42]), 14)
	reduce: -> $.assertEqual( $([1,2,3,4]).reduce( (a,x) -> a + x ), 10)
	union: -> $.assertArrayEqual($([1,2,3,4]).union([2,3,4,5]), [1,2,3,4,5])
	intersect: -> $.assertArrayEqual($([1,2,3,4]).intersect([2,3,4,5]), [2,3,4])
	distinct: -> $.assertArrayEqual($([1,2,2,3,4,3]).distinct(), [1,2,3,4])
	contains1: -> $.assert $([1,2,3,4]).contains(3)
	contains2: -> $.assert $(["foo","bar","baz"]).contains("bar")
	count: -> $.assertEqual( $([1,2,2,3,4,3]).count(3), 2 )
	select: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).select('id'), [1,2,3])
	select1: -> $.assertArrayEqual($([
		{a:{b:2}},
		{a:{b:4}},
		{a:{b:6}}
	]).select("a.b"), [2,4,6])
	select2: -> $.assertArrayEqual($([
		{a:[{b:3}]},
		{a:[{b:6}]},
		{a:[{b:9}]}
	]).select("a.0.b"), [3,6,9])
	select3: -> $.assertArrayEqual($([
		{a:{b:{c:4}}},
		{a:{b:{c:5}}},
		{a:{b:{c:6}}}
	]).select("a.b.c"), [4,5,6])
	zap: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).zap('id', 13).select('id'), [13,13,13])
	zapf: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).zap('id', () -> @ * 2).select('id'), [2,4,6])
	zapf2: -> $.assertArrayEqual( $([ {sub:{id:1}}, {sub:{id:2}}, {sub:{id:3}} ]).zap('sub.id', -> @*2).select('sub.id'), [2,4,6])
	take3: -> $.assertArrayEqual($([1,2,3,4]).take(0), [])
	take4: -> $.assertArrayEqual($([1,2,3,4]).take(1), [1])
	take5: -> $.assertArrayEqual($([1,2,3,4]).take(2), [1,2])
	take6: -> $.assertArrayEqual($([1,2,3,4]).take(3), [1,2,3])
	take7: -> $.assertArrayEqual($([1,2,3,4]).take(4), [1,2,3,4])
	take8: -> $.assertArrayEqual($([1,2,3,4]).take(5), [1,2,3,4])
	skip2: -> $.assertArrayEqual($([1,2,3,4]).skip(0), [1,2,3,4])
	skip3: -> $.assertArrayEqual($([1,2,3,4]).skip(1), [2,3,4])
	skip4: -> $.assertArrayEqual($([1,2,3,4]).skip(2), [3,4])
	skip5: -> $.assertArrayEqual($([1,2,3,4]).skip(3), [4])
	skip6: -> $.assertArrayEqual($([1,2,3,4]).skip(4), [])
	skip7: -> $.assertArrayEqual($([1,2,3,4]).skip(5), [])
	first1: -> $.assertEqual($([1,2,3,4]).first(), 1)
	first2: -> $.assertArrayEqual($([1,2,3,4]).first(5), [1,2,3,4])
	first3: -> $.assertArrayEqual($([1,2,3,4]).first(2), [1,2])
	first4: -> $.assertArrayEqual($([1,2,3,4]).first(0), [])
	last1: -> $.assertEqual($([1,2,3,4]).last(), 4)
	last2: -> $.assertArrayEqual($([1,2,3,4]).last(5), [1,2,3,4])
	last3: -> $.assertArrayEqual($([1,2,3,4]).last(2), [3,4])
	last4: -> $.assertArrayEqual($([1,2,3,4]).last(0), [])
	slice1: -> $.assertArrayEqual($([1,2,3,4,5]).slice(0,5), [1,2,3,4,5])
	slice2: -> $.assertArrayEqual($([1,2,3,4,5]).slice(1,5), [2,3,4,5])
	slice3: -> $.assertArrayEqual($([1,2,3,4,5]).slice(2,5), [3,4,5])
	slice4: -> $.assertArrayEqual($([1,2,3,4,5]).slice(3,5), [4,5])
	slice5: -> $.assertArrayEqual($([1,2,3,4,5]).slice(4,5), [5])
	slice6: -> $.assertArrayEqual($([1,2,3,4,5]).slice(1,-2), [2,3])
	slice7: -> $.assertArrayEqual($([1,2,3,4,5]).slice(-1,-3), [5,4])
	slice8: -> $.assertArrayEqual($([1,2,3,4,5]).slice(-1,-4), [5,4,3])
	push: -> $.assertArrayEqual($([1,2,3]).push(4), [1,2,3,4])
	filter1: -> $.assertArrayEqual($([1,2,3,4,5]).filter((x) -> x % 2), [1,3,5])
	filter2: -> $.assertArrayEqual($(["foo","bar","baz"]).filter(/^ba/), ["bar","baz"])
	filter3: -> $.assertArrayEqual($("*").filter("td").length, 8)
	filter4: -> $.assertEqual($("*").filter("td").filter(".d").length, 1)
	filter5: -> $.assertEqual($("*").filter("td").filter(".none").length, 0)
	matches: -> $.assertArrayEqual($("td").matches(".d"), [false,false,false,false,false,true,false,false])
	querySelectorAll: -> $.assertArrayEqual($("tr").querySelectorAll("td.d")[0].className, "d")
	weave1: -> $.assertArrayEqual($([1,1,1]).weave([2,2,2]), [2,1,2,1,2,1])
	weave2: -> $.assertArrayEqual($([1,1,1]).weave($([2,2,2])), [2,1,2,1,2,1])
	fold: -> $.assertArrayEqual($([1,1,1]).weave([2,2,2]).fold( (a,b) -> a+b ), [3,3,3])
	flatten: -> $.assertArrayEqual($([[1,2],[3,4]]).flatten(), [1,2,3,4])
	call: -> $.assertArrayEqual($([((x) -> x*2), ((x) -> x*x)]).call(4), [8, 16])
	apply: -> $.assertArrayEqual($([((x) -> @+x), ((x) -> @*x)]).apply(4,[2]), [6, 8])
	corrected_length: ->
		$.assertEqual(Array(10).length,10)
		$.assertEqual(Bling(10).length, 0)
)

$.testGroup("DOM",
	parse: ->
		d = $.HTML.parse("<div><a></a><b></b><c></c></div>")
		$.assertEqual( $.type(d), "node")
		$.assertEqual( d.nodeName, "DIV")
	stringify: ->
		h = "<div><a/><b/><c/></div>"
		$.assertEqual( $.HTML.stringify($.HTML.parse(h)), h)
	select_childNodes: -> $.assertEqual( $("<div><a></a><b></b><c></c></div>").select("childNodes").flatten().map($.type).toRepr(), "$(['node', 'node', 'node'])" )
	child: -> i = 0; d = $("<div><a></a><b></b><c></c></div>"); $.assertEqual( d.select('childNodes').flatten().map( () -> d.child(i++) ).toRepr(), "$([$([<a/>]), $([<b/>]), $([<c/>])])")
	child2: -> $.assertEqual($("tr").child(0).select('nodeName').toRepr(), "$(['TD', 'TD', 'TD', 'TD'])")
	textData: ->
		d = $("<div>&nbsp;</div>")
		$.assertEqual( d.toRepr(), "$([<div>&nbsp;</div>])" )
		t = d.child(0)
		$.assertEqual( t.toRepr(), "$([&nbsp;])")
		t.zap('data', '<p>')
		$.assertEqual( d.select('innerHTML').first(), '&lt;p&gt;' )
	escape: -> $.assertEqual($.HTML.escape("<p>"), "&lt;p&gt;")
	dashName1: -> $.assertEqual($.dashize("fooBar"), "foo-bar")
	dashName2: -> $.assertEqual($.dashize("FooBar"), "-foo-bar")
	html: -> $.assertEqual($("tr").html().first(), "<td>1,1</td><td>1,2</td>")
	append: ->
		try
			$.assertEqual($("tr td.d").append("<span>Hi</span>").html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	appendTo1:-> $.assertEqual($("<span>Hi</span>").toRepr(), "$([<span>Hi</span>])")
	appendTo2:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").toRepr(), "$([<span>Hi</span>])")
		finally
			$("tr td.d span").remove()
	appendTo3:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').toRepr(), '$([<td class="d">3,2<span>Hi</span></td>])')
		finally
			$("tr td.d span").remove()
	appendTo4:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	prepend: ->
		try
			$.assertEqual($("tr td.d").prepend("<span>Hi</span>").html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	prependTo: ->
		try
			$.assertEqual($("<span>Hi</span>").prependTo("tr td.d").select('parentNode').html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	before: -> $.assertEqual($("<a><b></b></a>").find("b").before("<c></c>").select('parentNode').toRepr(), "$([<a><c/><b/></a>])")
	after1: -> $.assertEqual($("<a><b></b></a>").find("b").after("<c></c>").select('parentNode').toRepr(), "$([<a><b/><c/></a>])")
	after2: -> $.assertEqual($("<b></b>").after("<c></c>").select('parentNode').toRepr(), "$([<b/><c/>])")
	wrap: -> $.assertEqual($("<b></b>").wrap("<a></a>").select('parentNode').toRepr(), "$([<a><b/></a>])")
	unwrap: -> $.assertEqual($("<a><b/></a>").find("b").unwrap().first().parentNode, null)
	replace: -> $.assertEqual($("<a><b/><c/><b/></a>").find("b").replace("<p/>").eq(0).select('parentNode').toRepr(), "$([<a><p/><c/><p/></a>])")
	removeClass: -> $.assertEqual($("<a class='test'></a>").removeClass('test').toRepr(), "$([<a/>])")
	removeClass2: -> $.assertEqual($("<a></a>").removeClass('test').toRepr(), "$([<a/>])")
	addClass: -> $.assertEqual($("<a></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	addClass2: -> $.assertEqual($("<a class='test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	addClass3: -> $.assertEqual($("<a class='test test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	toggleClass: -> $.assertEqual($("<a class='on'></a>").toggleClass("on").toRepr(), "$([<a/>])")
	toggleClass2: -> $.assertEqual($("<a class='off'></a>").toggleClass("on").toRepr(), '$([<a class="off on"/>])')
	toggleClass3: -> $.assertEqual($("<a class=''></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	toggleClass4: -> $.assertEqual($("<a></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	hasClass: -> $.assertEqual($("<a class='foo'></a>").hasClass("foo").first(), true)
	hasClass2: -> $.assertEqual($("<a class='bar'></a>").hasClass("foo").first(), false)
	text1: -> $.assertEqual($("<a>Hello<b>World</b></a>").select('innerText').toRepr(), "$(['HelloWorld'])")
	text3: -> $.assertEqual($("<a>Hello<b>World</b></a>").text().toRepr(), "$(['HelloWorld'])")
	text2: -> $.assertEqual($("<a>Hello<b>World</b></a>").text("Goodbye").toRepr(), "$([<a>Goodbye</a>])")
	value1: -> $.assertEqual($("<input type='text' value='foo'/>").val().toRepr(), "$(['foo'])")
	value2: -> $.assertEqual($("<input />").val().toRepr(), "$([''])")
	value3: -> $.assertEqual($("<input type='checkbox' checked />").val().toRepr(), "$(['on'])")
	parents: -> $.assertEqual($("td.d").parents().first().select('nodeName').toRepr(), "$(['TR', 'TABLE', 'BODY', 'HTML'])")
	prev: -> $.assertEqual($("div.c").prev().first().select('nodeName').toRepr(), "$(['TABLE'])")
	next: -> $.assertEqual($("div.c").next().first().select('nodeName').toRepr(), "$(['P'])")
	remove: ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
		b = a.find(".x")
			.assertEqual(2, -> @length)
			.assertEqual("$(['B', 'C'])", -> @select('nodeName').toRepr())
			.remove()
			.assertEqual("$([null, null])", -> @select('parentNode').toRepr() )
		$.assertEqual a.toRepr(), '$([<a><d/></a>])'
	find: ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
			.find(".x")
			.assertEqual(2, -> @length)
			.assertEqual("$(['B', 'C'])", -> @select('nodeName').toRepr())
	clone: ->
		c = $("div.c").clone()[0]
		d = $("div.c")[0]
		c.a = "magic"
		$.assertEqual( typeof d.a, "undefined")
		$.assertEqual( typeof c.a, "string")
	toFragment: ->
		$.assertEqual($("td").clone().toFragment().childNodes.length, 8)
)

$.testGroup "EventEmitter",
	basic: ->
		v = null
		$().on("change", (data) -> v = data)
			.emit("change", "foo")
		$.assertEqual v, "foo"

$.testGroup "Date",
	stamp: ->
		$.assert $.date.stamp(new Date(1000000), "ms") is 1000000
	stamp_sec: ->
		$.assert $.date.stamp(new Date(1000000), "s") is 1000
	unstamp: ->
		d1 = new Date(1000000)
		d2 = $.date.unstamp $.date.stamp d1
		$.assert d1.toString() is d2.toString()
	convert: ->
		$.assert $.date.convert(1000000, "ms", "s") is 1000
	midnight: ->
		d2 = $.date.unstamp $.date.midnight new Date 1000000000
		$.assert d2.toString().indexOf("19:00:00 GMT-0500") > -1
	format: ->
		d1 = new Date(1000000000)
		d2 = new Date(1000000)
		$.assertEqual $.date.format(d1, "yyyy-mm-dd HH:MM:SS"), "1970-01-12 13:46:40"
		$.assertEqual $.date.format(d2, "yyyy-mm-dd HH:MM:SS"), "1970-01-01 00:16:40"
	parse: ->
		$.assert $.date.parse("1970-01-12 13:46:40", "yyyy-mm-dd HH:MM:SS", "ms") is 1000000000
	range: ->
		$.assertEqual $($.date.range(1000, 1000000, 3, "dd", "s"))
			.unstamp("s")
			.select("getDate").call()
			.ints().sum(), 61
	chain_format: ->
		$.assertEqual $($.date.range 1000, 1000000, 3, "dd", "s")
			.dateFormat("dd", "s")
			.ints()
			.sum(), 35
	chain_midnight: ->
		$.assertEqual $($.date.range 1000, 1000000, 3, "dd", "s")
			.midnight("s")
			.dateFormat("HHMMSS", "s")
			.ints()
			.sum(), 0


$.testGroup "TNET",
	basic: ->
		obj = $.TNET.parse $.TNET.stringify a:1,b:[2,3]
		$.assert obj.a is 1, "1"
		$.assert obj.b[0] is 2, "2"
		$.assert obj.b[1] is 3, "3"
	basic2: ->
		a = $()

require("coffee-script")
dom = require("jldom")
dom.registerGlobals(global)
global.document = dom.createDocument()
global.window = global
require("../dist/bling.js")

$.testGroup "Test Internals",
	true: -> true
	trueFail: (cb) -> cb true
	trueAsync: (cb) -> setTimeout (-> cb false), 100
	trueAsyncFail: (cb) -> setTimeout (-> cb true), 200
	assert: -> $.assert true, "this will not display"
	asyncFail: (callback) ->
		setTimeout (->callback new Error("delayed error")), 500
	assertFail: (cb) ->
		$.assert false, "this will throw an exception, but is expected"
	async1: (callback) ->
		setTimeout (-> callback false), 300
	asyncDepends: (callback) ->
		$.depends 'async1', -> callback false

require "./common"

$.depends "math, random, unittest", ->
	$.testGroup "random",
		coin: ->
			$.assert $.approx $($.random.coin() for _ in [0...1000]).mean(), .5, .05
		ints: ->
			$.assert $.approx $($.random.int(0,10) for _ in [0...20000]).mean(), 5, .7
		gauss: ->
			$.assert $.approx $($.random.gaussian() for _ in [0...1000]).mean(), .5


common = require('./common')

testGroup("StateMachine",
	hello: ->
		class TestMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: ->
						@output = "<"
						@GO(1)
				}
					def: (c) -> @output += c.toUpperCase()
					eof: @GO(2)
				}
					enter: -> @output += ">"
				}
			]
			constructor: ->
				super(TestMachine.STATE_TABLE)
				@output = ""
		m = new TestMachine()
		assertEqual(m.run("hello").output, "<HELLO>")
		assertEqual(m.run("hi").output, "<HI>")
)

testGroup("Synth",
	basic_node: -> assertEqual($.synth("style").toString(), "$([<style/>])")
	class_node: -> assertEqual($.synth('style.specClass').toString(), '$([<style class="specClass"/>])')
	attr_node: -> assertEqual($.synth('style[foo=bar]').toString(), '$([<style foo="bar"/>])')
	text: -> assertEqual($.synth("style 'text'").toString(), "$([<style>text</style>])")
	entity1: -> assertEqual($.synth("style 'text&amp;stuff'").toString(), "$([<style>text&amp;stuff</style>])")
	entity2: -> assertEqual($.synth("style 'text&stuff'").toString(), "$([<style>text&stuff</style>])")
)

testReport()

global.assert = (c, msg) ->
	if not c
		throw Error msg
global.assertEqual = (a, b, label) ->
	if a != b
global.assertArrayEqual = (a, b, label) ->
	for i in [0...a.length]
		try
			assertEqual(a[i], b[i], label)
		catch err

UI =
		output: (a...) -> console.log.apply console, a
		red: ""
		green: ""
		yellow: ""
		normal: ""
		output: (a...) -> console.log.apply console, a
		red: "[0;31;40m"
		green: "[0;32;40m"
		yellow: "[0;33;40m"
		normal: "[0;37;40m"
		output: (a...) -> document.write a.join(' ')+"<br>"
		red: "<font color='red'>"
		green: "<font color='green'>"
		yellow: "<font color='yellow'>"
		normal: "</font>"

global.ui = switch process?.env.TERM
	when "dumb" then UI.dumb
	when undefined then UI.html
	else UI.cterm

argv = process?.argv
if argv and argv.length > 2
	test_to_run = argv[2]
else
	test_to_run = "*"

total = [0,0,0]
failures = []
global.testGroup = (name, tests) ->
	failed = passed = 0
	for test_name of tests
		if test_to_run in ["*", test_name, name]
			test = tests[test_name]
			total[0] += 1
			try
				if test_to_run isnt "*"
					console.log "Running test:"
					console.log test.toString()
				test()
				passed += 1
				total[1] += 1
			catch err
				failed += 1
				total[2] += 1
				failures.push(test_name)
				if test_to_run isnt "*"
					throw err
global.testReport = () ->

testGroup("Testing Framework"
	pass: () -> true
)
require "./common"
{config} = require("../../common")
baseUrl = config.get "MPATH_URL", "http://localhost:8080"

testGroup "Client",
	init: ->
		driver = require("../index").init baseUrl
		assert typeof driver.createApiKey is "function"
	api: ->
		driver = require("../index").init baseUrl
		assert typeof driver.createApiKey is "function"
		driver.createApiKey "jesse@conductrics.com", null, (err, json) ->
			throw err if err
			assert "key" of json
			assert "owner" of json
			apikey = json.key
			ownerCode = json.owner
			sessionCode = $.random.string(16)
			driver.getDecisions apikey, sessionCode, ownerCode, "agent-1", "point-1", (err, json) ->
				throw err if err
				
		
	
require "bling"
async = require 'async'
Tags = require './agent-tags'
Expire = require './expire'
History = require './history'
Schemas = require './schemas'
Learning = require './learning'
Validate = require './validate'
Agent = require './agent'
{mongo} = require './connections'
Accessors = module.exports


Accessors.createApiKey = (owner, email, callback, adminKey = "admin_" + $.random.string 26) ->
	masterKey =
		code: adminKey
		owner: owner
		email: email
		password: $.random.string 8
		active: true
		created: $.now
		mappings:
			"@":
				"access":
					"report:*": true
					"manage:*": true
			"*":
				"access":
					"report:*" : true
					"manage:*" : true
	slaveKey =
		code: "api-" + $.random.string 24
		owner: owner
		email: email
		active: true
		created: $.now
		mappings:
			"@":
				"access": {}
			"*":
				"access":
					"runtime:*" : true
	
	mongo.apikeys.find { owner: owner, email: email }, (err, result) ->
		return callback err if err
		if result? and result.length > 0
			$.assertEqual result.length, 2, "should be exactly zero or two keys for any given email"
			if "password" of result[0]
				[masterKey, slaveKey] = result
			else
				[slaveKey, masterKey] = result
			return callback false, $.log 'apikey already existed:',
				key: slaveKey.code
				owner: masterKey.owner
				password: masterKey.password
		mongo.apikeys.insert masterKey, {safe:true}, (err) ->
			return callback err if err
			mongo.apikeys.insert slaveKey, {safe:true}, (err) ->
				return callback err if err
				callback false, $.log 'apikey created:',
					key: slaveKey.code
					owner: masterKey.owner
					password: masterKey.password

Accessors.getAgents = (owner, codes, props, callback) ->
	iterator = (code, cb) -> Accessors.getAgent owner, code, props, cb
	async.mapSeries codes, iterator, callback

Accessors.getAgent = (owner, code, props, callback, count = 0) ->
	Accessors.getAgentRecord owner, code, (err, agent) ->
		return callback err if err
			return autoMutate agent, props, (err) ->
				return callback err if err
				mongo.agents_view.findOne {owner, code}, (err, runtimeAgent) ->
					return callback err if err
					process.nextTick ->
						historyDate = if isFinite(parseInt(props.ts)) then parseInt(props.ts) else $.date.stamp()
						History.updateHistoryOnDateChange runtimeAgent, historyDate, (err) ->
							if err then $.log "Error updating history on date change:", err
					$.delay 2, ->
						autoExpireSessions runtimeAgent

		return callback(false, null) if count > 0

		Validate.isAgent owner, code, agent, (err) ->
			return callback err if err
			Accessors.putAgent agent, (err) ->
				return callback err if err

autoMutate = (agent, props, callback) ->

	if props.goal?
		existingGoal = goal for goal in agent.goals when goal.code is props.goal
		unless existingGoal?
			if Validate.isIdentifier props.goal
				agent.goals.push {code:props.goal}

		existingSegment = null
		if agent.targeting?.segments
			existingSegment = seg for seg in agent.targeting.segments when seg.code is props.segment
		unless existingSegment?
			if Validate.isIdentifier props.segment
				agent.targeting ?= {}
				agent.targeting.segments ?= []
				agent.targeting.segments.push {code:props.segment}

	if props.features?
		for feature in props.features
			feature = feature.split(':')[0]
			existingFeature = null
			if agent.targeting?.features
				existingFeature = fea for fea in agent.targeting.features when fea.code is feature
			unless existingFeature?
					agent.targeting ?= {}
					agent.targeting.features ?= []
					agent.targeting.features.push {code: feature}
					agent.targeting.usesFeatures = true

	existingPoint = null
	if props.point?
		existingPoint = point for point in agent.points when point.code is props.point
		unless existingPoint?
			if Validate.isIdentifier props.point
				intuited = intuitDecisions(props.options)
				decisions = []; decisions.push {code:decisionCode, choices:decisionOptions} for decisionCode,decisionOptions of intuited
				agent.points.push {
					code:props.point
					decisions:decisions
				}

	if props.options?
		pointCode = props.point ? 'point-1'
		point = point for point in agent.points when point.code is props.point
		if point?
			knownDecs = {}; knownDecs[dec.code] = dec for dec in point.decisions
			intuited = intuitDecisions props.options
			for decisionCode,decisionOptions of intuited
				if knownDecs[decisionCode]?
					knownOpts = {}; knownOpts[opt.code] = opt for opt in knownDecs[decisionCode].choices
					for opt in decisionOptions
						unless knownOpts[opt.code]?
							knownDecs[decisionCode].choices.push opt
				else
					point.decisions.push
						code: decisionCode
						choices: decisionOptions

	return callback(false) unless changes.length > 0

	Validate.isAgent agent.owner, agent.code, agent, (validationErr, agent) ->
		$.log "Mutated agent validation error:", validationErr if validationErr
		return callback "Mutated agent did not validate" if validationErr
		Accessors.putAgent agent, (err) ->
			return callback(err) if err


Accessors.newAgent = (owner, code, props) ->
	template = $.extend Accessors.getAgentTemplate(owner)
	template.owner = owner
	template.code = code
	template.created = $.date.stamp()

	intuited = intuitDecisions(props.options)
	decisions = []; decisions.push {code:decisionCode, choices:decisionOptions} for decisionCode,decisionOptions of intuited
	template.points[0].decisions = decisions

	return template

Accessors.getAgentTemplate = (owner) ->
	template =
		'goals' : [
			'code': 'goal-1'
		],
		'points' : [
			'code': 'point-1'
			'decisions' : [
				'code' : 'decision-1'
			]
		]
	return template

intuitDecisions = (choices) ->
	result = {}
	chunks = (choices ? "a,b").split("/")
	for chunk,i in chunks
		parts = chunk.split(":")
		result[decisionCode] = intuitOptions parts[0]
	return result

intuitOptions = (choices) ->
	result = []
	choices ?= "a,b"
		parts = choices.split(',')
		if parts.length is 1
		if parts.length > 1
			for part in parts
				result.push {'code': part.toString()}
	return result

Accessors.getAgentRecord = (owner, code, callback) ->
	mongo.agents.findOne {owner, code}, callback

Accessors.putAgent = (agent, callback) ->
	query = {owner:agent.owner, code:agent.code}
	Schemas.toRuntimeStyle agent, (err, runtime) ->
		return callback err if err
		Tags.detectTags agent, runtime, false, (err) ->
			return callback err if err
			mongo.agents.update query, agent, {upsert:true, safe:true}, (err) ->
				return callback err if err
				mongo.agents_view.update query, runtime, {upsert:true, safe:true}, (err, data) ->
					return callback err if err
					Accessors.afterAgentPut(runtime)

Accessors.afterAgentPut = (agent) ->
	Schemas.applyTargeting agent, (err, agent) ->
		return callback err if err
		Accessors.ensureLearningRecords agent

Accessors.deleteAgentData = (agent, callback) ->
	History.removeAgentHistory agent, (err) ->
		return callback err if err
		mongo.sessions.remove {agent:agent.code, owner:agent.owner}, (err) ->
			return callback err if err
			exports.resetLearningRecords agent, (err) ->
				return callback err if err

Accessors.deleteAgent = (agent, callback) ->
	exports.deleteAgentData agent, (err) ->
		return callback err if err
		mongo.agents_view.remove {code:agent.code, owner:agent.owner}, (err) ->
			return callback err if err
			mongo.learning.remove {agent:agent.code, owner:agent.owner}, (err) ->
				return callback err if err
				mongo.agents.remove {code:agent.code, owner:agent.owner}, (err) ->
					return callback err if err

Accessors.getAgentList = (owner, callback) ->
	query = {owner}
	options = {"sort": [['name', 'asc'], ['code', 'asc']]}
	fields = {code:1, name:1, tags:1, created:1}
	mongo.agents.findItems query, fields, options, (err, data) ->
		return callback err if err
		$(data).clean '_id'
		callback false, data


Accessors.getApiKey = (code, owner, callback) ->
	query = {code, owner, active:true}
	mongo.apikeys.findOne query, (err, data) ->
		return callback err if err
		callback false, data

Accessors.getApiKeys = (owner, callback) ->
	query = {owner}
	mongo.apikeys.findItems query, (err, items) ->
		return callback err if err
		callback false, items

Accessors.getSession = (code, agent, mustBeActive, callback) ->
	query = {agent: agent.code, owner: agent.owner, code: code}
	query.status = 1 if mustBeActive

	mongo.sessions.findOne query, (err, sess) ->
		return callback err if err
		if sess?
			sess.ts = $.date.stamp()
			return callback(null, sess)
		sess = Accessors.newSession(agent, code)
		sess.isControl = $.random.coin agent.learning.controlGroupRate
		callback(null, sess)
		History.updateHistoryOnSessionStart(sess, agent)

Accessors.getSessionsToExpire = (agent, itemCallback) ->
	query =
		agent: agent.code
		owner: agent.owner
		status:
		ts:
	mongo.sessions.findEach query, {}, itemCallback

autoExpireSessions = $.throttle 10000, (agent) ->
	Accessors.getSessionsToExpire agent, (err, sess) ->
		return callback err if err
		Expire.handleExpiration(agent, sess) if sess

Accessors.newSession = (agent, code) -> {
	code: code
	agent: agent.code
	owner: agent.owner
	numdec: 0
	reward: 0
	goals: []
	targ: {seg: '(none)'}
	ts: $.date.stamp()
}

Accessors.sessionPut = (sess, agent, callback) ->
	query = {code:sess.code, agent:agent.code, owner:agent.owner}
	mongo.sessions.update query, sess, {upsert:true}, (err) ->

Accessors.getBest = (agent, decpoint, seg, callback) ->
	query = {
		agent: agent.code
		owner: agent.owner
		point: decpoint.code
		seg: seg
	}
	options = {"sort": [
		['val', 'desc'],
		['ts', 'asc']


	mongo.learning.findItems query, {decision:1}, options, (err, items) ->
		return callback err if err
		if items.length > 0
			pairs = items[0].decision.split(',')
			pairs.forEach (pair) ->
				parts = pair.split(':')
				choices[ parts[0] ] = parts[1]
		for item in items
			choices[item.decision] ?= decpoint.decisions[item.decision].choices[item.choice]
		callback(null, choices)

Accessors.updateOnTransition = (sess, agent, callback) ->
	Learning.updateLearningOnTransition sess, agent
		return callback err if err
	History.updateSimpleLift sess, agent, 'decision', (err) -> 
		return callback err if err
		History.updateHistoryOnSessionEnd(sess, agent)
	else
		sess.reward = 0

	Accessors.sessionPut sess, agent, (err) ->
		return callback err 

Accessors.updateOnGoal = (sess, agent, goalItem, callback) ->
	query = code: sess.code, agent: agent.code, owner: agent.owner
	update =
		'$inc':
			reward: goalItem.val
		'$push':
			goals: goalItem
		'$set':
		 	ts: sess.ts
	mongo.sessions.update query, update, (err) ->
		return callback(err) if err
		History.updateHistoryOnGoal sess, agent, callback
			returnc callback err if err 
		History.updateSimpleLift sess, agent, 'goal', (err) -> 
			return callback err if err

Accessors.updateOnExperience = (sess, agent, callback) ->
	return callback(false) if sess.isControl
	updateLearningExperience(sess, agent, 'current', callback)

updateLearningExperience = (session, agent, whichState, callback) ->
	query = getRelevantLearningRecordsCriteria(session, agent, whichState)
	update =
	mongo.learning.update query, update, {multi:true}, callback

Accessors.updateLearningScore = (session, agent, whichState, learned, callback) ->
	query = getRelevantLearningRecordsCriteria(session, agent, whichState)
	update = {
	}
	mongo.learning.update query, update, {multi:true}, (err) ->
		return callback err if err

Accessors.updateLearningScoreOne = (session, agent, learningRecord, learned, callback) ->
	query = {_id:learningRecord._id}
	update = {
	}
	mongo.learning.update query, update, {multi:false}, (err) ->
		return callback err if err

Accessors.ensureLearningRecords = (agent) ->
	for pointCode of agent.points
		choices = Agent.getSetsOfChoices(agent, pointCode)


		$(choices).each (item) ->
			decision = item

			if agent.targeting.usesFeatures
				features.push f.code for f in agent.targeting.features when features.indexOf(f.code) is -1

			for featureCode in features
				for segment in agent.targeting.segments
					Accessors.ensureLearningRecord(
						agent:agent.code
						owner:agent.owner
						decision:decision.join(',')
						point:pointCode
						seg:segment.code
						feature:featureCode
					)
	return null

Accessors.ensureLearningRecord = (fields) ->
	update =
		"$inc": {"exp":0, "val":0, "ts":0}
	mongo.learning.update fields, update, {upsert:true, multi:false, safe: true}, (err) ->
		return callback err if err

Accessors.resetLearningRecords = (agent, callback) ->
	query = owner:agent.owner, agent:agent.code
	update =
		"$set": {ts: $.date.stamp(), val:0, exp:0}
	mongo.learning.update query, update, {multi:true}, callback

Accessors.getRelevantLearningRecords = (session, agent, whichState, selectedChoicesOnly = true, callback) ->
	query = getRelevantLearningRecordsCriteria(session, agent, whichState, selectedChoicesOnly)
	return callback(false, []) unless query?
	mongo.learning.findItems query, callback

Accessors.getTransforms = (ownerCode, codes, callback) ->
	query = owner: ownerCode
	query.code = {'$in': codes} if codes?
	options =
		'sort': [['order', 'asc']]
	mongo.transforms.findItems query, options, callback

Accessors.getTransformRules = (ownerCode, agentCode, callback) ->
	query =
		owner: ownerCode
	options =
		'sort': [['order', 'asc']]
	mongo.transforms.findItems query, options, callback

Accessors.putTransformRule = (ownerCode, rule, callback) ->
	Validate.isTransform ownerCode, rule, (err, rule) ->
		return callback err if err
		query =
			owner:rule.owner
			code:rule.code
		mongo.transforms.update query, rule, {upsert:true}, (err) ->
			return callback err if err
			callback false, rule

Accessors.removeTransformRule = (ownerCode, ruleCode, callback) ->
	query =
		owner:ownerCode
		code:ruleCode
	mongo.transforms.remove query, callback

Accessors.transformsLookup = (owner, ns, key, callback) ->
	query = {owner, ns, key}
	mongo.transformsLookups.findOne query, (err, item) ->
		return callback err if err
		return callback false, null unless item.data
		return callback false, item.data

Accessors.transformLookupsCount = (owner, ns, callback) ->
	query = {owner, ns}
	mongo.transformsLookups.count query, callback

Accessors.transformsLookupPut = (owner, ns, keyField, data, callback) ->
	key = data[keyField]
	query = { owner, ns, key }
	update = { owner, ns, key, data }
	mongo.transformsLookups.update query, update, {safe:true, upsert:true}, callback

Accessors.transformLookupProviderPut = (providerItem, callback) ->
	query = {owner:providerItem.owner, ns:providerItem.ns}
	mongo.transformsLookupProviders.update query, providerItem, {safe:true, upsert:true}, callback

getRelevantLearningRecordsCriteria = (session, agent, whichState, selectedChoicesOnly = true) ->
	state = session.states[whichState]
	return null unless state?
	query =
		agent: agent.code
		owner: agent.owner
		point: state.point
		seg: state.segment
	if selectedChoicesOnly
		query.decision = {"$in": state.choice }
	if agent.targeting.usesFeatures and state.features
		features = Object.keys(state.features).concat(['(none)'])
		query.feature = {"$in" : features}
	return query

$.subscribe "app-start", ->
	rootkey = $.config.get "MPATH_APIKEY"
	$.assert rootkey?, "MPATH_APIKEY must be set in your environment"
	$.log "Creating root apikey..."
	mongo.apikeys.remove { owner: "mpath-signup" }, ->
		Accessors.createApiKey "mpath-signup",
			"signup@conductrics.com",
			(->),
			rootkey

if require.main is module
	x = intuitDecisions "a,b/c,d"
	$.log JSON.stringify x
exports.detectTags = (agent, runtime, keepExisting, callback) ->
	return callback "No agent object" unless agent?
	return callback "No runtime agent" unless runtime?
	agent.tags = [] unless keepExisting
	exports.addTag agent, 'redirect' if exports.detectRedirects(agent)
	exports.addTag agent, 'features' if runtime.targeting.usesFeatures
	exports.addTag agent, 'segments' if runtime.targeting.segments?.length > 1
	exports.addTag agent, 'testing' if runtime.learning.explorationRate is 1
	exports.addTag agent, 'adaptive' unless runtime.learning.explorationRate is 1

exports.addTag = (agent, tag) ->
	tags = agent.tags ? []
	agent.tags = tags

exports.detectRedirects = (agent) ->
	hasOptionRedirect = false
	for point in agent.points
		for decision in point.decisions
			hasOptionRedirect = true for choice in decision.choices when choice.data?['redirect-url']?
	hasGoalRedirect = true for goal in agent.goals when goal.data?['redirect-url']?
	return hasGoalRedirect or hasOptionRedirectAccessors = require './accessors'
Schemas = require './schemas'
Validate = require './validate'
Auth = require './auth'

exports.get = Auth.ensureAuthorized "manage:agent:get", (req, res) ->
	Accessors.getAgentRecord req.params.owner, req.params.agent, (err, agent) ->
		return res.endWithNotFound() unless agent?
		return res.endWithJson 200, agent unless req.query.runtime is 'true'
		Accessors.getAgent req.params.owner, req.params.agent, {}, (err, agent) ->
			return res.endWithNotFound() unless agent?
			res.endWithJson 200, agent

exports.put = Auth.ensureDotAuthorized "manage:agent:put", (req, res) ->
	Validate.isAgent req.params.owner, req.params.agent, req.body, (validationErr, agent) ->
		return res.endWithJson(400, {error:validationErr}) if validationErr
		Accessors.putAgent agent, (err) ->
			return res.endWithJson(501, {error:err}) if err
			res.endWithJson(200, agent)

exports.list = Auth.ensureDotAuthorized "manage:agent:list", (req, res) ->
	Accessors.getAgentList req.params.owner, (err, items) ->
		return res.endWithJson(501, {error:err}) if err
		res.endWithJson	200,
			data:
				agents:items

exports.refresh = Auth.ensureDotAuthorized "manage:agent:put", (req, res) ->
	Accessors.getAgentRecord req.params.owner, req.params.agent, (err, agentRecord) ->
		return res.endWithJson(501, {error:err}) if err
		Accessors.putAgent agentRecord, (err) ->
			return res.endWithJson(501, {error:err}) if err
			res.endWithJson(200, {success:true})

exports.delete = Auth.ensureAuthorized "manage:agent:delete", (req, res) ->
	Accessors.getAgentRecord req.params.owner, req.params.agent, (err, agent) ->
		return res.endWithNotFound() unless agent?
		Accessors.deleteAgent agent, (err) ->
			res.endWithJson(200, {success:true})

exports.delete_data = Auth.ensureAuthorized "manage:agent:delete", (req, res) ->
	Accessors.getAgentRecord req.params.owner, req.params.agent, (err, agent) ->
		return res.endWithNotFound() unless agent?
		Accessors.deleteAgentData agent, (err) ->
			res.endWithJson(200, {success:true})

exports.getAgentSchema = (req, res) ->
	res.endWithJson 200, Schemas.agentSchema

exports.hasTag = (agent, tag) ->
	return agent.tags?.indexOf(tag) > -1

exports.getSegmentCodes = (agent) ->
	result = []
	result.push(item.code) for item in agent.targeting.segments

exports.getFeatureCodes = (agent) ->
	result = []
	result.push(item.code) for item in agent.targeting.features
	return result

exports.blessFeatureCodes = (agent, features, groupSeparator) ->
	codes = exports.getFeatureCodes(agent)
	features = features.split(",") if features.split?
	result = []
	for item,i in features
	if groupSeparator?
		for item,i in features
			parts = item.split(groupSeparator)
			if parts.length > 0
				codez = []
				for part in parts
	for item in features
	return result

exports.getDefaultDecisionForPoint = (decpoint) ->
	choices = {}
	for decisionCode of decpoint.decisions
	return choices

exports.getDefaultDecisionForPointAsString = (decpoint) ->
	choices = exports.getDefaultDecisionForPoint decpoint
	result = []
	for code in decisionCodes
	return result.join(',')

exports.numActiveFeatures = (agent) ->

exports.numActivePoints = (agent) ->

exports.isMultiState = (agent) ->
	return exports.numActivePoints(agent) > 1

exports.getSetsOfChoices = (agent, pointCode) ->
	throw "getSetsOfChoices - no pointCode" unless pointCode?
	ret = []
	for code,point of agent.points
		if (point.code is pointCode)
			for code,decision of point.decisions
				set = []
				for code,choice of decision.choices
				ret.push set if set.length > 0
	result = $.cartesian(ret...).toArray()		
	return resultconsole.log 'Importing modules...'
require 'bling'
connect = require 'connect'
request = require 'request'
fs = require 'fs'
Decision = require './decision'
Reward = require './reward'
Expire = require './expire'
Agent = require './agent'
Owner = require './owner'
Reports = require './reports'
Recurly = require './recurly'
Deco = require './decorators'

serverPort = +$.config.get 'PORT', '80'
env = $.config.get 'NODE_ENV', 'development'

$.log "Connecting error handler..."
process.on 'uncaughtException', (err) ->

$.log "Creating server..."
serverReady = false
$.depends 'geoip-files', ->
	serverReady = true
server = connect.createServer()
	.use (req, res, next) ->
		if not serverReady
			return next new Error "Service Not Ready"
		next()
	.use(connect.logger("dev"))
		req.rawBody = ''
		req.on 'data', (chunk) ->
			req.rawBody += chunk
		next()
	)
	.use(connect.bodyParser())
	.use(connect.errorHandler())
	.use(connect.router (app) ->

		app.options "*", (req, res) ->
			allowHeaders = ['X-Requested-With', 'Content-Type', 'Accept']
			if req.headers['access-control-request-headers']
				for name in req.headers['access-control-request-headers'].split(/, */)

			res.writeHead '200',
				'Access-Control-Allow-Credentials': false,
				'Access-Control-Allow-Headers': allowHeaders.join(', ')
			res.end()

		$('get,post,put,delete'.split ',').each (n) ->
			orig = app[n]
			app[n] = (a...) ->
				if $.is "function", a[1] then a[1] = Deco.routeHandler a[1]
				try orig.apply app, a
				catch err
					$.log "FAILED:", err

		app.get "/:owner/:agent/decision", Decision.decision
		app.get "/:owner/:agent/decisions", Decision.decisions
		app.get "/:owner/:agent/decision/*", Decision.decision
		app.get "/:owner/:agent/decisions/*", Decision.decisions
		app.post "/:owner/:agent/goal/:goal?", Reward.goal
		app.get "/:owner/:agent/expire", Expire.get

		app.put "/:owner/create-key/:email", Owner.createApiKey
		app.get "/:owner/list-apikeys", Owner.listApiKeys
		app.get "/login", Owner.loginRoute
		app.get "/:owner/login", Owner.loginRoute
		app.get "/:owner/transforms-list", Owner.transformsList
		app.post "/:owner/transforms-test", Owner.transformsTest
		app.post "/:owner/transform-rule", Owner.transformPut
		app.delete "/:owner/transform-rule/:code", Owner.transformDelete
		app.get "/:owner/transforms-options", Owner.transformsOptions
		app.get "/:owner/list-agents", Agent.list
		app.get "/:owner/schema/agent", Agent.getAgentSchema
		app.get "/:owner/:agent", Agent.get
		app.get "/:owner/:agent/refresh", Agent.refresh
		app.put "/:owner/:agent", Agent.put
		app.delete "/:owner/:agent/data", Agent.delete_data
		app.delete "/:owner/:agent", Agent.delete

		app.get "/:owner/:agent/report/impact/:dateFrom/:dateThru?", Reports.impactReportData
		app.get "/:owner/:agent/report/confidence/:dateFrom/:dateThru?", Reports.decisionConfidenceReportData
		app.get "/:owner/:agent/report/learning/:dateFrom/:dateThru?", Reports.learnedValuesReportData
		app.get "/:owner/:agent/report/magic-quad/:dateFrom/:dateThru?", Reports.magicQuadReportData
		app.get "/:owner/report/status", Reports.statusReportData

		app.post "/test/json", (req, res) ->
			res.write JSON.stringify req.body
			res.end()
		app.post "/recurly", (req, res) -> req.on 'end', -> Recurly.POST(req, res)
		app.get "/error", (req, res) -> process.nextTick -> throw new Error("oops!")
		null
	)
	.listen(serverPort)


$.subscribe "app-start", ->
	geoFiles = ["GeoIPDomain.dat", "GeoIPOrg.dat", "GeoLiteCity.dat", "timezone.txt", "conductrics-usa-census.csv"]
	$.depends geoFiles, ->
		$.log "All geo files downloaded."
		$.provide "geoip-files"
	for file in geoFiles
		do (file) ->
			fs.exists outputPath, (exists) ->
				if exists
					return $.provide file
					$.provide file
				).pipe fs.createWriteStream outputPath

$.publish "app-start", server
require 'bling'
Accessors = require './accessors'
Auth = exports

Auth.isAuthorized = (apikey, owner, agentCode, perm, callback) ->
	Accessors.getApiKey apikey, owner, (err, record) ->
		return callback(err, false) if err
		callback false, switch true
			when not record? then null
			when not agentCode of record.mappings then false
			else Auth.resolveIsAuthorized record, agentCode, perm

Auth.resolveIsAuthorized = (keyRecord, agentCode, perm) ->
	if $.is "array", perm
		return ({perm,authorized:Auth.resolveIsAuthorized(keyRecord,agentCode,p)} for p in perm)

	flag = keyRecord.mappings[agentCode]?.access[perm]
	starFlag = keyRecord.mappings[agentCode]?.access[starPerm]
		return !!flag if flag?
		return !!starFlag if starFlag?
	return false

Auth.ensureAuthorized = (perm, func) ->
	(req, res) ->
		apikey = req.getApiKey()
		owner = req.getMpathParam('owner')
		agent = req.getMpathParam('agent')
		Auth.isAuthorized apikey, owner, agent, perm, (err, authorized) ->
			return res.endWithError(err) if err
			return res.endWithNotAuthorized() if not authorized
			return func(req, res)

Auth.ensureDotAuthorized = (perm, func) ->
	(req, res) ->
		apikey = req.getApiKey()
		owner = req.getMpathParam('owner')
		agent = '@'
		Auth.isAuthorized apikey, owner, agent, perm, (err, authorized) ->
			return res.endWithError(err) if err
			return res.endWithNotAuthorized() if not authorized
			return func(req, res)
require 'bling'
pm = require '../passive-models'

hub = pm.Hub.connect('redis://localhost:6379').on 'ready', ->
	first = count = 0
	while count < 50000
		first or= $.now
		count += 1
		hub.publish 'benchmark', ts: $.now
		if count % 1000 is 0
			$.log (count*1000/($.now - first)).toFixed(4), "publishes per second"

require 'bling'
pm = require '../passive-models'

hub = pm.Hub.connect("redis://localhost:6379").on 'ready', (hub) ->
	first = count = 0
	hub.subscribe 'benchmark', (message) ->
		first or= $.now
		count += 1
		delta = $.now - message.ts
		console.log (count*1000/($.now - first)).toFixed(4), delta
require 'bling'
mongo = require 'mongoskin'

db_url = $.config.get 'MPATH_MONGO', "mongodb://localhost:27017/mpath"
db = mongo.db db_url

db.bind 'agents'
db.bind 'agents_view'
db.bind 'apikeys'
db.bind 'sessions'
db.bind 'learning'
db.bind 'transforms'
db.bind 'historyLearning'
db.bind 'historyCombinations'
db.bind 'historyGoals'
db.bind 'historySimpleLift'
db.bind 'historySessions'
db.bind 'historySegments'
db.bind 'transformsLookups'
db.bind 'transformsLookupProviders'

exports.mongo = exports.db = db

$.subscribe "app-start", ->
	uniques =
		agents:
			owner: 1
			code: 1
		agents_view:
			owner: 1
			code: 1
		learning:
			owner: 1
			agent: 1
			point: 1
			seg: 1
			feature: 1
			decision: 1
		transforms:
			owner: 1
			code: 1
		transformsLookups:
			owner: 1
			ns: 1
			key: 1
		transformsLookupProviders:
			owner: 1
			ns: 1
		sessions:
			owner: 1
			agent: 1
			code: 1
		apikeys:
			owner: 1
			code: 1
		historySessions:
			owner: 1
			agent: 1
			date: 1
			isControl: 1
		historyGoals:
			owner: 1
			agent: 1
			date: 1
			goal: 1
			seg: 1
			isControl: 1
		historyLearning:
			owner: 1
			agent: 1
			date: 1
			point: 1
			choice: 1
			seg: 1
			feature: 1
		historyCombinations:
			owner: 1
			agent: 1
			date: 1
			point: 1
			seg:1
			feature:1
			choice: 1
		historySimpleLift:
			owner: 1
			agent: 1
			date: 1
			outcome: 1	
	indexes =
		apikeys:
			owner: 1
			email: 1
	$.log "Creating mongo indexes..."
	$(col for col of uniques).union(col for col of indexes).distinct().each (col) ->
		if $.config('NODE_ENV') is 'development'
			db[col].dropIndexes (err, success) ->
				if err
		if col of uniques
			db[col].ensureIndex uniques[col], unique: true
		if col of indexes
			db[col].ensureIndex indexes[col]

	$.log "Data cleanup / repairs..."
	db.historyCombinations.update {feature:{'$exists':false}}, {'$set':{feature:'(none)'}}, {multi:true, safe:true}, (err, status) ->
		throw err if err
knownCrawlers = [
	"AdsBot-Google"
	"Googlebot"
	"bingbot"
	"baiduspider"
	"bitlybot"
	"msnbot"
	"yahoo"
	"Ask Jeeves/Teoma"
	"facebookexternalhit"
	"Twitterbot"
	"AltaVista"
	"bot"
	"spider"
	"walker"
	"crawler"
	"fetcher"
	"finder"
]

exports.detect = (ua) ->
	ua = ua.toLowerCase()
	for crawler in data.crawlers

data = {}
initialize = ->
	data.cache = {}
	data.crawlers = []
	data.crawlers.push crawler.toLowerCase() for crawler in knownCrawlers
initialize()

if require.main is module
	uas = [
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.82 Safari/537.1"
		"Googlebot/5.0 (Macintosh; Intel Mac OS X 10_7_4) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.82 Safari/537.1"
	]
	for i in [0..100]
		for ua in uas
			result = exports.detect ua
Accessors = require './accessors'
Transforms = require './transforms'
Agent = require './agent'
Auth = require './auth'

exports.decision = Auth.ensureAuthorized "runtime:get-decision", (req, res) -> handleGet(req, res, 'json')
exports.decisions = Auth.ensureAuthorized "runtime:get-decision", (req, res) -> handleGet(req, res, 'json-n')
exports.redirect = Auth.ensureAuthorized "runtime:get-decision", (req, res) -> handleGet(req, res, 'redirect')

handleGet = (req, res, format) ->
	props = req.collectProps()
	Accessors.getTransformRules req.params.owner, req.params.agent, (err, rules) ->
		return res.endWithError err if err
		Transforms.applyTransforms rules, props, (err) ->
			return res.endWithError err if err
			Accessors.getAgent req.params.owner, req.params.agent, props, (err, agent) ->
				return res.endWithError err if err
				return res.endWithNotFound() unless agent?

				format = 'redirect' if format is 'json' and Agent.hasTag(agent, 'redirect')

				pointCode = req.getMpathParam('point') ? agent.defaults.point
				decpoint = agent.points[pointCode]

				Accessors.getSession req.getSessionId(agent), agent, true, (err, sess) ->

					req.applyToSession sess, props, agent

					res.setMpathCookie(agent, sess, req)

					control = sess.isControl or sess.crawler?
					exploit = !control && !$.random.coin(agent.learning.explorationRate)

					explicitPolicy = req.getMpathParam('decision-policy')
					switch explicitPolicy
						when 'control', 'crawler'
							control = true
							exploit = false
						when 'explore'
							control = false
							exploit = false
						when 'exploit'
							control = false
							exploit = true

					Accessors.getBest agent, decpoint, sess.targ.seg, (err, best) ->
						return callback err if err
						outcomes = 
							winner: best
							default: Agent.getDefaultDecisionForPoint(decpoint)

						if control
							return decisionViaControl agent, decpoint, sess, outcomes, (err, chosen) ->
								return afterDecision(agent, decpoint, sess, chosen, res, format, outcomes) if chosen?
								throw new Error("No decision via control policy")
						decisionViaSticky agent, decpoint, sess, outcomes, (err, chosen) ->
							return afterDecision(agent, decpoint, sess, chosen, res, format, outcomes) if chosen?
							if exploit
								return decisionViaExploit agent, decpoint, sess, outcomes, (err, chosen) ->
									return afterDecision(agent, decpoint, sess, chosen, res, format, outcomes) if chosen?
									throw new Error("No decision via exploit policy")
							decisionViaExplore agent, decpoint, sess, outcomes, (err, chosen) ->
								return afterDecision(agent, decpoint, sess, chosen, res, format, outcomes) if chosen?
								throw new Error("No decision via explore policy")


afterDecision = (agent, decpoint, sess, choice, res, format, outcomes) ->
	sess.numdec++

	curr =
		point: decpoint.code
		segment: sess.targ.seg
		policy: choice.policy
		outcomes: []

	unless choice.policy is 'sticky'
		if agent.targeting.usesFeatures
			choiceString = JSON.stringify choice.choice
			curr.outcomes.push 'random' if choice.policy is 'explore'

	if sess.targ.features?
		curr.features = sess.targ.features


	if agent.settings.sessions.sticky
		sess.stuck or= {}
		sess.stuck[decpoint.code] = curr.choice

	switch format
		when 'json'
			firstChoice = choice.choice[firstDecisionCode]
			res.endWithJson 200,
				session: sess.code
				decision: firstChoice
		when 'json-n'
			selections = {}
			for decisionCode of choice.choice
				selections[decisionCode] = decpoint.decisions[decisionCode].choices[ choice.choice[decisionCode] ]
			state = sess.states[0]
			res.endWithJson 200,
				session: sess.code
				policy: choice.policy
				decisions: selections
				point: state.point
				segment: state.segment
				features: state.features
		when 'redirect'
			firstChoiceCode = choice.choice[firstDecisionCode]
			firstChoice = decpoint.decisions[firstDecisionCode].choices[firstChoiceCode]
			res.redirect redirectUrl

	$.delay 1, ->
		Accessors.updateOnExperience sess, agent, (err) ->
			Accessors.updateOnTransition sess, agent, (err) ->
				return callback err if err

decisionViaExplore = (agent, decpoint, session, outcomes, callback) ->
	choices = {}
	for decisionCode of decpoint.decisions
		choiceCode = $.random.element Object.keys decpoint.decisions[decisionCode].choices
		choices[decisionCode] = choiceCode
	callback null,
		policy 	: 'explore'
		ts 		: $.date.stamp()
		choice 	: choices

decisionViaExploit = (agent, decpoint, session, outcomes, callback) ->
	return callback null, null if not outcomes.winner? 
	callback null,
		policy 	: 'exploit'
		ts      : $.date.stamp()
		choice 	: outcomes.winner 

decisionViaSticky = (agent, decpoint, session, outcomes, callback) ->
	unless agent.settings.sessions.sticky
		return callback null, null
	if session.stuck?[decpoint.code]
		return callback null,
			policy 	: 'sticky'
			ts 		: $.date.stamp()
			choice	: choiceSnapshotToMap(session.stuck[decpoint.code])
	callback null, null

decisionViaControl = (agent, decpoint, session, outcomes, callback) ->
	if agent.points[decpoint.code]?
		return callback null,
			policy 	: if session.crawler? then 'crawler' else 'control'
			ts 		: $.date.stamp()
			choice	: outcomes.default

choiceSnapshot = (choice) ->
	result = []
	for key in Object.keys(choice).sort()
	result.sort()
	return result

choiceSnapshotToMap = (snapshot) ->
	result = {}
	for part in snapshot
		[k,v] = part.split(":")
		result[k] = v
	result
require 'bling'
Auth = require './auth'
{serializeCookie} = require './node_modules/connect/lib/utils'
Validate = require './validate'
Crawlers = require './crawlers'

getMpathCookieName = (agent) -> agent.settings.cookies.name or "mpid"

requestExtensions =
	getMpathParam: (name) -> @headers['x-mpath-' + name] or @query[name] or @params[name]
	getApiKey: -> @getMpathParam 'apikey'
	getSessionId: (agent) -> @getMpathParam('session') ? @getMpathCookie(agent) ? $.random.string(16)
	getMpathCookie: (agent) -> @cookies[getMpathCookieName(agent)]

	collectProps: ->
		props =
			segment: @getMpathParam 'segment'
			features: @getMpathParam('features').split(',') if @getMpathParam('features')?
			inputs: {}
		props.inputs[key[1..]] = value for key,value of @query when key.length > 1 and key[0] is "@"
		return props

	applyToSession: (sess, props, agent) ->
		sess.crawler = Crawlers.detect(props.ua) if props.ua?
		if Validate.isIdentifier props.segment
			sess.targ.seg = props.segment
		if agent.targeting.usesFeatures
			if props.features?
				for feat in props.features
					feat = feat.split(':')
					if feat.length is 1 and Validate.isIdentifier(feat[0])
					else if feat.length is 2 and Validate.isIdentifier(feat[0]) and Validate.isNumeric(feat[1]) and feat[1] isnt 0
						sess.targ.features[feat[0]] = parseFloat feat[1]

responseExtensions =
	setMpathCookie: (agent, sess, req) ->
		if agent.settings.cookies?.enabled
			cookieName = getMpathCookieName(agent)
			@setHeader "Set-Cookie", serializeCookie(
				cookieName,
				sess.code,
			)

	endWithJson: (statusCode, value, allowCredentials = true) ->
		json = JSON.stringify value
		try @writeHead statusCode,
			'Content-Type': 'application/json'
			'Access-Control-Allow-Headers': 'X-Requested-With, Content-Type, Accept, x-mpath-apikey'
			'Cache-Control': 'max-age=0, no-cache, must-revalidate'
			'Content-Length': if json? then json.length else 0
		catch error 
		finally 
			@end json

	endWithError: (errMsg, code = 500) -> @endWithJson code, err: errMsg
	endWithNotAuthorized: (msg = "You do not have the appropriate access.") -> @endWithJson 403, err: msg
	endWithNotFound: (msg = "Agent not found.") -> @endWithJson 404, err: msg

	redirect: (url, code = 302) ->
		@writeHead code, Location: url
		@end()

module.exports.routeHandler = routeHandler = (f) ->
	(req, res) ->
		try
			$.delay 1000, ->
				if not res.finished
					res.endWithError "Request timeout"
			f ($.extend req, requestExtensions),
				($.extend res, responseExtensions)
		catch err
			if $.config "NODE_ENV" is "development" then throw err
			responseExtensions.endWithError.call res, err.message

$.extend module.exports, Auth
Accessors = require './accessors'

exports.get = (req, res) ->
	props = req.collectProps()

	Accessors.getAgent req.params.owner, req.params.agent, props, (err, agent) ->

		return res.endWithNotFound() unless agent?
		
		Accessors.getSession req.getSessionId(agent), agent, false, (err, sess) ->
			return res.endWithNotFound() unless sess?

			req.applyToSession sess, props, agent

			res.setMpathCookie agent, sess, req

			exports.handleExpiration agent, sess

			res.endWithJson 200,
				session: sess.code

exports.handleExpiration = (agent, sess) ->
	return $.log("Already expired: " + sess.code) if (sess.status == 0)

	
	
	$.delay 1, ->
		Accessors.updateOnTransition sess, agent, (err) ->
require 'bling'
async = require 'async'
mongo = require('./connections').db
stats = require './util/stats'
learning = require './learning'
Accessors = require './accessors'
Agent = require './agent'


skipHistory = (sess, agent) ->

exports.updateHistoryOnValueCombination = (sess, agent, callType, callback) ->
	return callback false if skipHistory sess, agent
	return callback false unless state?
	reward = sess.reward || 0
	query = baseUpdateCriteria sess, agent
	query.point = state.point
	query.choice = state.choice.join(',')
	query.seg = state.segment
	update = null
	if callType is 'decision'
		update = 
			'$set': ts: $.date.stamp()
			'$inc': 
				count: 1
				val: 0
				valSq: 0
	if callType is 'goal'
		totalReward = $(sess.goals).select('val').sum()
		priorReward = totalReward - reward
		update = 
			'$set': ts: $.date.stamp()
			'$inc':
				val: reward
				valSq:squared(reward+priorReward) - priorReward

		(feature, cb) ->
			query = $.extend {}, query
			query.feature = feature
			$.log "update historyCombinations with query", query
			mongo.historyCombinations.update query, update, {upsert:true}, cb

exports.updateHistoryOnGoal = (sess, agent, callback) ->
	return if skipHistory sess, agent
	reward = goalItem.val || 0
	query = baseUpdateCriteria sess, agent
	query.goal = goalItem.code
	query.isControl = sess.isControl
	query.seg = sess.targ.seg
	totalReward = getTotalRewardForGoal(sess, goalItem.code)
	priorReward = totalReward - reward
	update =
		'$inc': 
			count:1
			val:reward
			valSq:squared(totalReward) - squared(priorReward)
		'$set': ts: $.date.stamp()
	mongo.historyGoals.update query, update, {upsert:true}, (err) ->

exports.updateSimpleLift = (sess, agent, callType, callback) ->
	return if skipHistory sess, agent
	state = sess.states[0]
	switch callType
		when 'decision' 
			update = '$inc':
				decisions: 1
				goals: 0
				val: 0
		when 'goal'
			return callback "No goal or reward" unless goalItem?.val > 0
			update = '$inc':
				sessions: 0
				decisions: 0
				goals: 1
				val: goalItem.val || 0
		else return callback "Unknown callType"
	$.log "UDPATE", callType, update
	async.forEach state.outcomes, 
		(outcome, cb) ->	
			query = baseUpdateCriteria sess, agent
			query.outcome = outcome
			mongo.historySimpleLift.update query, update, {upsert:true}, cb
		(err) ->
			return callback err if err


getTotalRewardForGoal = (sess, goalCode) ->
	goalItems = $(sess.goals).filter (item) -> (item.code is goalCode and item.status isnt 0)
	return goalItems.select('val').sum()

exports.updateHistoryOnSessionStart = (sess, agent) ->
	return if skipHistory sess, agent
	query = baseUpdateCriteria sess, agent
	query.isControl = sess.isControl
	update =
		'$inc': {count:1},
		'$set': {ts:$.date.stamp()}
	mongo.historySessions.update query, update, {upsert:true}, (err) ->
		throw err if err


exports.updateHistoryOnSessionEnd = (sess, agent) ->
	return if skipHistory sess, agent
	query = baseUpdateCriteria sess, agent
	query.isControl = sess.isControl
	update =
		'$inc': {expired:1},
		'$set': {ts:$.date.stamp()}
	mongo.historySessions.update query, update, {upsert:true}, (err) ->
		throw err if err

exports.updateHistoryOnSegmentChange = (sess, agent) ->
	return if skipHistory sess, agent
	query = baseUpdateCriteria sess, agent
	query.isControl = sess.isControl
	query.seg = sess.targ.seg
	update =
		'$inc': {count:1},
		'$set': {ts: $.date.stamp()}
	mongo.historySegments.update query, update, {upsert:true}, (err) ->
		throw err if err

exports.updateUserAgentHistory = (sess, agent, props) ->
	return unless props.ua?
	query = baseUpdateCriteria sess, agent
	query.ua = props.ua
	query.crawler = sess.crawler
	update =
		'$inc': {count:1},
		'$set': {ts: $.date.stamp()}
	mongo.historyUserAgent.update query, update, {upsert:true}, (err) ->
		throw err if err

exports.updateHistoryOnDateChange = (agent, date, callback) ->
	date = $.date.midnight date
	date = $.date.addDays date, -1

	return callback(false) unless agent.housekeeping.lastLearningHistoryDate < date

	mongo.learning.findItems query, (err, items) ->
		for item in items
			changes =
			mongo.historyLearning.update qry, changes, {upsert:true}, (err) ->
		qry = {owner:agent.owner, code:agent.code}
		changes =
			'$set':{'housekeeping.lastLearningHistoryDate': date}
		mongo.agents_view.update qry, changes, (err) ->
			return callback(err) if err

exports.removeAgentHistory = (agent, callback) ->
	query = owner:agent.owner, agent:agent.code
	mongo.historyCombinations.remove query, (err) ->
		return callback(err) if err
		mongo.historySessions.remove query, (err) ->
			return callback(err) if err
			mongo.historyGoals.remove query, (err) ->
				mongo.historyLearning.remove query, (err) ->
					return callback(err) if err
					callback(err)

exports.getDecisionConfidenceReportData = (agent, dateFrom, dateThru, pointCode, comparisonDecision, aggregated, confidenceMeasure, useBonferroni, callback) ->

	dateFrom ?= $.date.midnight $.date.addHours($.date.stamp(), gmtOffset)
	dateThru ?= dateFrom
	pointCode ?= agent.points[0].code
	aggregated ?= true
	confidenceMeasure ?= .8
	useBonferroni ?= true

	query = baseReportCriteria agent, dateFrom, dateThru, pointCode
	mongo.historyCombinations.findItems query, (err, items) ->
		return callback err if err

		dates = dateRange dateFrom, dateThru
		decisions =  Agent.getSetsOfChoices(agent, pointCode)
		queries = makeDefaultRecords {agent:agent.code, owner:agent.owner}, dates, agent.targeting.segments, agent.targeting.features, [{code:pointCode}], decisions
		defaults = count:0, val:0, valSq:0
		items = findAndFillOmissions items, queries, defaults

		if aggregated
			items = aggregate items, 
				['owner', 'agent', 'point', 'choice', 'seg', 'feature'], 
				['count', 'val', 'valSq'], ['date']


		counts = {}
		for item in items
			key = dateStateKeyFor item
			counts[key]?= 0
			counts[key]++

		bLo = bHi = NaN
		for item in items
			key = dateStateKeyFor item
			numTests = counts[key] - 1
			comparisonItem = extractComparisonRollup items, item, comparisonDecision
			try
				decorateWithConfidenceAnalysis item, comparisonItem, confidenceMeasure, useBonferroni, numTests
			catch err
			bLo = item.bLo if item.bLo? and (isNaN(bLo) or item.bLo < bLo)
			bHi = item.bHi if item.bHi? and (isNaN(bHi) or item.bHi > bHi)

		for item in items
			item.lift = calculateLiftFromHistoryCombinations agent, item.date, items, item, comparisonDecision


exports.getLearnedValuesReportData = (agent, dateFrom, dateThru, pointCode, callback) ->
	today = $.date.midnight $.date.addHours($.date.stamp(), gmtOffset)
	choices = Agent.getSetsOfChoices(agent, pointCode)


	query = baseReportCriteria agent, dateFrom, dateThru, pointCode
	mongo.historyLearning.findItems query, (err, items) ->
		return callback err if err

		delete query.date
		mongo.learning.findItems query, (err, learningItems) ->
			if includeCurrent
				for item in learningItems
					item.choice = item.decision; delete item.decision
					item.count = item.exp; delete item.exp
				items = learningItems.concat(items)

			dates = dateRange dateFrom, dateThru
			queries = makeDefaultRecords {agent:agent.code, owner:agent.owner}, dates, agent.targeting.segments, agent.targeting.features, [{code:pointCode}], choices
			defaults = count:0, val:0, valSq:0
			items = findAndFillOmissions items, queries, defaults, true



exports.getMagicQuadReportData = (agent, dateFrom, dateThru, options, callback) ->

	exports.getLearnedValuesReportData agent, dateFrom, dateThru, options.pointCode, (err, items) ->
		map = {}
		for item in items
			agg = map[item.feature] ?= sum:0, recs:0, avg:0, min:NaN, max:NaN, range:0, effect:0
			agg.recs++
			agg.sum += item.val
			agg.min = item.val if isNaN(agg.min) or item.val < agg.min
			agg.max = item.val if isNaN(agg.max) or item.val > agg.max
		for feature,item of map
			item.range = (item.max - item.min)
			item.effect = Math.abs(item.range / item.avg) if item.avg isnt 0
		axisValue = 
			baseline: truncate $(Object.values(map)).select('avg').avg(), 2
		axisEffect = 
			max: asPercentage $(Object.values(map)).select('effect').max()
			min: asPercentage $(Object.values(map)).select('effect').min(), 2
		axisEffect.baseline = (axisEffect.max - axisEffect.min) / 2

		features = []
		for feature,item of map
			features.push
				feature: feature
				avg: truncate item.avg, 2
				effect: asPercentage item.effect 
		callback false, 
			features: features
			axes:
				value: axisValue
				effect: axisEffect

exports.getStatusReportData = (owner, agentCodes, todaysDate, daysBack, callback) ->
	dates = dateRange $.date.addDays(todaysDate, -daysBack), todaysDate

	result = {}; 
	for agentCode in agentCodes
		status = dates:[]
		status.dates.push {date, sessionCount:0, goalCount:0, liftOverDefault:0, liftOverRandom:0} for date in dates
		result[agentCode] = status

	query = 
		owner: owner, 
		agent: {'$in':agentCodes}
		date: {'$in':dates}

	agents = Accessors.getAgents owner, agentCodes, {}, (err, agents) ->
		agentMap = {}; agentMap[agent.code] = agent for agent in agents

		mongo.historySessions.findItems query, (err, items) ->
			return callback err if err
			for item in items
				status = result[item.agent]
				if status?
					dateItem = status.dates[dates.indexOf(item.date)]
					dateItem.sessionCount += item.count
			mongo.historyGoals.findItems query, (err, items) ->
				return callback err if err
				for item in items
					status = result[item.agent]
					if status?
						dateItem = status.dates[dates.indexOf(item.date)]
						dateItem.goalCount += item.count

				mongo.historyCombinations.findItems query, (err, items) ->
					return callback err if err
					for item in items
						status = result[item.agent]
						if status?
							agent = agentMap[item.agent]
							dateItem = status.dates[dates.indexOf(item.date)]
							unless dateItem.liftOverDefault isnt 0 or dateItem.liftOverRandom isnt 0 or agent.targeting.usesFeatures
								liftOver = calculateLiftFromHistoryCombinations agent, item.date, items, null, null
								dateItem.liftOverDefault = liftOver.default
								dateItem.liftOverRandom  = liftOver.random

					mongo.historySimpleLift.findItems query, (err, items) ->
						return callback err if err 
						for item in items
							status = result[item.agent]
							if status?
								agent = agentMap[item.agent]
								dateItem = status.dates[dates.indexOf(item.date)]
								unless dateItem.liftOverDefault isnt 0 or dateItem.liftOverRandom isnt 0 or !agent.targeting.usesFeatures
									liftOver = calculateLiftFromHistorySimpleLift agent, item.date, items
									dateItem.liftOverDefault = liftOver.default
									dateItem.liftOverRandom  = liftOver.random

						for code,status of result
							status.trends =
								dates: $(status.dates).select 'date'
								sessionCount: $(status.dates).select 'sessionCount'
								goalCount: $(status.dates).select 'goalCount'
								liftOverDefault: $(status.dates).select 'liftOverDefault'
								liftOverRandom: $(status.dates).select 'liftOverRandom'

							status.totals = 
								sessionCount: $(status.trends.sessionCount).sum()
								goalCount: $(status.trends.goalCount).sum()

						return callback false, result

baseUpdateCriteria = (sess, agent) ->
	return {
		owner: agent.owner
		agent: agent.code
		date: $.date.midnight(sess.ts)
	}

baseReportCriteria = (agent, dateFrom, dateThru, pointCode = null) ->
	query =
		owner: agent.owner
		agent: agent.code
		date: {'$gte': $.date.midnight(dateFrom), '$lte': $.date.midnight(dateThru)}
	query.point = pointCode if pointCode?
	return query

makeDefaultRecords = (defaults, dates, segments, features, points, decisions) ->
	result = []
	dates = [null] if not dates?
	segments = [null] if not segments?
	features = [null] if not features?
	points = [null] if not points?
	decisions = [null] if not decisions?

	for date in dates
		for segment in segments
			for feature in features
				for point in points
					for decision in decisions
						item = {}
						item[key] = val for key,val of defaults
						item.date = date if date?
						item.seg = segment.code if segment?
						item.feature = feature.code if feature?
						item.point = point.code if point?
						item.choice = decision.join(',') if decision?
						result.push item
	return result

findAndFillOmissions = (items, queries, defaults, usePriorFields) ->
	throw "No items" unless items?
	return [] if queries.length is 0
	result = []
	itemsUsed = 0
	map = {}
	priorsMap = {}
	if usePriorFields?
		priorFields = fields.concat()
	for item in items
		key = mapKey item, fields
		map[key] = item
	for query in queries
		key = mapKey query, fields
		if map[key]?
			result.push item
			itemsUsed++
			if usePriorFields
				key = mapKey item, priorFields
		else
			if usePriorFields
				key = mapKey item, priorFields
				if priorsMap[key]?
					priorItem  = priorsMap[key]
			result.push item


	return result

decorateWithConfidenceAnalysis = (item, comparisonItem, confidenceMeasure, useBonferroni, numTests) ->
	bounds = stats.getConfidenceBounds item.count, item.val, item.valSq, confidenceMeasure, useBonferroni, numTests
	item.bLo = bounds[0]
	item.bHi = bounds[1]
	item.vVari = stats.getVariance(item.count, item.val, item.valSq)
	item.vMean = stats.getMean(item.count, item.val)
	item.stdDev = stats.getStandardDeviation(item.vVari)
	item.tScore = 0- stats.getTScore(item.count, comparisonItem.count, item.val, comparisonItem.val, item.valSq, comparisonItem.valSq)
	item.dgFree = stats.getDegreeFreedom(item.count, comparisonItem.count, item.val, comparisonItem.val, item.valSq, comparisonItem.valSq)
	item.pValue = stats.getPValue(item.tScore, item.dgFree)
	item.signif = stats.isSignificant2(item.pValue, confidenceMeasure, numTests, useBonferroni)
	item.confidence = asPercentage stats.getConfidence(item.count, comparisonItem.count, item.pValue)
	item.confidenceLevel = stats.getConfidenceLevel(item.count, comparisonItem.count, item.pValue)

	liftOvers = 
		default: 0
		random: 0 

	outcomes = {}
	for item in historyItems
		item.valuePerSession = if item.sessions > 0 then (item.val / item.sessions) else 0
		outcomes[item.outcome] = item
	winning = outcomes?.winner; return liftOvers unless winning?
		versus  = outcomes?[key] ? {valuePerSession : 0}
		if versus.valuePerSession > 0
			lift = (winning.valuePerSession - versus.valuePerSession) / versus.valuePerSession
			liftOvers[key] = asPercentage(lift)
	return liftOvers


	result =
		default: 0
		random: 0

	if historyItem?
		points = {}; points[historyItem.point] = agent.points[historyItem.point]
		segments = [{code:historyItem.seg}]
		features = [{code:historyItem.feature}]
	else
		points = agent.points
		segments = agent.targeting.segments
		features = agent.targeting.features

	totalTraffic = $(historyItems).select('count').sum()

	for pointCode,point of points
		defChoice = comparisonDecision ? Agent.getDefaultDecisionForPointAsString(point)
		
				items = $(historyItems).filter(-> @point is pointCode and @seg is seg.code and @feature is feature.code)
				trafficThisTarget = $(items).select('count').sum()
				percentTrafficThisTarget = trafficThisTarget / totalTraffic
				defItem = $(items).filter(-> @choice is defChoice).first()
				maxItem = $(items).maxBy('val')
				itemBeingTested = if historyItem? then historyItem else maxItem
				randVal = 0; randVal += item.val * (1/items.length) for item in items

				liftOverDefault = 0
				if itemBeingTested? and defItem? 
						liftOverDefault = if itemBeingTested.val > 0 then 1 else 0
					else
						liftOverDefault = (itemBeingTested.val - defItem.val) / defItem.val
				result.default += liftOverDefault * percentTrafficThisTarget
				result.random  += (itemBeingTested.val - randVal) / randVal if randVal > 0
	result.random = asPercentage result.random
	result.default = asPercentage result.default
	return result

extractComparisonRollup = (items, item, comparisonDecisionString) ->
	key = dateStateKeyFor item
	for item in items
			if item.choice.toString() is comparisonDecisionString
				return item
	return null

mapKey = (item, fields) ->
	key = []
	for field in fields
	return key.join ","

dateStateKeyFor = (item) ->
	[item.date, item.seg, item.feature, item.point].join('|')

dateRange = exports.dateRange = (dateFrom, dateThru) ->
	dates = [$.date.midnight(dateFrom)]
	dates.push($.date.addDays($(dates).last(), 1)) while $(dates).last() < dateThru
	return dates

today = () ->
	return $.date.midnight($.date.stamp())
squared = (num) -> 
	Math.pow(num, 2)
exports.asPercentage = asPercentage = (val) ->
	return 0 if isNaN val
	return Math.round(val * 100)
exports.truncate = truncate = (num, dec = 1) ->
	return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec)	

aggregate = (items, keyFields, sumFields, lastFields) ->
	result = []
	map = {}
	for item in items
		key = mapKey(item, keyFields)
		if not map[key]?
			agg = {}
			agg[k] = item[k] for k in keyFields
			agg[s] = item[s] for s in sumFields
			map[key] = agg
			result.push agg
		else
			agg = map[key]
			agg[s] += item[s] for s in sumFields
		agg[l] = item[l] for l in lastFields
	return result	


if require.main is module

	query = 
		owner:'test'
		agent:'agent-1'
		date: today()
		result:'best'
	update = 
		'$inc':
			count:1
	mongo.historySimpleLift.update query, update, {upsert:true, multi:true, safe:true}, (err) ->
		$.log "err", err
accessors = require './accessors'
Agent = require './agent'
mongo = require('./connections').db
History = require('./history')
require 'bling'

skipLearning = (sess, agent) ->
	return sess.isControl or sess.crawler?

exports.updateLearningOnTransition = (sess, agent) ->
	return if skipLearning sess, agent

exports.updateLearningOnExpire = (sess, agent) ->
	return if skipLearning sess, agent

exports.updateLearningOnGoal = (sess, agent) ->

updateLearning = (sess, agent, updateWhichState, bonusFromState = undefined) ->
		numFeatures = Agent.numActiveFeatures(agent)
		accessors.getRelevantLearningRecords sess, agent, updateWhichState, true, (err, learningRecords) ->
			return callback err if err
			sumQ = $(learningRecords).select('val').sum() ? 0
			for learningRecord in learningRecords
				learningRate = effectiveLearningRate(agent, learningRecord.exp)
				reward = sess.reward + bonusReward
				learned = -learningRate * (sumQ - reward) / numFeatures

				accessors.updateLearningScoreOne sess, agent, learningRecord, learned, (err) ->
					return callback err if err


calculateLearningBonus = (sess, agent, bonusFromState, callback) ->
	return callback false, 0 unless bonusFromState? and Agent.isMultiState(agent) and (sess.states.length > 1)
	useExpectedSarsa = (Agent.numActiveFeatures(agent) > 1)
	accessors.getRelevantLearningRecords sess, agent, bonusFromState, false, (err, learningRecords) ->
		return callback err if err
			return callback false, calculateLearningBonusUsingExpectedSarsa(sess, agent, learningRecords)
			return callback false, calculateLearningBonusUsingQLearning(sess, agent, learningRecords)

calculateLearningBonusUsingQLearning = (sess, agent, learningRecords) ->
	maxQ = $(learningRecords).select('val').max() ? 0
	return maxQ * agent.learning.discountRate

calculateLearningBonusUsingExpectedSarsa = (sess, agent, learningRecords) ->
	state = sess.states[0]
	return 0 unless state?.features?
	featureCodes = Object.keys(state.features)
	impacts = exports.calculateImpact(agent, state.point, featureCodes, learningRecords)
	bonus = 0
	exploreCorrection = 0

	map = {}
	for impactItem in impacts
		for action in impactItem.actions
			map[key] = action.impact / 100

	for record in learningRecords
		impact = map[key] || 0
		bonus += (impact * record.val)
		exploreCorrection += (evenSlice * record.val)
	return (bonus * agent.learning.explorationRate) + (exploreCorrection * (1 - agent.learning.explorationRate))


exports.calculateImpact = (agent, pointCode, featureSets, items, temperatureMeasure = 1) ->
	featureSets[i] = ensureArray(featureSet) for featureSet,i in featureSets

	map = {}
	countTotals = {}
	keyFields = ['choice', 'feature']
	byFeature = []
	choices = Agent.getSetsOfChoices(agent, pointCode)

	for item in items
		key = mapKey item, keyFields
		countTotals[item.feature] ?= {count:0, min:null, max:null, total:0}
		totalItem.count += item.count

	for featureSet in featureSets
		numerators = {}

		aggregates = {val:0, items:0, min:null, max:null, avg:0, range:0}
		for choice in choices
			for feature in featureSet
				featureKey = mapKey({choice, feature}, keyFields)
				featureItem = map[featureKey]
				aggregates.val += featureItem.val
				aggregates.min = featureItem.val if (not aggregates.min?) or (featureItem.val < aggregates.min)
				aggregates.max = featureItem.val if (not aggregates.max?) or (featureItem.val > aggregates.max)
		aggregates.avg = (aggregates.val/aggregates.items) if aggregates.items > 0
		aggregates.range = (aggregates.max - aggregates.min)

		for choice in choices
			numerator = 0
			interceptKey = mapKey {choice, feature:'(none)'}, keyFields
			interceptItem = map[interceptKey]
			for feature in featureSet
				featureKey = mapKey({choice, feature}, keyFields)
				featureItem = map[featureKey]
			scoreNormalized = if aggregates.range is 0 then score else (score - aggregates.avg) / aggregates.range
			numerator = Math.exp(scoreNormalized / temperatureMeasure)
			numeratorKey = numerKey choice, featureSet
			numerators[numeratorKey] = numerator

		numeratorTotal = 0
		for k,v of numerators
			numeratorTotal += v


		byFeatureItem = {feature:featureSet.join('~'), actions:[], winner:null}
		for choice in choices
			numeratorKey = numerKey choice, featureSet
			numerator = numerators[numeratorKey]
			actionItem = {choice:choice.join(','), impact:History.asPercentage(choiceImpact)}
			byFeatureItem.winner = actionItem if ( (byFeatureItem.winner is null and aggregates.range isnt 0) or (byFeatureItem.winner? and actionItem.impact > byFeatureItem.winner.impact) )
			byFeatureItem.actions.push actionItem
		byFeatureItem.frequency = 0
		byFeature.push byFeatureItem
	return byFeature

effectiveLearningRate = (agent, experienceCount) ->
	return agent.learning.learningRate / (Math.sqrt(experienceCount / agent.learning.experienceThreshold) + 1)

numerKey = (choice, featureSet) ->
exports.truncate = truncate = (num, dec = 1) ->
	return Math.round(num*Math.pow(10,dec))/Math.pow(10,dec)
ensureArray = (stuff) ->
	return [] if not stuff?
	return [stuff] if not stuff.join?
	return stuff
mapKey = (item, fields) ->
	key = []
	for field in fields
	return key.join ","




Object.keys ?= (o) -> (k for k of o)

Object.values ?= (o) -> (o[k] for k of o)

extend = (a, b) ->
	if b then a[k] = v for k,v of b when v?
	a

defineProperty = (o,name,opts) ->
	Object.defineProperty o,name, extend({
		configurable: true
		enumerable: true
	}, opts)
	o



isType = (T, o) ->
	if not o? then T in [o,"null","undefined"]
	else o.constructor is T or
		o.constructor.name is T or

inherit = (parent, obj) ->
	if typeof parent is "function"
		parent = parent.prototype
	if parent.__proto__ is Object.prototype
		parent.__proto__ = obj.__proto__
	obj.__proto__ = parent
	obj

_type = do ->

	cache = {}

	base =
		name: 'unknown'
		match: (o) -> true

	order = []

	register = (name, data) ->
		order.unshift name if not (name of cache)
		cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
		cache[name][name] = (o) -> o

	_extend = (name, data) ->
		if typeof name is "string"
			cache[name] ?= register name, {}
			cache[name] = extend cache[name], data
		else if typeof name is "object"
			(_extend k, name[k]) for k of name

	lookup = (obj) ->
		for name in order
			if cache[name]?.match.call obj, obj
				return cache[name]

	register "unknown",   base
	register "object",    match: -> typeof @ is "object"
	register "error",     match: -> isType 'Error', @
	register "regexp",    match: -> isType 'RegExp', @
	register "string",    match: -> typeof @ is "string" or isType String, @
	register "number",    match: -> (isType Number, @) and @ isnt NaN
	register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
	register "array",     match: -> Array.isArray?(@) or isType Array, @
	register "function",  match: -> typeof @ is "function"
	register "undefined", match: (x) -> x is undefined
	register "null",      match: (x) -> x is null

	return extend ((o) -> lookup(o).name),
		register: register
		lookup: lookup
		extend: _extend
		is: (t, o) -> cache[t]?.match.call o, o
		as: (t, o, rest...) -> lookup(o)[t]?(o, rest...)




_pipe = do ->




	pipes = {}

	(name, args) ->
		p = (pipes[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args






class Bling

	default_context = if document? then document else {}

	constructor: (selector, context = default_context) ->
		return Bling.pipe "bling-init", [selector, context]

	@pipe: _pipe

	@pipe("bling-init").prepend (args) ->
		[selector, context] = args
		inherit Bling, inherit {
			selector: selector
			context: context
		}, _type.lookup(selector).array(selector, context)





	@plugin: (opts, constructor) ->
		if not constructor?
			constructor = opts; opts = {}

		if "depends" of opts
			return @depends opts.depends, =>
				@plugin { provides: opts.provides }, constructor
		try
			if (plugin = constructor?.call @,@)
				extend @, plugin?.$
				['$','name'].forEach (k) -> delete plugin[k]
				extend @::, plugin
				for key of plugin then do (key) =>
					@[key] or= (a...) => (@::[key].apply $(a[0]), a[1...])
				if opts.provides? then @provide opts.provides
		catch error
			throw error
		@

		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)

	@depends: (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else dep.q.push (need) ->
			(needs.splice i, 1) if (i = needs.indexOf need) > -1
			return (needs.length is 0 and f)
		f

	@provide: (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data

	@provides: (needs, f) ->
		(args...) ->
			Bling.provide needs, f args...

	_type.extend
		unknown:   { array: (o) -> [o] }

		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }

	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) ->
			o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"

Bling.prototype = []
Bling.prototype.constructor = Bling

do ($ = Bling) ->

	$.global = glob = if window? then window else global

	$.plugin
		provides: "type"
	, ->
		$:
			inherit: inherit
			extend: extend
			defineProperty: defineProperty
			isType: isType
			type: _type
			is: _type.is
			as: _type.as
			isSimple: (o) -> _type(o) in ["string", "number", "bool"]
			isEmpty: (o) -> o in ["", null, undefined]



	$.plugin
		provides: "symbol"
		depends: "type"
	, ->
		symbol = null
		cache = {}
		glob.Bling = Bling
		if module?
			module.exports = Bling
		$.type.extend "bling",
			string: (o) -> symbol + "(["+ o.map($.toString).join(", ") + "])"
		defineProperty $, "symbol",
			set: (v) ->
				glob[symbol] = cache[symbol]
				cache[symbol = v] = glob[v]
				glob[v] = Bling
			get: -> symbol
		return $:
			symbol: "$"
			noConflict: ->
				Bling.symbol = "Bling"
				return Bling

	$.plugin ->
		String::trimLeft or= -> @replace(/^\s+/, "")
		String::split or= (sep) ->
			a = []; i = 0
			while (j = @indexOf sep,i) > -1
				a.push @substring(i,j)
				i = j + 1
			a
		String::lastIndexOf or= (s, c, i = -1) ->
			j = -1
			j = i while (i = s.indexOf c, i+1) > -1
			j

		Array::join or= (sep = '') ->
			n = @length
			return "" if n is 0
			s = @[n-1]
			while --n > 0
				s = @[n-1] + sep + s
			s

		if Event?
			Event::preventAll = () ->
				@preventDefault()
				@stopPropagation()
				@cancelBubble = true

		if Element?
			Element::matchesSelector = Element::webkitMatchesSelector or
				Element::mozMatchesSelector or
				Element::matchesSelector
			if Element::cloneNode.length is 0
				oldClone = Element::cloneNode
				Element::cloneNode = (deep = false) ->
					n = oldClone.call(@)
					if deep
						for i in @childNodes
							n.appendChild i.cloneNode true
					return n

		return { }

	$.plugin
		provides: "core"
		depends: "string"
	, ->

		defineProperty $, "now",
			get: -> +new Date

		index = (i, o) ->
			i += o.length while i < 0
			Math.min i, o.length

		baseTime = $.now
		return {
			$:
				log: $.extend((a...) ->
					if prefix.length > $.log.prefixSize + 2
					if a.length and $.is "string", a[0]
					else
						a.unshift prefix
					console.log a...
					return a[a.length-1] if a.length
				, prefixSize: 5)
				coalesce: (a...) -> $(a).coalesce()

			eq: (i) -> $([@[index i, @]])

			each: (f) -> (f.call(t,t) for t in @); @

			map: (f) -> $(f.call(t,t) for t in @)

			reduce: (f, a) ->
				i = 0; n = @length
				a = @[i++] if not a?
				(a = f.call @[x], a, @[x]) for x in [i...n] by 1
				return a
			union: (other, strict = true) ->
				ret = $()
				ret.push(x) for x in @ when not ret.contains(x, strict)
				ret.push(x) for x in other when not ret.contains(x, strict)
				ret
			distinct: (strict = true) -> @union @, strict
			contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
			count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
			coalesce: ->
				for i in @
					if $.type(i) in ["array","bling"] then i = $(i).coalesce()
					if i? then return i
				null
			swap: (i,j) ->
				i = index i, @
				j = index j, @
				if i isnt j
					[@[i],@[j]] = [@[j],@[i]]
				@
			shuffle: ->
				i = @length-1
				while i >= 0
					@swap --i, Math.floor(Math.random() * i)
				@

			select: (->
				getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
				select = (p) ->
					if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
					else @map(getter p)
			)()

			or: (x) -> @[i] or= x for i in [0...@length]; @

			zap: (p, v) ->

				i = p.lastIndexOf "."

				if i > 0
					head = p.substr 0,i
					tail = p.substr i+1
					@select(head).zap tail, v
					return @

				switch $.type(v)
					when "array","bling" then @each -> @[p] = v[++i % v.length]
					when "function" then @zap p, @select(p).map(v)
					else @each -> @[p] = v
				@

			clean: (prop) -> @each -> delete @[prop]

			take: (n = 1) ->
				end = Math.min n, @length
				$( @[i] for i in [0...end] )

			skip: (n = 0) ->
				start = Math.max 0, n|0
				$( @[i] for i in [start...@length] )

			first: (n = 1) -> if n is 1 then @[0] else @take(n)

			last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)

			slice: (start=0, end=@length) ->
				start = index start, @
				end = index end, @
				$( @[i] for i in [start...end] )

			extend: (b) -> @.push(i) for i in b; @

			push: (b) -> Array::push.call(@, b); @

			filter: (f) ->
				g = switch $.type f
					when "string" then (x) -> x.matchesSelector(f)
					when "regexp" then (x) -> f.test(x)
					when "function" then f
					else
				$( it for it in @ when g.call(it,it) )

			matches: (expr) -> @select('matchesSelector').call(expr)

			querySelectorAll: (expr) ->
				@filter("*")
				.reduce (a, i) ->
					a.extend i.querySelectorAll expr
				, $()

			weave: (b) ->
				c = $()
				for i in [@length-1..0] by -1
					c[(i*2)+1] = @[i]
				for i in [0...b.length] by 1
					c[i*2] = b[i]
				c

			fold: (f) ->
				n = @length
				b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
				if (n%2) is 1
					b.push( f.call @, @[n-1], undefined )
				b

			flatten: ->
				b = $()
				(b.push(j) for j in i) for i in @
				b

			call: -> @apply(null, arguments)

			apply: (context, args) ->
				@map -> if $.is "function", @ then @apply(context, args) else @

			log: (label) ->
				if label
					$.log(label, @toString(), @length + " items")
				else
					$.log(@toString(), @length + " items")
				@

			toArray: ->
				@__proto__ = Array::
		}

	$.plugin
		provides: "math"
		depends: "core"
	, ->
		$.type.extend
			bool: { number: (o) -> if o then 1 else 0 }
			number: { bool: (o) -> not not o }

		$:
			range: (start, end, step = 1) ->
				if not end? then (end = start; start = 0)
				$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
			zeros: (n) -> $( 0 for i in [0...n] )
			ones: (n) -> $( 1 for i in [0...n] )
		floats: -> @map parseFloat
		ints: -> @map -> parseInt @, 10
		px: (delta) -> @ints().map -> $.px @,delta
		min: -> @filter( isFinite ).reduce Math.min
		max: -> @filter( isFinite ).reduce Math.max
		mean: -> @sum() / @length
		avg: -> @sum() / @length
		sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
		product: -> @filter( isFinite ).reduce (a) -> a * @
		squares: -> @map -> @ * @
		magnitude: -> Math.sqrt @floats().squares().sum()
		scale: (r) -> @map -> r * @
		add: (d) -> switch $.type(d)
			when "number" then @map -> d + @
			when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
		normalize: -> @scale(1/@magnitude())

	$.plugin
		provides: "string"
		depends: "function"
	, ->
		$.type.extend
			unknown:
				string: (o) -> o.toString?() ? String(o)
				repr: (o) -> $.type.lookup(o).string(o)
				number: (o) -> parseFloat String o
			null: { string: -> "null" }
			undefined: { string: -> "undefined" }
			string:
				number: parseFloat
			array:  { string: (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
			function:
				string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
			number:
				repr:   (n) -> String(n)
				string: (n) ->
					switch true
						when n.precision? then n.toPrecision(n.precision)
						when n.fixed? then n.toFixed(n.fixed)
						else String(n)

		return {
			$:
				toString: (x) ->
					if not x? then "function Bling(selector, context) { [ ... ] }"
					else $.type.lookup(x).string(x)

				toRepr: (x) -> $.type.lookup(x).repr(x)

				px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"



				capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")

				dashize: (name) ->
					ret = ""
					for i in [0...(name?.length|0)]
						c = name.charCodeAt i
						if 91 > c > 64
							c += 32
							ret += '-'
						ret += String.fromCharCode(c)
					ret

				camelize: (name) ->
					name.split('-')
					while (i = name?.indexOf('-')) > -1
						name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
					name

				padLeft: (s, n, c = " ") ->
					while s.length < n
						s = c + s
					s

				padRight: (s, n, c = " ") ->
					while s.length < n
						s = s + c
					s

				stringCount: (s, x, i = 0, n = 0) ->
					if (j = s.indexOf x,i) > i-1
						$.stringCount s, x, j+1, n+1
					else n

				stringSplice: (s, i, j, n) ->
					nn = s.length
					end = j
					if end < 0
						end += nn
					start = i
					if start < 0
						start += nn
					s.substring(0,start) + n + s.substring(end)

				checksum: (s) ->
					a = 1; b = 0
					for i in [0...s.length]
						a = (a + s.charCodeAt(i)) % 65521
						b = (b + a) % 65521
					(b << 16) | a

				repeat: (x, n=2) ->
					switch true
						when n is 1 then x
						when n < 1 then ""
						when $.is "string", x then x + $.repeat(x, n-1)
						else $(x).extend $.repeat(x, n-1)

				stringBuilder: ->
					if $.is("global", @) then return new $.stringBuilder()
					items = []
					@length   = 0
					@append   = (s) => items.push s; @length += s?.toString().length|0
					@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
					@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
					@toString = ( ) => items.join("")
					@
			toString: -> $.toString @
			toRepr: -> $.toRepr @
		}

	$.plugin
		provides: "function"
		depends: "hash"
	, ->
		$:
			identity: (o) -> o
			not: (f) -> -> not f.apply @, arguments
			compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
			and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
			once: (f, n=1) ->
				$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
					"exhausted",
						get: -> n <= 0
			cycle: (f...) ->
				i = -1
				-> f[i = ++i % f.length].apply @, arguments
			bound: (t, f, args = []) ->
				if $.is "function", f.bind
					args.splice 0, 0, t
					r = f.bind.apply f, args
				else
					r = (a...) -> f.apply t, (args if args.length else a)
			memoize: (f) ->
				cache = {}
			E: (callback) -> (f) -> (err, data) ->
				return f(data) unless err
				callback err, data

	$.plugin
		provides: "hash"
		depends: "type"
	, ->
		$.type.extend
			unknown: { hash: (o) -> $.checksum $.toString o }
			object:  { hash: (o) ->
				$.hash(Object) +
					$($.hash(o[k]) for k of o).sum() +
					$.hash Object.keys o
			}
			array:   { hash: (o) ->
				$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
					(a*a)+(x|0)
				, 1
			}
			bool:    { hash: (o) -> parseInt(1 if o) }
		return {
			$:
				hash: (x) -> $.type.lookup(x).hash(x)
			hash: -> $.hash @
		}

	$.plugin
		provides: "pubsub"
	, ->
		return {
			$:
				publish: (e, args...) ->
					f.apply null, args for f in (subscribers[e] or= [])
					args
				publisher: (e, func) ->
					(args...) ->
						func.apply @, args
						$.publish e, args
				subscribe: (e, func) ->
					(subscribers[e] or= []).push func
					func
				unsubscribe: (e, func) ->
					if not func?
						subscribers[e] = []
					else
						a = (subscribers[e] or= [])
						if (i = a.indexOf func)  > -1
							a.splice(i,i)
		}

	$.plugin
		provides: "throttle"
		depends: "core"
	, ->
		$:
			throttle: (f,n=250,last=0) ->
				(a...) ->
					gap = $.now - last
					if gap > n
						last += gap
						return f.apply @,a
					null
				(a...) ->
					last += (gap = $.now - last)
					return f.apply @,a if gap > n else null

	$.plugin
		provides: "EventEmitter"
	, ->
		$: EventEmitter: $.pipe("bling-init").append (obj) ->
			listeners = {}
			list = (e) -> (listeners[e] or= [])
			inherit {
				emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
				addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
				on:                 (e, h) -> @addListener e, h
				removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
				removeAllListeners: (e) -> listeners[e] = []
				listeners:          (e) -> list(e).slice 0
			}, obj

Object.keys ?= (o) -> (k for k of o)
Object.values ?= (o) -> (o[k] for k of o)
extend = (a, b) ->
	if b then a[k] = v for k,v of b when v?
	a
defineProperty = (o,name,opts) ->
	Object.defineProperty o,name, extend({
		configurable: true
		enumerable: true
	}, opts)
	o
isType = (T, o) ->
	if not o? then T in [o,"null","undefined"]
	else o.constructor is T or
		o.constructor.name is T or
inherit = (parent, obj) ->
	if typeof parent is "function"
		parent = parent.prototype
	if parent.__proto__ is Object.prototype
		parent.__proto__ = obj.__proto__
	obj.__proto__ = parent
	obj
_type = do ->
	cache = {}
	base =
		name: 'unknown'
		match: (o) -> true
	order = []
	register = (name, data) ->
		order.unshift name if not (name of cache)
		cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
		cache[name][name] = (o) -> o
	_extend = (name, data) ->
		if typeof name is "string"
			cache[name] ?= register name, {}
			cache[name] = extend cache[name], data
		else if typeof name is "object"
			(_extend k, name[k]) for k of name
	lookup = (obj) ->
		for name in order
			if cache[name]?.match.call obj, obj
				return cache[name]
	register "unknown",   base
	register "object",    match: -> typeof @ is "object"
	register "error",     match: -> isType 'Error', @
	register "regexp",    match: -> isType 'RegExp', @
	register "string",    match: -> typeof @ is "string" or isType String, @
	register "number",    match: -> (isType Number, @) and @ isnt NaN
	register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
	register "array",     match: -> Array.isArray?(@) or isType Array, @
	register "function",  match: -> typeof @ is "function"
	register "undefined", match: (x) -> x is undefined
	register "null",      match: (x) -> x is null
	return extend ((o) -> lookup(o).name),
		register: register
		lookup: lookup
		extend: _extend
		is: (t, o) -> cache[t]?.match.call o, o
		as: (t, o, rest...) -> lookup(o)[t]?(o, rest...)
_pipe = do ->
	pipes = {}
	(name, args) ->
		p = (pipes[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args
class Bling
	default_context = if document? then document else {}
	constructor: (selector, context = default_context) ->
		return Bling.pipe "bling-init", [selector, context]
	@pipe: _pipe
	@pipe("bling-init").prepend (args) ->
		[selector, context] = args
		inherit Bling, inherit {
			selector: selector
			context: context
		}, _type.lookup(selector).array(selector, context)
	@plugin: (opts, constructor) ->
		if not constructor?
			constructor = opts; opts = {}
		if "depends" of opts
			return @depends opts.depends, =>
				@plugin { provides: opts.provides }, constructor
		try
			if (plugin = constructor?.call @,@)
				extend @, plugin?.$
				['$','name'].forEach (k) -> delete plugin[k]
				extend @::, plugin
				for key of plugin then do (key) =>
					@[key] or= (a...) => (@::[key].apply $(a[0]), a[1...])
				if opts.provides? then @provide opts.provides
		catch error
			throw error
		@
		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)
	@depends: (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else dep.q.push (need) ->
			(needs.splice i, 1) if (i = needs.indexOf need) > -1
			return (needs.length is 0 and f)
		f
	@provide: (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data
	@provides: (needs, f) ->
		(args...) ->
			Bling.provide needs, f args...
	_type.extend
		unknown:   { array: (o) -> [o] }
		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }
	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) ->
			o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"
Bling.prototype = []
Bling.prototype.constructor = Bling
do ($ = Bling) ->
	$.global = glob = if window? then window else global
	$.plugin
		provides: "type"
	, ->
		$:
			inherit: inherit
			extend: extend
			defineProperty: defineProperty
			isType: isType
			type: _type
			is: _type.is
			as: _type.as
			isSimple: (o) -> _type(o) in ["string", "number", "bool"]
			isEmpty: (o) -> o in ["", null, undefined]
	$.plugin
		provides: "symbol"
		depends: "type"
	, ->
		symbol = null
		cache = {}
		glob.Bling = Bling
		if module?
			module.exports = Bling
		$.type.extend "bling",
			string: (o) -> symbol + "(["+ o.map($.toString).join(", ") + "])"
		defineProperty $, "symbol",
			set: (v) ->
				glob[symbol] = cache[symbol]
				cache[symbol = v] = glob[v]
				glob[v] = Bling
			get: -> symbol
		return $:
			symbol: "$"
			noConflict: ->
				Bling.symbol = "Bling"
				return Bling
	$.plugin ->
		String::trimLeft or= -> @replace(/^\s+/, "")
		String::split or= (sep) ->
			a = []; i = 0
			while (j = @indexOf sep,i) > -1
				a.push @substring(i,j)
				i = j + 1
			a
		String::lastIndexOf or= (s, c, i = -1) ->
			j = -1
			j = i while (i = s.indexOf c, i+1) > -1
			j
		Array::join or= (sep = '') ->
			n = @length
			return "" if n is 0
			s = @[n-1]
			while --n > 0
				s = @[n-1] + sep + s
			s
		if Event?
			Event::preventAll = () ->
				@preventDefault()
				@stopPropagation()
				@cancelBubble = true
		if Element?
			Element::matchesSelector = Element::webkitMatchesSelector or
				Element::mozMatchesSelector or
				Element::matchesSelector
			if Element::cloneNode.length is 0
				oldClone = Element::cloneNode
				Element::cloneNode = (deep = false) ->
					n = oldClone.call(@)
					if deep
						for i in @childNodes
							n.appendChild i.cloneNode true
					return n
		return { }
	$.plugin
		provides: "core"
		depends: "string"
	, ->
		defineProperty $, "now",
			get: -> +new Date
		index = (i, o) ->
			i += o.length while i < 0
			Math.min i, o.length
		baseTime = $.now
		return {
			$:
				log: $.extend((a...) ->
					if prefix.length > $.log.prefixSize + 2
					if a.length and $.is "string", a[0]
					else
						a.unshift prefix
					console.log a...
					return a[a.length-1] if a.length
				, prefixSize: 5)
				coalesce: (a...) -> $(a).coalesce()
			eq: (i) -> $([@[index i, @]])
			each: (f) -> (f.call(t,t) for t in @); @
			map: (f) -> $(f.call(t,t) for t in @)
			reduce: (f, a) ->
				i = 0; n = @length
				a = @[i++] if not a?
				(a = f.call @[x], a, @[x]) for x in [i...n] by 1
				return a
			union: (other, strict = true) ->
				ret = $()
				ret.push(x) for x in @ when not ret.contains(x, strict)
				ret.push(x) for x in other when not ret.contains(x, strict)
				ret
			distinct: (strict = true) -> @union @, strict
			contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
			count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
			coalesce: ->
				for i in @
					if $.type(i) in ["array","bling"] then i = $(i).coalesce()
					if i? then return i
				null
			swap: (i,j) ->
				i = index i, @
				j = index j, @
				if i isnt j
					[@[i],@[j]] = [@[j],@[i]]
				@
			shuffle: ->
				i = @length-1
				while i >= 0
					@swap --i, Math.floor(Math.random() * i)
				@
			select: (->
				getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
				select = (p) ->
					if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
					else @map(getter p)
			)()
			or: (x) -> @[i] or= x for i in [0...@length]; @
			zap: (p, v) ->
				i = p.lastIndexOf "."
				if i > 0
					head = p.substr 0,i
					tail = p.substr i+1
					@select(head).zap tail, v
					return @
				switch $.type(v)
					when "array","bling" then @each -> @[p] = v[++i % v.length]
					when "function" then @zap p, @select(p).map(v)
					else @each -> @[p] = v
				@
			clean: (prop) -> @each -> delete @[prop]
			take: (n = 1) ->
				end = Math.min n, @length
				$( @[i] for i in [0...end] )
			skip: (n = 0) ->
				start = Math.max 0, n|0
				$( @[i] for i in [start...@length] )
			first: (n = 1) -> if n is 1 then @[0] else @take(n)
			last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)
			slice: (start=0, end=@length) ->
				start = index start, @
				end = index end, @
				$( @[i] for i in [start...end] )
			extend: (b) -> @.push(i) for i in b; @
			push: (b) -> Array::push.call(@, b); @
			filter: (f) ->
				g = switch $.type f
					when "string" then (x) -> x.matchesSelector(f)
					when "regexp" then (x) -> f.test(x)
					when "function" then f
					else
				$( it for it in @ when g.call(it,it) )
			matches: (expr) -> @select('matchesSelector').call(expr)
			querySelectorAll: (expr) ->
				@filter("*")
				.reduce (a, i) ->
					a.extend i.querySelectorAll expr
				, $()
			weave: (b) ->
				c = $()
				for i in [@length-1..0] by -1
					c[(i*2)+1] = @[i]
				for i in [0...b.length] by 1
					c[i*2] = b[i]
				c
			fold: (f) ->
				n = @length
				b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
				if (n%2) is 1
					b.push( f.call @, @[n-1], undefined )
				b
			flatten: ->
				b = $()
				(b.push(j) for j in i) for i in @
				b
			call: -> @apply(null, arguments)
			apply: (context, args) ->
				@map -> if $.is "function", @ then @apply(context, args) else @
			log: (label) ->
				if label
					$.log(label, @toString(), @length + " items")
				else
					$.log(@toString(), @length + " items")
				@
			toArray: ->
				@__proto__ = Array::
		}
	$.plugin
		provides: "math"
		depends: "core"
	, ->
		$.type.extend
			bool: { number: (o) -> if o then 1 else 0 }
			number: { bool: (o) -> not not o }
		$:
			range: (start, end, step = 1) ->
				if not end? then (end = start; start = 0)
				$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
			zeros: (n) -> $( 0 for i in [0...n] )
			ones: (n) -> $( 1 for i in [0...n] )
		floats: -> @map parseFloat
		ints: -> @map -> parseInt @, 10
		px: (delta) -> @ints().map -> $.px @,delta
		min: -> @filter( isFinite ).reduce Math.min
		max: -> @filter( isFinite ).reduce Math.max
		mean: -> @sum() / @length
		avg: -> @sum() / @length
		sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
		product: -> @filter( isFinite ).reduce (a) -> a * @
		squares: -> @map -> @ * @
		magnitude: -> Math.sqrt @floats().squares().sum()
		scale: (r) -> @map -> r * @
		add: (d) -> switch $.type(d)
			when "number" then @map -> d + @
			when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
		normalize: -> @scale(1/@magnitude())
	$.plugin
		provides: "string"
		depends: "function"
	, ->
		$.type.extend
			unknown:
				string: (o) -> o.toString?() ? String(o)
				repr: (o) -> $.type.lookup(o).string(o)
				number: (o) -> parseFloat String o
			null: { string: -> "null" }
			undefined: { string: -> "undefined" }
			string:
				number: parseFloat
			array:  { string: (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
			function:
				string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
			number:
				repr:   (n) -> String(n)
				string: (n) ->
					switch true
						when n.precision? then n.toPrecision(n.precision)
						when n.fixed? then n.toFixed(n.fixed)
						else String(n)
		return {
			$:
				toString: (x) ->
					if not x? then "function Bling(selector, context) { [ ... ] }"
					else $.type.lookup(x).string(x)
				toRepr: (x) -> $.type.lookup(x).repr(x)
				px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"
				capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")
				dashize: (name) ->
					ret = ""
					for i in [0...(name?.length|0)]
						c = name.charCodeAt i
						if 91 > c > 64
							c += 32
							ret += '-'
						ret += String.fromCharCode(c)
					ret
				camelize: (name) ->
					name.split('-')
					while (i = name?.indexOf('-')) > -1
						name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
					name
				padLeft: (s, n, c = " ") ->
					while s.length < n
						s = c + s
					s
				padRight: (s, n, c = " ") ->
					while s.length < n
						s = s + c
					s
				stringCount: (s, x, i = 0, n = 0) ->
					if (j = s.indexOf x,i) > i-1
						$.stringCount s, x, j+1, n+1
					else n
				stringSplice: (s, i, j, n) ->
					nn = s.length
					end = j
					if end < 0
						end += nn
					start = i
					if start < 0
						start += nn
					s.substring(0,start) + n + s.substring(end)
				checksum: (s) ->
					a = 1; b = 0
					for i in [0...s.length]
						a = (a + s.charCodeAt(i)) % 65521
						b = (b + a) % 65521
					(b << 16) | a
				repeat: (x, n=2) ->
					switch true
						when n is 1 then x
						when n < 1 then ""
						when $.is "string", x then x + $.repeat(x, n-1)
						else $(x).extend $.repeat(x, n-1)
				stringBuilder: ->
					if $.is("global", @) then return new $.stringBuilder()
					items = []
					@length   = 0
					@append   = (s) => items.push s; @length += s?.toString().length|0
					@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
					@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
					@toString = ( ) => items.join("")
					@
			toString: -> $.toString @
			toRepr: -> $.toRepr @
		}
	$.plugin
		provides: "function"
		depends: "hash"
	, ->
		$:
			identity: (o) -> o
			not: (f) -> -> not f.apply @, arguments
			compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
			and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
			once: (f, n=1) ->
				$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
					"exhausted",
						get: -> n <= 0
			cycle: (f...) ->
				i = -1
				-> f[i = ++i % f.length].apply @, arguments
			bound: (t, f, args = []) ->
				if $.is "function", f.bind
					args.splice 0, 0, t
					r = f.bind.apply f, args
				else
					r = (a...) -> f.apply t, (args if args.length else a)
			memoize: (f) ->
				cache = {}
			E: (callback) -> (f) -> (err, data) ->
				return f(data) unless err
				callback err, data
	$.plugin
		provides: "hash"
		depends: "type"
	, ->
		$.type.extend
			unknown: { hash: (o) -> $.checksum $.toString o }
			object:  { hash: (o) ->
				$.hash(Object) +
					$($.hash(o[k]) for k of o).sum() +
					$.hash Object.keys o
			}
			array:   { hash: (o) ->
				$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
					(a*a)+(x|0)
				, 1
			}
			bool:    { hash: (o) -> parseInt(1 if o) }
		return {
			$:
				hash: (x) -> $.type.lookup(x).hash(x)
			hash: -> $.hash @
		}
	$.plugin
		provides: "pubsub"
	, ->
		return {
			$:
				publish: (e, args...) ->
					f.apply null, args for f in (subscribers[e] or= [])
					args
				publisher: (e, func) ->
					(args...) ->
						func.apply @, args
						$.publish e, args
				subscribe: (e, func) ->
					(subscribers[e] or= []).push func
					func
				unsubscribe: (e, func) ->
					if not func?
						subscribers[e] = []
					else
						a = (subscribers[e] or= [])
						if (i = a.indexOf func)  > -1
							a.splice(i,i)
		}
	$.plugin
		provides: "throttle"
		depends: "core"
	, ->
		$:
			throttle: (f,n=250,last=0) ->
				(a...) ->
					gap = $.now - last
					if gap > n
						last += gap
						return f.apply @,a
					null
				(a...) ->
					last += (gap = $.now - last)
					return f.apply @,a if gap > n else null
	$.plugin
		provides: "EventEmitter"
	, ->
		$: EventEmitter: $.pipe("bling-init").append (obj) ->
			listeners = {}
			list = (e) -> (listeners[e] or= [])
			inherit {
				emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
				addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
				on:                 (e, h) -> @addListener e, h
				removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
				removeAllListeners: (e) -> listeners[e] = []
				listeners:          (e) -> list(e).slice 0
			}, obj
(($) ->
	$.plugin
		provides: "cartesian"
	, ->
		$:
			cartesian: (sets...) ->
				n = sets.length
				ret = []
				helper = (cur, i) ->
					(return ret.push cur) if ++i >= n
					for x in sets[i]
						helper (cur.concat x), i
					null
				helper [], -1
				return $(ret)
)(Bling)
(($) ->
	$.plugin
		provides: 'config'
	, ->
		get = (name, def) -> process.env[name] ? def
		$: config: $.extend(get, get: get)
)(Bling)
(($) ->
	$.plugin
		provides: "date"
	, ->
		[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]
		units = {
			ms, s, m, h, d,
			sec: s
			second: s
			seconds: s
			min: m
			minute: m
			minutes: m
			hr: h
			hour: h
			hours: h
			day: d
			days: d
		}
		formats =
			yyyy: Date::getUTCFullYear
			mm: -> @getUTCMonth() + 1
			dd: Date::getUTCDate
			HH: Date::getUTCHours
			MM: Date::getUTCMinutes
			SS: Date::getUTCSeconds
			MS: Date::getUTCMilliseconds
		format_keys = Object.keys(formats).sort().reverse()
		parsers =
			yyyy: Date::setUTCFullYear
			mm: (x) -> @setUTCMonth(x - 1)
			dd: Date::setUTCDate
			HH: Date::setUTCHours
			MM: Date::setUTCMinutes
			SS: Date::setUTCSeconds
			MS: Date::setUTCMilliseconds
		parser_keys = Object.keys(parsers).sort().reverse()
		floor = Math.floor
		$.type.register "date",
			match: (o) -> $.isType Date, o
			array: (o) -> [o]
			string: (o, fmt, unit) -> $.date.format o, fmt, unit
			number: (o, unit) -> $.date.stamp o, unit
		$.type.extend 'string', date: (o, fmt = $.date.defaultFormat) -> new Date $.date.parse o, fmt, "ms"
		$.type.extend 'number', date: (o, unit) -> $.date.unstamp o, unit
		adder = (key) ->
			(stamp, delta, stamp_unit = $.date.defaultUnit) ->
				date = $.date.unstamp(stamp, stamp_unit)
				parsers[key].call date, (formats[key].call date) + delta
				$.date.stamp date, stamp_unit
		$:
			date:
				defaultUnit: "s"
				defaultFormat: "yyyy-mm-dd HH:MM:SS"
				stamp: (date = new Date, unit = $.date.defaultUnit) ->
					floor (date / units[unit])
				unstamp: (stamp, unit = $.date.defaultUnit) ->
					new Date floor(stamp * units[unit])
				convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
					(floor stamp * units[from] / units[to])
				midnight: (stamp, unit = $.date.defaultUnit) ->
					$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
				format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
					date = $.date.unstamp stamp, unit
					for k in format_keys
						fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
					fmt
				parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
					date = new Date(0)
					for i in [0...fmt.length] by 1
						for k in parser_keys
							if fmt.indexOf(k, i) is i
								try
									parsers[k].call date,
										parseInt dateString[i...i+k.length], 10
								catch err
					$.date.stamp date, to
				addMilliseconds: adder("MS")
				addSeconds: adder("SS")
				addMinutes: adder("MM")
				addHours: adder("HH")
				addDays: adder("dd")
				addMonths: adder("mm")
				addYears: adder("yyyy")
				range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
					add = adder(interval_unit)
					ret = [from]
					while (cur = ret[ret.length-1]) < to
						ret.push add(cur, interval, stamp_unit)
					ret
	
		midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
		unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
		stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
		dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
		dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)
)(Bling)
(($) ->
	$.plugin
		provides: "delay"
		depends: "function"
	, ->
		$:
			delay: (->
				timeoutQueue = $.extend [], (->
					next = (a) -> -> a.shift()() if a.length
					add: (f, n) ->
						f.order = n + $.now
						for i in [0..@length] by 1
							if i is @length or @[i].order > f.order
								@splice i,0,f
								break
						setTimeout next(@), n
						@
					cancel: (f) ->
						for i in [0...@length] by 1
							if @[i] == f
								@splice i, 1
								break
						@
				)()
				(n, f) ->
					if $.is("function",f) then timeoutQueue.add(f, n)
					cancel: -> timeoutQueue.cancel(f)
			)()
		delay: (n, f, c=@) ->
			$.delay n, $.bound(c, f)
			@
)(Bling)
(($) ->
	if $.global.document?
		$.plugin
			depends: "function"
			provides: "dom"
		, ->
			$.type.register "nodelist",
				match:  (o) -> o? and $.isType "NodeList", o
				hash:   (o) -> $($.hash(i) for i in x).sum()
				array:  $.identity
				string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
				node:   (o) -> $(o).toFragment()
			$.type.register "node",
				match:  (o) -> o?.nodeType > 0
				hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "fragment",
				match:  (o) -> o?.nodeType is 11
				hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "html",
				match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
				node:   (h) ->
					(node = document.createElement('div')).innerHTML = h
					if n = (childNodes = node.childNodes).length is 1
						return node.removeChild(childNodes[0])
					df = document.createDocumentFragment()
					df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
					df
				array:  (o,c) -> $.type.lookup(h = Bling.HTML.parse o).array h, c
				repr:   (o) -> '"' + o + '"'
			$.type.extend
				unknown:  { node: -> null }
				bling:    { node: (o) -> o.toFragment() }
				node:     { html: (n) ->
					d = document.createElement "div"
					d.appendChild (n = n.cloneNode true)
					ret = d.innerHTML
					ret
				}
				string:
					node:  (o) -> $(o).toFragment()
					array: (o,c) -> c.querySelectorAll?(o)
				function: { node: (o) -> $(o.toString()).toFragment() }
			toFrag = (a) ->
				if not a.parentNode?
					df = document.createDocumentFragment()
					df.appendChild(a)
				a
			before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
			after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
			toNode = (x) -> $.type.lookup(x).node(x)
			escaper = false
			parser = false
			computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue(k)
			getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select(p)
			selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )
			return {
				$:
					HTML:
						parse: (h) -> $.type.lookup(h).node(h)
						stringify: (n) -> $.type.lookup(n).html(n)
						escape: (h) ->
							escaper or= $("<div>&nbsp;</div>").child(0)
							ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
							escaper.zap('data', '')
							ret
				html: (h) ->
					return switch $.type h
						when "undefined","null" then @select 'innerHTML'
						when "string","html" then @zap 'innerHTML', h
						when "bling" then @html h.toFragment()
						when "node"
								@replaceChild @childNodes[0], h
								while @childNodes.length > 1
									@removeChild @childNodes[1]
					@each -> @appendChild x.cloneNode true
					clones = @map( -> @cloneNode true)
					i = 0
					$(x).each -> @appendChild clones[i++]
					clones
					if x?
						x = toNode(x)
						@take(1).each ->
							before @childNodes[0], x
						@skip(1).each ->
							before @childNodes[0], x.cloneNode(true)
					@
					if x?
						$(x).prepend(@)
					@
					if x?
						x = toNode(x)
						@take(1).each -> before @, x
						@skip(1).each -> before @, x.cloneNode(true)
					@
					if x?
						x = toNode(x)
						@take(1).each -> after @, x
						@skip(1).each -> after @, x.cloneNode(true)
					@
					parent = toNode(parent)
					if $.is "fragment", parent
						throw new Error("cannot call .wrap() with a fragment as the parent")
					@each (child) ->
						if ($.is "fragment", child) or not child.parentNode
							return parent.appendChild child
						grandpa = child.parentNode
						marker = document.createElement "dummy"
						parent.appendChild grandpa.replaceChild marker, child
						grandpa.replaceChild parent, marker
					@each ->
						if @parentNode and @parentNode.parentNode
							@parentNode.parentNode.replaceChild(@, @parentNode)
						else if @parentNode
							@parentNode.removeChild(@)
					n = toNode(n)
					clones = @map(-> n.cloneNode true)
					for i in [0...clones.length] by 1
						@[i].parentNode?.replaceChild clones[i], @[i]
					clones
					return switch v
						when undefined then @select("getAttribute").call(a, v)
						when null then @select("removeAttribute").call(a, v)
						else
							@select("setAttribute").call(a, v)
							@
					notempty = (y) -> y isnt ""
					@removeClass(x).each ->
						c = @className.split(" ").filter notempty
						c.push(x)
						@className = c.join " "
					notx = (y) -> y != x
					@each ->
						c = @className.split(" ").filter(notx).join(" ")
						if c.length is 0
							@removeAttribute('class')
					notx = (y) -> y isnt x
					@each ->
						cls = @className.split(" ")
						filter = $.not $.isEmpty
						if( cls.indexOf(x) > -1 )
							filter = $.and notx, filter
						else
							cls.push(x)
						c = cls.filter(filter).join(" ")
						@className = c
						if c.length is 0
							@removeAttribute('class')
					@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1
					return @zap('textContent', t) if t?
					return @select('textContent')
					return @zap('value', v) if v?
					return @select('value')
				css: (k,v) ->
					if v? or $.is "object", k
						setter = @select 'style.setProperty'
						if $.is "object", k then setter.call i, k[i], "" for i of k
						else if $.is "string", v then setter.call k, v, ""
						else if $.is "array", v
							setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
						return @
					else
						cv = @map computeCSSProperty(k)
						ov = @select('style').select k
						ov.weave(cv).fold (x,y) -> x or y
				defaultCss: (k, v) ->
					sel = @selector
					style = ""
					if $.is "string", k
						if $.is "string", v
						else throw Error("defaultCss requires a value with a string key")
					else if $.is "object", k
						"} "
					$("<style></style>").text(style).appendTo("head")
					@
				rect: -> @select('getBoundingClientRect').call()
				width: getOrSetRect("width")
				height: getOrSetRect("height")
				top: getOrSetRect("top")
				left: getOrSetRect("left")
				bottom: getOrSetRect("bottom")
				right: getOrSetRect("right")
				position: (left, top) ->
					switch true
						when not left? then @rect()
						when not top? then @css("left", $.px(left))
						else @css({top: $.px(top), left: $.px(left)})
				scrollToCenter: ->
					document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
					@
				child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]
				parents: selectChain('parentNode')
				prev: selectChain('previousSibling')
				next: selectChain('nextSibling')
				remove: -> @each -> @parentNode?.removeChild(@)
				find: (css) ->
					@filter("*")
						.map( -> $(css, @) )
						.flatten()
				clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @
				toFragment: ->
					if @length > 1
						df = document.createDocumentFragment()
						(@map toNode).map $.bound df, df.appendChild
						return df
					return toNode @[0]
			}
)(Bling)
(($) ->
	$.plugin
		depends: "dom,function,core"
		provides: "event"
	, ->
		EVENTSEP_RE = /,* +/
		events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
			'load','unload','reset','submit','keyup','keydown','change',
			'abort','cut','copy','paste','selection','drag','drop','orientationchange',
			'touchstart','touchmove','touchend','touchcancel',
			'gesturestart','gestureend','gesturecancel',
			'hashchange'
		]
		binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)
		register_live = (selector, context, evt, f, h) ->
			$(context).bind(evt, h)
				.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h
		unregister_live = (selector, context, e, f) ->
			$c = $(context)
			$c.each ->
				a = (@__alive__ or= {})
				b = (a[selector] or= {})
				c = (b[e] or= {})
				$c.unbind(e, c[f])
				delete c[f]
		triggerReady = $.once ->
			$(document).trigger("ready").unbind("ready")
			document.removeEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.removeEventListener?("load", triggerReady, false)
		bindReady = $.once ->
			document.addEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.addEventListener?("load", triggerReady, false)
		bindReady()
		ret = {
			bind: (e, f) ->
				c = (e or "").split(EVENTSEP_RE)
				h = (evt) ->
					ret = f.apply @, arguments
					if ret is false
						evt.preventAll()
					ret
				@each -> (@addEventListener i, h, false) for i in c
			unbind: (e, f) ->
				c = (e or "").split EVENTSEP_RE
				@each -> (@removeEventListener i, f, null) for i in c
			trigger: (evt, args = {}) ->
				args = $.extend
					bubbles: true
					cancelable: true
				, args
				for evt_i in (evt or "").split(EVENTSEP_RE)
						e = document.createEvent "MouseEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							button: 0,
							relatedTarget: null
						, args
						e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.button, args.relatedTarget
						e = document.createEvent "UIEvents"
						e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1
						e = document.createEvent "TouchEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							touches: [],
							targetTouches: [],
							changedTouches: [],
							scale: 1.0,
							rotation: 0.0
						, args
						e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)
						e = document.createEvent "GestureEvents"
						args = $.extend {
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							target: null,
							scale: 1.0,
							rotation: 0.0
						}, args
						e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.target, args.scale, args.rotation
					else
						e = document.createEvent "Events"
						e.initEvent evt_i, args.bubbles, args.cancelable
						try
							e = $.extend e, args
						catch err
					if not e
						continue
					else
						try
							@each -> @dispatchEvent e
						catch err
							$.log "dispatchEvent error:", err
				@
			live: (e, f) ->
				selector = @selector
				context = @context
				handler = (evt) ->
					$(selector, context)
						.intersect($(evt.target).parents().first().union($(evt.target)))
						.each -> f.call(evt.target = @, evt)
				register_live selector, context, e, f, handler
				@
			die: (e, f) ->
				$(@context).unbind e, unregister_live(@selector, @context, e, f)
				@
			click: (f = {}) ->
				if @css("cursor") in ["auto",""]
					@css "cursor", "pointer"
				if $.is "function", f then @bind 'click', f
				else @trigger 'click', f
				@
			ready: (f) ->
				return (f.call @) if triggerReady.exhausted
				@bind "ready", f
		}
		events.forEach (x) -> ret[x] = binder(x)
		return ret
)(Bling)
(($) ->
	$.plugin ->
		$:
			histogram: (data, bucket_width=1, output_width=80) ->
				buckets = $()
				len = 0
				for x in data
					i = Math.floor( x / bucket_width )
					buckets[i] ?= 0
					buckets[i] += 1
					len = Math.max(len, i+1)
				buckets.length = len
				max = buckets.max()
				buckets = buckets.map((x) -> x or 0)
					.scale(1/max)
					.scale(output_width)
				sum = buckets.sum()
				ret = ""
				for n in [0...len] by 1
					end = (n+1) * bucket_width
					pct = (buckets[n]*100/sum).toFixed(0)
				ret
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->
		$.type.register "http",
			match: (o) -> $.isType 'XMLHttpRequest', o
			array: (o) -> [o]
		return {
			$:
				http: (url, opts = {}) ->
					xhr = new XMLHttpRequest()
					if $.is "function", opts
						opts = success: $.bound(xhr, opts)
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts
					opts.state = $.bound(xhr, opts.state)
					opts.success = $.bound(xhr, opts.success)
					opts.error = $.bound(xhr, opts.error)
					if opts.data and opts.method is "GET"
						url += "?" + formencode(opts.data)
					else if opts.data and opts.method is "POST"
						opts.data = formencode(opts.data)
					xhr.open(opts.method, url, opts.async)
					xhr = $.extend xhr,
						asBlob: opts.asBlob
						timeout: opts.timeout
						followRedirects: opts.followRedirects
						withCredentials: opts.withCredentials
						onreadystatechange: ->
							opts.state?()
							if xhr.readyState is 4
								if xhr.status is 200
									opts.success xhr.responseText
								else
									opts.error xhr.status, xhr.statusText
					xhr.send opts.data
					return $(xhr)
				post: (url, opts = {}) ->
					if $.is("function",opts)
						opts = success: opts
					opts.method = "POST"
					$.http(url, opts)
				get: (url, opts = {}) ->
					if( $.is("function",opts) )
						opts = success: opts
					opts.method = "GET"
					$.http(url, opts)
		}
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "lazy"
	, ->
		lazy_load = (elementName, props) ->
			$("head").append $.extend document.createElement(elementName), props
		$:
			script: (src) ->
				lazy_load "script", { src: src }
			style: (src) ->
				lazy_load "link", { href: src, rel: "stylesheet" }
)(Bling)
(($) ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""
		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615
		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)
			index = (index + 1) % 624
			(y + a) / b
		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()
		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
	)()
	$.plugin
		provides: "random"
	, ->
		$:
			random: random
)(Bling)
(($) ->
	$.plugin
		provides: "sendgrid"
		depends: "config"
	, ->
		try
			nodemailer = require 'nodemailer'
		catch err
			`return`
		transport = nodemailer.createTransport 'SMTP',
			service: 'SendGrid'
			auth:
				user: $.config.get 'SENDGRID_USERNAME'
		$:
			sendMail: (mail, callback) ->
				mail.transport ?= transport
				mail.from ?= $.config.get 'EMAILS_FROM'
				mail.bcc ?= $.config.get 'EMAILS_BCC'
				if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
					nodemailer.sendMail mail, callback
				else
)(Bling)
(($) ->
	$.plugin
		provides: "StateMachine"
	, ->
		$: StateMachine: class StateMachine
			constructor: (stateTable) ->
				@debug = false
				@reset()
				@table = stateTable
				Object.defineProperty @, "modeline",
					get: -> @table[@_mode]
				Object.defineProperty @, "mode",
					set: (m) ->
						@_lastMode = @_mode
						@_mode = m
						if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
							ret = @modeline['enter'].call @
							while $.is("function",ret)
								ret = ret.call @
						m
					get: -> @_mode
			reset: ->
				@_mode = null
				@_lastMode = null
			GO: (m) -> -> @mode = m
			@GO: (m) -> -> @mode = m
			
			tick: (c) ->
				row = @modeline
				if not row?
					ret = null
				else if c of row
					ret = row[c]
				else if 'def' of row
					ret = row['def']
				while $.is "function",ret
					ret = ret.call @, c
				ret
			run: (inputs) ->
				@mode = 0
				for c in inputs
					ret = @tick(c)
				if $.is "function",@modeline?.eof
					ret = @modeline.eof.call @
				while $.is "function",ret
					ret = ret.call @
				@reset()
				return @
	$.plugin
		provides: "synth"
		depends: "StateMachine"
	, ->
		class SynthMachine extends $.StateMachine
			basic =
				".": @GO 3
				"[": @GO 4
				'"': @GO 6
				"'": @GO 7
				" ": @GO 8
				",": @GO 10
				"+": @GO 11
				eof: @GO 13
			@STATE_TABLE = [
					enter: ->
						@tag = @id = @cls = @attr = @val = @text = ""
						@attrs = {}
						@GO 1
				},
					def: (c) -> @tag += c
				}, basic),
					def: (c) -> @id += c
				}, basic),
					enter: -> @cls += " " if @cls.length > 0
					def: (c) -> @cls += c
				}, basic),
					"=": @GO 5
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @attr += c
					eof: @GO 12
				},
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @val += c
					eof: @GO 12
				},
					'"': @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					"'": @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					enter: ->
						@emitNode() if @tag
						@emitText() if @text
						@GO 0
				},
					enter: ->
						@emitNode()
						@cursor = null
						@GO 0
				},
					enter: ->
						@emitNode()
						@cursor = @cursor?.parentNode
						@GO 0
				},
				},
					enter: ->
						@emitNode() if @tag
						@emitText() if @text
				}
			]
			constructor: ->
				super(SynthMachine.STATE_TABLE)
				@fragment = @cursor = document.createDocumentFragment()
			emitNode: ->
				if @tag
					node = document.createElement @tag
					node.id = @id or null
					node.className = @cls or null
					for k of @attrs
						node.setAttribute k, @attrs[k]
					@cursor.appendChild node
					@cursor = node
			emitText: ->
				@cursor.appendChild $.type.lookup("<html>").node(@text)
				@text = ""
		return {
			$:
				synth: (expr) ->
					s = new SynthMachine()
					s.run(expr)
					if s.fragment.childNodes.length == 1
						$(s.fragment.childNodes[0])
					else
						$(s.fragment)
		}
)(Bling)
(($) ->
		current_engine = null
		engines = {}
		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine
		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()
		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop]
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1
	$.template.register_engine 'pythonic', (() ->
		chunk_re = /%[\(\/]/
		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n]
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}
			if not cache?
			n = cache.length
			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""
		return render
	)()
		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
)(Bling)
(($) ->
		parseOne = (data) ->
			i = data.indexOf ":"
			if i > 0
				len = parseInt data[0...i], 10
				item = data[i+1...i+1+len]
				type = data[i+1+len]
				extra = data[i+len+2...]
				item = switch type
					when "'" then String(item)
					when "!" then (item is "true")
					when "~" then null
					when "]" then parseArray(item)
					when "}" then parseObject(item)
				return [item, extra]
			return undefined
		parseArray = (x) ->
			data = []
			while x.length > 0
				[one, x] = parseOne(x)
				data.push(one)
			data
		parseObject = (x) ->
			data = {}
			while x.length > 0
				[key, x] = parseOne(x)
				[value, x] = parseOne(x)
				data[key] = value
			data
		$:
			TNET:
				stringify: (x) ->
					[data, type] = switch $.type x
						when "string" then [x, "'"]
						when "function" then [String(x), "'"]
						when "boolean" then [String(not not x), "!"]
						when "null" then ["", "~"]
						when "undefined" then ["", "~"]
						when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
						when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
					return (data.length|0) + ":" + data + type
				parse: (x) ->
					parseOne(x)?[0]
)(Bling)
(($) ->
	$.plugin
		provides: "trace"
		depends: "function,type"
	, ->
		$.type.extend
			unknown: { trace: $.identity }
			function:
				trace: (label, f, tracer) ->
					label or= f.name
					r = (a...) ->
						f.apply @, a
					r
		return $: trace: (label, o, tracer) ->
			if not $.is "string", label
				[tracer, o] = [o, label]
			tracer or= $.log
			label or= ""
			$.type.lookup(o).trace(label, o, tracer)
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
	, ->
		COMMASEP = ", "
			"slow": 700
			"medium": 500
			"normal": 300
			"fast": 100
			"instant": 0
			"now": 0
		accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
		testStyle = document.createElement("div").style
		transformProperty = "transform"
		transitionProperty = "transition-property"
		transitionDuration = "transition-duration"
		transitionTiming = "transition-timing-function"
		if "WebkitTransform" of testStyle
			transformProperty = "-webkit-transform"
			transitionProperty = "-webkit-transition-property"
			transitionDuration = "-webkit-transition-duration"
			transitionTiming = "-webkit-transition-timing-function"
		else if "MozTransform" of testStyle
			transformProperty = "-moz-transform"
			transitionProperty = "-moz-transition-property"
			transitionDuration = "-moz-transition-duration"
			transitionTiming = "-moz-transition-timing-function"
		else if "OTransform" of testStyle
			transformProperty = "-o-transform"
			transitionProperty = "-o-transition-property"
			transitionDuration = "-o-transition-duration"
			transitionTiming = "-o-transition-timing-function"
		return {
			$:
				duration: (speed) ->
					d = speeds[speed]
					return d if d?
					return parseFloat speed
			transform: (end_css, speed, easing, callback) ->
				if $.is("function",speed)
					callback = speed
					speed = easing = null
				else if $.is("function",easing)
					callback = easing
					easing = null
				speed ?= "normal"
				easing or= "ease"
				duration = $.duration(speed) + "ms"
				props = []
				trans = ""
				css = {}
				for i of end_css
					if accel_props_re.test(i)
						ii = end_css[i]
						if ii.join
							ii = $(ii).px().join COMMASEP
						else if ii.toString
							ii = ii.toString()
						trans += " " + i + "(" + ii + ")"
					else css[i] = end_css[i]
				(props.push i) for i of css
				if trans
					props.push transformProperty
				css[transitionProperty] = props.join COMMASEP
				css[transitionDuration] = props.map(-> duration).join COMMASEP
				css[transitionTiming] = props.map(-> easing).join COMMASEP
				if trans
					css[transformProperty] = trans
				@css css
				@delay duration, callback
				@each ->
					if @style
						if @style.display is not "none"
							@_display = @syle.display
						@style.display = "none"
				.trigger "hide"
				.delay updateDelay, callback
				@each ->
					if @style
						@style.display = @_display
						delete @_display
				.trigger "show"
				.delay updateDelay, callback
				@weave(@css("display"))
					.fold (display, node) ->
						if display is "none"
							node.style.display = node._display or ""
							delete node._display
							$(node).trigger "show"
						else
							node._display = display
							node.style.display = "none"
							$(node).trigger "hide"
						node
					.delay(updateDelay, callback)
				@.css('opacity','0.0')
					.show ->
						@transform {
							opacity:"1.0",
							translate3d: [0,0,0]
						}, speed, callback
				@transform {
					opacity:"0.0",
					translate3d:[x,y,0.0]
				}, speed, -> @hide(callback)
			fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
			fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
			fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
			fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
		}
)(Bling)
(($) ->
	$.plugin
		provides: "unittest"
		depends: "core,function"
	, ->
		testCount = passCount = failCount = 0
		failed = []
		invokeTest = (group, name, func) ->
			return if not $.is "function", func
			shouldFail = name.toLowerCase().indexOf("fail") isnt -1
			done = $.once (err) ->
				testCount--
				if (!!err isnt shouldFail)
					failCount++
					failed.push name
				else
					_log "pass"
					passCount++
					$.provide name
			f = (done) ->
				try func(done)
				catch err then done(err)
				finally
					if name.toLowerCase().indexOf("async") is -1 then done()
			testCount++
			try f(done)
			catch err then done(err)
		testReport = $.once ->
		$:
			approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
			assertEqual: (a, b, label) ->
				if a isnt b
			assertArrayEqual: (a, b, label) ->
				for i in [0...a.length] by 1
					try
						$.assertEqual(a[i], b[i], label)
					catch err
			testGroup: (name, funcs) ->
				interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
				for k,func of funcs
					invokeTest(name, k, func)
		assertEqual: (args...) ->
					if $.is "function", x then x.call(@,@) else x
				a = args[0]
				for i in [1...args.length]
					$.assertEqual a, args[i]
			return @
)(Bling)
(($) ->
	$.plugin
		provides: "cartesian"
	, ->
		$:
			cartesian: (sets...) ->
				n = sets.length
				ret = []
				helper = (cur, i) ->
					(return ret.push cur) if ++i >= n
					for x in sets[i]
						helper (cur.concat x), i
					null
				helper [], -1
				return $(ret)

)(Bling)
(($) ->
	$.plugin
		provides: 'config'
	, ->
		get = (name, def) -> process.env[name] ? def
		$: config: $.extend(get, get: get)
)(Bling)

(($) ->
	$.plugin
		provides: "date"
	, ->
		[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]

		units = {
			ms, s, m, h, d,
			sec: s
			second: s
			seconds: s
			min: m
			minute: m
			minutes: m
			hr: h
			hour: h
			hours: h
			day: d
			days: d
		}

		formats =
			yyyy: Date::getUTCFullYear
			mm: -> @getUTCMonth() + 1
			dd: Date::getUTCDate
			HH: Date::getUTCHours
			MM: Date::getUTCMinutes
			SS: Date::getUTCSeconds
			MS: Date::getUTCMilliseconds
		format_keys = Object.keys(formats).sort().reverse()

		parsers =
			yyyy: Date::setUTCFullYear
			mm: (x) -> @setUTCMonth(x - 1)
			dd: Date::setUTCDate
			HH: Date::setUTCHours
			MM: Date::setUTCMinutes
			SS: Date::setUTCSeconds
			MS: Date::setUTCMilliseconds
		parser_keys = Object.keys(parsers).sort().reverse()

		floor = Math.floor

		$.type.register "date",
			match: (o) -> $.isType Date, o
			array: (o) -> [o]
			string: (o, fmt, unit) -> $.date.format o, fmt, unit
			number: (o, unit) -> $.date.stamp o, unit

		$.type.extend 'string', date: (o, fmt = $.date.defaultFormat) -> new Date $.date.parse o, fmt, "ms"
		$.type.extend 'number', date: (o, unit) -> $.date.unstamp o, unit

		adder = (key) ->
			(stamp, delta, stamp_unit = $.date.defaultUnit) ->
				date = $.date.unstamp(stamp, stamp_unit)
				parsers[key].call date, (formats[key].call date) + delta
				$.date.stamp date, stamp_unit

		$:
			date:
				defaultUnit: "s"
				defaultFormat: "yyyy-mm-dd HH:MM:SS"
				stamp: (date = new Date, unit = $.date.defaultUnit) ->
					floor (date / units[unit])
				unstamp: (stamp, unit = $.date.defaultUnit) ->
					new Date floor(stamp * units[unit])
				convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
					(floor stamp * units[from] / units[to])
				midnight: (stamp, unit = $.date.defaultUnit) ->
					$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
				format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
					date = $.date.unstamp stamp, unit
					for k in format_keys
						fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
					fmt
				parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
					date = new Date(0)
					for i in [0...fmt.length] by 1
						for k in parser_keys
							if fmt.indexOf(k, i) is i
								try
									parsers[k].call date,
										parseInt dateString[i...i+k.length], 10
								catch err
					$.date.stamp date, to
				addMilliseconds: adder("MS")
				addSeconds: adder("SS")
				addMinutes: adder("MM")
				addHours: adder("HH")
				addDays: adder("dd")
				addMonths: adder("mm")
				addYears: adder("yyyy")
				range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
					add = adder(interval_unit)
					ret = [from]
					while (cur = ret[ret.length-1]) < to
						ret.push add(cur, interval, stamp_unit)
					ret
	
		midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
		unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
		stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
		dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
		dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)

)(Bling)

(($) ->

	$.plugin
		provides: "delay"
		depends: "function"
	, ->
		$:
			delay: (->
				timeoutQueue = $.extend [], (->
					next = (a) -> -> a.shift()() if a.length
					add: (f, n) ->
						f.order = n + $.now
						for i in [0..@length] by 1
							if i is @length or @[i].order > f.order
								@splice i,0,f
								break
						setTimeout next(@), n
						@
					cancel: (f) ->
						for i in [0...@length] by 1
							if @[i] == f
								@splice i, 1
								break
						@
				)()

				(n, f) ->
					if $.is("function",f) then timeoutQueue.add(f, n)
					cancel: -> timeoutQueue.cancel(f)

			)()

		delay: (n, f, c=@) ->
			$.delay n, $.bound(c, f)
			@

)(Bling)
(($) ->
	if $.global.document?
		$.plugin
			depends: "function"
			provides: "dom"
		, ->
			$.type.register "nodelist",
				match:  (o) -> o? and $.isType "NodeList", o
				hash:   (o) -> $($.hash(i) for i in x).sum()
				array:  $.identity
				string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
				node:   (o) -> $(o).toFragment()
			$.type.register "node",
				match:  (o) -> o?.nodeType > 0
				hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "fragment",
				match:  (o) -> o?.nodeType is 11
				hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "html",
				match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
				node:   (h) ->
					(node = document.createElement('div')).innerHTML = h
					if n = (childNodes = node.childNodes).length is 1
						return node.removeChild(childNodes[0])
					df = document.createDocumentFragment()
					df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
					df
				array:  (o,c) -> $.type.lookup(h = Bling.HTML.parse o).array h, c
				repr:   (o) -> '"' + o + '"'
			$.type.extend
				unknown:  { node: -> null }
				bling:    { node: (o) -> o.toFragment() }
				node:     { html: (n) ->
					d = document.createElement "div"
					d.appendChild (n = n.cloneNode true)
					ret = d.innerHTML
					ret
				}
				string:
					node:  (o) -> $(o).toFragment()
					array: (o,c) -> c.querySelectorAll?(o)
				function: { node: (o) -> $(o.toString()).toFragment() }

			toFrag = (a) ->
				if not a.parentNode?
					df = document.createDocumentFragment()
					df.appendChild(a)
				a
			before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
			after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
			toNode = (x) -> $.type.lookup(x).node(x)
			escaper = false
			parser = false

			computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue(k)

			getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select(p)

			selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )

			return {
				$:

					HTML:
						parse: (h) -> $.type.lookup(h).node(h)
						stringify: (n) -> $.type.lookup(n).html(n)
						escape: (h) ->
							escaper or= $("<div>&nbsp;</div>").child(0)
							ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
							escaper.zap('data', '')
							ret

				html: (h) ->
					return switch $.type h
						when "undefined","null" then @select 'innerHTML'
						when "string","html" then @zap 'innerHTML', h
						when "bling" then @html h.toFragment()
						when "node"
								@replaceChild @childNodes[0], h
								while @childNodes.length > 1
									@removeChild @childNodes[1]

					@each -> @appendChild x.cloneNode true

					clones = @map( -> @cloneNode true)
					i = 0
					$(x).each -> @appendChild clones[i++]
					clones

					if x?
						x = toNode(x)
						@take(1).each ->
							before @childNodes[0], x
						@skip(1).each ->
							before @childNodes[0], x.cloneNode(true)
					@

					if x?
						$(x).prepend(@)
					@

					if x?
						x = toNode(x)
						@take(1).each -> before @, x
						@skip(1).each -> before @, x.cloneNode(true)
					@

					if x?
						x = toNode(x)
						@take(1).each -> after @, x
						@skip(1).each -> after @, x.cloneNode(true)
					@

					parent = toNode(parent)
					if $.is "fragment", parent
						throw new Error("cannot call .wrap() with a fragment as the parent")
					@each (child) ->
						if ($.is "fragment", child) or not child.parentNode
							return parent.appendChild child
						grandpa = child.parentNode
						marker = document.createElement "dummy"
						parent.appendChild grandpa.replaceChild marker, child
						grandpa.replaceChild parent, marker

					@each ->
						if @parentNode and @parentNode.parentNode
							@parentNode.parentNode.replaceChild(@, @parentNode)
						else if @parentNode
							@parentNode.removeChild(@)

					n = toNode(n)
					clones = @map(-> n.cloneNode true)
					for i in [0...clones.length] by 1
						@[i].parentNode?.replaceChild clones[i], @[i]
					clones

					return switch v
						when undefined then @select("getAttribute").call(a, v)
						when null then @select("removeAttribute").call(a, v)
						else
							@select("setAttribute").call(a, v)
							@


					notempty = (y) -> y isnt ""
					@removeClass(x).each ->
						c = @className.split(" ").filter notempty
						c.push(x)
						@className = c.join " "

					notx = (y) -> y != x
					@each ->
						c = @className.split(" ").filter(notx).join(" ")
						if c.length is 0
							@removeAttribute('class')

					notx = (y) -> y isnt x
					@each ->
						cls = @className.split(" ")
						filter = $.not $.isEmpty
						if( cls.indexOf(x) > -1 )
							filter = $.and notx, filter
						else
							cls.push(x)
						c = cls.filter(filter).join(" ")
						@className = c
						if c.length is 0
							@removeAttribute('class')

					@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1

					return @zap('textContent', t) if t?
					return @select('textContent')

					return @zap('value', v) if v?
					return @select('value')

				css: (k,v) ->
					if v? or $.is "object", k
						setter = @select 'style.setProperty'
						if $.is "object", k then setter.call i, k[i], "" for i of k
						else if $.is "string", v then setter.call k, v, ""
						else if $.is "array", v
							setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
						return @
					else
						cv = @map computeCSSProperty(k)
						ov = @select('style').select k
						ov.weave(cv).fold (x,y) -> x or y

				defaultCss: (k, v) ->
					sel = @selector
					style = ""
					if $.is "string", k
						if $.is "string", v
						else throw Error("defaultCss requires a value with a string key")
					else if $.is "object", k
						"} "
					$("<style></style>").text(style).appendTo("head")
					@

				rect: -> @select('getBoundingClientRect').call()

				width: getOrSetRect("width")

				height: getOrSetRect("height")

				top: getOrSetRect("top")

				left: getOrSetRect("left")

				bottom: getOrSetRect("bottom")

				right: getOrSetRect("right")

				position: (left, top) ->
					switch true
						when not left? then @rect()
						when not top? then @css("left", $.px(left))
						else @css({top: $.px(top), left: $.px(left)})

				scrollToCenter: ->
					document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
					@

				child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]

				parents: selectChain('parentNode')

				prev: selectChain('previousSibling')

				next: selectChain('nextSibling')

				remove: -> @each -> @parentNode?.removeChild(@)

				find: (css) ->
					@filter("*")
						.map( -> $(css, @) )
						.flatten()

				clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @

				toFragment: ->
					if @length > 1
						df = document.createDocumentFragment()
						(@map toNode).map $.bound df, df.appendChild
						return df
					return toNode @[0]
			}
)(Bling)
(($) ->
	$.plugin
		depends: "dom,function,core"
		provides: "event"
	, ->
		EVENTSEP_RE = /,* +/
		events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
			'load','unload','reset','submit','keyup','keydown','change',
			'abort','cut','copy','paste','selection','drag','drop','orientationchange',
			'touchstart','touchmove','touchend','touchcancel',
			'gesturestart','gestureend','gesturecancel',
			'hashchange'
		]

		binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)

		register_live = (selector, context, evt, f, h) ->
			$(context).bind(evt, h)
				.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h

		unregister_live = (selector, context, e, f) ->
			$c = $(context)
			$c.each ->
				a = (@__alive__ or= {})
				b = (a[selector] or= {})
				c = (b[e] or= {})
				$c.unbind(e, c[f])
				delete c[f]

		triggerReady = $.once ->
			$(document).trigger("ready").unbind("ready")
			document.removeEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.removeEventListener?("load", triggerReady, false)
		bindReady = $.once ->
			document.addEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.addEventListener?("load", triggerReady, false)
		bindReady()

		ret = {
			bind: (e, f) ->
				c = (e or "").split(EVENTSEP_RE)
				h = (evt) ->
					ret = f.apply @, arguments
					if ret is false
						evt.preventAll()
					ret
				@each -> (@addEventListener i, h, false) for i in c

			unbind: (e, f) ->
				c = (e or "").split EVENTSEP_RE
				@each -> (@removeEventListener i, f, null) for i in c

			trigger: (evt, args = {}) ->
				args = $.extend
					bubbles: true
					cancelable: true
				, args

				for evt_i in (evt or "").split(EVENTSEP_RE)
						e = document.createEvent "MouseEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							button: 0,
							relatedTarget: null
						, args
						e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.button, args.relatedTarget

						e = document.createEvent "UIEvents"
						e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1

						e = document.createEvent "TouchEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							touches: [],
							targetTouches: [],
							changedTouches: [],
							scale: 1.0,
							rotation: 0.0
						, args
						e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)

						e = document.createEvent "GestureEvents"
						args = $.extend {
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							target: null,
							scale: 1.0,
							rotation: 0.0
						}, args
						e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.target, args.scale, args.rotation

					else
						e = document.createEvent "Events"
						e.initEvent evt_i, args.bubbles, args.cancelable
						try
							e = $.extend e, args
						catch err

					if not e
						continue
					else
						try
							@each -> @dispatchEvent e
						catch err
							$.log "dispatchEvent error:", err
				@

			live: (e, f) ->
				selector = @selector
				context = @context
				handler = (evt) ->
					$(selector, context)
						.intersect($(evt.target).parents().first().union($(evt.target)))
						.each -> f.call(evt.target = @, evt)
				register_live selector, context, e, f, handler
				@

			die: (e, f) ->
				$(@context).unbind e, unregister_live(@selector, @context, e, f)
				@

			click: (f = {}) ->
				if @css("cursor") in ["auto",""]
					@css "cursor", "pointer"
				if $.is "function", f then @bind 'click', f
				else @trigger 'click', f
				@

			ready: (f) ->
				return (f.call @) if triggerReady.exhausted
				@bind "ready", f
		}

		events.forEach (x) -> ret[x] = binder(x)
		return ret
)(Bling)

(($) ->
	$.plugin
		depends: "experimental"
	, ->
		pruners = {}
		register = (type, f) -> (pruners[type] = f)
		lookup = (obj) -> pruners[obj.t or obj.type]
		stack = []

		$.type.extend null,        { compact: (o) -> $.toString(o) }
		$.type.extend "undefined", { compact: (o) -> "" }
		$.type.extend "null",      { compact: (o) -> "" }
		$.type.extend "string",    { compact: $.identity }
		$.type.extend "array",     { compact: (o) -> (Object.Compact(x) for x in o).join("") }
		$.type.extend "bling",     { compact: (o) -> o.map(Object.Compact).join("") }
		$.type.extend "object",    { compact: (o) -> Object.Compact(lookup(o)?.call o, o) }

		Object.Compact = (o) ->
			stack.push(o)
			$.type.lookup(o)?.compact(o)
			stack.pop()
		$.extend Object.Compact,
			register: register
			lookup: lookup

		register 'page', -> [
			"<!DOCTYPE html><html><head>",
				@head,
			"</head><body>",
				@body,
			"</body></html>"
		]
		register 'text', -> @EN
		register 'link', ->
			a = $(["<a"])
			a.extend(" ",k,"='",@[k],"'") for k in ["href","name","target"] when k of @
			a.extend(">",node.content,"</a>")

		$.assert(Object.Compact({ t: "page", head: [], body: {type: "text", EN: "Hello World"} }) is
			"<!DOCTYPE html><html><head></head><body>Hello World</body></html>")

		return { name: "Compact" }
)(Bling)

(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'ClientRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts

				post: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "POST"
					$.http url, opts

				get: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "GET"
					$.http url, opts
		}
)(Bling)
(($) ->
		operatorHtml = "<span class='opr'>$&</span>"
		keywords = /\b[Ff]unction\b|\bvar\b|\.prototype\b|\.__proto__\b|\bString\b|\bArray\b|\bNumber\b|\bObject\b|\bbreak\b|\bcase\b|\bcontinue\b|\bdelete\b|\bdo\b|\bif\b|\belse\b|\bfinally\b|\binstanceof\b|\breturn\b|\bthrow\b|\btry\b|\btypeof\b|\btrue\b|\bfalse\b/g
		keywordHtml = "<span class='kwd'>$&</span>"
		allNumbers = /\d+\.*\d*/g
		numberHtml = "<span class='num'>$&</span>"
		blingSymbol = /\$(\(|\.)/g
		blingHtml = "<span class='bln'>$$</span>$1"
		tabs = /\t/g
		tabHtml = "&nbsp;&nbsp;"
		singlelineComment = /\/\/.*?(?:\n|$)/
		multilineComment = /\/\*(?:.|\n)*?\*\//
		commentHtml = (comment) ->
		quotedHtml = (quoted) ->

			a = s.indexOf('"', i)
			b = s.indexOf("'", i)
			a = s.length if a is -1
			b = s.length if b is -1
			return [null, -1] if a is b
			return ['"', a] if a < b
			return ["'", b]
			r = s.indexOf(q, i)
			while( s.charAt(r-1) is "\\" and 0 < r < s.length)
				r = s.indexOf(q, r+1)
			r
			i = 0
			n = s.length
			ret = []
			if not Object.IsString(s)
				if not Object.IsFunction(s.toString)
					throw TypeError("invalid string argument to split_quoted")
				else
					s = s.toString()
					n = s.length
			while( i < n )
				q = firstQuote(s, i)
				j = q[1]
				if( j is -1 )
					ret.push(s.substring(i))
					break
				ret.push(s.substring(i,j))
				k = closingQuote(s, j+1, q[0])
				if( k is -1 )
					throw Error("unclosed quote: "+q[0]+" starting at "+j)
				ret.push(s.substring(j, k+1))
				i = k+1
			ret

		firstComment = (s) ->
			a = s.match(singlelineComment)
			b = s.match(multilineComment)
			return [-1, null] if a is b
			return [b.index, b[0]] if a == null and b != null
			return [a.index, a[0]] if a != null && b == null
			return [b.index, b[0]] if b.index < a.index
			return [a.index, a[0]]

		splitComments = (s) ->
			ret = []
			i = 0
			n = s.length
			while( i < n )
				ss = s.substring(i)
				q = firstComment(ss)
				j = q[0]
				if( j > -1 )
					ret.push(ss.substring(0,j))
					ret.push(q[1])
					i += j + q[1].length
				else
					ret.push(ss)
					break
			ret

		foldCodeAndQuoted = (code, quoted) ->
			code.replace(operators, operatorHtml).replace(allNumbers, numberHtml).replace(keywords, keywordHtml).replace(blingSymbol, blingHtml).replace(tabs, tabHtml) + quotedHtml(quoted)

		foldTextAndComments = (text, comment) ->
			$(splitQuoted(text)).fold(foldCodeAndQuoted).join('') + commentHtml(comment)

		return {
			name: "PrettyPrint"
			$:
				prettyPrint: (js, colors) ->
					js = js.toString() if Object.IsFunction(js)
					if not Object.IsString(js)
						throw TypeError("prettyPrint requires a function or string to format, not '"+Object.Type(js)+"'")
						css = "code.pp .bln { font-size: 17px; } "
						colors = Object.Extend(
						, colors)
						for cls of colors
							.text(css)
							.appendTo("head")
					ret = "<code class='pp'>" + ($(splitComments(js)).fold(foldTextAndComments).join('')) + "</code>"
		}

)(Bling)
require "../../dist/bling"

do ($ = Bling) ->

	$.plugin
		provides: "text-analysis"
	, ->
		indices = $.memoize (str, substr) ->
			switch substr.length
				when 0 then $.range 0, str.length
				when 1
					i = -1
					i while (i = str.indexOf substr, i+1) > -1
				else
					subsub = substr[0...substr.length-1]
					indices(str, subsub).filter (x) -> str.indexOf(substr,x) is x

		ld = $.memoize (s, t) ->
			switch true
				when not s then t.length
				when not t then s.length
				when s is t then 0
				when s[0] is t[0] then ld s[1..],t[1..]
				else 1 + Math.min(
					ld(s, t[1..]),
					ld(s[1..], t),
					ld(s[1..], t[1..])
				)

		commonSubstrings = (a,b,min_length=1,limit=1) ->
			a = a.toLowerCase()
			b = b.toLowerCase()
			ret = {}
			for i in [0...b.length]
				for j in [0...b.length]
					if (j - i) < min_length-1 then continue
					c = b[i..j]
					if (indices a,c).length > 0
							ret[c] = 1
			$(Object.keys ret)
				.sort((x,y) -> y.length - x.length)
				.take(limit)

		$:
			stringDistance: ld
			stringsInCommon: commonSubstrings

(($) ->

	$.plugin () ->

		Dialog = (selector, opts) ->
			opts = $.extend({
				autoOpen: false
				draggable: true
			}, opts)
			dialog = $(selector)
				.addClass("dialog")
			if opts.draggable
				dialog.draggable()
			if opts.autoOpen
				dialog.show().center()
			dialog
				.find("button.close, .close-button")
				.bind "click touchstart", () ->
					dialog.hide()
					false
			dialog
		
		Draggable = (selector, opts) ->
			opts = $.extend({
				handleCSS: {}
			}, opts)

			opts.handleCSS = $.extend({
				position: "absolute"
				top: "0px"
				left: "0px"
				width: "100%"
				height: "6px"
			}, opts.handleCSS)

			dragObject = $(selector)
			moving = false
			oX = oY = 0
			handle = $
				.synth("div.handle")
				.defaultCss({
					height: "6px"
					"border-radius": "3px"
					cursor: "move"
				})
				.css(opts.handleCSS)
				.bind 'mousedown, touchstart', (evt) ->
					moving = true
					oX or= evt.pageX
					oY or= evt.pageY
					false
			$(document)
			.bind 'mousemove, touchmove', (evt) ->
				if moving
					dX = (evt.pageX - oX)
					dY = (evt.pageY - oY)
					dragObject.transform({
						translate: [ dX, dY ]
					}, 0)
					.trigger 'drag', {
						dragObject: dragObject
					}
					false
			.bind 'mouseup, touchend', (evt) ->
				if moving
					moving = false
					pos = handle.position()[0]
					$(document.elementFromPoint(pos.left, pos.top - 1))
					.trigger 'drop',
						dropObject: dragObject

			dragObject
				.addClass("draggable")
				.css {
					position: "relative"
					"padding-top": dragObject.css("padding-top")
						.map(Number.AtLeast(parseInt(opts.handleCSS.height,10)))
						.px().first()
				}
				.append(handle)

		ProgressBar = (selector, opts) ->
			opts = $.extend({
				change: null
				barColor: "rgba(0,128,0,0.5)"
				textColor: "white"
				reset: false
			}, opts)

			node = $(selector)
				.addClass('progress-bar')
				_bg = node.css("background").first()
				_color = node.css("color").first()

			node.zap 'updateProgress', (pct) ->
				while pct < 1.0
					pct *= 100.0
					node.css
						background: _bg
						color: _color
				else
					node.css
						background:"""
						"""
						color: opts.textColor
				if $.is "function", opts.change
					opts.change pct

		Accordion = (selector, opts) ->
			opts = $.extend({
				exclusive: false
				sticky: false
			}, opts)
			node = $(selector).addClass("accordion")
			selectedChild = null

			initRow = (n) ->
				t = $(n).children().first().filter("*")
				if( t.len() isnt 2 )
				title = t.eq(0).addClass("title")
				body = t.eq(1).addClass("body").hide()
				bodyVisible = false
				title.click () ->
					if opts.exclusive
						node.find(".body").hide()
					if bodyVisible
						if not opts.sticky
							body.hide().removeClass("visible")
							title.removeClass("selected").trigger("deselect")
							bodyVisible = false
						else
							body.show().addClass("visible")
							title.addClass("selected").trigger("select")
							bodyVisible = true
					else
						body.show().addClass("visible")
						title.addClass("selected").trigger("select")
						bodyVisible = true

			node.bind "DOMNodeInserted", (evt) ->
				directChildren = node.children().first().filter("*")
				parentsOfInserted = $(evt.target).parents().first()
				initRow(parentsOfInserted.intersect(directChildren))

			node.children().first()
				.map(initRow)

			return node

		ViewStack = (selector, opts) ->
			items = $(selector)
				.css {
					position: "relative"
					top: "0px"
					left: "0px"
				}
				.hide()
				.map($)
			active = 0
			items[active].show()
			items.next = () ->
				items[active].hide()
				active = (++active % items.length)
				items[active].show()
			items.activate = (k) ->
				items[active].hide()
				active = k
				items[k].show()
			for j in [0...items.len()]
				items[j]
				.zap("_viewIndex", j)
				.zap "activate", ->
					items.activate(this._viewIndex)
			items

		Tabs = (selector, views) ->
			tabs = $(selector)
			views = $(views).viewStack()
			nn = tabs.len()
			tabs._tabIndex = i for i in [0..nn]
			$(tabs[0]).addClass("active")
			tabs.click () ->
				tabs.removeClass("active")
				views.activate(this._tabIndex)
				$(this).addClass("active")

		return {
			$:
				UI:
					Draggable: Draggable
					ProgressBar: ProgressBar
					ViewStack: ViewStack
					Tabs: Tabs
					Accordion: Accordion

			dialog: (opts) -> Dialog(this, opts)
			progressBar: (opts) -> ProgressBar(this, opts)
			viewStack: (opts) -> ViewStack(this, opts)
			tabs: (views) -> Tabs(this, views)
			accordion: (opts) -> Accordion(this, opts)
			draggable: (opts) -> Draggable(this, opts)
		}

)(Bling)


	units = ["px","pt","pc","em","%","in","cm","mm","ex",""]
	UNIT_RE = /(\d+\.*\d*)(px|pt|pc|em|%|in|cm|mm|ex)/

	parseUnits = (s) -> UNIT_RE.exec(s)[2] if UNIT_RE.test(s) else ""

	conv = (a,b) -> conv[a][b]()
	for a in units
		for b in units
			(conv[a] or= {})[b] = trick +(a is b or a is "" or b is "")
	conv.in.pt = -> 72
	conv.in.px = -> 96
	conv.in.cm = -> 2.54
	conv.pc.pt = -> 12
	conv.cm.mm = -> 10
	conv.em.px = ->
		x = $("<span style='font-size:1em;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.px = ->
		x = $("<span style='font-size:1ex;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.em = -> 2
	fillIn = ->
		for a in units
			for b in units
				if not conv(a,b) and conv(b,a)
					conv[a][b] = trick 1.0/conv(b,a)
				for c in units
					if not conv(a,c) and conv(a,b) and conv(b,c)
						conv[a][c] = trick conv(a,b) * conv(b,c)
	fillIn(); fillIn()
	
	convertUnits = (number, unit) -> parseFloat(number) * conv[parseUnits(number)][unit]() + unit

	$.assert(convertUnits("300px", "cm") == "10cm")

	convertAll = (to, a) ->
		for i in [0...a.length]
			a[i] = convertTo(to, a[i])

	Object.Type.register "units",
		match: (x) -> UNIT_RE.test(x)

	unit_scalar = (f) ->
		(a...) ->
			convertAll( unit = parseUnits(@[0]), @)
			(f.apply @, a) + unit
	unit_vector = (f) ->
		(a...) ->
			u = @map parseUnits
			f.apply(@floats(), a).map ->

	{
		min: unit_scalar -> @reduce (a) -> Math.min parseFloat(@), a
		max: unit_scalar -> @reduce (a) -> Math.max parseFloat(@), a
		sum: unit_scalar -> @reduce (a) -> parseFloat(@) + a
		mean: unit_scalar -> parseFloat(@sum()) / @length
		magnitude: unit_scalar -> Math.sqrt @floats().squares().sum()
		squares: -> @map -> (x=parseFloat(@)) * x
		scale: (n) -> @map -> n * parseFloat(@)
		add: (d) -> @map -> d + @
		normalize: -> @scale(1/@magnitude())
	}


	EOF = -> "EOF"

	BackgroundQueue = (opts) ->
		opts = extend {
			item: -> EOF
			action: Function.Identity
			latency: 10
		}, opts

		return extend new $.EventEmitter(), {
			run: ->
				r = () =>
					if (item = opts.action(opts.item())) isnt EOF
						@emit("data", item)
						setTimeout r, opts.latency
				setTimeout r, opts.latency
		}

	data = x for x in [0...1000]
	i = 0
	BackgroundQueue
		item: ->
			return data[i++] if i < data.length else EOF
		action: (item) -> (item*item) - 1
		latency: 10
	.on "data", (x) -> console.log "data:", x
	.on "error", (x) -> console.log "error:", x
	
(($) ->
	$.plugin ->
		$:
			histogram: (data, bucket_width=1, output_width=80) ->
				buckets = $()
				len = 0
				for x in data
					i = Math.floor( x / bucket_width )
					buckets[i] ?= 0
					buckets[i] += 1
					len = Math.max(len, i+1)
				buckets.length = len

				max = buckets.max()
				buckets = buckets.map((x) -> x or 0)
					.scale(1/max)
					.scale(output_width)
				sum = buckets.sum()

				ret = ""
				for n in [0...len] by 1
					end = (n+1) * bucket_width
					pct = (buckets[n]*100/sum).toFixed(0)
				ret
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'XMLHttpRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					xhr = new XMLHttpRequest()
					if $.is "function", opts
						opts = success: $.bound(xhr, opts)
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts
					opts.state = $.bound(xhr, opts.state)
					opts.success = $.bound(xhr, opts.success)
					opts.error = $.bound(xhr, opts.error)
					if opts.data and opts.method is "GET"
						url += "?" + formencode(opts.data)
					else if opts.data and opts.method is "POST"
						opts.data = formencode(opts.data)
					xhr.open(opts.method, url, opts.async)
					xhr = $.extend xhr,
						asBlob: opts.asBlob
						timeout: opts.timeout
						followRedirects: opts.followRedirects
						withCredentials: opts.withCredentials
						onreadystatechange: ->
							opts.state?()
							if xhr.readyState is 4
								if xhr.status is 200
									opts.success xhr.responseText
								else
									opts.error xhr.status, xhr.statusText
					xhr.send opts.data
					return $(xhr)

				post: (url, opts = {}) ->
					if $.is("function",opts)
						opts = success: opts
					opts.method = "POST"
					$.http(url, opts)

				get: (url, opts = {}) ->
					if( $.is("function",opts) )
						opts = success: opts
					opts.method = "GET"
					$.http(url, opts)
		}
)(Bling)
(($) ->

	$.plugin
		depends: "dom"
		provides: "lazy"
	, ->
		lazy_load = (elementName, props) ->
			$("head").append $.extend document.createElement(elementName), props
		$:
			script: (src) ->
				lazy_load "script", { src: src }
			style: (src) ->
				lazy_load "link", { href: src, rel: "stylesheet" }

)(Bling)
(($) ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""

		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615

		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)

			index = (index + 1) % 624
			(y + a) / b

		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()

		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
	)()

	$.plugin
		provides: "random"
	, ->
		$:
			random: random

)(Bling)
(($) ->
	$.plugin
		provides: "sendgrid"
		depends: "config"
	, ->
		try
			nodemailer = require 'nodemailer'
		catch err
			`return`
		transport = nodemailer.createTransport 'SMTP',
			service: 'SendGrid'
			auth:
				user: $.config.get 'SENDGRID_USERNAME'

		$:
			sendMail: (mail, callback) ->
				mail.transport ?= transport
				mail.from ?= $.config.get 'EMAILS_FROM'
				mail.bcc ?= $.config.get 'EMAILS_BCC'

				if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
					nodemailer.sendMail mail, callback
				else
)(Bling)
(($) ->
	$.plugin
		provides: "StateMachine"
	, ->
		$: StateMachine: class StateMachine
			constructor: (stateTable) ->
				@debug = false
				@reset()
				@table = stateTable
				Object.defineProperty @, "modeline",
					get: -> @table[@_mode]
				Object.defineProperty @, "mode",
					set: (m) ->
						@_lastMode = @_mode
						@_mode = m
						if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
							ret = @modeline['enter'].call @
							while $.is("function",ret)
								ret = ret.call @
						m
					get: -> @_mode

			reset: ->
				@_mode = null
				@_lastMode = null

			GO: (m) -> -> @mode = m
			@GO: (m) -> -> @mode = m
			
			tick: (c) ->
				row = @modeline
				if not row?
					ret = null
				else if c of row
					ret = row[c]
				else if 'def' of row
					ret = row['def']
				while $.is "function",ret
					ret = ret.call @, c
				ret

			run: (inputs) ->
				@mode = 0
				for c in inputs
					ret = @tick(c)
				if $.is "function",@modeline?.eof
					ret = @modeline.eof.call @
				while $.is "function",ret
					ret = ret.call @
				@reset()
				return @

	$.plugin
		provides: "synth"
		depends: "StateMachine"
	, ->
		class SynthMachine extends $.StateMachine
			basic =
				".": @GO 3
				"[": @GO 4
				'"': @GO 6
				"'": @GO 7
				" ": @GO 8
				",": @GO 10
				"+": @GO 11
				eof: @GO 13

			@STATE_TABLE = [
					enter: ->
						@tag = @id = @cls = @attr = @val = @text = ""
						@attrs = {}
						@GO 1
				},
					def: (c) -> @tag += c
				}, basic),
					def: (c) -> @id += c
				}, basic),
					enter: -> @cls += " " if @cls.length > 0
					def: (c) -> @cls += c
				}, basic),
					"=": @GO 5
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @attr += c
					eof: @GO 12
				},
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @val += c
					eof: @GO 12
				},
					'"': @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					"'": @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					enter: ->
						@emitNode() if @tag
						@emitText() if @text
						@GO 0
				},
					enter: ->
						@emitNode()
						@cursor = null
						@GO 0
				},
					enter: ->
						@emitNode()
						@cursor = @cursor?.parentNode
						@GO 0
				},
				},
					enter: ->
						@emitNode() if @tag
						@emitText() if @text
				}
			]
			constructor: ->
				super(SynthMachine.STATE_TABLE)
				@fragment = @cursor = document.createDocumentFragment()
			emitNode: ->
				if @tag
					node = document.createElement @tag
					node.id = @id or null
					node.className = @cls or null
					for k of @attrs
						node.setAttribute k, @attrs[k]
					@cursor.appendChild node
					@cursor = node
			emitText: ->
				@cursor.appendChild $.type.lookup("<html>").node(@text)
				@text = ""

		return {
			$:
				synth: (expr) ->
					s = new SynthMachine()
					s.run(expr)
					if s.fragment.childNodes.length == 1
						$(s.fragment.childNodes[0])
					else
						$(s.fragment)
		}

)(Bling)
(($) ->


		current_engine = null
		engines = {}

		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine

		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()

		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop]
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1

	$.template.register_engine 'pythonic', (() ->

		chunk_re = /%[\(\/]/

		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n]
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}

			if not cache?
			n = cache.length

			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""

		return render
	)()

		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()


)(Bling)
(($) ->
		parseOne = (data) ->
			i = data.indexOf ":"
			if i > 0
				len = parseInt data[0...i], 10
				item = data[i+1...i+1+len]
				type = data[i+1+len]
				extra = data[i+len+2...]
				item = switch type
					when "'" then String(item)
					when "!" then (item is "true")
					when "~" then null
					when "]" then parseArray(item)
					when "}" then parseObject(item)
				return [item, extra]
			return undefined
		parseArray = (x) ->
			data = []
			while x.length > 0
				[one, x] = parseOne(x)
				data.push(one)
			data
		parseObject = (x) ->
			data = {}
			while x.length > 0
				[key, x] = parseOne(x)
				[value, x] = parseOne(x)
				data[key] = value
			data
		$:
			TNET:
				stringify: (x) ->
					[data, type] = switch $.type x
						when "string" then [x, "'"]
						when "function" then [String(x), "'"]
						when "boolean" then [String(not not x), "!"]
						when "null" then ["", "~"]
						when "undefined" then ["", "~"]
						when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
						when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
					return (data.length|0) + ":" + data + type
				parse: (x) ->
					parseOne(x)?[0]
)(Bling)
(($) ->

	$.plugin
		provides: "trace"
		depends: "function,type"
	, ->
		$.type.extend
			unknown: { trace: $.identity }
			function:
				trace: (label, f, tracer) ->
					label or= f.name
					r = (a...) ->
						f.apply @, a
					r
		return $: trace: (label, o, tracer) ->
			if not $.is "string", label
				[tracer, o] = [o, label]
			tracer or= $.log
			label or= ""
			$.type.lookup(o).trace(label, o, tracer)

)(Bling)
(($) ->
	$.plugin
		depends: "dom"
	, ->
		COMMASEP = ", "
			"slow": 700
			"medium": 500
			"normal": 300
			"fast": 100
			"instant": 0
			"now": 0
		accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
		testStyle = document.createElement("div").style

		transformProperty = "transform"
		transitionProperty = "transition-property"
		transitionDuration = "transition-duration"
		transitionTiming = "transition-timing-function"

		if "WebkitTransform" of testStyle
			transformProperty = "-webkit-transform"
			transitionProperty = "-webkit-transition-property"
			transitionDuration = "-webkit-transition-duration"
			transitionTiming = "-webkit-transition-timing-function"
		else if "MozTransform" of testStyle
			transformProperty = "-moz-transform"
			transitionProperty = "-moz-transition-property"
			transitionDuration = "-moz-transition-duration"
			transitionTiming = "-moz-transition-timing-function"
		else if "OTransform" of testStyle
			transformProperty = "-o-transform"
			transitionProperty = "-o-transition-property"
			transitionDuration = "-o-transition-duration"
			transitionTiming = "-o-transition-timing-function"

		return {
			$:
				duration: (speed) ->
					d = speeds[speed]
					return d if d?
					return parseFloat speed

			transform: (end_css, speed, easing, callback) ->

				if $.is("function",speed)
					callback = speed
					speed = easing = null
				else if $.is("function",easing)
					callback = easing
					easing = null
				speed ?= "normal"
				easing or= "ease"
				duration = $.duration(speed) + "ms"
				props = []
				trans = ""
				css = {}
				for i of end_css
					if accel_props_re.test(i)
						ii = end_css[i]
						if ii.join
							ii = $(ii).px().join COMMASEP
						else if ii.toString
							ii = ii.toString()
						trans += " " + i + "(" + ii + ")"
					else css[i] = end_css[i]
				(props.push i) for i of css
				if trans
					props.push transformProperty

				css[transitionProperty] = props.join COMMASEP
				css[transitionDuration] = props.map(-> duration).join COMMASEP
				css[transitionTiming] = props.map(-> easing).join COMMASEP

				if trans
					css[transformProperty] = trans
				@css css
				@delay duration, callback

				@each ->
					if @style
						if @style.display is not "none"
							@_display = @syle.display
						@style.display = "none"
				.trigger "hide"
				.delay updateDelay, callback

				@each ->
					if @style
						@style.display = @_display
						delete @_display
				.trigger "show"
				.delay updateDelay, callback

				@weave(@css("display"))
					.fold (display, node) ->
						if display is "none"
							node.style.display = node._display or ""
							delete node._display
							$(node).trigger "show"
						else
							node._display = display
							node.style.display = "none"
							$(node).trigger "hide"
						node
					.delay(updateDelay, callback)

				@.css('opacity','0.0')
					.show ->
						@transform {
							opacity:"1.0",
							translate3d: [0,0,0]
						}, speed, callback
				@transform {
					opacity:"0.0",
					translate3d:[x,y,0.0]
				}, speed, -> @hide(callback)
			fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
			fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
			fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
			fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
		}
)(Bling)
(($) ->
	$.plugin
		provides: "unittest"
		depends: "core,function"
	, ->
		testCount = passCount = failCount = 0
		failed = []
		invokeTest = (group, name, func) ->
			return if not $.is "function", func
			shouldFail = name.toLowerCase().indexOf("fail") isnt -1
			done = $.once (err) ->
				testCount--
				if (!!err isnt shouldFail)
					failCount++
					failed.push name
				else
					_log "pass"
					passCount++
					$.provide name
			f = (done) ->
				try func(done)
				catch err then done(err)
				finally
					if name.toLowerCase().indexOf("async") is -1 then done()
			testCount++
			try f(done)
			catch err then done(err)

		testReport = $.once ->

		$:
			approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
			assertEqual: (a, b, label) ->
				if a isnt b
			assertArrayEqual: (a, b, label) ->
				for i in [0...a.length] by 1
					try
						$.assertEqual(a[i], b[i], label)
					catch err
			testGroup: (name, funcs) ->
				interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
				for k,func of funcs
					invokeTest(name, k, func)
		assertEqual: (args...) ->
					if $.is "function", x then x.call(@,@) else x
				a = args[0]
				for i in [1...args.length]
					$.assertEqual a, args[i]
			return @
)(Bling)
require('./common')

$.testGroup "Object",
	keys: -> $.assertArrayEqual Object.keys({a: 1, b: 2}), ['a','b']

$.testGroup "Type",
	string: -> $.assertEqual $.type(""), "string"
	number:-> $.assertEqual $.type(42), "number"
	undef: -> $.assertEqual $.type(), "undefined"
	null: -> $.assertEqual $.type(null), "null"
	array: -> $.assertEqual $.type([]), "array"
	function: -> $.assertEqual $.type(() -> null), "function"
	bool: -> $.assertEqual $.type(true), "bool"
	regexp: -> $.assertEqual $.type(//), "regexp"
	window: -> $.assertEqual $.type(window), "global"
	is: ->
		$.assert($.is "function", ->)
		$.assert($.is "array", [])
	inherit: ->
		a = { a: 1 }
		b = { b: 2 }
		$.inherit a, b
		$.assertEqual(b.__proto__, a)
		$.assertEqual(b.a, 1)
		$.assert( not b.hasOwnProperty("a") )
	extend: -> $.assertArrayEqual Object.keys($.extend({A:1},{B:2})), ['A','B']
	defineProperty: ->
		a = {}
		$.defineProperty a, "b",
			get: -> 2
		$.assert( "b" of a )
	isType1: ->
		$.assert( $.isType(Array, []) )
	isType2: ->
		$.assert( $.isType('Array', []) )
	isType3: ->
		class Foo
		f = new Foo()
		$.assert( $.isType Foo, f )
	isSimple1: -> $.assert( $.isSimple "" )
	isSimple2: -> $.assert( $.isSimple 42.0 )
	isSimple3: -> $.assert( $.isSimple false )
	isSimple4: -> $.assert( not $.isSimple {} )
	isEmpty1: -> $.assert( $.isEmpty "" )
	isEmpty2: -> $.assert( $.isEmpty null )
	isEmpty3: -> $.assert( $.isEmpty undefined )
	toArray1: ->
		a = $([1,2,3])
		b = a.toArray()
		$.assert b.constructor.name is "Array", "constructor name is Array"
		$.assert b[1] is 2, "still has data"
		$.assert b.length is 3, "length is preserved"
		$.assert not b.zap, "has shed bling"
	as1: ->
		$.assert ($.as "number", "1234") is 1234

$.testGroup "Function",
	identity1: -> $.assertEqual $.type($.identity), "function"
	identity2: -> $.assertEqual( $.identity(a = {}), a)
	bound: ->
		f = -> @value
		a = { value: 'a' }
		b = { value: 'b' }
		g = $.bound(a, f)
		h = $.bound(b, f)
		$.assertEqual(g(), 'a')
		$.assertEqual(h(), 'b')
	trace: ->
		f = -> 42
		g = []
		h = $.trace "label", f, (a...) ->
			g.push a.join ''
		$.assertArrayEqual(g, [ "global.label('one','two')" ])

$.testGroup "String",
	Px1: -> $.assertEqual($.px(100), "100px")
	Px2: -> $.assertEqual($.px(-100.0), "-100px")
	Px3: -> $.assertEqual $.px("100.0px"), "100px"
	PadLeft1: -> $.assertEqual($.padLeft("foo", 5), "  foo")
	PadLeft2: -> $.assertEqual($.padLeft("foo", 3), "foo")
	PadLeft3: -> $.assertEqual($.padLeft("foo", 2), "foo")
	PadLeft4: -> $.assertEqual($.padLeft("foo", 5, "X"), "XXfoo")
	PadRight1: -> $.assertEqual($.padRight("foo", 5), "foo  ")
	PadRight2: -> $.assertEqual($.padRight("foo", 3), "foo")
	PadRight3: -> $.assertEqual($.padRight("foo", 2), "foo")
	PadRight4: -> $.assertEqual($.padRight("foo", 5, "X"), "fooXX")
	Splice1: -> $.assertEqual($.stringSplice("foobar",3,3,"baz"), "foobazbar")
	Splice2: -> $.assertEqual($.stringSplice("foobar",1,5,"baz"), "fbazr")
	Splice3: -> $.assertEqual($.stringSplice("foobar",0,6,"baz"), "baz")
	Splice4: -> $.assertEqual($.stringSplice("foobar",0,0,"baz"), "bazfoobar")
	Checksum2: -> $.assertEqual($.checksum("foobarbaz"), 310051767)
	ToString: -> $.assertEqual $([2,3,4]).toString(), "$([2, 3, 4])"
	ToString2: -> $.assertEqual $.toString(-> $.log), "function () { ... }"

$.testGroup "Plugins",
	new_plugin: ->
		$.plugin ->
			$:
				testGlobal: -> 9
			testOp: -> 42
		$.assertEqual $.testGlobal?(), 9
		$.assertEqual $().testOp?(), 42
		$.assertEqual $.testOp?(), 42

$.testGroup "Symbol",
	exists: -> $.assert( Bling?, "bling should exist")
	current: ->
		Bling.assertEqual( Bling.symbol, "$" )
		Bling.assertEqual( $, Bling )
	set: ->
		Bling.symbol = "_"
		Bling.assertEqual( _, Bling )
	preserve: ->
		Bling.global.$ = "before"
		Bling.symbol = "$"
		Bling.assertEqual(Bling.global.$, Bling)
		Bling.symbol = "_"
		Bling.assertEqual(Bling.global.$, "before")
	reset: ->
		Bling.symbol = "$"
		Bling.assertEqual($, Bling)
	noConflict: ->
		Bling.global.noConflictTest = "magic"
		Bling.symbol = "noConflictTest"
		Bling.assert Bling.global.noConflictTest is Bling, 1
		foo = Bling.noConflict()
		Bling.assert Bling.symbol = "Bling", 2
		Bling.assert Bling.global[Bling.symbol] is Bling, 3
		Bling.assert foo is Bling, 4
		Bling.assert Bling.global.noConflictTest is "magic", 5
		Bling.symbol = "$"

$.testGroup "Math",
	sum0: -> $.assertEqual($([]).sum(), 0)
	sum1: -> $.assertEqual($([1,2,3,4,5]).sum(), 15)
	sum2: -> $.assertEqual($([1,2,NaN,3]).sum(), 6)
	range1: -> $.assertEqual($.range(1,6).toRepr(), '$([1, 2, 3, 4, 5])')
	range2: -> $.assertEqual($.range(5).toRepr(), '$([0, 1, 2, 3, 4])')
	zeros1: -> $.assertEqual($.zeros(10).sum(), 0)
	zeros2: -> $.assertEqual($.zeros(5).toRepr(), '$([0, 0, 0, 0, 0])')
	ones: -> $.assertEqual($.ones(10).sum(), 10)
	floats: -> $.assertEqual($(["12.1","29.9"]).floats().sum(), 42)
	ints: -> $.assertEqual($(["12.1","29.9px"]).ints().sum(), 41)
	px: -> $.assertEqual( $(["12.1", "29.9"]).px(2).toRepr(), "$(['14px', '31px'])" )
	min1: -> $.assertEqual( $([12.1, 29.9]).min(), 12.1)
	min2: -> $.assertEqual( $([12.1, NaN, 29.9]).min(), 12.1)
	max1: -> $.assertEqual( $([12.1, 29.9]).max(), 29.9)
	max2: -> $.assertEqual( $([12.1, NaN, 29.9]).max(), 29.9)

$.testGroup "Random",
	random: ->
		$.assert 0.0 < $.random() < 1.0
	real: ->
		$.assert 10.0 < $.random.real(10,100) < 100.0
	integer: ->
		r = $.random.integer(3,9)
		$.assert 3 <= r <= 9, "r is in range"
		$.assert Math.floor(r) is r, "r is an integer"
	string: ->
		s = $.random.string(16)
		$.assert $.type(s) is "string", "s is a string"
		$.assert s.length is 16, "s has the right length"
	seed: ->
		$.random.seed = 42
		r = $.random.string(16)
		$.random.seed = 43
		s = $.random.string(16)
		$.random.seed = 42
		t = $.random.string(16)
		$.assert r is t, "same seed produces same output"
		$.assert r isnt s, "different seed produces different output"

$.testGroup "Hash",
	number: -> $.assert $.hash(42) isnt $.hash(43)
	string: -> $.assert $.hash("foo") isnt $.hash("bar")
	array:  -> $.assert $.hash("poop") isnt $.hash(["poop"])
	array_order: -> $.assert $.hash(["a","b"]) isnt $.hash(["b","a"])
	object: -> $.assert ($.hash a:1) isnt ($.hash a:2)
	object2: -> $.assert isFinite $.hash a:1
	object3: -> $.assert isFinite $.hash {}
	object4: -> $.assert ($.hash {}) isnt ($.hash [])
	bling:  -> $.assert ($.hash $)?
	bling_order: -> $.assert $.hash($(["a","b"])) isnt $.hash($(["b","a"]))

document.body.innerHTML = """
<table>
	<tr><td>1,1</td><td>1,2</td></tr>
	<tr><td>2,1</td><td>2,2</td></tr>
	<tr><td>3,1</td><td class='d'>3,2</td></tr>
	<tr><td>4,1</td><td>4,2</td></tr>
</table>
<div class='c'>C</div>
<p><span>foobar</span></p>
"""
$.testGroup "Core",
	new1: ->
		b = $([1,2,3])
		$.assertEqual(b[0], 1)
		$.assertEqual(b[1], 2)
		$.assertEqual(b[2], 3)
		$.assertEqual(b.constructor.name, "Bling")
	pipe1: ->
		$.pipe('unit-test').append (x) -> x += 2
		$.pipe('unit-test').prepend (x) -> x *= 2
		$.assertEqual( $.pipe('unit-test', 4), 10)
	eq: -> $.assertEqual($([1,2,3]).eq(1)[0], 2)
	each: ->
		sum = 0
		$([1,2,3,4]).each ->
			sum += @
		$.assertEqual(sum, 10)
	map: -> $.assertArrayEqual( $([1,2,3,4]).map( (x) -> x * x ), [1,4,9,16] )
	map2: ->
		d = [1,2,3,4,5]
		$.assertArrayEqual($(d).map(-> @ * 2), [2,4,6,8,10])
		$.assertArrayEqual($(d).map(-> @ * 2), [2,4,6,8,10])
	coalesce1: -> $.assertEqual($.coalesce(null, 42, 22), 42)
	coalesce2: -> $.assertEqual($.coalesce([null, 14, 42]), 14)
	coalesce3: -> $.assertEqual($.coalesce([null, [null, 14], 42]), 14)
	reduce: -> $.assertEqual( $([1,2,3,4]).reduce( (a,x) -> a + x ), 10)
	union: -> $.assertArrayEqual($([1,2,3,4]).union([2,3,4,5]), [1,2,3,4,5])
	intersect: -> $.assertArrayEqual($([1,2,3,4]).intersect([2,3,4,5]), [2,3,4])
	distinct: -> $.assertArrayEqual($([1,2,2,3,4,3]).distinct(), [1,2,3,4])
	contains1: -> $.assert $([1,2,3,4]).contains(3)
	contains2: -> $.assert $(["foo","bar","baz"]).contains("bar")
	count: -> $.assertEqual( $([1,2,2,3,4,3]).count(3), 2 )
	select: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).select('id'), [1,2,3])
	select1: -> $.assertArrayEqual($([
		{a:{b:2}},
		{a:{b:4}},
		{a:{b:6}}
	]).select("a.b"), [2,4,6])
	select2: -> $.assertArrayEqual($([
		{a:[{b:3}]},
		{a:[{b:6}]},
		{a:[{b:9}]}
	]).select("a.0.b"), [3,6,9])
	select3: -> $.assertArrayEqual($([
		{a:{b:{c:4}}},
		{a:{b:{c:5}}},
		{a:{b:{c:6}}}
	]).select("a.b.c"), [4,5,6])
	zap: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).zap('id', 13).select('id'), [13,13,13])
	zapf: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).zap('id', () -> @ * 2).select('id'), [2,4,6])
	zapf2: -> $.assertArrayEqual( $([ {sub:{id:1}}, {sub:{id:2}}, {sub:{id:3}} ]).zap('sub.id', -> @*2).select('sub.id'), [2,4,6])
	take3: -> $.assertArrayEqual($([1,2,3,4]).take(0), [])
	take4: -> $.assertArrayEqual($([1,2,3,4]).take(1), [1])
	take5: -> $.assertArrayEqual($([1,2,3,4]).take(2), [1,2])
	take6: -> $.assertArrayEqual($([1,2,3,4]).take(3), [1,2,3])
	take7: -> $.assertArrayEqual($([1,2,3,4]).take(4), [1,2,3,4])
	take8: -> $.assertArrayEqual($([1,2,3,4]).take(5), [1,2,3,4])
	skip2: -> $.assertArrayEqual($([1,2,3,4]).skip(0), [1,2,3,4])
	skip3: -> $.assertArrayEqual($([1,2,3,4]).skip(1), [2,3,4])
	skip4: -> $.assertArrayEqual($([1,2,3,4]).skip(2), [3,4])
	skip5: -> $.assertArrayEqual($([1,2,3,4]).skip(3), [4])
	skip6: -> $.assertArrayEqual($([1,2,3,4]).skip(4), [])
	skip7: -> $.assertArrayEqual($([1,2,3,4]).skip(5), [])
	first1: -> $.assertEqual($([1,2,3,4]).first(), 1)
	first2: -> $.assertArrayEqual($([1,2,3,4]).first(5), [1,2,3,4])
	first3: -> $.assertArrayEqual($([1,2,3,4]).first(2), [1,2])
	first4: -> $.assertArrayEqual($([1,2,3,4]).first(0), [])
	last1: -> $.assertEqual($([1,2,3,4]).last(), 4)
	last2: -> $.assertArrayEqual($([1,2,3,4]).last(5), [1,2,3,4])
	last3: -> $.assertArrayEqual($([1,2,3,4]).last(2), [3,4])
	last4: -> $.assertArrayEqual($([1,2,3,4]).last(0), [])
	slice1: -> $.assertArrayEqual($([1,2,3,4,5]).slice(0,5), [1,2,3,4,5])
	slice2: -> $.assertArrayEqual($([1,2,3,4,5]).slice(1,5), [2,3,4,5])
	slice3: -> $.assertArrayEqual($([1,2,3,4,5]).slice(2,5), [3,4,5])
	slice4: -> $.assertArrayEqual($([1,2,3,4,5]).slice(3,5), [4,5])
	slice5: -> $.assertArrayEqual($([1,2,3,4,5]).slice(4,5), [5])
	slice6: -> $.assertArrayEqual($([1,2,3,4,5]).slice(1,-2), [2,3])
	slice7: -> $.assertArrayEqual($([1,2,3,4,5]).slice(-1,-3), [5,4])
	slice8: -> $.assertArrayEqual($([1,2,3,4,5]).slice(-1,-4), [5,4,3])
	push: -> $.assertArrayEqual($([1,2,3]).push(4), [1,2,3,4])
	filter1: -> $.assertArrayEqual($([1,2,3,4,5]).filter((x) -> x % 2), [1,3,5])
	filter2: -> $.assertArrayEqual($(["foo","bar","baz"]).filter(/^ba/), ["bar","baz"])
	filter3: -> $.assertArrayEqual($("*").filter("td").length, 8)
	filter4: -> $.assertEqual($("*").filter("td").filter(".d").length, 1)
	filter5: -> $.assertEqual($("*").filter("td").filter(".none").length, 0)
	filter6: -> $.assertArrayEqual($(["one","two","three"]).filter(-> String(@) isnt "three"), ["one", "two"])
	matches: -> $.assertArrayEqual($("td").matches(".d"), [false,false,false,false,false,true,false,false])
	querySelectorAll: -> $.assertArrayEqual($("tr").querySelectorAll("td.d")[0].className, "d")
	weave1: -> $.assertArrayEqual($([1,1,1]).weave([2,2,2]), [2,1,2,1,2,1])
	weave2: -> $.assertArrayEqual($([1,1,1]).weave($([2,2,2])), [2,1,2,1,2,1])
	fold: -> $.assertArrayEqual($([1,1,1]).weave([2,2,2]).fold( (a,b) -> a+b ), [3,3,3])
	flatten: -> $.assertArrayEqual($([[1,2],[3,4]]).flatten(), [1,2,3,4])
	call: -> $.assertArrayEqual($([((x) -> x*2), ((x) -> x*x)]).call(4), [8, 16])
	apply: -> $.assertArrayEqual($([((x) -> @+x), ((x) -> @*x)]).apply(4,[2]), [6, 8])
	corrected_length: ->
		$.assertEqual(Array(10).length,10)
		$.assertEqual(Bling(10).length, 0)

$.testGroup "DOM",
	parse: ->
		d = $.HTML.parse "<div><a></a><b></b><c></c></div>"
		$.assertEqual $.type(d), "node"
		$.assertEqual d.nodeName, "DIV"
	stringify: -> $.assertEqual $.HTML.stringify($.HTML.parse(h = "<div><a/><b/><c/></div>")), h
	select_childNodes: -> $.assertEqual( $("<div><a></a><b></b><c></c></div>").select("childNodes").flatten().map($.type).toRepr(), "$(['node', 'node', 'node'])" )
	child: -> i = 0; d = $("<div><a></a><b></b><c></c></div>"); $.assertEqual( d.select('childNodes').flatten().map( () -> d.child(i++) ).toRepr(), "$([$([<a/>]), $([<b/>]), $([<c/>])])")
	child2: -> $.assertEqual($("tr").child(0).select('nodeName').toRepr(), "$(['TD', 'TD', 'TD', 'TD'])")
	textData: ->
		d = $("<div>&nbsp;</div>")
		$.assertEqual d.toRepr(), "$([<div>&nbsp;</div>])"
		t = d.child 0
		$.assertEqual t.toRepr(), "$([&nbsp;])"
		t.zap 'data', '<p>'
		$.assertEqual d.select('innerHTML').first(), '&lt;p&gt;'
	escape: -> $.assertEqual $.HTML.escape("<p>"), "&lt;p&gt;"
	dashName1: -> $.assertEqual $.dashize("fooBar"), "foo-bar"
	dashName2: -> $.assertEqual $.dashize("FooBar"), "-foo-bar"
	html1: -> $.assertEqual $("tr").html().first(), "<td>1,1</td><td>1,2</td>"
	html2: -> $.assertEqual $("div").html("<span>C</span>").html().first(), "<span>C</span>"
	append: ->
		try
			$.assertEqual($("tr td.d").append("<span>Hi</span>").html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	appendTo1:-> $.assertEqual($("<span>Hi</span>").toRepr(), "$([<span>Hi</span>])")
	appendTo2:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").toRepr(), "$([<span>Hi</span>])")
		finally
			$("tr td.d span").remove()
	appendTo3:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').toRepr(), '$([<td class="d">3,2<span>Hi</span></td>])')
		finally
			$("tr td.d span").remove()
	appendTo4:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	prepend: ->
		try
			$.assertEqual($("tr td.d").prepend("<span>Hi</span>").html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	prependTo: ->
		try
			$.assertEqual($("<span>Hi</span>").prependTo("tr td.d").select('parentNode').html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	before: -> $.assertEqual($("<a><b></b></a>").find("b").before("<c></c>").select('parentNode').toRepr(), "$([<a><c/><b/></a>])")
	after1: -> $.assertEqual($("<a><b></b></a>").find("b").after("<c></c>").select('parentNode').toRepr(), "$([<a><b/><c/></a>])")
	after2: -> $.assertEqual($("<b></b>").after("<c></c>").select('parentNode').toRepr(), "$([<b/><c/>])")
	wrap: -> $.assertEqual($("<b></b>").wrap("<a></a>").select('parentNode').toRepr(), "$([<a><b/></a>])")
	unwrap: -> $.assertEqual($("<a><b/></a>").find("b").unwrap().first().parentNode, null)
	replace: -> $.assertEqual($("<a><b/><c/><b/></a>").find("b").replace("<p/>").eq(0).select('parentNode').toRepr(), "$([<a><p/><c/><p/></a>])")
	removeClass: -> $.assertEqual($("<a class='test'></a>").removeClass('test').toRepr(), "$([<a/>])")
	removeClass2: -> $.assertEqual($("<a></a>").removeClass('test').toRepr(), "$([<a/>])")
	addClass: -> $.assertEqual($("<a></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	addClass2: -> $.assertEqual($("<a class='test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	addClass3: -> $.assertEqual($("<a class='test test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	toggleClass: -> $.assertEqual($("<a class='on'></a>").toggleClass("on").toRepr(), "$([<a/>])")
	toggleClass2: -> $.assertEqual($("<a class='off'></a>").toggleClass("on").toRepr(), '$([<a class="off on"/>])')
	toggleClass3: -> $.assertEqual($("<a class=''></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	toggleClass4: -> $.assertEqual($("<a></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	hasClass: -> $.assertEqual($("<a class='foo'></a>").hasClass("foo").first(), true)
	hasClass2: -> $.assertEqual($("<a class='bar'></a>").hasClass("foo").first(), false)
	text1: -> $.assertEqual($("<a>Hello<b>World</b></a>").select('innerText').toRepr(), "$(['HelloWorld'])")
	text3: -> $.assertEqual($("<a>Hello<b>World</b></a>").text().toRepr(), "$(['HelloWorld'])")
	text2: -> $.assertEqual($("<a>Hello<b>World</b></a>").text("Goodbye").toRepr(), "$([<a>Goodbye</a>])")
	value1: -> $.assertEqual($("<input type='text' value='foo'/>").val().toRepr(), "$(['foo'])")
	value2: -> $.assertEqual($("<input />").val().toRepr(), "$([''])")
	value3: -> $.assertEqual($("<input type='checkbox' checked />").val().toRepr(), "$(['on'])")
	parents: -> $.assertEqual($("td.d").parents().first().select('nodeName').toRepr(), "$(['TR', 'TABLE', 'BODY', 'HTML'])")
	remove: ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
		b = a.find(".x")
			.assertEqual(2, -> @length)
			.assertEqual("$(['B', 'C'])", -> @select('nodeName').toRepr())
			.remove()
			.assertEqual("$([null, null])", -> @select('parentNode').toRepr() )
		$.assertEqual a.toRepr(), '$([<a><d/></a>])'
	find: ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
			.find(".x")
			.assertEqual(2, -> @length)
			.assertEqual("$(['B', 'C'])", -> @select('nodeName').toRepr())
	clone: ->
		c = $("div.c").clone()[0]
		d = $("div.c")[0]
		c.a = "magic"
		$.assertEqual( typeof d.a, "undefined")
		$.assertEqual( typeof c.a, "string")
	toFragment: ->
		$.assertEqual($("td").clone().toFragment().childNodes.length, 8)

$.testGroup "EventEmitter",
	basic: ->
		v = null
		$().on("change", (data) -> v = data)
			.emit("change", "foo")
		$.assertEqual v, "foo"

$.testGroup "Date",
	stamp: ->
		$.assert $.date.stamp(new Date(1000000), "ms") is 1000000
	stamp_sec: ->
		$.assert $.date.stamp(new Date(1000000), "s") is 1000
	unstamp: ->
		d1 = new Date(1000000)
		d2 = $.date.unstamp $.date.stamp d1
		$.assert d1.toString() is d2.toString()
	convert: ->
		$.assert $.date.convert(1000000, "ms", "s") is 1000
	midnight: ->
		d2 = $.date.unstamp $.date.midnight new Date 1000000000
		$.assert d2.toString().indexOf("19:00:00 GMT-0500") > -1
	format: ->
		d1 = new Date(1000000000)
		d2 = new Date(1000000)
		$.assertEqual $.date.format(d1, "yyyy-mm-dd HH:MM:SS"), "1970-01-12 13:46:40"
		$.assertEqual $.date.format(d2, "yyyy-mm-dd HH:MM:SS"), "1970-01-01 00:16:40"
	parse: ->
		$.assert $.date.parse("1970-01-12 13:46:40", "yyyy-mm-dd HH:MM:SS", "ms") is 1000000000
	range: ->
		$.assertEqual $($.date.range(1000, 1000000, 3))
			.unstamp()
			.select("getUTCDate").call()
	chain_format: ->
		$.assertEqual $($.date.range 1000, 1000000, 3)
			.dateFormat("dd")
			.ints().sum(), 35
	chain_midnight: ->
		$.assertEqual $($.date.range 1000, 1000000, 3)
			.midnight()
			.dateFormat("HHMMSS")
			.ints().sum(), 0
	dateAsString: ->
		$.assertEqual ($.as "string", new Date 1,2,3,4,5,6), "1901-03-03 09:05:06"
	stringAsDate: ->
		$.assertEqual ($.as "date", "1901-03-03 09:05:06").toString(), new Date(1,2,3,4,5,6).toString()
	dateAsNumber: ->
		$.assertEqual ($.as "number", new Date 1,2,3,4,5,6), -2172149694
	numberAsDate: ->
		$.assertEqual ($.as "date", -2172149694).toString(), (new Date 1,2,3,4,5,6).toString()

$.testGroup "TNET",
	basic: ->
		obj = $.TNET.parse $.TNET.stringify a:1,b:[2,"3"]
		$.assert obj.a is 1, "1"
		$.assert obj.b[0] is 2, "2"
		$.assert obj.b[1] is "3", "3"

$.testGroup "StateMachine",
	hello: ->
		class TestMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: ->
						@output = "<"
						@GO 1
				}
					def: (c) -> @output += c.toUpperCase()
					eof: @GO 2
				}
					enter: -> @output += ">"
				}
			]
			constructor: ->
				super(TestMachine.STATE_TABLE)
				@output = ""
		m = new TestMachine
		$.assertEqual m.run("hello").output, "<HELLO>"
		$.assertEqual m.run("hi").output, "<HI>"

$.testGroup "Synth",
	basic_node: -> $.assertEqual $.synth("style").toString(), "$([<style/>])"
	class_node: -> $.assertEqual $.synth('style.specClass').toString(), '$([<style class="specClass"/>])'
	attr_node: -> $.assertEqual $.synth('style[foo=bar]').toString(), '$([<style foo="bar"/>])'
	text: -> $.assertEqual $.synth("style 'text'").toString(), "$([<style>text</style>])"
	entity1: -> $.assertEqual $.synth("style 'text&amp;stuff'").toString(), "$([<style>text&amp;stuff</style>])"
	entity2: -> $.assertEqual $.synth("style 'text&stuff'").toString(), "$([<style>text&stuff</style>])"

$.testGroup "Delay",
	delayAsync: (callback) ->
		t = $.now
		ferry_errors = (callback, f) ->
			return (a...) ->
				try f(a...)
				catch err
					callback err
		$.delay 1000, ferry_errors callback, ->
			delta = Math.abs(($.now - t) - 1000)
			callback false

$.testGroup "Config",
	hasDefault: ->
		$.assertEqual $.config.get("does-not-exist","default"), "default"
	canCall: ->
		$.assertEqual $.config("foo","default"), $.config.get("foo","default")
		

require("coffee-script")
dom = require("jldom")
dom.registerGlobals(global)
global.document = dom.createDocument()
global.window = global
require("../dist/bling.js")

$.testGroup "Test Internals",
	true: -> true
	trueFail: (cb) -> cb true
	trueAsync: (cb) -> setTimeout (-> cb false), 100
	trueAsyncFail: (cb) -> setTimeout (-> cb true), 200
	assert: -> $.assert true, "this will not display"
	asyncFail: (callback) ->
		setTimeout (->callback new Error("delayed error")), 500
	assertFail: (cb) ->
		$.assert false, "this will throw an exception, but is expected"
	async1: (callback) ->
		setTimeout (-> callback false), 300
	asyncDepends: (callback) ->
		$.depends 'async1', -> callback false

require "./common"

$.depends "math, random, unittest", ->
	$.testGroup "random",
		coin: ->
			$.assert $.approx $($.random.coin() for _ in [0...1000]).mean(), .5, .05
		ints: ->
			$.assert $.approx $($.random.int(0,10) for _ in [0...20000]).mean(), 5, .7
		gauss: ->
			$.assert $.approx $($.random.gaussian() for _ in [0...1000]).mean(), .5

'use strict'

GEOIP_COUNTRY_CODES = [
	"", "AP", "EU", "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", "AO", "AQ",
	"AR", "AS", "AT", "AU", "AW", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH",
	"BI", "BJ", "BM", "BN", "BO", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA",
	"CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU",
	"CV", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG",
	"EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "FX", "GA", "GB",
	"GD", "GE", "GF", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT",
	"GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IN",
	"IO", "IQ", "IR", "IS", "IT", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM",
	"KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS",
	"LT", "LU", "LV", "LY", "MA", "MC", "MD", "MG", "MH", "MK", "ML", "MM", "MN",
	"MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA",
	"NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA",
	"PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY",
	"QA", "RE", "RO", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI",
	"SJ", "SK", "SL", "SM", "SN", "SO", "SR", "ST", "SV", "SY", "SZ", "TC", "TD",
	"TF", "TG", "TH", "TJ", "TK", "TM", "TN", "TO", "TL", "TR", "TT", "TV", "TW",
	"TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN",
	"VU", "WF", "WS", "YE", "YT", "RS", "ZA", "ZM", "ME", "ZW", "A1", "A2", "O1",
	"AX", "GG", "IM", "JE", "BL", "MF"
]

GEOIP_COUNTRY_CODES3 = [
	"","AP","EU","AND","ARE","AFG","ATG","AIA","ALB","ARM","ANT","AGO","AQ","ARG",
	"ASM","AUT","AUS","ABW","AZE","BIH","BRB","BGD","BEL","BFA","BGR","BHR","BDI",
	"BEN","BMU","BRN","BOL","BRA","BHS","BTN","BV","BWA","BLR","BLZ","CAN","CC",
	"COD","CAF","COG","CHE","CIV","COK","CHL","CMR","CHN","COL","CRI","CUB","CPV",
	"CX","CYP","CZE","DEU","DJI","DNK","DMA","DOM","DZA","ECU","EST","EGY","ESH",
	"ERI","ESP","ETH","FIN","FJI","FLK","FSM","FRO","FRA","FX","GAB","GBR","GRD",
	"GEO","GUF","GHA","GIB","GRL","GMB","GIN","GLP","GNQ","GRC","GS","GTM","GUM",
	"GNB","GUY","HKG","HM","HND","HRV","HTI","HUN","IDN","IRL","ISR","IND","IO",
	"IRQ","IRN","ISL","ITA","JAM","JOR","JPN","KEN","KGZ","KHM","KIR","COM","KNA",
	"PRK","KOR","KWT","CYM","KAZ","LAO","LBN","LCA","LIE","LKA","LBR","LSO","LTU",
	"LUX","LVA","LBY","MAR","MCO","MDA","MDG","MHL","MKD","MLI","MMR","MNG","MAC",
	"MNP","MTQ","MRT","MSR","MLT","MUS","MDV","MWI","MEX","MYS","MOZ","NAM","NCL",
	"NER","NFK","NGA","NIC","NLD","NOR","NPL","NRU","NIU","NZL","OMN","PAN","PER",
	"PYF","PNG","PHL","PAK","POL","SPM","PCN","PRI","PSE","PRT","PLW","PRY","QAT",
	"REU","ROU","RUS","RWA","SAU","SLB","SYC","SDN","SWE","SGP","SHN","SVN","SJM",
	"SVK","SLE","SMR","SEN","SOM","SUR","STP","SLV","SYR","SWZ","TCA","TCD","TF",
	"TGO","THA","TJK","TKL","TLS","TKM","TUN","TON","TUR","TTO","TUV","TWN","TZA",
	"UKR","UGA","UM","USA","URY","UZB","VAT","VCT","VEN","VGB","VIR","VNM","VUT",
	"WLF","WSM","YEM","YT","SRB","ZAF","ZMB","MNE","ZWE","A1","A2","O1",
	"ALA","GGY","IMN","JEY","BLM","MAF"
]

GEOIP_COUNTRY_NAMES = [
	"", "Asia/Pacific Region", "Europe", "Andorra", "United Arab Emirates",
	"Afghanistan", "Antigua and Barbuda", "Anguilla", "Albania", "Armenia",
	"Netherlands Antilles", "Angola", "Antarctica", "Argentina", "American Samoa",
	"Austria", "Australia", "Aruba", "Azerbaijan", "Bosnia and Herzegovina",
	"Barbados", "Bangladesh", "Belgium", "Burkina Faso", "Bulgaria", "Bahrain",
	"Burundi", "Benin", "Bermuda", "Brunei Darussalam", "Bolivia", "Brazil",
	"Bahamas", "Bhutan", "Bouvet Island", "Botswana", "Belarus", "Belize",
	"Canada", "Cocos (Keeling) Islands", "Congo, The Democratic Republic of the",
	"Central African Republic", "Congo", "Switzerland", "Cote D'Ivoire", "Cook Islands",
	"Chile", "Cameroon", "China", "Colombia", "Costa Rica", "Cuba", "Cape Verde",
	"Christmas Island", "Cyprus", "Czech Republic", "Germany", "Djibouti",
	"Denmark", "Dominica", "Dominican Republic", "Algeria", "Ecuador", "Estonia",
	"Egypt", "Western Sahara", "Eritrea", "Spain", "Ethiopia", "Finland", "Fiji",
	"Falkland Islands (Malvinas)", "Micronesia, Federated States of", "Faroe Islands",
	"France", "France, Metropolitan", "Gabon", "United Kingdom",
	"Grenada", "Georgia", "French Guiana", "Ghana", "Gibraltar", "Greenland",
	"Gambia", "Guinea", "Guadeloupe", "Equatorial Guinea", "Greece", "South Georgia and the South Sandwich Islands",
	"Guatemala", "Guam", "Guinea-Bissau",
	"Guyana", "Hong Kong", "Heard Island and McDonald Islands", "Honduras",
	"Croatia", "Haiti", "Hungary", "Indonesia", "Ireland", "Israel", "India",
	"British Indian Ocean Territory", "Iraq", "Iran, Islamic Republic of",
	"Iceland", "Italy", "Jamaica", "Jordan", "Japan", "Kenya", "Kyrgyzstan",
	"Cambodia", "Kiribati", "Comoros", "Saint Kitts and Nevis", "Korea, Democratic People's Republic of",
	"Korea, Republic of", "Kuwait", "Cayman Islands",
	"Kazakstan", "Lao People's Democratic Republic", "Lebanon", "Saint Lucia",
	"Liechtenstein", "Sri Lanka", "Liberia", "Lesotho", "Lithuania", "Luxembourg",
	"Latvia", "Libyan Arab Jamahiriya", "Morocco", "Monaco", "Moldova, Republic of",
	"Madagascar", "Marshall Islands", "Macedonia",
	"Mali", "Myanmar", "Mongolia", "Macau", "Northern Mariana Islands",
	"Martinique", "Mauritania", "Montserrat", "Malta", "Mauritius", "Maldives",
	"Malawi", "Mexico", "Malaysia", "Mozambique", "Namibia", "New Caledonia",
	"Niger", "Norfolk Island", "Nigeria", "Nicaragua", "Netherlands", "Norway",
	"Nepal", "Nauru", "Niue", "New Zealand", "Oman", "Panama", "Peru", "French Polynesia",
	"Papua New Guinea", "Philippines", "Pakistan", "Poland", "Saint Pierre and Miquelon",
	"Pitcairn Islands", "Puerto Rico", "Palestinian Territory",
	"Portugal", "Palau", "Paraguay", "Qatar", "Reunion", "Romania",
	"Russian Federation", "Rwanda", "Saudi Arabia", "Solomon Islands",
	"Seychelles", "Sudan", "Sweden", "Singapore", "Saint Helena", "Slovenia",
	"Svalbard and Jan Mayen", "Slovakia", "Sierra Leone", "San Marino", "Senegal",
	"Somalia", "Suriname", "Sao Tome and Principe", "El Salvador", "Syrian Arab Republic",
	"Swaziland", "Turks and Caicos Islands", "Chad", "French Southern Territories",
	"Togo", "Thailand", "Tajikistan", "Tokelau", "Turkmenistan",
	"Tunisia", "Tonga", "Timor-Leste", "Turkey", "Trinidad and Tobago", "Tuvalu",
	"Taiwan", "Tanzania, United Republic of", "Ukraine",
	"Uganda", "United States Minor Outlying Islands", "United States", "Uruguay",
	"Uzbekistan", "Holy See (Vatican City State)", "Saint Vincent and the Grenadines",
	"Venezuela", "Virgin Islands, British", "Virgin Islands, U.S.",
	"Vietnam", "Vanuatu", "Wallis and Futuna", "Samoa", "Yemen", "Mayotte",
	"Serbia", "South Africa", "Zambia", "Montenegro", "Zimbabwe",
	"Anonymous Proxy","Satellite Provider","Other",
	"Aland Islands","Guernsey","Isle of Man","Jersey","Saint Barthelemy","Saint Martin"
]

buffer = null

GEOIP_TYPE = 1
GEOIP_RECORD_LEN = 3
GEOIP_COUNTRY_BEGIN = 16776960

seekCountry = seekCountry3 = (ip32) ->

	offset = 0
	for depth in [31..0]
		pos = 6 * offset
		pos += 3 if ip32 & (1 << depth)
		offset = buffer[pos] + (buffer[pos + 1] << 8) + (buffer[pos + 2] << 16)
		return offset - GEOIP_COUNTRY_BEGIN if offset >= GEOIP_COUNTRY_BEGIN
	0

seekCountry4 = (ip32) ->

	offset = 0
	for depth in [31..0]
		pos = 8 * offset
		pos += 4 if ip32 & (1 << depth)
		offset = buffer[pos] + (buffer[pos + 1] << 8) + (buffer[pos + 2] << 16) + (buffer[pos + 3] << 24)
		return offset - GEOIP_COUNTRY_BEGIN if offset >= GEOIP_COUNTRY_BEGIN
	0

getLocation = (ipaddr, full) ->

	p = String(ipaddr).split('.')
	ip32 = +p[0] * 16777216 + +p[1] * 65536 + +p[2] * 256 + +p[3]

	id = seekCountry ip32
	return undefined if id <= 0

	if GEOIP_TYPE > 1
		offset = id + (2 * GEOIP_RECORD_LEN) * GEOIP_COUNTRY_BEGIN
		id = buffer[offset]

	return id unless full

	record =
		id: id
		country_code: GEOIP_COUNTRY_CODES[id]
		country_code3: GEOIP_COUNTRY_CODES3[id]
		country_name: GEOIP_COUNTRY_NAMES[id]

	if GEOIP_TYPE > 1
		b = e = offset + 1
		e++ while buffer[e]
		record.region_name = buffer.toString 'utf8', b, e
		b = e = e + 1
		e++ while buffer[e]
		record.city_name = buffer.toString 'utf8', b, e
		b = e = e + 1
		e++ while buffer[e]
		record.postal_code = buffer.toString 'utf8', b, e
		b = e + 1
		n = buffer[b] + (buffer[b + 1] << 8) + (buffer[b + 2] << 16)
		b += 3
		record.latitude = (n/10000.0).toFixed(6) - 180
		n = buffer[b] + (buffer[b + 1] << 8) + (buffer[b + 2] << 16)
		b += 3
		record.longitude = (n/10000.0).toFixed(6) - 180
		if GEOIP_TYPE is 2
				n = buffer[b] + (buffer[b + 1] << 8) + (buffer[b + 2] << 16)
				record.dma_code = record.metro_code = Math.floor n / 1000
				record.area_code = n % 1000

	record

module.exports = (filename = "./GeoIP.dat") ->

	buffer = require('fs').readFileSync filename
	buflen = buffer.length

	for i in [0..19]
		pos = buflen - i - 3
		if buffer[pos] is 255 and buffer[pos + 1] is 255 and buffer[pos + 2] is 255
			GEOIP_TYPE = buffer[pos + 3]
			GEOIP_TYPE -= 105 if GEOIP_TYPE >= 106
			GEOIP_COUNTRY_BEGIN = 16700000 if GEOIP_TYPE is 7
			GEOIP_COUNTRY_BEGIN = 16000000 if GEOIP_TYPE is 3
			if GEOIP_TYPE in [2, 4, 5, 6, 9]
				GEOIP_COUNTRY_BEGIN = buffer[pos + 4] + (buffer[pos + 5] << 8) + (buffer[pos + 6] << 16)
				if GEOIP_TYPE in [4, 5]
					GEOIP_RECORD_LEN = 4
					seekCountry = seekCountry4


	getLocation
accessors = require "./accessors"
transforms = require "./transforms"
marked = require 'marked'
Validate = require "./validate"
Auth = require './auth'
Deco = require './decorators'
{mongo} = require './connections'

exports.createApiKey = Auth.ensureDotAuthorized "manage:owner:put", (req, res) ->
	accessors.createApiKey req.params.owner, req.params.email, (err, result) ->
		return res.endWithError "Error 42: Failed to create an api key." unless result.key
		res.endWithJson 200,
			key: result.key,
			owner: result.owner
			password: result.password

exports.loginRoute = Deco.routeHandler (req, res) ->
	email = req.getMpathParam('email')
	password = req.getMpathParam('password')
	return res.endWithNotAuthorized("Email and password are both required.") unless (email and password and email.length > 3 and password.length > 1)
	mongo.apikeys.findOne { email: email, password: password }, (err, doc) ->
		return res.endWithError(err) if err
		return res.endWithNotAuthorized("Incorrect email/password combination.") unless doc
		return res.endWithJson 200, { key: doc.code, email: email, owner: doc.owner }

exports.listApiKeys = Auth.ensureDotAuthorized "manage:apikeys-list", (req, res) ->
	agentCode = req.getMpathParam('agent') ? '@'
	accessors.getApiKeys req.params.owner, (err, items) ->
		return res.endWithError err if err
		if req.getMpathParam('perms')?
			perms = req.getMpathParam('perms').split(',')
			for item in items
				item.permissions = resolveIsAuthorized item, agentCode, perms
		$(items).clean('_id')
		res.endWithJson 200,
			data: {apikeys: items}

exports.transformsList = Auth.ensureDotAuthorized "manage:transforms-list", (req, res) ->
	accessors.getTransforms req.params.owner, codes, (err, items) ->
		return res.endWithError err if err
		$(items).clean('_id')
		for item in items
			item.when[i] = transforms.splitConditionExpression(condition) for i,condition of item.when
		res.endWithJson 200,
			data: {transforms: items}

exports.transformsTest = Auth.ensureDotAuthorized "manage:transforms-test", (req, res) ->
	props = req.collectProps()
	markdown = req.query['expand-markdown']?

	transforms.testTransformRules req.params.owner, rules, props, (err, messages) ->
		return res.endWithError err if err
		messages = marked messages.join('  \n') if markdown
		res.endWithJson 200,
			data: 
				props: props, 
				messages: messages

exports.transformsOptions = Deco.routeHandler (req, res) ->
	transforms.getAvailableOptions req.params.owner, (err, items) ->
		return res.endWithError err if err
		res.endWithJson 200,
			data: {options: items}

exports.transformPut = Auth.ensureDotAuthorized "manage:transform-put", (req, res) ->
	accessors.putTransformRule req.params.owner, req.body, (err, transform) ->
		return res.endWithError err if err
		res.endWithJson 200, transform

exports.transformDelete = Auth.ensureDotAuthorized "manage:transform-delete", (req, res) ->
	accessors.removeTransformRule req.params.owner, req.params.code, (err, transform) ->
		return res.endWithError err if err
		res.endWithJson 200, transform
require 'bling'
{EventEmitter} = require 'events'
Url = require 'url'
try
	Redis = require 'redis'
	$.provide $.log 'Supported:', 'redis'
try
	Memcache = require 'memcached'
	$.provide $.log 'Supported:', 'memcache'
try
	Mongo = require 'mongoskin'
	$.provide $.log 'Supported:', 'mongo'

E = (callback) -> (f) -> (err, data) ->
	return f(data) unless err
	callback err, data

class LRUCache
	constructor: (@limit) ->
		@cache = {}
		@sparseList = {}
		@lruList = []
	insert: (key, data) ->
		@cache[key] =
			lruIndex: @lruList.push(key)
			data: data
	get: (key) ->
		item = @cache[key]
		if item?
				i--
			return item.data


`return`
class BinaryTree
	values = (tree) ->
		ret = (tree.values or [])[0..]
		(ret = ret.concat values tree.left) if tree.left
		(ret = ret.concat values tree.right) if tree.right
		ret
	constructor: ->
		@left = @right = @values = false
	insert: (label, value = label) ->
		return (@values or= []).push(value) if label.length is 0
		rest = label[1...]
		if label.charCodeAt(0) % 2
			(@left or= new BinaryTree).insert rest, value
		else
			(@right or= new BinaryTree).insert rest, value
	remove: (label, item) ->
		if label.length is 0
			if not item?
				@values = []
			else if (i = @values.indexOf item) > -1
				@values.splice i, 1
		else
			rest = label[1...]
			if label.charCodeAt(0) % 2 and @left
				@left.remove rest, item
			else if @right
				@right.remove rest, item
		item
	findPrefix: (label) ->
		return values(@) if label.length is 0
		bit = label.charCodeAt(0) % 2
		rest = label[1...]
		if bit
			return @left.findPrefix rest if @left
		else
			return @right.findPrefix rest if @right
		return []
	find: (label) ->
		return @values if label.length is 0
		bit = label.charCodeAt(0) % 2
		rest = label[1...]
		if bit
			return @left.find rest if @left
		else
			return @right.find rest if @right
		return []
	toString: (indent = 0) ->
		indent += 1
		space = $.repeat '  ', indent
		return JSON.stringify(@values) +

b = new BinaryTree()
start = process.hrtime()
op = 0
logTime = ->
	elapsed = process.hrtime(start)
	ms = elapsed[0]*1000.0 + elapsed[1]/1000000.0
while ++op < 10000
	b.insert $.random.string(16), $.random.string(16)
	logTime()
process.stdout.write "\n"
$.log "Done."

class Cache
	Cache.memory = (url) ->
		cache = {}
		expire = (key) ->
			delete cache[key]
			null
		$.delay 0, => @emit 'ready', @
		$.extend @,
			get: (key, callback) ->
				return (callback false, null) unless (key of ttls)
				return (callback false, expire key) unless cache[key].until > $.now
				callback false, cache[key].value
			set: (key, value, ttl = 0) ->
				cache[key] =
					value: value
					until: $.now + parseInt(ttl, 10) * 1000
					lru: lru.length-1
			remove: expire
			close: -> true

	$.depends 'redis', ->
		Cache.redis = (url) ->
			client = Redis.createClient(url.port, url.hostname)
			client.on("error", $.trace 'redis-ttl-cache-error', (err) ->)
				.on "ready", => @emit 'ready', @
			$.extend @,
				get: (key, callback) -> client.get "ttl-cache-"+key, callback
				set: (key, value, ttl = 0) ->
					k = "ttl-cache-"+key
					client.set k, value, ->
						client.expire k, ttl, (err) ->
				remove: (key) -> $.log "TODO: redis.remove() :TODO"
				close: -> client.quit()
	
	$.depends 'memcache', ->
		Cache.memcache = (url) ->
			$.extend @,
				get: -> throw new Error("memcached not supported yet")
				set: -> throw new Error("memcached not supported yet")
				close: ->

	@connect = (url) ->
		if $.is "string", url then url = Url.parse(url)
		proto = (url.protocol or 'memory').replace /:$/,''
		return Cache[proto].apply $.EventEmitter({}), url

class Hub
	Hub.memory = ->
		$.extend @,
			publish: $.publish
			subscribe: $.subscribe
			unsubscribe: $.unsubscribe

	$.depends 'redis', ->
		Hub.redis = (url) ->
			subber = Redis.createClient(url.port, url.hostname)
			pubber = Redis.createClient(url.port, url.hostname)

			onerror = $.trace 'redis-error', (err) ->
			subber.on "error", onerror
			pubber.on "error", onerror

			onready = => if --readyCount <= 0 then @emit("ready", @)
			subber.on "ready", onready
			pubber.on "ready", onready

			subber.on "message", (channel, data) ->
				channels[channel]?.call(data)

			$.extend @,
				publish: (channel, data) -> pubber.publish channel, JSON.stringify data
				subscribe: (channel, callback) ->
					(channels[channel] or= $()).push (data) -> callback JSON.parse data
					subber.subscribe channel
				unsubscribe: (channel, callback) ->
					if not callback
						channels[channel] = $()
					callbacks = channels[channel]
					if callbacks and (i = callbacks.indexOf callback) > -1
						callbacks.splice i, 1
					if not callbacks?.length
						subber.unsubscribe channel
				close: -> subber.quit(); pubber.quit()
	
	@connect = (url) ->
		if $.is "string", url then url = Url.parse(url)
		proto = (url.protocol or 'memory').replace /:$/,''
		return Hub[proto].call $.EventEmitter({}), url

Factory = (args) ->
	cls = $.EventEmitter (->)
	onReady = -> if --readyLatch <= 0 then cls.emit 'ready'
	mongo = Mongo.db args.db; do onReady
	hub = Hub.connect(args.hub).on 'ready', onReady
	cache = Cache.connect(args.cache).on 'ready', onReady
	collection = (t) -> t.collection or (t.name.toLowerCase() + 's')
	cache_key = (t, query) -> $.hash(collection t) + $.hash query
	find = $.trace 'find', (t, query, callback) ->
		mongo.collection(collection t)
			.findOne query, callback
	changelog = []
	$.extend cls::,
		update: (query, callback) ->
			e = E callback
			coll = collection @constructor
			self = @
			mongo.collection(coll).updateById self._id, query, {safe: true, upsert:false}, e (data) ->
					$.extend self, data
					return callback false, data
		release: ->
			hub.unsubscribe @_id.toString()
			@
	$.extend cls,
		unique: (args...) ->
			for arg in args
				$.log "creating unique index:",collection(@),arg
				mongo.collection(collection @).ensureIndex arg, { unique: true }, ->
		index: (args...) ->
			for arg in args
				$.log "creating index:",collection(@),arg
				mongo.collection(collection @).ensureIndex arg, ->
		get: (query, callback) ->
			e = E callback
			self = @
			key = cache_key self, query
			cache.get key, e (cached) ->
				$.log "cached?:",cached?
				return callback false, cached if cached?
				find self, query, e $.trace 'find-result', (doc) ->
					$.inherit self, doc
					cache.set key, doc, self.cache_timeout or 90
					$.log "Hub: SUBscribing to",doc._id
					hub.subscribe doc._id.toString(), ->
						$.log "Hub: TRIGGER subscription"
						find self, query, e (newdoc) ->
							$.extend doc, newdoc
							cache.set key, newdoc, self.cache_timeout or 90
					callback false, doc
		create: (obj, callback) ->
			e = E callback
			mongo.collection(collection @).insert obj, {safe: false}, e (data) =>
				return callback false, $.inherit @, data[0]

		remove: (query, callback) ->
			e = E callback
			key = cache_key @, query
			mongo.collection(collection @).remove query, e ->
				cache.get key, e (data) ->
					if data?
						$.log "Hub: UNsubscribing from", data._id
						hub.unsubscribe data._id.toString()
						cache.remove key, e ->
					callback false, null
		disconnect: ->
			mongo.close()
			hub.close()
			cache.close()
	cls

$.depends 'mongo', ->
	$.type.register "mongoid",
		match:      -> @_bsontype is "ObjectID"
		string: (x) -> x.toString()
		number: (x) -> parseInt x.toString(), 16
		hash:   (x) -> $.hash x.toString()
	
	id = new Mongo.ObjectID()
	$.assert $.type(id) is "mongoid"
	$.assert $.toString(id) is id.toString()
	$.assert isFinite $.as "number", id

	$.log "error:",err
$.extend module.exports,
	init: Factory
	Hub: Hub
	Cache: Cache

h = Hub.connect("redis://localhost:6379").on 'ready', ->
	h.subscribe 'test', -> $.log 'test1'
	h.subscribe 'test', -> $.log 'test2'
	h2 = Hub.connect("redis://localhost:6379").on 'ready', ->
		h2.subscribe 'test', -> $.log 'test3'
		h.publish 'test', "message"
		$.delay 10, ->
			h2.close()
			h.close()
`return`

PassiveRecord = requre('passive-models').init(
	db: "mongo://localhost:27017/test",
	cache: "memory://localhost",
	hub: "redis://localhost:6379"
).on 'ready', ->
	$.log "PassiveRecord is ready."

	class Agent extends PassiveRecord
		@unique owner: 1, code: 1
		@index owner: 1


	$.assert "get" of Agent
	$.assert "update" of new Agent()

	Agent.remove {}, (err) ->

		Agent.create { owner: 'acme', code: 'asdf' }, e (agent1) ->

				Agent.get { owner: 'acme', code: 'asdf' }, e (agent2) ->
					$.assertEqual ($.log "agent2.magic:", agent2.magic), undefined

				agent1.update { $set: { magic: 'xyzl' } }, e (doc) ->
					$.assertEqual ($.log "agent1.magic:", agent1.magic), 'xyzl'

			$.delay 150, ->
				Agent.get { owner: 'acme', code: 'asdf' }, e (agent3) ->
					$.assertEqual ($.log "agent3 magic:", agent3.magic), 'xyzl'
	
			RemoteRecord = Factory(
				db: "mongo://localhost:27017/test",
				cache: "memory://localhost",
				hub: "redis://localhost:6379"
			).on 'ready', ->
				log = (a...) -> $.log "remote:", a...
				log "RemoteRecord is ready."

				class RemoteAgent extends RemoteRecord
					@collection = 'agents'

				$.delay 10, ->
					RemoteAgent.get { owner: 'acme', code: 'asdf' }, e (agent) ->
						$.assertEqual (log 'agent1.magic:',agent.magic), undefined

				$.delay 400, ->
					RemoteAgent.get { owner: 'acme', code: 'asdf' }, e (agent2) ->
						$.assertEqual (log 'agent2.magic:',agent2.magic), 'xyzl'
				RemoteRecord.disconnect()
	$.delay 300, ->
		PassiveRecord.disconnect()

require 'bling'
crypto = require 'crypto'
{mongo} = require '../connections'
xml2js = require 'xml2js'

Recurly = module.exports

	sha = crypto.createHash 'sha1'
	sha.update config.PRIVATE_KEY
	sha = sha.digest 'binary'
	hmac = crypto.createHmac 'sha1', sha
	hmac.update data
	hmac.digest 'hex'

e = (res) ->
	$.E (err) ->
		if err
		if res? and not res.finished
			res.endWithError err.message

	xmlString = req.rawBody
	parser = new xml2js.Parser( explicitRoot: true, explicitArray: false )
	parser.parseString xmlString, e(res) (xmlDoc) ->
		rootKey = $.keysOf(xmlDoc)[0]
		email = try xmlDoc[rootKey].account.email
		mongo.collection('subscription.events').insert {
			ts: $.now
			email: email
			kind: rootKey
			body: xmlString
		}, e(res)
		publishKey = switch rootKey
			when "new_subscription_notification" then "subscription-new"
			when "successful_payment_notification" then "subscription-renew"
			when "canceled_subscription_notification" then "subscription-cancel"
			else "subscription-ignored"
		$.publish publishKey, email, xmlDoc
		res.end() if not res.finished

$.subscribe "app-start", ->
	$.log "Creating subscription plans..."
	plans = mongo.collection('plans')
	plans.ensureIndex { code: 1 }, { unique: true }
	plans.insert { meta: { name: "Free" }, code: "free" }
	plans.insert { meta: { name: "Developer" }, code: "dev" }
	plans.insert { meta: { name: "Enterprise" }, code: "ent" }

updateSubscription = (email, plan_code) ->
	mongo.collection("plans").findOne { code: plan_code }, (err, plan) ->
		try delete plan.meta
		try delete plan._id
		$.log "Attaching plan:"
		console.log plan
		mongo.collection("apikeys").update { email: email }, { $set: { plan: plan } }, { safe: true, upsert: false, multi: true }, (err) ->
			if err

$.subscribe "subscription-new", (email, xmlDoc) ->
	plan_code = xmlDoc.new_subscription_notification.subscription.plan.plan_code
	updateSubscription email, plan_code

$.subscribe "subscription-cancel", (email, xmlDoc) ->
	updateSubscription email, "free"
require 'bling'
request = require 'request'
{mongo} = require '../connections'
MPATH_URL = $.config "MPATH_URL", "http://localhost:5000"

query = {}
fields = {}
hasId = false

if process.argv.length > 2
	hasId = true
	query._id = mongo.ObjectID(process.argv[2])
	fields = { body: 1 }

mongo.collection('subscription.events').findItems query, fields, (err, items) ->
	i = 0
	$(items).each ->
		if not hasId
		console.log "Re-posting to /recurly..."
		console.log @body
		r = request {
			method: "POST"
			url: [MPATH_URL, "recurly"].join "/"
			body: @body
			jar: false
		}, (err, response, body) ->

	mongo.close()
require 'bling'
accessors = require './accessors'
history = require './history'
Agent = require './agent'
Auth = require './auth'
Learning = require './learning'

exports.decisionConfidenceReportData = Auth.ensureAuthorized 'report:decision-confidence', (req, res) ->
	accessors.getAgent req.params.owner, req.params.agent, {}, (err, agent) ->
		return res.endWithError err if err
		return res.endWithNotFound() unless agent?

		dates = requestedDateRange(req, agent)
		pointCode = requestedPointCode(req, agent)
		comparisonDecision = req.getMpathParam('comparison-decision')

		history.getDecisionConfidenceReportData agent, dates.dateFrom, dates.dateThru, pointCode, comparisonDecision, aggregated, confidenceMeasure, useBonferroni, (err, data) ->
			return res.endWithError err if err

			item.ts = item.date for item in data.items
			$(data.items)
				.clean('_id')
				.zap('date', -> $.date.format @, agent.dateFormat)

			res.endWithJson(200,{
				agent: agent.code
				dateFrom: $.date.format dates.dateFrom, agent.dateFormat
				dateThru: $.date.format dates.dateThru, agent.dateFormat
				data: data})

calculateImpact = (agent, date, pointCode, featureSets, items, temperatureMeasure) ->
	byFeature = Learning.calculateImpact(agent, pointCode, featureSets, items, temperatureMeasure)

	range = min:null, max:null
	for featureItem in byFeature
		for actionItem in featureItem.actions
			range.min = actionItem.impact if (not range.min?) or (actionItem.impact < range.min)
			range.max = actionItem.impact if (not range.max?) or (actionItem.impact > range.max)

	byChoice = []
	choices = Agent.getSetsOfChoices(agent, pointCode)
	for choice in choices
		choiceItem = {choice:choice.join(','), features:[]}
		for featureItem in byFeature
			if featureItem.winner?.choice.toString() is choice.toString()
				choiceItem.features.push {feature:featureItem.feature, impact:featureItem.winner.impact}
		byChoice.push choiceItem

	return {byFeature, byChoice, range, date}


exports.learnedValuesReportData = Auth.ensureAuthorized 'report:learned-values', (req, res) ->
	accessors.getAgent req.params.owner, req.params.agent, {}, (err, agent) ->
		return res.endWithError err if err
		return res.endWithNotFound() unless agent?

		dates = requestedDateRange(req, agent)
		pointCode = requestedPointCode(req, agent)

		history.getLearnedValuesReportData agent, dates.dateFrom, dates.dateThru, pointCode, (err, items) ->
			return res.endWithError err if err

			$(items)
				.clean('_id')
				.zap('date', -> $.date.format @, agent.dateFormat)

			res.endWithJson 200,
				agent: agent.code
				dateFrom: $.date.format dates.dateFrom, agent.dateFormat
				dateThru: $.date.format dates.dateThru, agent.dateFormat
				data: items


exports.impactReportData = Auth.ensureAuthorized 'report:impact', (req, res) ->
	accessors.getAgent req.params.owner, req.params.agent, {}, (err, agent) ->
		return res.endWithError err if err
		return res.endWithNotFound() unless agent?

		dates = requestedDateRange(req, agent)
		pointCode = requestedPointCode(req, agent)

		history.getLearnedValuesReportData agent, dates.dateFrom, dates.dateThru, pointCode, (err, items) ->
			return res.endWithError err if err
			result = []

			dateRange = history.dateRange(dates.dateFrom, dates.dateThru)

			for date in dateRange
				impacts = calculateImpact agent, date, pointCode, features, items, temperatureMeasure
				result.push impacts

			item.date = $.date.format(item.date, agent.dateFormat) for item in result

			res.endWithJson 200,
				agent: agent.code
				dateFrom: $.date.format dates.dateFrom, agent.dateFormat
				dateThru: $.date.format dates.dateThru, agent.dateFormat
				data: result

exports.statusReportData = Auth.ensureDotAuthorized 'report:status', (req, res) ->
	codes = (req.getMpathParam('codes') ? '').split(',')
	numDays = req.getMpathParam('days') ? 14
	todaysDate = $.date.midnight $.date.stamp()

	history.getStatusReportData req.params.owner, codes, todaysDate, numDays - 1, (err, items) ->
		return res.endWithError err if err

exports.magicQuadReportData = Auth.ensureDotAuthorized 'report:magic-quad', (req, res) ->
	accessors.getAgent req.params.owner, req.params.agent, {}, (err, agent) ->
		dates = requestedDateRange(req, agent)
		options = 
			pointCode: requestedPointCode(req, agent)

		history.getMagicQuadReportData agent, dates.dateFrom, dates.dateThru, options, (err, items) ->
			return res.endWithError err if err

requestedPointCode = (req, agent) ->
	pointCode = req.getMpathParam('point')
	pointCode = agent.defaults.point unless agent.points[pointCode]?
	return pointCode

requestedDateRange = (req, agent) ->
	result =
		dateFrom: $.date.parse(req.params.dateFrom, agent.dateFormat)


if require.main is module
	fakeResponse = -> end: $.log
	req =
		params:
			agent: 'agent-103'
			owner: 'acme'
			dateFrom: '2012-07-04'
			dateThru: '2012-07-05'
		query:
			apikey: '123456789'
		headers: {}

	exports.decisionConfidenceReportData(req, fakeResponse())
{db} = require './connections'
accessors = require('./accessors')
Agent = require "./agent"
Learning = require './learning'
 
exports.goal = (req, res) -> handleGet(req, res, 'json')
exports.redirect = (req, res) -> handleGet(req, res, 'redirect')

handleGet = (req, res, format) ->
	props = req.collectProps()

	accessors.getAgent req.params.owner, req.params.agent, props, (err, agent) ->
		return res.endWithNotFound() unless agent?

		format = 'redirect' if format is 'json' and Agent.hasTag(agent, 'redirect')

		goalCode = req.params.goal ? agent.defaults.goal
		goal = agent.goals[goalCode]
		return res.endWithNotFound("No such goal") unless goal?

		accessors.getSession req.getSessionId(agent), agent, true, (err, sess) ->
			return res.endWithNotFound('Unknown session') unless sess?

			req.applyToSession sess, props, agent

			res.setMpathCookie agent, sess, req

			reward = readRewardValue agent, sess, req.getMpathParam('reward')
			isRewardValid = isFinite(reward)

			goalItem = code: goalCode, val: reward, ts: sess.ts

			if isRewardValid
				sess.goals.push goalItem
				sess.reward += reward

			switch format
				when 'json'
					res.endWithJson 200,
						session: sess.code
						reward: sess.reward
				when 'redirect'
					res.redirect redirectUrl

			if isRewardValid
				$.delay 1, ->
					accessors.updateOnGoal sess, agent, goalItem, (err) ->
						Learning.updateLearningOnGoal sess, agent

readRewardValue = (agent, sess, passed) ->
	s = agent.settings.goals ? {value: default: 1}
	reward = defaultReward = (s.value?.default || 1)
	unless s.explicit?.enabled is false
		passed = parseFloat(passed)
		reward = passed if passed?
	totals = getGoalTotals(sess)
	if s.session?.limit?
		reward = NaN unless (totals.count + 1) <= s.session.limit
	return reward ? defaultReward

getGoalTotals = (sess) ->
	totals = {val:0, count:0}
	for goalItem in sess.goals 
		totals.count++
		totals.val += goalItem.val 
	return totals
require 'bling'

exports.transformSchema = 
	type:"object",
	additionalProperties:false,
	properties:
		owner:
			type: "string"
			required: true
		code:
			type: "string"
			required: true
		agents:
			type: "array"
			required: true
			minItems: 1
			maxItems: 100
			items:
				type:"string"
		apply:
			type: "object"
			required: true
			additionalProperties:false,
			properties:
				segment:
					type: "string"
					required: false
				feature:
					type: "string"
					required: false
		when:
			minItems: 0
			maxItems: 100
			items:
				minItems: 3
				maxItems: 3
				items:
					type:"string"

exports.agentSchema =
	type:"object",
	additionalProperties:false,
	properties:
		owner:
			type: "string"
			required: true
		code:
			type: "string"
			required: true
		name:
			type: "string"
			required: false
		created:
			type: "number"
			required: false
		_id:
			type: "string"
			required: false
		tags:
			type: "array"
			required: false
			items:
				type: "string"
		goals:
			type: "array"
			required: true
			minItems: 1
			items:
				type: "object"
				additionalProperties:false
				properties:
					code:
						type: "string"
						required: true
					name:
						type: "string"
						required: false
					value:
						type: "object"
						required: false
						additionalProperties: false
						properties:
							default:
								type: "number"
								required: false
							min:
								type: "number"
								required: false
							max:
								type: "number"
								required: false
					data:
						type:"object"
						required:false
						additionalProperties:true
		learning:
			type:"object"
			additionalProperties:false
			required:false
			properties:
				controlGroupRate:
					type:"number"
					required: false
				learningRate:
					type:"number"
					required: false
				explorationRate:
					type:"number"
					required: false
				discountRate:	
					type:"number"
					required: false
				experienceThreshold:
					type:"number"
					required:false
		settings:
			type:"object"
			additionalProperties:false
			required:false
			properties:
				sessions:
					type:"object"
					required:false
					additionalProperties:false
					properties:
						sticky:
							type:"boolean"
							required:false
				cookies:
					type:"object"
					required:false
					additionalProperties:false
					properties:
						enabled:
							type:"boolean"
							required:false
				goals:
					type:"object"
					required:false
					additionalProperties:false
					properties:
						value:
							type:"object"
							required:false
							additionalProperties:false
							properties:
								default:
									type:"number"
									required:false
								min:
									type:"number"
									required:false
								max:
									type:"number"
									required:false
						explicit:
							type:"object"
							required:false
							additionalProperties:false
							properties:
								enabled:
									type:"boolean"
									required:false
								min:
									type:"number"
									required:false
								max:
									type:"number"
									required:false
						session:
							type:"object"
							required:false
							additionalProperties:false
							properties:
								limit:
									type:"number"
									required:false
		targeting:
			type:"object"
			additionalProperties:false
			required:false
			properties:
				segments:
					type:"array"
					required:false
					items:
						type: "object"
						additionalProperties:false
						properties :
							code:
								type: "string"
								required:true
							name:
								type:"string"
								required:false
				features:
					type:"array"
					required:false
					items:
						type: "object"
						additionalProperties:false
						properties :
							code:
								type: "string"
								required:true
							name:
								type:"string"
								required:false
				usesFeatures:
					type:"boolean"
					required: false
		points:
			type:"array"
			required:true
			minItems:1
			items:
				type: "object"
				additionalProperties:false
				properties :
					code:
						type: "string"
						required:true
					name:
						type:"string"
						required:false
					decisions:
						type: "array"
						required:true
						minItems:1
						items:
							type:"object"
							additionalProperties:false
							properties:
								code:
									type: "string"
									required:true
								name:
									type:"string"
									required:false
								choices:
									type:"array"
									required:true
									minItems:2
									items:
										type:"object"
										additionalProperties:false
										properties:
											code:
												type: "string"
												required:true
											name:
												type:"string"
												required:false
											ranks:
												type:"object"
												required:false
												items:
													type:"object"
													properties:
															type:"array"
															items:
																type:"string"
											data:
												type:"object"
												required:false
												additionalProperties:true

exports.toRuntimeStyle = (agent, callback) ->
	return callback(false, agent) unless agent

	delete agent._id if agent._id?
	
	applyName(agent)
	applyNames(agent.points)
	applyNames(agent.goals)

	agent.points.forEach (point) ->
		applyNames(point.decisions)
		point.decisions.forEach (decision) ->
			applyNames(decision.choices)
			if not decision.ranks
				decision.ranks = default: []
				decision.choices.forEach (choice) ->
					decision.ranks['default'].push(choice.code)
					choice.data = safeMap(choice.data) if choice.data?
			decision.choices = arrayToMap(decision.choices, "code")
		point.decisions = arrayToMap(point.decisions, "code")

	agent.goals.forEach (goal) ->
		goal.value = {default: 1} unless goal.value?
		goal.data = safeMap(goal.data) if goal.data?

	agent.defaults =

	agent.goals = arrayToMap(agent.goals, "code")
	agent.points = arrayToMap(agent.points, "code")


	agent.settings = $.extend(def.settings, agent.settings)
	agent.learning = $.extend(def.learning, agent.learning)

	agent.housekeeping ?= {}

	exports.applyTargeting(agent, callback)

exports.applyTargeting = (agent, callback) ->
	agent.targeting ?= {}
	agent.targeting.segments ?= defaults().targeting.segments.concat()
	agent.targeting.features ?= defaults().targeting.features.concat()

	segmentCodes = getCodes agent.targeting.segments
	agent.targeting.segments.unshift({code:'(none)'}) if segmentCodes.indexOf('(none)') is -1
	featureCodes = getCodes agent.targeting.features
	agent.targeting.features.unshift({code:'(none)'}) if featureCodes.indexOf('(none)') is -1


	applyNames(agent.targeting.segments)
	applyNames(agent.targeting.features)

	callback(false, agent)


applyNames = (arr) -> arr.forEach applyName
applyName = (item) -> (item.name = item.code) unless item.name?

getCodes = (arr) ->
	codes = []
	for item in arr
		codes.unshift item.code if item.code?
	return codes

	settings:
		sessions:
			sticky: true
		cookies:
			enabled: true
		goals:
			value:
				default: 1
			explicit:
				allow: true
			session:
				limit: 1
	learning:
		controlGroupRate: 0
		discountRate: 0.9
		explorationRate: .5
		learningRate: .15
		experienceThreshold: 100
	targeting :
		segments: [{
			code:"(none)"
			name:"(no segment)"
		}]
		features: [{
			code:"(none)"
			name:"(no feature)"
		}]

safeMap = (o) ->
	map = {}
	for key,value of o
		map[key] = value.toString() if value?
	map

arrayToMap = (arr, key) ->
	map = {}
	for item in arr
		map[item[key]] = item
	map
require 'bling'
request = require 'request'

rootKey = $.config "MPATH_APIKEY"
baseUrl = $.config "MPATH_URL", "http://localhost:5001"
goalCode = 'goal-1'
pointCode = 'point-1'
decisionCode = 'decision-1'
numLoops = 10000

createUrl = (owner, email) -> [baseUrl,owner,"create-key",email].join "/"
agentUrl = (owner, agent) -> [baseUrl,owner,agent].join "/"
goalUrl =  (owner, agent, goal, value) ->
	ret = [agentUrl(owner, agent), "goal", goal].join "/"
	if value?
	ret
decisionUrl = (owner, agent, actions, features, point) ->
	if $.is "array", actions then actions = actions.join ","
	ret = ([agentUrl(owner, agent),"decisions", actions].join "/") + "?"
	if features?
	if point
	ret
expireUrl = (owner, agent) -> [agentUrl(owner, agent),"expire"].join "/"

$.log """
"""

skipSuccess = (n, f) ->
	(args...) ->
		(return) if not args[0]? and --n > 0
		f(args...)

normalizeOutcomes = (n, obj) ->
	for a of obj
		for b of obj[a]
			obj[a][b] /= n
	obj

compareOutcomes = (expected, real) ->
	for a of expected
		for b of expected[a]
			delta = Math.abs(expected[a][b] - real[a][b])

timing = {}
queues =
	decision: 0
	reward: 0
	expire: 0
maxQueue =
	decision: 0
	reward: 0
	expire: 0
checkQueue = ->
	for k of queues
		maxQueue[k] = Math.max maxQueue[k]|0, queues[k]

$.testGroup "Learning",
	featureLoopAsync: (cb) ->
		startDate = $.date.addDays $.date.stamp(), -14
		endDate = $.date.stamp()
		dateStep = Math.floor (endDate - startDate) / numLoops
		loopDate = (i) -> startDate + (dateStep * i)
		owner = "owner_" + $.random.string 9
		agent = "agent_" + $.random.string 9
		email = $.random.string(8) + "@conductrics.com"
		actions = ["FamilyOffer", "IndividualOffer", "SocialOffer"]
		outcomes =
			control: { }
			explore: { }
			exploit: { }
		expected_outcomes = {
			control: { a: 0.2, b: 0 }
			explore: { a: 0.17, b: 0.17 }
			exploit: { a: 0.0, b: .45 }
		}
		done = skipSuccess numLoops, (err) ->
			cb(err) if err
			normalizeOutcomes(numLoops, outcomes)
			$.log "Outcomes:", outcomes
			$.log "Max Queues:", maxQueue
			try
				compareOutcomes(outcomes, expected_outcomes)
				cb()
			catch err
				cb(err)

		request
			method: "PUT"
			url: createUrl owner, email
			headers:
				"x-mpath-apikey": rootKey
				"x-mpath-owner": "mpath-signup"
				"x-mpath-ts": startDate
		, (err, resp, body) ->
			done(err) if err
			key = JSON.parse(body)
			apikey = key.key

			get_decision = (loopIndex) ->
				ts = loopDate(loopIndex)
				session = $.random.string 16
				timing[session] = {}
				mpath_request = (method, url, done) ->
					checkQueue()
					request
						method: method
						url: url
						headers:
							"x-mpath-apikey": apikey
							"x-mpath-session": session
							"x-mpath-ts": ts
					, done
				expire_session = ->
					timing[session].expire = $.now
					queues.expire += 1
					mpath_request "GET", expireUrl(owner, agent), (err, resp, body) ->
						queues.expire -= 1
						done(err)

				f =
					apartments: 0
					singleFamily: 0
					newCustomer: 0
					currentCustomer: 0
					incomeHigh: 0
					incomeLow: 0
					google: 0
					facebook: 0
				f.apartments = $.random.coin(.2)
				f.singleFamily = not f.apartments
				f.newCustomer = $.random.coin(.7)
				f.currentCustomer = not f.newCustomer
				f.incomeHigh = $.random.coin(.7)
				f.incomeLow = not f.incomeHigh
				i = $.random.integer(100)
				if i < 30
					f.google = 1
					f.facebook = 0
				if 30 < i < 50
					f.google = 0
					f.facebook = 1

				features = $(Object.keys(f))
					.filter(-> f[@])

				url = decisionUrl(owner, agent, actions, features)
				send_reward = (amount) ->
					goal_url = goalUrl(owner, agent, goalCode, amount)
					timing[session].reward = $.now
					queues.reward += 1
					mpath_request "POST", goal_url, (err, resp, body) ->
						queues.reward -= 1
						done(err) if err
						expire_session session

				timing[session].decision = $.now
				queues.decision += 1
				mpath_request "GET", url, (err, resp, body) ->
					queues.decision -= 1
					done(err) if err
					body = JSON.parse(body)
					code = body.decisions[decisionCode].code
					outcomes[body.policy][code] or= 0
					outcomes[body.policy][code] += 1
					send_reward switch code
						when "FamilyOffer"
							3 + (10 * f.singleFamily) + (-3 * f.apartments) + (5 * f.incomeHigh) + (-2 * f.incomeLow)
						when "IndividualOffer"
							2 + (-2 * f.singleFamily) + (10 * f.apartments) + (2 * f.incomeHigh)
						when "SocialOffer"
							5 + (5 * f.facebook) + (2 * f.google)

			for i in [0...numLoops] then do (i) ->
				setTimeout((-> get_decision i), i * testInterval)

require 'bling'
request = require 'request'

rootKey = process.env.SIGNUP_MPATH_APIKEY
rootOwner = "mpath-signup"
baseUrl = process.env.MPATH_URL or "http://localhost:5001"
goalCode = 'goal-1'
pointCode = 'point-1'
decisionCode = 'decision-1'
numLoops = 20000
startDate = $.date.addDays $.date.stamp(), -14
endDate = $.date.stamp()
dateStep = (endDate - startDate) / numLoops
loopDate = (i) -> startDate + (dateStep * i)


createUrl = (owner, email) -> [baseUrl,owner,"create-key",email].join "/"
agentUrl = (owner, agent) -> [baseUrl,owner,agent].join "/"
goalUrl =  (owner, agent, goal) -> [agentUrl(owner, agent), "goal", goal].join "/"
decisionUrl = (owner, agent) -> [agentUrl(owner, agent),"decisions"].join "/"
expireUrl = (owner, agent) -> [agentUrl(owner, agent),"expire"].join "/"
impactReportUrl = (owner, agent) -> [agentUrl(owner, agent),"report","impact"].join "/"

$.log """
"""

skipSuccess = (n, f) ->
	(args...) ->
		(return) if not args[0]? and --n > 0
		f(args...)

normalizeOutcomes = (n, obj) ->
	for a of obj
		for b of obj[a]
			obj[a][b] /= n
	obj

compareOutcomes = (expected, real) ->
	for a of expected
		for b of expected[a]
			delta = Math.abs(expected[a][b] - real[a][b])

$.testGroup "Learning",
	learningLoopAsync: (cb) ->
		owner = "owner_" + $.random.string 9
		agent = "agent_" + $.random.string 9
		email = $.random.string(8) + "@conductrics.com"
		outcomes =
			control: { }
			explore: { }
			exploit: { }
		expected_outcomes = {
			control: { a: 0.1, b: 0 }
			explore: { a: 0.1, b: 0.1 }
			exploit: { a: 0.0, b: .65 }
		}
		done = skipSuccess numLoops, (err) ->
			cb(err) if err
			normalizeOutcomes(numLoops, outcomes)
			$.log "Outcomes:"
			$.log outcomes
			try
				compareOutcomes(outcomes, expected_outcomes)
				cb()
			catch err
				cb(err)
		$.log "creating api key..."
		request
			method: "PUT"
			url: createUrl owner, "jesse@conductrics.com"
			headers:
				"x-mpath-apikey": rootKey
				"x-mpath-owner": rootOwner
				"x-mpath-ts": startDate
		, (err, resp, body) ->
			done(err) if err
			key = JSON.parse(body)
			
			get_decision = (loopIndex) ->
				apikey = key.key
				ts = loopDate(loopIndex)
				session = $.random.string 16
				mpath_request = (method, url, done) ->
					request
						method: method
						url: url
						headers:
							"x-mpath-apikey": apikey
							"x-mpath-session": session
							"x-mpath-ts": ts
					, done
				expire_session = -> mpath_request "GET", expireUrl(owner, agent), done
				send_reward = ->
					mpath_request "POST", goalUrl(owner, agent), (err, resp, body) ->
						done(err) if err
						expire_session session
				mpath_request "GET", decisionUrl(owner, agent), (err, resp, body) ->
					done(err) if err
					$.log body
					body = JSON.parse(body)
					code = body.decision[decisionCode].code
					policy = body.policy
					outcomes[policy][code] or= 0
					outcomes[policy][code] += 1
					if code is "b"
						send_reward()
					else
						expire_session()
			setTimeout((-> get_decision(i)),i*testInterval) for i in [0...numLoops]

require 'bling'
request = require 'request'

rootKey = process.env.SIGNUP_MPATH_APIKEY
rootOwner = "mpath-signup"
baseUrl = process.env.MPATH_URL or "http://localhost:5000"
goalCode = 'goal-1'
pointCode = 'point-1'
decisionCode = 'decision-1'
numLoops = 20000

createUrl = (owner, email) -> [baseUrl,owner,"create-key",email].join "/"
agentUrl = (owner, agent) -> [baseUrl,owner,agent].join "/"
goalUrl =  (owner, agent, goal) -> [agentUrl(owner, agent), "goal", goal].join "/"
decisionUrl = (owner, agent) -> [agentUrl(owner, agent),"decision"].join "/"
expireUrl = (owner, agent) -> [agentUrl(owner, agent),"expire"].join "/"
impactReportUrl = (owner, agent) -> [agentUrl(owner, agent),"report","impact"].join "/"

$.log """
"""

skipSuccess = (n, f) ->
	(args...) ->
		(return) if not args[0]? and --n > 0
		f(args...)

$.testGroup "Learning",
	asyncStressDecisionsOnly: (cb) ->
		owner = "owner_" + $.random.string 9
		agent = "agent_" + $.random.string 9
		email = $.random.string(8) + "@conductrics.com"
		done = skipSuccess numLoops, (err) ->
			return cb(err) if err
			cb()
		request
			method: "PUT"
			url: createUrl owner, "jesse@conductrics.com"
			headers:
				"x-mpath-apikey": rootKey
				"x-mpath-owner": rootOwner
		, (err, resp, body) ->
			return done(err) if err
			key = JSON.parse(body)
			
			get_decision = (loopIndex) ->
				apikey = key.key
				session = $.random.string 16
				mpath_request = (method, url, done) ->
					request
						method: method
						url: url
						headers:
							"x-mpath-apikey": apikey
							"x-mpath-session": session
					, done
				mpath_request "GET", decisionUrl(owner, agent), (err, resp, body) ->
					return done(err) if err
					body = JSON.parse(body)
					done()
			get_decision(i) for i in [0...numLoops]

require 'bling'
request = require 'request'

rootKey = process.env.SIGNUP_MPATH_APIKEY
rootOwner = "mpath-signup"
baseUrl = process.env.MPATH_URL or "http://localhost:5000"
goalCode = 'goal-1'
pointCode = 'point-1'
decisionCode = 'decision-1'
numLoops = 20000

createUrl = (owner, email) -> [baseUrl,owner,"create-key",email].join "/"
agentUrl = (owner, agent) -> [baseUrl,owner,agent].join "/"
goalUrl =  (owner, agent, goal) -> [agentUrl(owner, agent), "goal", goal].join "/"
decisionUrl = (owner, agent) -> [agentUrl(owner, agent),"decision"].join "/"
expireUrl = (owner, agent) -> [agentUrl(owner, agent),"expire"].join "/"
impactReportUrl = (owner, agent) -> [agentUrl(owner, agent),"report","impact"].join "/"

$.log """
"""

skipSuccess = (n, f) ->
	(args...) ->
		(return) if not args[0]? and --n > 0
		f(args...)

$.testGroup "Learning",
	asyncStressDecisionsOnly: (cb) ->
		owner = "owner_" + $.random.string 9
		agent = "agent_" + $.random.string 9
		email = $.random.string(8) + "@conductrics.com"
		done = skipSuccess numLoops*2, (err) ->
			return cb(err) if err
			cb()
		request
			method: "PUT"
			url: createUrl owner, "jesse@conductrics.com"
			headers:
				"x-mpath-apikey": rootKey
				"x-mpath-owner": rootOwner
		, (err, resp, body) ->
			return done(err) if err
			key = JSON.parse(body)
			
			get_decision = (loopIndex) ->
				apikey = key.key
				session = $.random.string 16
				mpath_request = (method, url, done) ->
					request
						method: method
						url: url
						headers:
							"x-mpath-apikey": apikey
							"x-mpath-session": session
					, done
				mpath_request "GET", decisionUrl(owner, agent), (err, resp, body) ->
					return done(err) if err
					done()
				mpath_request "GET", decisionUrl(owner, agent), (err, resp, body) ->
					return done(err) if err
					done()
			get_decision(i) for i in [0...numLoops]

fs = require 'fs'

map = null

exports.timezoneFile = './data/timezone.txt'

exports.lookup = (country, region) ->
	initialize() if not map?
	key = keyFor(country, region ? '')
	return map[key]

keyFor = (country, region) ->

initialize = () ->
	map = {}
	text = fs.readFileSync exports.timezoneFile, 'ascii'
	lines = text.split '\n'
	count = 0
	for line in lines
		parts = line.split '\t'
		if parts.length is 3
			[country, region, timezone] = parts
			key = keyFor country, region
			map[key] = timezone
			count++


if require.main is module
	timezone = exports.lookup 'US', 'CA'
accessors = require './accessors'
timezones = require './timezones'
async = require 'async'
csv = require 'csv'
URL = require 'url'
try
catch e
	GeoIP = require 'geoip-static'
Validate = require './validate'

	apply: {segment: "high-value"}
	when: [ "@pastPurchaseTotal gt 100" ]

exports.applyTransforms = (rules, props, callback) ->
	return callback false unless rules?.length > 0
	applyTransformRules rules, props, null, callback

exports.testTransformRules = (ownerCode, rules, props, callback) ->
	async.mapSeries rules,
		(rule, cb) -> 
		(err) -> 
			messages = []
			applyTransformRules rules, props, messages, (err) ->
				return callback err if err

applyTransformRules = (rules, props, messages, callback) ->
	async.forEach rules, 
		(rule, cb) ->
			applyTransformRule props, rule, messages, cb
		(err) ->

applyTransformRule = (props, rule, messages, callback) ->
	return callback false unless rule.when?
	evaluateConditions rule.when, props, messages, (err, conditionsPassed) ->
		return callback(false) unless conditionsPassed
		return callback(false) unless rule.apply.segment? or rule.apply.feature?
		if rule.apply.segment?
			lookupValue rule.apply.segment, props, false, (err, segmentToApply) ->
				if segmentToApply?
					props.segment = segmentToApply
				return callback false
		if rule.apply.feature?
			props.features ?= []
			async.map rule.apply.feature.split(','),
				(feature, cb) ->
					lookupValue feature, props, false, cb
				(err, featuresToApply) ->
					return callback err if err
					for featureToApply in featuresToApply
						if featureToApply?
							props.features.push featureToApply

evaluateConditions = (conditions, props, messages, callback) ->
	result = true
	async.mapSeries conditions,
		(condition, cb) ->
			evaluateCondition condition, props, messages, cb
		(err, results) ->
			return callback err if err
			for rr in results
				result = false unless (result and rr)
			return callback false, result

evaluateCondition = (condition, props, messages, callback) ->
	parts = exports.splitConditionExpression condition
	return callback(false, undefined) unless parts?
	evaluator = operators[parts[1]]
	lookupValue parts[0], props, true, (err, left) ->
		lookupValue parts[2], props, true, (err, right) ->
			return callback(false, undefined) unless evaluator? and left? and right?
			return callback(false, result)

exports.splitConditionExpression = (condition) ->
	return condition if require('util').isArray(condition)
	return [parts[0], parts[1], parts[2..].join(' ')]

lookupValue = (name, props, flexible, callback) ->
		if providers[name]?
			return providers[name].get props, (err, value) ->
				return callback false, name if value is true
				return callback false, null
		if providers[name]?
			return providers[name].get props, callback
	if props.inputs? and name[0] is '@'
		return callback false, props.inputs[name]
	if flexible
		if providers[name]?
			return providers[name].get props, callback
		if looksLikeArray name
			return callback false, parseArray name
		if isFinite parseInt name
			return callback false, parseInt name
		return callback false, name

providers =
	gmtHourOfDay:
		help: "The hour of the day according to the 24-hour clock, as a number from 0 to 23 (where 0 indicates the hour that starts at midnight)."
		tags: ['GMT','Time']
		get: (props, cb) ->
			return cb false, timeHere().getUTCHours()
	gmtDayOfMonth:
		help: "The day of the month, as a number from 1 through 30 or 31 (for most months)."
		tags: ['GMT','Time']
		get: (props, cb) ->
			return cb false, timeHere().getUTCDate()
	gmtDayOfWeek:
		help: "The day of the week, as a number from 1 to 7 (where 1 indicates Sunday)."
		tags: ['GMT','Time']
		get: (props, cb) ->
			return cb false, timeHere().getUTCDay()
	gmtWeekPart:
		help: "Will be 'weekend' or 'weekday' depending on whether it is a Saturday or Sunday."
		tags: ['GMT','Time']
		providesFeatures: true
		get: (props, cb) ->
	gmtMonthOfYear:
		help: "The month of the year, as a number from 0 through 11 for January through December, respectively."
		tags: ['GMT','Time']
		get: (props, cb) ->
			return cb false, timeHere().getMonth()
	locHourOfDay:
		help: "The hour of the day according to the 24-hour clock, as a number from 0 to 23 (where 0 indicates the hour that starts at midnight)."
		tags: ['Geo','Time']
		get: (props, cb) ->
			return cb false, timeThere(props).getHours()
	locDayOfMonth:
		help: "The day of the month, as a number from 1 through 30 or 31 (for most months)."
		tags: ['Geo','Time']
		get: (props, cb) ->
			return cb false, timeThere(props).getDate()
	locDayOfWeek:
		help: "The day of the week, as a number from 1 to 7 (where 1 indicates Sunday)."
		tags: ['Geo','Time']
		get: (props, cb) ->
			return cb false, timeThere(props).getDay()
	locWeekPart:
		help: "Will be 'weekend' or 'weekday' depending on whether it is a Saturday or Sunday."
		tags: ['Geo','Time']
		providesFeatures: true
		get: (props, cb) ->
	locMonthOfYear:
		help: "The month of the year, as a number from 0 through 11 for January through December, respectively."
		tags: ['Geo','Time']
		get: (props, cb) ->
			return cb false, timeThere(props).getMonth()
	locOffsetMins:
		help: "The current offset from GMT, in minutes. For instance, New York is usually 4 hours behind GMT in the summer, so this value would be -240."
		tags: ['Geo','Time']
		get: (props, cb) ->
			return cb false, timeThere(props).getTimezoneOffset()
	locOffsetHours:
		help: "The current offset from GMT, in hours. For instance, this value would be -4 or -5 for a New York visitor depending on the Time of year."
		tags: ['Geo','Time']
		get: (props, cb) ->
			return cb false, Math.floor(timeThere(props).getTimezoneOffset() / 60)
	locTimezoneCode:
		help: "The timezone code, such as EST or PDT."
		tags: ['Geo','Time']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, timeThere(props).getTimezoneAbbr()
	locTimezoneName:
		help: "The timezone name, such as America/New_York or Pacific/Auckland (see http://en.wikipedia.org/wiki/List_of_tz_database_time_zones)"
		tags: ['Geo','Time']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, Validate.makeIdentifier timeThere(props).getTimezone()

	userCompanyName:
		help: "The company or organization name (such as 'Starbucks') where the end user is connecting from, if available."
		tags: ['Geo']
		get: (props, cb) ->
			return cb false, orgLookup(props)
	userDomainName:
		help: "The domain name (with one dot, such as 'mit.edu') associated with the end user's computer or device, if available."
		tags: ['Geo']
		get: (props, cb) ->
			return cb false, domainLookup(props)
	userTopLevelDomain:
		help: "The top-level domain (preceded with 'dot-', such as 'dot-com', 'dot-gov', or 'dot-uk') associated with the end user's computer or device, if available."
		tags: ['Geo']
		providesFeatures: true
		get: (props, cb) ->
			lookup = domainLookup(props)
			if lookup?
				parts = lookup.split('.') 
				tld = 'dot-' + parts[parts.length-1] if parts.length > 1
			return cb false, tld

	geoRegion:
		help: "The region code. In the US, the region code refers to the state, such as CA for California. See http://www.maxmind.com/fips10-4.csv for other region codes."
		tags: ['Geo']
		get: (props, cb) ->
			return cb false, geoLookup(props).region
	geoContinent:
		help: "The continent code, such as EU for Europe or NA for North America. See http://www.maxmind.com/app/country_continent for a listing of codes."
		tags: ['Geo']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, geoLookup(props).continent_code
	geoCity:
		help: "The user's city, with reasonable accuracy."
		tags: ['Geo']
		get: (props, cb) ->
			return cb false, geoLookup(props).city
	geoCountryCode:
		help: "The user's country, as a two-character code, such as 'US' or 'JP'. See http://www.maxmind.com/app/country_continent for a listing of codes."
		tags: ['Geo']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, geoLookup(props).country_code
	geoCountryCode3:
		help: "Three-character country code."
		tags: ['Geo']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, geoLookup(props).country_code3
	geoCountryName:
		help: "Country name, such as 'France' or 'Mexico'."
		tags: ['Geo']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, Validate.makeIdentifier geoLookup(props).country_name
	geoPostalCode:
		help: "Approximate postal code."
		tags: ['Geo']
		get: (props, cb) ->
			return cb false, geoLookup(props).postal_code
	geoLatitude:
		help: "Approximate latitude."
		tags: ['Geo']
		get: (props, cb) ->
			return cb false, geoLookup(props).latitude
	geoLongitude:
		help: "Approximate longitude."
		tags: ['Geo']
		get: (props, cb) ->
			return cb false, geoLookup(props).longitude
	geoAreaCode:
		help: "Telephone area code for user's location (USA only)."
		tags: ['Geo']
		get: (props, cb) ->
			return cb false, geoLookup(props).area_code
	geoMetroCode:
		help: "Metro code for user's location (USA only). See https://developers.google.com/adwords/api/docs/appendix/metrocodes for details."
		tags: ['Geo']
		get: (props, cb) ->
	geoDmaCode:
		help: "Nielsen-style DMA (designated market area) code. See http://en.wikipedia.org/wiki/Media_market for details."
		tags: ['Geo']
		get: (props, cb) ->
	refSearchTerms:
		help: "Search terms, if the user was coming from a common search engine (assuming that the search engine provides the search terms in the query string)."
		tags: ['Referer']
		get: (props, cb) ->
			return cb false, getQueryStringValue props, ["q", "p", "query", "enc_query", "terms", "rdata", "qs", "wd", "text", "words", "k", "search_word"]
	refHostName:
		help: "The 'Hostname' portion of the referring page, such as www.google.com or www.somecompany.com"
		tags: ['Referer']
		get: (props, cb) ->
			return cb false, referer(props).hostname
	refReferer:
		help: "The complete referring URL."
		tags: ['Referer']
		get: (props, cb) ->
			return cb false, referer(props).href
	refPath:
		help: "The 'Path' portion of the referring page, for example '/pizza/big.htm' if the referring page was http://example.com/pizza/big.htm"
		tags: ['Referer']
		get: (props, cb) ->
			return cb false, referer(props).path
	refProtocol:
		help: "The 'Protocol' portion of the referring page, such as 'http:' or 'https:' if the referer was secured with SSL."
		tags: ['Referer']
		get: (props, cb) ->
			return cb false, referer(props).path
	refSearch:
		help: "The 'Query String' portion of the referring page (starting with the ? mark, if any)."
		tags: ['Referer']
		get: (props, cb) ->
			return cb false, referer(props).search
	refHash:
		tags: ['Referer']
		get: (props, cb) ->
			return cb false, referer(props).hash
	uaBrowserName:
		help: "The browser name (such as IE, iPad, Safari, or Chrome) being used by the user, if it can be determined via the user-agent string."
		tags: ['User-Agent']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, Validate.makeIdentifier userAgent(props).family
	uaIsMobile:
		help: "The string 'mobile' if the user appears to be using a mobile device, or 'not-mobile' otherwise."
		tags: ['User-Agent']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, if userAgent(props).isMobile then 'mobile' else 'not-mobile'
	uaDevice:
		help: "The type of mobile device the user is using (such as iPad or Android), or 'Other' if unknown or not mobile."
		tags: ['User-Agent']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, Validate.makeIdentifier userAgent(props).device
	uaOperatingSystem:
		help: "The operating system being used by the user (such as 'Windows' or 'Mac OS X'), if it can be determined via the user-agent string."
		tags: ['User-Agent']
		providesFeatures: true
		get: (props, cb) ->
			return cb false, Validate.makeIdentifier userAgent(props).os
operators =
	eq: (left, right) ->
		return left is right
	neq: (left, right) ->
		return left isnt right
	gt: (left, right) ->
		return left > right
	gte: (left, right) ->
		return left >= right
	lt: (left, right) ->
		return left < right
	lte: (left, right) ->
		return left <= right
	contains: (left, right) ->
		return left.toString().indexOf(right) isnt -1
	in: (left, right) ->
		return right.toString().indexOf(left) isnt -1

geoLookup = (props) ->
	cached = lookupCacheGet props, 'geo'; return cached if cached?
	return lookupCachePut props, 'geo', lookup
orgLookup = (props) ->
	cached = lookupCacheGet props, 'org'; return cached if cached?
	return lookupCachePut props, 'org', lookup
domainLookup = (props) ->
	cached = lookupCacheGet props, 'domain'; return cached if cached?
	return lookupCachePut props, 'domain', lookup
internalLookup = (props, providerItem, callback) ->
	cached = lookupCacheGet props, cacheKey
	return callback(false, cached) if cached?
	if providerItem.geoKeyField?
		geo = geoLookup props
		key = geo[providerItem.geoKeyField]
		return callback false, null unless key?
	accessors.transformsLookup providerItem.owner, providerItem.ns, key, (err, lookup) ->
		return callback err if err
		return callback false, null unless lookup?
		return callback false, lookupCachePut props, cacheKey, lookup

geo = $.memoize ->
org = $.memoize ->
	return new GeoIP.Org '/tmp/GeoIPOrg.dat', true
domain = $.memoize ->

timeHere = () ->
	return new Date()

timeThere = (props) ->
	data = geoLookup props
	d = new Time.Date()
	d.setTimezone timezone
	return d

referer = (props) ->
	ref = URL.parse(props.ref ? '', true) ? {}

userAgentCache = {}
userAgent = (props) ->
	return userAgentCache[props.ua] if userAgentCache[props.ua]
	ua = uaParser.parse(props.ua ? '')
	userAgentCache[props.ua] = ua
	return ua

getQueryStringValue = (props, names) ->
	q = referer(props).query
	return null if not q?
	for key in names
		return q[key] if q[key]?
	return null

parseArray = (str) ->
	return null unless looksLikeArray(str)

looksLikeArray = (str) ->
	return false unless str?
	return (str.length >= 2) and (str[0] is '[') and (str[-1..] is ']')

exports.getAvailableOptions = (ownerCode, callback) ->
	result = providers: [], operators: []
	callback false, result

lookupCacheGet = (props, key) ->
	return props.lookupCache?[key]
lookupCachePut = (props, key, value) ->
	props.lookupCache ?= {}
	props.lookupCache[key] = value
	return value

loadTransformLookupProviders = (callback) ->
	accessors.transformLookupProvidersGet (err, providerItems) ->
		return callback err if err
		loadTransformLookupProvider(providerItem) for providerItem in providerItems

loadTransformLookupProvider = (providerItem, callback) ->
	return callback false unless providerItem.fields?
	for field in providerItem.fields then do (providerItem, field) ->
		key = providerItem.fieldPrefix + field if providerItem.fieldPrefix?
		providers[key] = 
			help: providerItem.help[field] ? ''
			tags: (providerItem.tags ? [])
			flag: true
			providesFeatures: providerItem.providesFeatures
			get: (props, cb) ->
				internalLookup props, providerItem, (err, lookup) ->
					return cb(false, lookup? and lookup[field] is 1)
	loadTransformLookupProviderData providerItem, true, (err) ->
		return callback err if err

loadTransformLookupProviderData = (providerItem, skipIfExists, callback) ->
	accessors.transformLookupsCount providerItem.owner, providerItem.ns, (err, count) ->
		return callback err if err
		if count > 0 and skipIfExists
		internalLookupImport providerItem, {}, (err) ->
			return callback err if err

createTransformLookupProvider = (providerItem, callback) ->
	accessors.transformLookupProviderPut providerItem, (err) ->
		return callback err if err
		loadTransformLookupProvider providerItem, (err) ->
			return callback err if err

createBuiltInTransformLookupProviders = (callback) ->
	providerItem = 
		owner: 'conductrics'
		ns: 'usa-census'
		tags: ['Geo', 'Census']
		keyField: 'ZipCode'
		fields: [
			'HighPctChildren','LowPctChildren','LowPctTeen','HighPctTeen','HighPctOver60YO','LowPctOver60YO',
			'HighPopulation','LowPopulation','HighHouseValue','LowHouseValue','HighIncome','LowIncome',
			'HighPopDensity','LowPopDensity','HighPctApts','LowPctApts','HighPctBusiness','LowPctBusiness']
		fieldPrefix: 'cen'
		path: './data/conductrics-usa-census.csv'
		geoKeyField: 'postal_code'
		providesFeatures: true
		help: 
			LowPctChildren: "Whether the user/visitor is in an area with a relatively low percentage of children, according to US Census records."
			HighPctChildren: "Whether the user/visitor is in an area with a relatively high percentage of children, according to US Census records."
			LowPctTeen: "Whether the user/visitor is in an area with a relatively low percentage of teenagers, according to US Census records."
			HighPctTeen: "Whether the user/visitor is in an area with a relatively high percentage of teenagers, according to US Census records."
			LowPctOver60YO: "Whether the user/visitor is in an area with a relatively low percentage of people over 60 years old, according to US Census records."
			HighPctOver60YO: "Whether the user/visitor is in an area with a relatively high percentage of people over 60 years old, according to US Census records."
			LowPopulation: "Whether the user/visitor is in an area with a relatively low overall population, according to US Census records."
			HighPopulation: "Whether the user/visitor is in an area with a relatively high overallp opulation, according to US Census records."
			LowHouseValue: "Whether the user/visitor is in an area with a relatively low home value, according to US Census records."
			HighHouseValue: "Whether the user/visitor is in an area with a relatively high home value, according to US Census records."
			LowIncome: "Whether the user/visitor is in an area with a relatively low income level, according to US Census records."
			HighIncome: "Whether the user/visitor is in an area with a relatively high income level, according to US Census records."
			LowPopDensity: "Whether the user/visitor is in an area with a relatively low population density, according to US Census records."
			HighPopDensity: "Whether the user/visitor is in an area with a relatively high population density, according to US Census records."
			LowPctApts: "Whether the user/visitor is in an area with a relatively low percentage of apartment dwellers, according to US Census records."
			HighPctApts: "Whether the user/visitor is in an area with a relatively high percentage of apartment dwellers, according to US Census records."
			LowPctBusiness: "Whether the user/visitor is in an area with a relatively low percentage of businesses, according to US Census records."
			HighPctBusiness: "Whether the user/visitor is in an area with a relatively high percentage of businesses, according to US Census records."
	createTransformLookupProvider providerItem, (err) ->
		return callback err if err

$.depends "conductrics-usa-census.csv", ->
	createBuiltInTransformLookupProviders (err) ->
		throw err if err
		$.log "Created Built-In TransformLookupProviders."

children-low
teenagers-low
over-sixty-low
population-low
home-value-low
income-low
pop-density-low
apartments-low
business-low

internalLookupImport = (providerItem, options, callback) ->
	worker = (task, cb) ->
		accessors.transformsLookupPut providerItem.owner, providerItem.ns, providerItem.keyField, task, (err) ->
			cb(err)
	queue = async.queue worker, 100
	queue.drain = ->

	count = 0
	responder = (err) ->
		count++ unless err

	csv()
		.from.path(providerItem.path, {columns:true, trim:true})
		.transform (data) ->
			data = options.transformer data if options.transformer?
			item = {}
			item[providerItem.keyField] = data[providerItem.keyField]
			item[key] = 1 for key of data when (data[key] is "1")
			return item
		.on 'record', (data, index) ->
			queue.push data, responder
		.on 'error', (err) ->
			return callback err


if require.main is module

	createBuiltInTransformLookupProviders (err) ->
		throw err if err
		$.log "Created Built-In TransformLookupProviders."

		rule =
			owner: 'nate'
			code: 'whatever'
			agents: ['*']
			when: [
				["cenLowPctTeen", "eq", "true"]
				["geoRegion", "eq", "CA"]
			]
			apply:

		props = 
			owner: 'nate'
			ip: '173.194.43.35'

		exports.testTransformRules 'nate', [rule], props, (err, messages) ->
			return $.log err if err
			$.log messages

	return 
	options = 
		transformer: (data) ->
			return data

	internalLookupImport 'conductrics', 'usa-census', './data/conductrics-usa-census.csv', 'ZipCode', options, (err, count) ->
		throw err if err

		referer: "google.com?q=bigtrak"
	accessors.getAgent 'acme', 'agent-103', props, (err, agent) ->
		rule =
			apply:
				segment: 'seg-1'
			when: [
				"refSearchTerms in [one,bigtrak,two]"
			]

		applyTransformRule agent, props, rule
		$.log "PROPS AFTER TRANSFORMS"
exports.getConfidenceBounds = (count, val, valSq, confidenceMeasure, useBonferonni, numTests) ->

	numTests = 1 if not useBonferonni
	confidenceMeasure = (1-confidenceMeasure)/numTests

	mean = exports.getMean count, val
	variance = exports.getVariance count, val, valSq
	distance = tVal * Math.sqrt(variance) / Math.sqrt(count)


	lower = mean - distance
	upper = mean + distance
	return [lower, upper]

exports.getTScore = (countA, countB, valA, valB, valSqA, valSqB) ->
	meanA = exports.getMean countA, valA
	meanB = exports.getMean countB, valB
	varianceA = exports.getVariance countA, valA, valSqA
	varianceB = exports.getVariance countB, valB, valSqB
	return (meanA - meanB) / Math.sqrt( (varianceA/countA) + (varianceB/countB) )

exports.getDegreeFreedom = (countA, countB, valA, valB, valSqA, valSqB) ->
	varianceA = exports.getVariance countA, valA, valSqA
	varianceB = exports.getVariance countB, valB, valSqB
	numerator = (varianceA/countA) + (varianceB/countB)
	denomA = (varianceA * varianceA) / (countA * countA * (countA-1))
	denomB = (varianceB * varianceB) / (countB * countB * (countB-1))
	return Math.round( (numerator*numerator) / (denomA+denomB) )

exports.getPValue = (tScore, degreeFreedom) ->
	return -1 if degreeFreedom is 0
	return -1 unless isFinite(tScore)
	pValue = exports.getStudentT(tScore, degreeFreedom)
	return 1 - pValue

exports.getSignificanceLevel = (pValue, confidences, useBonferonni, numTests) ->
	numTests = 1 if useBonferonni
	for confidence in confidences
		if exports.isSignificant pValue, confidence, numTests
			return confidence
	return null

exports.isSignificant = (pValue, confidence, numTests) ->
	return false if numTests is 0
	alpha = (1-confidence) / numTests
	return pValue <= alpha

exports.isSignificant2 = (pValue, confidence, numTests, useBonferonni) ->
	numTests = 1 if not useBonferonni
	alpha = (1-confidence) / numTests
	return pValue < alpha

exports.getStandardDeviation = (variance) ->

exports.getVariance = (n, x, xsqr) ->
	mean = exports.getMean(n, x);
	return (1/(n-1)) * xsqr - (n/(n-1)) * (mean*mean);

exports.getMean = (count, val) ->
	return 0 unless count > 0
	return (val / count)

exports.getConfidence = (countA, countB, pValue) ->
	return (1 - pValue)

exports.getConfidenceLevel = (countA, countB, pValue) ->
	confidence = Math.round(exports.getConfidence(countA, countB, pValue) * 100)
	return 5 if confidence >= 99
	return 4 if confidence >= 95
	return 3 if confidence >= 90
	return 2 if confidence >= 80
	return 1 if confidence >= 70
	return 0

jStat = require('jStat').jStat
exports.getStudentT = (x, degreesFreedom) ->
	return jStat.studentt.cdf(x, degreesFreedom)

exports.getInverseStudentT = (p, degreesFreedom) ->
	return jStat.studentt.inv(p, degreesFreedom)

if require.main is module
	$.log pdf = exports.getStudentT(3, 4)
	$.log exports.getInverseStudentT(pdf, 4)
Amanda = require 'amanda'
Schemas = require './schemas'

module.exports =
	isNumeric: (n) -> isFinite(parseFloat(n))
	isEmail: (s) -> s.indexOf('.') > s.indexOf('@') > -1
	isIdentifier: (s) -> s?.length > 0 and not /[^0-9A-Za-z_-]/.test s
	makeIdentifier: (s) ->
		return null unless s?
		return s.replace(/[^0-9A-Za-z_-]/g, '-').replace(/-+/g, '-')
	isAgent: (ownerCode, agentCode, agent, callback) ->
		Amanda.validate agent, Schemas.agentSchema, (err) ->
			return callback("Wrong owner") if agent.owner isnt ownerCode
			return callback("Wrong agent code") if agent.code isnt agentCode
			callback(false, agent)
	isTransform: (ownerCode, rule, callback) ->
		Amanda.validate rule, Schemas.transformSchema, (err) ->
			return callback("Wrong owner") if rule.owner isnt ownerCode
			callback(false, rule)require 'bling'
require 'longjohn'
express = require 'express'
coffeekup = require 'coffeekup'
routes = require './routes'

app = module.exports = express.createServer()

app.configure ->
	app.set 'views', __dirname + '/views'
	app.set 'view engine', 'coffee'
	app.register '.coffee', coffeekup.adapters.express
	app.use express.bodyParser()
	app.use express.methodOverride()
	app.use app.router
	app.use express.static(__dirname + '/public')
	app.use(express.favicon('public/img/favicon.ico'))

app.configure 'development', ->
	app.use express.errorHandler { dumpExceptions: true, showStack: true }

app.configure 'production', ->
	app.use express.errorHandler()

app.get '/', routes.index
app.post '/', routes.index_submit
app.get '/:owner/:agent/cheat-sheet', routes.welcome_dev
app.get '/test/email', routes.test_email

app.listen parseInt($.config.get("PORT", 3000), 10), ->
	$.log "Express server listening on port %d in %s mode", app.address().port, app.settings.env
 

requestExtensions = {}
responseExtensions =
	endWithError: (err) ->
		@writeHead '500',
			'Content-Type': 'text/plain'
		@write JSON.stringify(err)
		@end()

module.exports =
	routeHandler: (f) ->
		(req, res) ->
			try
				f(($.extend req, requestExtensions),
					($.extend res, responseExtensions))
			catch err
				res.endWithError(err)




log = (a...) ->
	try return console.log.apply console, a
	alert a.join(", ")
	return a[a.length-1]

Object.keys ?= (o) -> (k for k of o)

extend = (a, b) ->
	return a if not b
	for k of b
		v = b[k]
		if v? then a[k] = v
	a

defineProperty = (o,name,opts) ->
	Object.defineProperty o,name, extend({
		configurable: true
		enumerable: true
	}, opts)
	o



isType = (T, o) ->
	if not o? then T in [o,"null","undefined"]
	else o.constructor is T or
		o.constructor.name is T or

inherit = (parent, obj) ->
	if typeof parent is "function"
		parent = parent.prototype
	if parent.__proto__ is Object.prototype
		parent.__proto__ = obj.__proto__
	obj.__proto__ = parent
	obj

_type = do ->

	cache = {}

	base =
		name: 'unknown'
		match: (o) -> true

	order = []

	register = (name, data) ->
		order.unshift name if not (name of cache)
		cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
		cache[name][name] = (o) -> o

	_extend = (name, data) ->
		if typeof name is "string"
			cache[name] ?= register name, {}
			cache[name] = extend cache[name], data
		else if typeof name is "object"
			(_extend k, name[k]) for k of name

	lookup = (obj) ->
		for name in order
			if cache[name]?.match.call obj, obj
				return cache[name]

	register "unknown",   base
	register "object",    match: -> typeof @ is "object"
	register "error",     match: -> isType 'Error', @
	register "regexp",    match: -> isType 'RegExp', @
	register "string",    match: -> typeof @ is "string" or isType String, @
	register "number",    match: -> isType Number, @
	register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
	register "array",     match: -> Array.isArray?(@) or isType Array, @
	register "function",  match: -> typeof @ is "function"
	register "undefined", match: (x) -> x is undefined
	register "null",      match: (x) -> x is null

	return extend ((o) -> lookup(o).name),
		register: register
		lookup: lookup
		extend: _extend
		is: (t, o) -> cache[t]?.match.call o, o
		as: (t, o) -> lookup(o)[t]?(o)




_pipe = do ->




	pipes = {}

	(name, args) ->
		p = (pipes[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args






class Bling

	default_context = if document? then document else {}

	constructor: (selector, context = default_context) ->
		return Bling.pipe "bling-init", [selector, context]

	@pipe: _pipe

	@pipe("bling-init").prepend (args) ->
		[selector, context] = args
		inherit Bling, inherit {
			selector: selector
			context: context
		}, _type.lookup(selector).array(selector, context)





	@plugin: (opts, constructor) ->
		if not constructor?
			constructor = opts; opts = {}

		if "depends" of opts
			return @depends opts.depends, =>
				@plugin { provides: opts.provides }, constructor
		try
			if (plugin = constructor?.call @,@)
				extend @, plugin?.$
				['$','name'].forEach (k) -> delete plugin[k]
				extend @::, plugin
				for key of plugin then do (key) =>
					@[key] or= (a...) => (@::[key].apply $(a[0]), a[1...])
				if opts.provides? then @provide opts.provides
		catch error
			throw error
		@

		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)

	@depends: (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else dep.q.push (need) ->
			(needs.splice i, 1) if (i = needs.indexOf need) > -1
			return (needs.length is 0 and f)
		f

	@provide: (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data

	@provides: (needs, f) ->
		(args...) ->
			Bling.provide needs, f args...

	_type.extend
		unknown:   { array: (o) -> [o] }

		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }

	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) ->
			o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"

Bling.prototype = []
Bling.prototype.constructor = Bling

do ($ = Bling) ->

	$.global = glob = if window? then window else global

	$.plugin
		provides: "type"
	, ->
		$:
			inherit: inherit
			extend: extend
			defineProperty: defineProperty
			isType: isType
			type: _type
			is: _type.is
			as: _type.as
			isSimple: (o) -> _type(o) in ["string", "number", "bool"]
			isEmpty: (o) -> o in ["", null, undefined]



	$.plugin
		provides: "symbol"
		depends: "type"
	, ->
		symbol = null
		cache = {}
		glob.Bling = Bling
		if module?
			module.exports = Bling
		$.type.extend "bling",
			string: (o) -> symbol + "(["+ o.map($.toString).join(", ") + "])"
		defineProperty $, "symbol",
			set: (v) ->
				glob[symbol] = cache[symbol]
				cache[symbol = v] = glob[v]
				glob[v] = Bling
			get: -> symbol
		return $:
			symbol: "$"
			noConflict: ->
				Bling.symbol = "Bling"
				return Bling

	$.plugin ->
		String::trimLeft or= -> @replace(/^\s+/, "")
		String::split or= (sep) ->
			a = []; i = 0
			while (j = @indexOf sep,i) > -1
				a.push @substring(i,j)
				i = j + 1
			a
		String::lastIndexOf or= (s, c, i = -1) ->
			j = -1
			j = i while (i = s.indexOf c, i+1) > -1
			j

		Array::join or= (sep = '') ->
			n = @length
			return "" if n is 0
			s = @[n-1]
			while --n > 0
				s = @[n-1] + sep + s
			s

		if Event?
			Event::preventAll = () ->
				@preventDefault()
				@stopPropagation()
				@cancelBubble = true

		if Element?
			Element::matchesSelector = Element::webkitMatchesSelector or
				Element::mozMatchesSelector or
				Element::matchesSelector
			if Element::cloneNode.length is 0
				oldClone = Element::cloneNode
				Element::cloneNode = (deep = false) ->
					n = oldClone.call(@)
					if deep
						for i in @childNodes
							n.appendChild i.cloneNode true
					return n

		return { }

	$.plugin
		provides: "core"
		depends: "string"
	, ->

		defineProperty $, "now",
			get: -> +new Date

		index = (i, o) ->
			i += o.length while i < 0
			Math.min i, o.length

		baseTime = $.now
		return {
			$:
				log: $.extend((a...) ->
					prefix = $.padLeft String($.now - baseTime), $.log.prefixSize, '0'
				, prefixSize: 5)
				coalesce: (a...) -> $(a).coalesce()

			eq: (i) -> $([@[index i, @]])

			each: (f) -> (f.call(t,t) for t in @); @

			map: (f) -> $(f.call(t,t) for t in @)

			reduce: (f, a) ->
				i = 0; n = @length
				a = @[i++] if not a?
				(a = f.call @[x], a, @[x]) for x in [i...n] by 1
				return a
			union: (other, strict = true) ->
				ret = $()
				ret.push(x) for x in @ when not ret.contains(x, strict)
				ret.push(x) for x in other when not ret.contains(x, strict)
				ret
			distinct: (strict = true) -> @union @, strict
			contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
			count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
			coalesce: ->
				for i in @
					if $.type(i) in ["array","bling"] then i = $(i).coalesce()
					if i? then return i
				null
			swap: (i,j) ->
				i = index i, @
				j = index j, @
				if i isnt j
					[@[i],@[j]] = [@[j],@[i]]
				@
			shuffle: ->
				i = @length-1
				while i >= 0
					@swap --i, Math.floor(Math.random() * i)
				@

			select: (->
				getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
				select = (p) ->
					if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
					else @map(getter p)
			)()

			or: (x) -> @[i] or= x for i in [0...@length]; @

			zap: (p, v) ->

				i = p.lastIndexOf "."

				if i > 0
					head = p.substr 0,i
					tail = p.substr i+1
					@select(head).zap tail, v
					return @

				switch $.type(v)
					when "array","bling" then @each -> @[p] = v[++i % v.length]
					when "function" then @zap p, @select(p).map(v)
					else @each -> @[p] = v
				@

			clean: (prop) -> @each -> delete @[prop]

			take: (n = 1) ->
				end = Math.min n, @length
				$( @[i] for i in [0...end] )

			skip: (n = 0) ->
				start = Math.max 0, n|0
				$( @[i] for i in [start...@length] )

			first: (n = 1) -> if n is 1 then @[0] else @take(n)

			last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)

			slice: (start=0, end=@length) ->
				start = index start, @
				end = index end, @
				$( @[i] for i in [start...end] )

			extend: (b) -> @.push(i) for i in b; @

			push: (b) -> Array::push.call(@, b); @

			filter: (f) ->
				g = switch $.type f
					when "string" then (x) -> x.matchesSelector(f)
					when "regexp" then (x) -> f.test(x)
					when "function" then f
					else
				$( it for it in @ when g.call(it,it) )

			matches: (expr) -> @select('matchesSelector').call(expr)

			querySelectorAll: (expr) ->
				@filter("*")
				.reduce (a, i) ->
					a.extend i.querySelectorAll expr
				, $()

			weave: (b) ->
				c = $()
				for i in [@length-1..0] by -1
					c[(i*2)+1] = @[i]
				for i in [0...b.length] by 1
					c[i*2] = b[i]
				c

			fold: (f) ->
				n = @length
				b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
				if (n%2) is 1
					b.push( f.call @, @[n-1], undefined )
				b

			flatten: ->
				b = $()
				(b.push(j) for j in i) for i in @
				b

			call: -> @apply(null, arguments)

			apply: (context, args) ->
				@map -> if $.is "function", @ then @apply(context, args) else @

			log: (label) ->
				if label
					$.log(label, @toString(), @length + " items")
				else
					$.log(@toString(), @length + " items")
				@

			toArray: ->
				@__proto__ = Array::
		}

	$.plugin
		provides: "math"
		depends: "core"
	, ->
		$:
			range: (start, end, step = 1) ->
				if not end? then (end = start; start = 0)
				$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
			zeros: (n) -> $( 0 for i in [0...n] )
			ones: (n) -> $( 1 for i in [0...n] )
		floats: -> @map parseFloat
		ints: -> @map -> parseInt @, 10
		px: (delta) -> @ints().map -> $.px @,delta
		min: -> @filter( isFinite ).reduce Math.min
		max: -> @filter( isFinite ).reduce Math.max
		mean: -> @sum() / @length
		avg: -> @sum() / @length
		sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
		product: -> @filter( isFinite ).reduce (a) -> a * @
		squares: -> @map -> @ * @
		magnitude: -> Math.sqrt @floats().squares().sum()
		scale: (r) -> @map -> r * @
		add: (d) -> switch $.type(d)
			when "number" then @map -> d + @
			when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
		normalize: -> @scale(1/@magnitude())

	$.plugin
		provides: "string"
		depends: "function"
	, ->
		$.type.extend
			unknown:
				string: (o) -> o.toString?() ? String(o)
				repr: (o) -> $.type.lookup(o).string(o)
			null: { string: -> "null" }
			undefined: { string: -> "undefined" }
			string:
				number: parseFloat
				string: $.identity
			array:  { string: (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
			function:
				string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
			number:
				repr:   (n) -> String(n)
				string: (n) ->
					switch true
						when n.precision? then n.toPrecision(n.precision)
						when n.fixed? then n.toFixed(n.fixed)
						else String(n)

		return {
			$:
				toString: (x) ->
					if not x? then "function Bling(selector, context) { [ ... ] }"
					else $.type.lookup(x).string(x)

				toRepr: (x) -> $.type.lookup(x).repr(x)

				px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"



				capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")

				dashize: (name) ->
					ret = ""
					for i in [0...(name?.length|0)]
						c = name.charCodeAt i
						if 91 > c > 64
							c += 32
							ret += '-'
						ret += String.fromCharCode(c)
					ret

				camelize: (name) ->
					name.split('-')
					while (i = name?.indexOf('-')) > -1
						name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
					name

				padLeft: (s, n, c = " ") ->
					while s.length < n
						s = c + s
					s

				padRight: (s, n, c = " ") ->
					while s.length < n
						s = s + c
					s

				stringCount: (s, x, i = 0, n = 0) ->
					if (j = s.indexOf x,i) > i-1
						$.stringCount s, x, j+1, n+1
					else n

				stringSplice: (s, i, j, n) ->
					nn = s.length
					end = j
					if end < 0
						end += nn
					start = i
					if start < 0
						start += nn
					s.substring(0,start) + n + s.substring(end)

				checksum: (s) ->
					a = 1; b = 0
					for i in [0...s.length]
						a = (a + s.charCodeAt(i)) % 65521
						b = (b + a) % 65521
					(b << 16) | a

				repeat: (x, n=2) ->
					switch true
						when n is 1 then x
						when n < 1 then ""
						when $.is "string", x then x + $.repeat(x, n-1)
						else $(x).extend $.repeat(x, n-1)

				stringBuilder: ->
					if $.is("global", @) then return new $.stringBuilder()
					items = []
					@length   = 0
					@append   = (s) => items.push s; @length += s?.toString().length|0
					@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
					@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
					@toString = ( ) => items.join("")
					@
			toString: -> $.toString @
			toRepr: -> $.toRepr @
		}

	$.plugin
		provides: "function"
		depends: "hash"
	, ->
		$:
			identity: (o) -> o
			not: (f) -> -> not f.apply @, arguments
			compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
			and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
			once: (f, n=1) ->
				$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
					"exhausted",
						get: -> n <= 0
			cycle: (f...) ->
				i = -1
				-> f[i = ++i % f.length].apply @, arguments
			bound: (t, f, args = []) ->
				if $.is "function", f.bind
					args.splice 0, 0, t
					r = f.bind.apply f, args
				else
					r = (a...) -> f.apply t, (args if args.length else a)
			memoize: (f) ->
				cache = {}
					stats: -> Object.keys(cache).length
					cache: -> cache

	$.plugin
		provides: "hash"
		depends: "type"
	, ->
		$.type.extend
			unknown: { hash: (o) -> $.checksum $.toString(o) }
			object:  { hash: (o) -> $($.hash(o[k]) for k of o).sum() + $.hash(Object.keys(o)) }
			array:   { hash: (o) ->
				$.hash(Array) + ($.hash(i) for i in o).reduce (a,x) -> (a*a)+x }
			bool:    { hash: (o) -> parseInt(1 if o) }
		return {
			$:
				hash: (x) -> $.type.lookup(x).hash(x)
			hash: -> $.hash @
		}

	$.plugin
		provides: "pubsub"
	, ->
		return {
			$:
				publish: (e, args...) ->
					f.apply null, args for f in (subscribers[e] or= [])
					args
				publisher: (e, func) ->
					(args...) ->
						func.apply @, args
						$.publish e, args
				subscribe: (e, func) ->
					(subscribers[e] or= []).push func
					func
				unsubscribe: (e, func) ->
					if not func?
						subscribers[e] = []
					else
						a = (subscribers[e] or= [])
						if (i = a.indexOf func)  > -1
							a.splice(i,i)
		}

	$.plugin
		provides: "throttle"
		depends: "core"
	, ->
		$:
			throttle: (f,n=250,last=0) ->
				(a...) ->
					gap = $.now - last
					if gap > n
						last += gap
						return f.apply @,a
					null
				(a...) ->
					last += (gap = $.now - last)
					return f.apply @,a if gap > n else null

	$.plugin
		provides: "EventEmitter"
	, ->
		$: EventEmitter: $.pipe("bling-init").append (obj) ->
			listeners = {}
			list = (e) -> (listeners[e] or= [])
			inherit {
				emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
				addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
				on:                 (e, h) -> @addListener e, h
				removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
				removeAllListeners: (e) -> listeners[e] = []
				listeners:          (e) -> list(e).slice 0
			}, obj

log = (a...) ->
	try return console.log.apply console, a
	alert a.join(", ")
	return a[a.length-1]
Object.keys ?= (o) -> (k for k of o)
extend = (a, b) ->
	return a if not b
	for k of b
		v = b[k]
		if v? then a[k] = v
	a
defineProperty = (o,name,opts) ->
	Object.defineProperty o,name, extend({
		configurable: true
		enumerable: true
	}, opts)
	o
isType = (T, o) ->
	if not o? then T in [o,"null","undefined"]
	else o.constructor is T or
		o.constructor.name is T or
inherit = (parent, obj) ->
	if typeof parent is "function"
		parent = parent.prototype
	if parent.__proto__ is Object.prototype
		parent.__proto__ = obj.__proto__
	obj.__proto__ = parent
	obj
_type = do ->
	cache = {}
	base =
		name: 'unknown'
		match: (o) -> true
	order = []
	register = (name, data) ->
		order.unshift name if not (name of cache)
		cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
		cache[name][name] = (o) -> o
	_extend = (name, data) ->
		if typeof name is "string"
			cache[name] ?= register name, {}
			cache[name] = extend cache[name], data
		else if typeof name is "object"
			(_extend k, name[k]) for k of name
	lookup = (obj) ->
		for name in order
			if cache[name]?.match.call obj, obj
				return cache[name]
	register "unknown",   base
	register "object",    match: -> typeof @ is "object"
	register "error",     match: -> isType 'Error', @
	register "regexp",    match: -> isType 'RegExp', @
	register "string",    match: -> typeof @ is "string" or isType String, @
	register "number",    match: -> isType Number, @
	register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
	register "array",     match: -> Array.isArray?(@) or isType Array, @
	register "function",  match: -> typeof @ is "function"
	register "undefined", match: (x) -> x is undefined
	register "null",      match: (x) -> x is null
	return extend ((o) -> lookup(o).name),
		register: register
		lookup: lookup
		extend: _extend
		is: (t, o) -> cache[t]?.match.call o, o
		as: (t, o) -> lookup(o)[t]?(o)
_pipe = do ->
	pipes = {}
	(name, args) ->
		p = (pipes[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args
class Bling
	default_context = if document? then document else {}
	constructor: (selector, context = default_context) ->
		return Bling.pipe "bling-init", [selector, context]
	@pipe: _pipe
	@pipe("bling-init").prepend (args) ->
		[selector, context] = args
		inherit Bling, inherit {
			selector: selector
			context: context
		}, _type.lookup(selector).array(selector, context)
	@plugin: (opts, constructor) ->
		if not constructor?
			constructor = opts; opts = {}
		if "depends" of opts
			return @depends opts.depends, =>
				@plugin { provides: opts.provides }, constructor
		try
			if (plugin = constructor?.call @,@)
				extend @, plugin?.$
				['$','name'].forEach (k) -> delete plugin[k]
				extend @::, plugin
				for key of plugin then do (key) =>
					@[key] or= (a...) => (@::[key].apply $(a[0]), a[1...])
				if opts.provides? then @provide opts.provides
		catch error
			throw error
		@
		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)
	@depends: (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else dep.q.push (need) ->
			(needs.splice i, 1) if (i = needs.indexOf need) > -1
			return (needs.length is 0 and f)
		f
	@provide: (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data
	@provides: (needs, f) ->
		(args...) ->
			Bling.provide needs, f args...
	_type.extend
		unknown:   { array: (o) -> [o] }
		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }
	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) ->
			o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"
Bling.prototype = []
Bling.prototype.constructor = Bling
do ($ = Bling) ->
	$.global = glob = if window? then window else global
	$.plugin
		provides: "type"
	, ->
		$:
			inherit: inherit
			extend: extend
			defineProperty: defineProperty
			isType: isType
			type: _type
			is: _type.is
			as: _type.as
			isSimple: (o) -> _type(o) in ["string", "number", "bool"]
			isEmpty: (o) -> o in ["", null, undefined]
	$.plugin
		provides: "symbol"
		depends: "type"
	, ->
		symbol = null
		cache = {}
		glob.Bling = Bling
		if module?
			module.exports = Bling
		$.type.extend "bling",
			string: (o) -> symbol + "(["+ o.map($.toString).join(", ") + "])"
		defineProperty $, "symbol",
			set: (v) ->
				glob[symbol] = cache[symbol]
				cache[symbol = v] = glob[v]
				glob[v] = Bling
			get: -> symbol
		return $:
			symbol: "$"
			noConflict: ->
				Bling.symbol = "Bling"
				return Bling
	$.plugin ->
		String::trimLeft or= -> @replace(/^\s+/, "")
		String::split or= (sep) ->
			a = []; i = 0
			while (j = @indexOf sep,i) > -1
				a.push @substring(i,j)
				i = j + 1
			a
		String::lastIndexOf or= (s, c, i = -1) ->
			j = -1
			j = i while (i = s.indexOf c, i+1) > -1
			j
		Array::join or= (sep = '') ->
			n = @length
			return "" if n is 0
			s = @[n-1]
			while --n > 0
				s = @[n-1] + sep + s
			s
		if Event?
			Event::preventAll = () ->
				@preventDefault()
				@stopPropagation()
				@cancelBubble = true
		if Element?
			Element::matchesSelector = Element::webkitMatchesSelector or
				Element::mozMatchesSelector or
				Element::matchesSelector
			if Element::cloneNode.length is 0
				oldClone = Element::cloneNode
				Element::cloneNode = (deep = false) ->
					n = oldClone.call(@)
					if deep
						for i in @childNodes
							n.appendChild i.cloneNode true
					return n
		return { }
	$.plugin
		provides: "core"
		depends: "string"
	, ->
		defineProperty $, "now",
			get: -> +new Date
		index = (i, o) ->
			i += o.length while i < 0
			Math.min i, o.length
		baseTime = $.now
		return {
			$:
				log: $.extend((a...) ->
					prefix = $.padLeft String($.now - baseTime), $.log.prefixSize, '0'
				, prefixSize: 5)
				coalesce: (a...) -> $(a).coalesce()
			eq: (i) -> $([@[index i, @]])
			each: (f) -> (f.call(t,t) for t in @); @
			map: (f) -> $(f.call(t,t) for t in @)
			reduce: (f, a) ->
				i = 0; n = @length
				a = @[i++] if not a?
				(a = f.call @[x], a, @[x]) for x in [i...n] by 1
				return a
			union: (other, strict = true) ->
				ret = $()
				ret.push(x) for x in @ when not ret.contains(x, strict)
				ret.push(x) for x in other when not ret.contains(x, strict)
				ret
			distinct: (strict = true) -> @union @, strict
			contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
			count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
			coalesce: ->
				for i in @
					if $.type(i) in ["array","bling"] then i = $(i).coalesce()
					if i? then return i
				null
			swap: (i,j) ->
				i = index i, @
				j = index j, @
				if i isnt j
					[@[i],@[j]] = [@[j],@[i]]
				@
			shuffle: ->
				i = @length-1
				while i >= 0
					@swap --i, Math.floor(Math.random() * i)
				@
			select: (->
				getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
				select = (p) ->
					if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
					else @map(getter p)
			)()
			or: (x) -> @[i] or= x for i in [0...@length]; @
			zap: (p, v) ->
				i = p.lastIndexOf "."
				if i > 0
					head = p.substr 0,i
					tail = p.substr i+1
					@select(head).zap tail, v
					return @
				switch $.type(v)
					when "array","bling" then @each -> @[p] = v[++i % v.length]
					when "function" then @zap p, @select(p).map(v)
					else @each -> @[p] = v
				@
			clean: (prop) -> @each -> delete @[prop]
			take: (n = 1) ->
				end = Math.min n, @length
				$( @[i] for i in [0...end] )
			skip: (n = 0) ->
				start = Math.max 0, n|0
				$( @[i] for i in [start...@length] )
			first: (n = 1) -> if n is 1 then @[0] else @take(n)
			last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)
			slice: (start=0, end=@length) ->
				start = index start, @
				end = index end, @
				$( @[i] for i in [start...end] )
			extend: (b) -> @.push(i) for i in b; @
			push: (b) -> Array::push.call(@, b); @
			filter: (f) ->
				g = switch $.type f
					when "string" then (x) -> x.matchesSelector(f)
					when "regexp" then (x) -> f.test(x)
					when "function" then f
					else
				$( it for it in @ when g.call(it,it) )
			matches: (expr) -> @select('matchesSelector').call(expr)
			querySelectorAll: (expr) ->
				@filter("*")
				.reduce (a, i) ->
					a.extend i.querySelectorAll expr
				, $()
			weave: (b) ->
				c = $()
				for i in [@length-1..0] by -1
					c[(i*2)+1] = @[i]
				for i in [0...b.length] by 1
					c[i*2] = b[i]
				c
			fold: (f) ->
				n = @length
				b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
				if (n%2) is 1
					b.push( f.call @, @[n-1], undefined )
				b
			flatten: ->
				b = $()
				(b.push(j) for j in i) for i in @
				b
			call: -> @apply(null, arguments)
			apply: (context, args) ->
				@map -> if $.is "function", @ then @apply(context, args) else @
			log: (label) ->
				if label
					$.log(label, @toString(), @length + " items")
				else
					$.log(@toString(), @length + " items")
				@
			toArray: ->
				@__proto__ = Array::
		}
	$.plugin
		provides: "math"
		depends: "core"
	, ->
		$:
			range: (start, end, step = 1) ->
				if not end? then (end = start; start = 0)
				$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
			zeros: (n) -> $( 0 for i in [0...n] )
			ones: (n) -> $( 1 for i in [0...n] )
		floats: -> @map parseFloat
		ints: -> @map -> parseInt @, 10
		px: (delta) -> @ints().map -> $.px @,delta
		min: -> @filter( isFinite ).reduce Math.min
		max: -> @filter( isFinite ).reduce Math.max
		mean: -> @sum() / @length
		avg: -> @sum() / @length
		sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
		product: -> @filter( isFinite ).reduce (a) -> a * @
		squares: -> @map -> @ * @
		magnitude: -> Math.sqrt @floats().squares().sum()
		scale: (r) -> @map -> r * @
		add: (d) -> switch $.type(d)
			when "number" then @map -> d + @
			when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
		normalize: -> @scale(1/@magnitude())
	$.plugin
		provides: "string"
		depends: "function"
	, ->
		$.type.extend
			unknown:
				string: (o) -> o.toString?() ? String(o)
				repr: (o) -> $.type.lookup(o).string(o)
			null: { string: -> "null" }
			undefined: { string: -> "undefined" }
			string:
				number: parseFloat
				string: $.identity
			array:  { string: (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
			function:
				string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
			number:
				repr:   (n) -> String(n)
				string: (n) ->
					switch true
						when n.precision? then n.toPrecision(n.precision)
						when n.fixed? then n.toFixed(n.fixed)
						else String(n)
		return {
			$:
				toString: (x) ->
					if not x? then "function Bling(selector, context) { [ ... ] }"
					else $.type.lookup(x).string(x)
				toRepr: (x) -> $.type.lookup(x).repr(x)
				px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"
				capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")
				dashize: (name) ->
					ret = ""
					for i in [0...(name?.length|0)]
						c = name.charCodeAt i
						if 91 > c > 64
							c += 32
							ret += '-'
						ret += String.fromCharCode(c)
					ret
				camelize: (name) ->
					name.split('-')
					while (i = name?.indexOf('-')) > -1
						name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
					name
				padLeft: (s, n, c = " ") ->
					while s.length < n
						s = c + s
					s
				padRight: (s, n, c = " ") ->
					while s.length < n
						s = s + c
					s
				stringCount: (s, x, i = 0, n = 0) ->
					if (j = s.indexOf x,i) > i-1
						$.stringCount s, x, j+1, n+1
					else n
				stringSplice: (s, i, j, n) ->
					nn = s.length
					end = j
					if end < 0
						end += nn
					start = i
					if start < 0
						start += nn
					s.substring(0,start) + n + s.substring(end)
				checksum: (s) ->
					a = 1; b = 0
					for i in [0...s.length]
						a = (a + s.charCodeAt(i)) % 65521
						b = (b + a) % 65521
					(b << 16) | a
				repeat: (x, n=2) ->
					switch true
						when n is 1 then x
						when n < 1 then ""
						when $.is "string", x then x + $.repeat(x, n-1)
						else $(x).extend $.repeat(x, n-1)
				stringBuilder: ->
					if $.is("global", @) then return new $.stringBuilder()
					items = []
					@length   = 0
					@append   = (s) => items.push s; @length += s?.toString().length|0
					@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
					@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
					@toString = ( ) => items.join("")
					@
			toString: -> $.toString @
			toRepr: -> $.toRepr @
		}
	$.plugin
		provides: "function"
		depends: "hash"
	, ->
		$:
			identity: (o) -> o
			not: (f) -> -> not f.apply @, arguments
			compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
			and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
			once: (f, n=1) ->
				$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
					"exhausted",
						get: -> n <= 0
			cycle: (f...) ->
				i = -1
				-> f[i = ++i % f.length].apply @, arguments
			bound: (t, f, args = []) ->
				if $.is "function", f.bind
					args.splice 0, 0, t
					r = f.bind.apply f, args
				else
					r = (a...) -> f.apply t, (args if args.length else a)
			memoize: (f) ->
				cache = {}
					stats: -> Object.keys(cache).length
					cache: -> cache
	$.plugin
		provides: "hash"
		depends: "type"
	, ->
		$.type.extend
			unknown: { hash: (o) -> $.checksum $.toString(o) }
			object:  { hash: (o) -> $($.hash(o[k]) for k of o).sum() + $.hash(Object.keys(o)) }
			array:   { hash: (o) ->
				$.hash(Array) + ($.hash(i) for i in o).reduce (a,x) -> (a*a)+x }
			bool:    { hash: (o) -> parseInt(1 if o) }
		return {
			$:
				hash: (x) -> $.type.lookup(x).hash(x)
			hash: -> $.hash @
		}
	$.plugin
		provides: "pubsub"
	, ->
		return {
			$:
				publish: (e, args...) ->
					f.apply null, args for f in (subscribers[e] or= [])
					args
				publisher: (e, func) ->
					(args...) ->
						func.apply @, args
						$.publish e, args
				subscribe: (e, func) ->
					(subscribers[e] or= []).push func
					func
				unsubscribe: (e, func) ->
					if not func?
						subscribers[e] = []
					else
						a = (subscribers[e] or= [])
						if (i = a.indexOf func)  > -1
							a.splice(i,i)
		}
	$.plugin
		provides: "throttle"
		depends: "core"
	, ->
		$:
			throttle: (f,n=250,last=0) ->
				(a...) ->
					gap = $.now - last
					if gap > n
						last += gap
						return f.apply @,a
					null
				(a...) ->
					last += (gap = $.now - last)
					return f.apply @,a if gap > n else null
	$.plugin
		provides: "EventEmitter"
	, ->
		$: EventEmitter: $.pipe("bling-init").append (obj) ->
			listeners = {}
			list = (e) -> (listeners[e] or= [])
			inherit {
				emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
				addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
				on:                 (e, h) -> @addListener e, h
				removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
				removeAllListeners: (e) -> listeners[e] = []
				listeners:          (e) -> list(e).slice 0
			}, obj
(($) ->
	$.plugin
		provides: "cartesian"
	, ->
		$:
			cartesian: (sets...) ->
				n = sets.length
				ret = []
				helper = (cur, i) ->
					(return ret.push cur) if ++i >= n
					for x in sets[i]
						helper (cur.concat x), i
					null
				helper [], -1
				return $(ret)
)(Bling)
(($) ->
	$.plugin
		provides: 'config'
	, ->
		$: config: get: (name, def) -> process.env[name] ? def
)(Bling)
(($) ->
	$.plugin
		provides: "date"
	, ->
		[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]
		units = {
			ms, s, m, h, d,
			sec: s
			second: s
			seconds: s
			min: m
			minute: m
			minutes: m
			hr: h
			hour: h
			hours: h
			day: d
			days: d
		}
		formats =
			yyyy: Date::getUTCFullYear
			mm: -> @getUTCMonth() + 1
			dd: Date::getUTCDate
			HH: Date::getUTCHours
			MM: Date::getUTCMinutes
			SS: Date::getUTCSeconds
			MS: Date::getUTCMilliseconds
		format_keys = Object.keys(formats).sort().reverse()
		parsers =
			yyyy: Date::setUTCFullYear
			mm: (x) -> @setUTCMonth(x - 1)
			dd: Date::setUTCDate
			HH: Date::setUTCHours
			MM: Date::setUTCMinutes
			SS: Date::setUTCSeconds
			MS: Date::setUTCMilliseconds
		parser_keys = Object.keys(parsers).sort().reverse()
		floor = Math.floor
		$.type.register "date",
			match: (o) -> $.isType Date, o
			array: (o) -> [o]
		adder = (key) ->
			(stamp, delta, stamp_unit = $.date.defaultUnit) ->
				date = $.date.unstamp(stamp, stamp_unit)
				parsers[key].call date, (formats[key].call date) + delta
				$.date.stamp date, stamp_unit
		$:
			date:
				defaultUnit: "s"
				defaultFormat: "yyyy-mm-dd HH:MM:SS"
				stamp: (date = new Date, unit = $.date.defaultUnit) ->
					floor (date / units[unit])
				unstamp: (stamp, unit = $.date.defaultUnit) ->
					new Date floor(stamp * units[unit])
				convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
					(floor stamp * units[from] / units[to])
				midnight: (stamp, unit = $.date.defaultUnit) ->
					$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
				format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
					date = $.date.unstamp stamp, unit
					for k in format_keys
						fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
					fmt
				parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
					date = new Date(0)
					for i in [0...fmt.length] by 1
						for k in parser_keys
							if fmt.indexOf(k, i) is i
								try
									parsers[k].call date,
										parseInt dateString[i...i+k.length], 10
								catch err
					$.date.stamp date, to
				addMilliseconds: adder("MS")
				addSeconds: adder("SS")
				addMinutes: adder("MM")
				addHours: adder("HH")
				addDays: adder("dd")
				addMonths: adder("mm")
				addYears: adder("yyyy")
				range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
					add = adder(interval_unit)
					ret = [from]
					while (cur = ret[ret.length-1]) < to
						ret.push add(cur, interval, stamp_unit)
					ret
	
		midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
		unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
		stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
		dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
		dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)
)(Bling)
(($) ->
	$.plugin
		provides: "delay"
		depends: "function"
	, ->
		$:
			delay: (->
				timeoutQueue = $.extend [], (->
					next = (a) -> -> a.shift()() if a.length
					add: (f, n) ->
						f.order = n + $.now
						for i in [0..@length] by 1
							if i is @length or @[i].order > f.order
								@splice i,0,f
								break
						setTimeout next(@), n
						@
					cancel: (f) ->
						for i in [0...@length] by 1
							if @[i] == f
								@splice i, 1
								break
						@
				)()
				(n, f) ->
					if $.is("function",f) then timeoutQueue.add(f, n)
					cancel: -> timeoutQueue.cancel(f)
			)()
		delay: (n, f, c=@) ->
			$.delay n, $.bound(c, f)
			@
)(Bling)
(($) ->
	if $.global.document?
		$.plugin
			depends: "function"
			provides: "dom"
		, ->
			$.type.register "nodelist",
				match:  (o) -> o? and $.isType "NodeList", o
				hash:   (o) -> $($.hash(i) for i in x).sum()
				array:  $.identity
				string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
				node:   (o) -> $(o).toFragment()
			$.type.register "node",
				match:  (o) -> o?.nodeType > 0
				hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "fragment",
				match:  (o) -> o?.nodeType is 11
				hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "html",
				match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
				node:   (h) ->
					(node = document.createElement('div')).innerHTML = h
					if n = (childNodes = node.childNodes).length is 1
						return node.removeChild(childNodes[0])
					df = document.createDocumentFragment()
					df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
					df
				array:  (o,c) -> $.type.lookup(h = Bling.HTML.parse o).array h, c
				repr:   (o) -> '"' + o + '"'
			$.type.extend
				unknown:  { node: -> null }
				bling:    { node: (o) -> o.toFragment() }
				node:     { html: (n) ->
					d = document.createElement "div"
					d.appendChild (n = n.cloneNode true)
					ret = d.innerHTML
					ret
				}
				string:
					node:  (o) -> $(o).toFragment()
					array: (o,c) -> c.querySelectorAll?(o)
				function: { node: (o) -> $(o.toString()).toFragment() }
			toFrag = (a) ->
				if not a.parentNode?
					df = document.createDocumentFragment()
					df.appendChild(a)
				a
			before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
			after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
			toNode = (x) -> $.type.lookup(x).node(x)
			escaper = false
			parser = false
			computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue(k)
			getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select(p)
			selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )
			return {
				$:
					HTML:
						parse: (h) -> $.type.lookup(h).node(h)
						stringify: (n) -> $.type.lookup(n).html(n)
						escape: (h) ->
							escaper or= $("<div>&nbsp;</div>").child(0)
							ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
							escaper.zap('data', '')
							ret
				html: (h) ->
					return switch $.type h
						when "undefined","null" then @select 'innerHTML'
						when "string" then @zap 'innerHTML', h
						when "bling" then @html h.toFragment()
						when "node"
								@replaceChild @childNodes[0], h
								while @childNodes.length > 1
									@removeChild @childNodes[1]
					@each -> @appendChild x.cloneNode true
					clones = @map( -> @cloneNode true)
					i = 0
					$(x).each -> @appendChild clones[i++]
					clones
					if x?
						x = toNode(x)
						@take(1).each ->
							before @childNodes[0], x
						@skip(1).each ->
							before @childNodes[0], x.cloneNode(true)
					@
					if x?
						$(x).prepend(@)
					@
					if x?
						x = toNode(x)
						@take(1).each -> before @, x
						@skip(1).each -> before @, x.cloneNode(true)
					@
					if x?
						x = toNode(x)
						@take(1).each -> after @, x
						@skip(1).each -> after @, x.cloneNode(true)
					@
					parent = toNode(parent)
					if $.is "fragment", parent
						throw new Error("cannot call .wrap() with a fragment as the parent")
					@each (child) ->
						if ($.is "fragment", child) or not child.parentNode
							return parent.appendChild child
						grandpa = child.parentNode
						marker = document.createElement "dummy"
						parent.appendChild grandpa.replaceChild marker, child
						grandpa.replaceChild parent, marker
					@each ->
						if @parentNode and @parentNode.parentNode
							@parentNode.parentNode.replaceChild(@, @parentNode)
						else if @parentNode
							@parentNode.removeChild(@)
					n = toNode(n)
					clones = @map(-> n.cloneNode true)
					for i in [0...clones.length] by 1
						@[i].parentNode?.replaceChild clones[i], @[i]
					clones
					return switch v
						when undefined then @select("getAttribute").call(a, v)
						when null then @select("removeAttribute").call(a, v)
						else
							@select("setAttribute").call(a, v)
							@
					notempty = (y) -> y isnt ""
					@removeClass(x).each ->
						c = @className.split(" ").filter notempty
						c.push(x)
						@className = c.join " "
					notx = (y) -> y != x
					@each ->
						c = @className.split(" ").filter(notx).join(" ")
						if c.length is 0
							@removeAttribute('class')
					notx = (y) -> y isnt x
					@each ->
						cls = @className.split(" ")
						filter = $.not $.isEmpty
						if( cls.indexOf(x) > -1 )
							filter = $.and notx, filter
						else
							cls.push(x)
						c = cls.filter(filter).join(" ")
						@className = c
						if c.length is 0
							@removeAttribute('class')
					@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1
					return @zap('textContent', t) if t?
					return @select('textContent')
					return @zap('value', v) if v?
					return @select('value')
				css: (k,v) ->
					if v? or $.is "object", k
						setter = @select 'style.setProperty'
						if $.is "object", k then setter.call i, k[i], "" for i of k
						else if $.is "string", v then setter.call k, v, ""
						else if $.is "array", v
							setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
						return @
					else
						cv = @map computeCSSProperty(k)
						ov = @select('style').select k
						ov.weave(cv).fold (x,y) -> x or y
				defaultCss: (k, v) ->
					sel = @selector
					style = ""
					if $.is "string", k
						if $.is "string", v
						else throw Error("defaultCss requires a value with a string key")
					else if $.is "object", k
						"} "
					$("<style></style>").text(style).appendTo("head")
					@
				rect: -> @select('getBoundingClientRect').call()
				width: getOrSetRect("width")
				height: getOrSetRect("height")
				top: getOrSetRect("top")
				left: getOrSetRect("left")
				bottom: getOrSetRect("bottom")
				right: getOrSetRect("right")
				position: (left, top) ->
					switch true
						when not left? then @rect()
						when not top? then @css("left", $.px(left))
						else @css({top: $.px(top), left: $.px(left)})
				scrollToCenter: ->
					document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
					@
				child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]
				parents: selectChain('parentNode')
				prev: selectChain('previousSibling')
				next: selectChain('nextSibling')
				remove: -> @each -> @parentNode?.removeChild(@)
				find: (css) ->
					@filter("*")
						.map( -> $(css, @) )
						.flatten()
				clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @
				toFragment: ->
					if @length > 1
						df = document.createDocumentFragment()
						(@map toNode).map $.bound df, df.appendChild
						return df
					return toNode @[0]
			}
)(Bling)
(($) ->
	$.plugin
		depends: "dom,function,core"
		provides: "event"
	, ->
		EVENTSEP_RE = /,* +/
		events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
			'load','unload','reset','submit','keyup','keydown','change',
			'abort','cut','copy','paste','selection','drag','drop','orientationchange',
			'touchstart','touchmove','touchend','touchcancel',
			'gesturestart','gestureend','gesturecancel',
			'hashchange'
		]
		binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)
		register_live = (selector, context, evt, f, h) ->
			$(context).bind(evt, h)
				.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h
		unregister_live = (selector, context, e, f) ->
			$c = $(context)
			$c.each ->
				a = (@__alive__ or= {})
				b = (a[selector] or= {})
				c = (b[e] or= {})
				$c.unbind(e, c[f])
				delete c[f]
		triggerReady = $.once ->
			$(document).trigger("ready").unbind("ready")
			document.removeEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.removeEventListener?("load", triggerReady, false)
		bindReady = $.once ->
			document.addEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.addEventListener?("load", triggerReady, false)
		bindReady()
		ret = {
			bind: (e, f) ->
				c = (e or "").split(EVENTSEP_RE)
				h = (evt) ->
					ret = f.apply @, arguments
					if ret is false
						evt.preventAll()
					ret
				@each -> (@addEventListener i, h, false) for i in c
			unbind: (e, f) ->
				c = (e or "").split EVENTSEP_RE
				@each -> (@removeEventListener i, f, null) for i in c
			trigger: (evt, args = {}) ->
				args = $.extend
					bubbles: true
					cancelable: true
				, args
				for evt_i in (evt or "").split(EVENTSEP_RE)
						e = document.createEvent "MouseEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							button: 0,
							relatedTarget: null
						, args
						e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.button, args.relatedTarget
						e = document.createEvent "UIEvents"
						e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1
						e = document.createEvent "TouchEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							touches: [],
							targetTouches: [],
							changedTouches: [],
							scale: 1.0,
							rotation: 0.0
						, args
						e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)
						e = document.createEvent "GestureEvents"
						args = $.extend {
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							target: null,
							scale: 1.0,
							rotation: 0.0
						}, args
						e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.target, args.scale, args.rotation
					else
						e = document.createEvent "Events"
						e.initEvent evt_i, args.bubbles, args.cancelable
						try
							e = $.extend e, args
						catch err
					if not e
						continue
					else
						try
							@each -> @dispatchEvent e
						catch err
							$.log "dispatchEvent error:", err
				@
			live: (e, f) ->
				selector = @selector
				context = @context
				handler = (evt) ->
					$(selector, context)
						.intersect($(evt.target).parents().first().union($(evt.target)))
						.each -> f.call(evt.target = @, evt)
				register_live selector, context, e, f, handler
				@
			die: (e, f) ->
				$(@context).unbind e, unregister_live(@selector, @context, e, f)
				@
			click: (f = {}) ->
				if @css("cursor") in ["auto",""]
					@css "cursor", "pointer"
				if $.is "function", f then @bind 'click', f
				else @trigger 'click', f
				@
			ready: (f) ->
				return (f.call @) if triggerReady.exhausted
				@bind "ready", f
		}
		events.forEach (x) -> ret[x] = binder(x)
		return ret
)(Bling)
(($) ->
	$.plugin ->
		$:
			histogram: (data, bucket_width=1, output_width=80) ->
				buckets = $()
				len = 0
				for x in data
					i = Math.floor( x / bucket_width )
					buckets[i] ?= 0
					buckets[i] += 1
					len = Math.max(len, i+1)
				buckets.length = len
				max = buckets.max()
				buckets = buckets.map((x) -> x or 0)
					.scale(1/max)
					.scale(output_width)
				sum = buckets.sum()
				ret = ""
				for n in [0...len] by 1
					end = (n+1) * bucket_width
					pct = (buckets[n]*100/sum).toFixed(0)
				ret
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->
		$.type.register "http",
			match: (o) -> $.isType 'XMLHttpRequest', o
			array: (o) -> [o]
		return {
			$:
				http: (url, opts = {}) ->
					xhr = new XMLHttpRequest()
					if $.is "function", opts
						opts = success: $.bound(xhr, opts)
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts
					opts.state = $.bound(xhr, opts.state)
					opts.success = $.bound(xhr, opts.success)
					opts.error = $.bound(xhr, opts.error)
					if opts.data and opts.method is "GET"
						url += "?" + formencode(opts.data)
					else if opts.data and opts.method is "POST"
						opts.data = formencode(opts.data)
					xhr.open(opts.method, url, opts.async)
					xhr = $.extend xhr,
						asBlob: opts.asBlob
						timeout: opts.timeout
						followRedirects: opts.followRedirects
						withCredentials: opts.withCredentials
						onreadystatechange: ->
							opts.state?()
							if xhr.readyState is 4
								if xhr.status is 200
									opts.success xhr.responseText
								else
									opts.error xhr.status, xhr.statusText
					xhr.send opts.data
					return $(xhr)
				post: (url, opts = {}) ->
					if $.is("function",opts)
						opts = success: opts
					opts.method = "POST"
					$.http(url, opts)
				get: (url, opts = {}) ->
					if( $.is("function",opts) )
						opts = success: opts
					opts.method = "GET"
					$.http(url, opts)
		}
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "lazy"
	, ->
		lazy_load = (elementName, props) ->
			$("head").append $.extend document.createElement(elementName), props
		$:
			script: (src) ->
				lazy_load "script", { src: src }
			style: (src) ->
				lazy_load "link", { href: src, rel: "stylesheet" }
)(Bling)
(($) ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""
		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615
		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)
			index = (index + 1) % 624
			(y + a) / b
		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()
		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
	)()
	$.plugin
		provides: "random"
	, ->
		$:
			random: random
)(Bling)
(($) ->
	$.plugin
		provides: "sendgrid"
		depends: "config"
	, ->
		try
			nodemailer = require 'nodemailer'
		catch err
			`return`
		transport = nodemailer.createTransport 'SMTP',
			service: 'SendGrid'
			auth:
				user: $.config.get 'SENDGRID_USERNAME'
		$:
			sendMail: (mail, callback) ->
				mail.transport ?= transport
				mail.from ?= $.config.get 'EMAILS_FROM'
				mail.bcc ?= $.config.get 'EMAILS_BCC'
				if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
					nodemailer.sendMail mail, callback
				else
)(Bling)
(($) ->
	$.plugin
		provides: "StateMachine"
	, ->
		$: StateMachine: class StateMachine
			constructor: (stateTable) ->
				@debug = false
				@reset()
				@table = stateTable
				Object.defineProperty @, "modeline",
					get: -> @table[@_mode]
				Object.defineProperty @, "mode",
					set: (m) ->
						@_lastMode = @_mode
						@_mode = m
						if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
							ret = @modeline['enter'].call @
							while $.is("function",ret)
								ret = ret.call @
						m
					get: -> @_mode
			reset: ->
				@_mode = null
				@_lastMode = null
			GO: (m) -> -> @mode = m
			@GO: (m) -> -> @mode = m
			
			tick: (c) ->
				row = @modeline
				if not row?
					ret = null
				else if c of row
					ret = row[c]
				else if 'def' of row
					ret = row['def']
				while $.is "function",ret
					ret = ret.call @, c
				ret
			run: (inputs) ->
				@mode = 0
				for c in inputs
					ret = @tick(c)
				if $.is "function",@modeline?.eof
					ret = @modeline.eof.call @
				while $.is "function",ret
					ret = ret.call @
				@reset()
				return @
	$.plugin
		provides: "synth"
		depends: "StateMachine"
	, ->
		class SynthMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: ->
						@tag = @id = @cls = @attr = @val = @text = ""
						@attrs = {}
						@GO 1
				},
					def: (c) -> @tag += c
					eof: @GO 13
				},
					".": @GO(3), "[": @GO(4), " ": @GO(9), "+": @GO(11), ",": @GO(10),
					def: (c) -> @id += c
					eof: @GO 13
				},
					enter: -> @cls += " " if @cls.length > 0
					def: (c) -> @cls += c
					eof: @GO 13
				},
					"=": @GO 5
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @attr += c
					eof: @GO 12
				},
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @val += c
					eof: @GO 12
				},
					'"': @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					"'": @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					enter: ->
						@emitText()
						@GO 0
				},
					enter: ->
						@emitNode()
						@GO 0
				},
					enter: ->
						@emitNode()
						@parent = null
						@GO 0
				},
					enter: ->
						@emitNode()
						@parent = @parent?.parentNode
						@GO 0
				},
				},
					enter: ->
						@emitNode() if @tag.length
						@emitText() if @text.length
				}
			]
			constructor: ->
				super(SynthMachine.STATE_TABLE)
				@fragment = @parent = document.createDocumentFragment()
			emitNode: ->
				node = document.createElement(@tag)
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@parent.appendChild node
				@parent = node
			emitText: ->
				@parent.appendChild $.type.lookup("<html>").node(@text)
				@text = ""
		return {
			$:
				synth: (expr) ->
					s = new SynthMachine()
					s.run(expr)
					if s.fragment.childNodes.length == 1
						$(s.fragment.childNodes[0])
					else
						$(s.fragment)
		}
)(Bling)
(($) ->
		current_engine = null
		engines = {}
		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine
		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()
		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop]
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1
	$.template.register_engine 'pythonic', (() ->
		chunk_re = /%[\(\/]/
		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n]
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}
			if not cache?
			n = cache.length
			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""
		return render
	)()
		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
)(Bling)
(($) ->
		parseOne = (data) ->
			i = data.indexOf ":"
			if i > 0
				len = parseInt data[0...i], 10
				item = data[i+1...i+1+len]
				type = data[i+1+len]
				extra = data[i+len+2...]
				item = switch type
					when "'" then String(item)
					when "!" then (item is "true")
					when "~" then null
					when "]" then parseArray(item)
					when "}" then parseObject(item)
				return [item, extra]
			return undefined
		parseArray = (x) ->
			data = []
			while x.length > 0
				[one, x] = parseOne(x)
				data.push(one)
			data
		parseObject = (x) ->
			data = {}
			while x.length > 0
				[key, x] = parseOne(x)
				[value, x] = parseOne(x)
				data[key] = value
			data
		$:
			TNET:
				stringify: (x) ->
					[data, type] = switch $.type x
						when "string" then [x, "'"]
						when "function" then [String(x), "'"]
						when "boolean" then [String(not not x), "!"]
						when "null" then ["", "~"]
						when "undefined" then ["", "~"]
						when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
						when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
					return (data.length|0) + ":" + data + type
				parse: (x) ->
					parseOne(x)?[0]
)(Bling)
(($) ->
	$.plugin
		provides: "trace"
		depends: "function,type"
	, ->
		$.type.extend
			unknown: { trace: $.identity }
			function:
				trace: (label, f, tracer) ->
					label or= f.name
					r = (a...) ->
						f.apply @, a
					r
		return $: trace: (label, o, tracer) ->
			if not $.is "string", label
				[tracer, o] = [o, label]
			tracer or= $.log
			label or= ""
			$.type.lookup(o).trace(label, o, tracer)
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
	, ->
		COMMASEP = ", "
			"slow": 700
			"medium": 500
			"normal": 300
			"fast": 100
			"instant": 0
			"now": 0
		accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
		testStyle = document.createElement("div").style
		transformProperty = "transform"
		transitionProperty = "transition-property"
		transitionDuration = "transition-duration"
		transitionTiming = "transition-timing-function"
		if "WebkitTransform" of testStyle
			transformProperty = "-webkit-transform"
			transitionProperty = "-webkit-transition-property"
			transitionDuration = "-webkit-transition-duration"
			transitionTiming = "-webkit-transition-timing-function"
		else if "MozTransform" of testStyle
			transformProperty = "-moz-transform"
			transitionProperty = "-moz-transition-property"
			transitionDuration = "-moz-transition-duration"
			transitionTiming = "-moz-transition-timing-function"
		else if "OTransform" of testStyle
			transformProperty = "-o-transform"
			transitionProperty = "-o-transition-property"
			transitionDuration = "-o-transition-duration"
			transitionTiming = "-o-transition-timing-function"
		return {
			$:
				duration: (speed) ->
					d = speeds[speed]
					return d if d?
					return parseFloat speed
			transform: (end_css, speed, easing, callback) ->
				if $.is("function",speed)
					callback = speed
					speed = easing = null
				else if $.is("function",easing)
					callback = easing
					easing = null
				speed ?= "normal"
				easing or= "ease"
				duration = $.duration(speed) + "ms"
				props = []
				trans = ""
				css = {}
				for i of end_css
					if accel_props_re.test(i)
						ii = end_css[i]
						if ii.join
							ii = $(ii).px().join COMMASEP
						else if ii.toString
							ii = ii.toString()
						trans += " " + i + "(" + ii + ")"
					else css[i] = end_css[i]
				(props.push i) for i of css
				if trans
					props.push transformProperty
				css[transitionProperty] = props.join COMMASEP
				css[transitionDuration] = props.map(-> duration).join COMMASEP
				css[transitionTiming] = props.map(-> easing).join COMMASEP
				if trans
					css[transformProperty] = trans
				@css css
				@delay duration, callback
				@each ->
					if @style
						if @style.display is not "none"
							@_display = @syle.display
						@style.display = "none"
				.trigger "hide"
				.delay updateDelay, callback
				@each ->
					if @style
						@style.display = @_display
						delete @_display
				.trigger "show"
				.delay updateDelay, callback
				@weave(@css("display"))
					.fold (display, node) ->
						if display is "none"
							node.style.display = node._display or ""
							delete node._display
							$(node).trigger "show"
						else
							node._display = display
							node.style.display = "none"
							$(node).trigger "hide"
						node
					.delay(updateDelay, callback)
				@.css('opacity','0.0')
					.show ->
						@transform {
							opacity:"1.0",
							translate3d: [0,0,0]
						}, speed, callback
				@transform {
					opacity:"0.0",
					translate3d:[x,y,0.0]
				}, speed, -> @hide(callback)
			fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
			fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
			fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
			fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
		}
)(Bling)
(($) ->
	$.plugin
		provides: "unittest"
		depends: "core,function"
	, ->
		testCount = passCount = failCount = 0
		failed = []
		invokeTest = (group, name, func) ->
			return if not $.is "function", func
			shouldFail = name.toLowerCase().indexOf("fail") isnt -1
			done = $.once (err) ->
				testCount--
				if (!!err isnt shouldFail)
					failCount++
					failed.push name
				else
					_log "pass"
					passCount++
					$.provide name
			f = (done) ->
				try func(done)
				catch err then done(err)
				finally
					if name.toLowerCase().indexOf("async") is -1 then done()
			testCount++
			try f(done)
			catch err then done(err)
		testReport = $.once ->
		$:
			approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
			assertEqual: (a, b, label) ->
				if a isnt b
			assertArrayEqual: (a, b, label) ->
				for i in [0...a.length] by 1
					try
						$.assertEqual(a[i], b[i], label)
					catch err
			testGroup: (name, funcs) ->
				interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
				for k,func of funcs
					invokeTest(name, k, func)
		assertEqual: (args...) ->
					if $.is "function", x then x.call(@,@) else x
				a = args[0]
				for i in [1...args.length]
					$.assertEqual a, args[i]
			return @
)(Bling)
(($) ->
	$.plugin
		provides: "cartesian"
	, ->
		$:
			cartesian: (sets...) ->
				n = sets.length
				ret = []
				helper = (cur, i) ->
					(return ret.push cur) if ++i >= n
					for x in sets[i]
						helper (cur.concat x), i
					null
				helper [], -1
				return $(ret)

)(Bling)
(($) ->
	$.plugin
		provides: 'config'
	, ->
		$: config: get: (name, def) -> process.env[name] ? def
)(Bling)

(($) ->
	$.plugin
		provides: "date"
	, ->
		[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]

		units = {
			ms, s, m, h, d,
			sec: s
			second: s
			seconds: s
			min: m
			minute: m
			minutes: m
			hr: h
			hour: h
			hours: h
			day: d
			days: d
		}

		formats =
			yyyy: Date::getUTCFullYear
			mm: -> @getUTCMonth() + 1
			dd: Date::getUTCDate
			HH: Date::getUTCHours
			MM: Date::getUTCMinutes
			SS: Date::getUTCSeconds
			MS: Date::getUTCMilliseconds
		format_keys = Object.keys(formats).sort().reverse()

		parsers =
			yyyy: Date::setUTCFullYear
			mm: (x) -> @setUTCMonth(x - 1)
			dd: Date::setUTCDate
			HH: Date::setUTCHours
			MM: Date::setUTCMinutes
			SS: Date::setUTCSeconds
			MS: Date::setUTCMilliseconds
		parser_keys = Object.keys(parsers).sort().reverse()

		floor = Math.floor

		$.type.register "date",
			match: (o) -> $.isType Date, o
			array: (o) -> [o]

		adder = (key) ->
			(stamp, delta, stamp_unit = $.date.defaultUnit) ->
				date = $.date.unstamp(stamp, stamp_unit)
				parsers[key].call date, (formats[key].call date) + delta
				$.date.stamp date, stamp_unit

		$:
			date:
				defaultUnit: "s"
				defaultFormat: "yyyy-mm-dd HH:MM:SS"
				stamp: (date = new Date, unit = $.date.defaultUnit) ->
					floor (date / units[unit])
				unstamp: (stamp, unit = $.date.defaultUnit) ->
					new Date floor(stamp * units[unit])
				convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
					(floor stamp * units[from] / units[to])
				midnight: (stamp, unit = $.date.defaultUnit) ->
					$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
				format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
					if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
					date = $.date.unstamp stamp, unit
					for k in format_keys
						fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
					fmt
				parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
					date = new Date(0)
					for i in [0...fmt.length] by 1
						for k in parser_keys
							if fmt.indexOf(k, i) is i
								try
									parsers[k].call date,
										parseInt dateString[i...i+k.length], 10
								catch err
					$.date.stamp date, to
				addMilliseconds: adder("MS")
				addSeconds: adder("SS")
				addMinutes: adder("MM")
				addHours: adder("HH")
				addDays: adder("dd")
				addMonths: adder("mm")
				addYears: adder("yyyy")
				range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
					add = adder(interval_unit)
					ret = [from]
					while (cur = ret[ret.length-1]) < to
						ret.push add(cur, interval, stamp_unit)
					ret
	
		midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
		unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
		stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
		dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
		dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)

)(Bling)

(($) ->

	$.plugin
		provides: "delay"
		depends: "function"
	, ->
		$:
			delay: (->
				timeoutQueue = $.extend [], (->
					next = (a) -> -> a.shift()() if a.length
					add: (f, n) ->
						f.order = n + $.now
						for i in [0..@length] by 1
							if i is @length or @[i].order > f.order
								@splice i,0,f
								break
						setTimeout next(@), n
						@
					cancel: (f) ->
						for i in [0...@length] by 1
							if @[i] == f
								@splice i, 1
								break
						@
				)()

				(n, f) ->
					if $.is("function",f) then timeoutQueue.add(f, n)
					cancel: -> timeoutQueue.cancel(f)

			)()

		delay: (n, f, c=@) ->
			$.delay n, $.bound(c, f)
			@

)(Bling)
(($) ->
	if $.global.document?
		$.plugin
			depends: "function"
			provides: "dom"
		, ->
			$.type.register "nodelist",
				match:  (o) -> o? and $.isType "NodeList", o
				hash:   (o) -> $($.hash(i) for i in x).sum()
				array:  $.identity
				string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
				node:   (o) -> $(o).toFragment()
			$.type.register "node",
				match:  (o) -> o?.nodeType > 0
				hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "fragment",
				match:  (o) -> o?.nodeType is 11
				hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
				string: (o) -> o.toString()
				node:   $.identity
			$.type.register "html",
				match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
				node:   (h) ->
					(node = document.createElement('div')).innerHTML = h
					if n = (childNodes = node.childNodes).length is 1
						return node.removeChild(childNodes[0])
					df = document.createDocumentFragment()
					df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
					df
				array:  (o,c) -> $.type.lookup(h = Bling.HTML.parse o).array h, c
				repr:   (o) -> '"' + o + '"'
			$.type.extend
				unknown:  { node: -> null }
				bling:    { node: (o) -> o.toFragment() }
				node:     { html: (n) ->
					d = document.createElement "div"
					d.appendChild (n = n.cloneNode true)
					ret = d.innerHTML
					ret
				}
				string:
					node:  (o) -> $(o).toFragment()
					array: (o,c) -> c.querySelectorAll?(o)
				function: { node: (o) -> $(o.toString()).toFragment() }

			toFrag = (a) ->
				if not a.parentNode?
					df = document.createDocumentFragment()
					df.appendChild(a)
				a
			before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
			after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
			toNode = (x) -> $.type.lookup(x).node(x)
			escaper = false
			parser = false

			computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue(k)

			getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select(p)

			selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )

			return {
				$:

					HTML:
						parse: (h) -> $.type.lookup(h).node(h)
						stringify: (n) -> $.type.lookup(n).html(n)
						escape: (h) ->
							escaper or= $("<div>&nbsp;</div>").child(0)
							ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
							escaper.zap('data', '')
							ret

				html: (h) ->
					return switch $.type h
						when "undefined","null" then @select 'innerHTML'
						when "string" then @zap 'innerHTML', h
						when "bling" then @html h.toFragment()
						when "node"
								@replaceChild @childNodes[0], h
								while @childNodes.length > 1
									@removeChild @childNodes[1]

					@each -> @appendChild x.cloneNode true

					clones = @map( -> @cloneNode true)
					i = 0
					$(x).each -> @appendChild clones[i++]
					clones

					if x?
						x = toNode(x)
						@take(1).each ->
							before @childNodes[0], x
						@skip(1).each ->
							before @childNodes[0], x.cloneNode(true)
					@

					if x?
						$(x).prepend(@)
					@

					if x?
						x = toNode(x)
						@take(1).each -> before @, x
						@skip(1).each -> before @, x.cloneNode(true)
					@

					if x?
						x = toNode(x)
						@take(1).each -> after @, x
						@skip(1).each -> after @, x.cloneNode(true)
					@

					parent = toNode(parent)
					if $.is "fragment", parent
						throw new Error("cannot call .wrap() with a fragment as the parent")
					@each (child) ->
						if ($.is "fragment", child) or not child.parentNode
							return parent.appendChild child
						grandpa = child.parentNode
						marker = document.createElement "dummy"
						parent.appendChild grandpa.replaceChild marker, child
						grandpa.replaceChild parent, marker

					@each ->
						if @parentNode and @parentNode.parentNode
							@parentNode.parentNode.replaceChild(@, @parentNode)
						else if @parentNode
							@parentNode.removeChild(@)

					n = toNode(n)
					clones = @map(-> n.cloneNode true)
					for i in [0...clones.length] by 1
						@[i].parentNode?.replaceChild clones[i], @[i]
					clones

					return switch v
						when undefined then @select("getAttribute").call(a, v)
						when null then @select("removeAttribute").call(a, v)
						else
							@select("setAttribute").call(a, v)
							@


					notempty = (y) -> y isnt ""
					@removeClass(x).each ->
						c = @className.split(" ").filter notempty
						c.push(x)
						@className = c.join " "

					notx = (y) -> y != x
					@each ->
						c = @className.split(" ").filter(notx).join(" ")
						if c.length is 0
							@removeAttribute('class')

					notx = (y) -> y isnt x
					@each ->
						cls = @className.split(" ")
						filter = $.not $.isEmpty
						if( cls.indexOf(x) > -1 )
							filter = $.and notx, filter
						else
							cls.push(x)
						c = cls.filter(filter).join(" ")
						@className = c
						if c.length is 0
							@removeAttribute('class')

					@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1

					return @zap('textContent', t) if t?
					return @select('textContent')

					return @zap('value', v) if v?
					return @select('value')

				css: (k,v) ->
					if v? or $.is "object", k
						setter = @select 'style.setProperty'
						if $.is "object", k then setter.call i, k[i], "" for i of k
						else if $.is "string", v then setter.call k, v, ""
						else if $.is "array", v
							setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
						return @
					else
						cv = @map computeCSSProperty(k)
						ov = @select('style').select k
						ov.weave(cv).fold (x,y) -> x or y

				defaultCss: (k, v) ->
					sel = @selector
					style = ""
					if $.is "string", k
						if $.is "string", v
						else throw Error("defaultCss requires a value with a string key")
					else if $.is "object", k
						"} "
					$("<style></style>").text(style).appendTo("head")
					@

				rect: -> @select('getBoundingClientRect').call()

				width: getOrSetRect("width")

				height: getOrSetRect("height")

				top: getOrSetRect("top")

				left: getOrSetRect("left")

				bottom: getOrSetRect("bottom")

				right: getOrSetRect("right")

				position: (left, top) ->
					switch true
						when not left? then @rect()
						when not top? then @css("left", $.px(left))
						else @css({top: $.px(top), left: $.px(left)})

				scrollToCenter: ->
					document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
					@

				child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]

				parents: selectChain('parentNode')

				prev: selectChain('previousSibling')

				next: selectChain('nextSibling')

				remove: -> @each -> @parentNode?.removeChild(@)

				find: (css) ->
					@filter("*")
						.map( -> $(css, @) )
						.flatten()

				clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @

				toFragment: ->
					if @length > 1
						df = document.createDocumentFragment()
						(@map toNode).map $.bound df, df.appendChild
						return df
					return toNode @[0]
			}
)(Bling)
(($) ->
	$.plugin
		depends: "dom,function,core"
		provides: "event"
	, ->
		EVENTSEP_RE = /,* +/
		events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
			'load','unload','reset','submit','keyup','keydown','change',
			'abort','cut','copy','paste','selection','drag','drop','orientationchange',
			'touchstart','touchmove','touchend','touchcancel',
			'gesturestart','gestureend','gesturecancel',
			'hashchange'
		]

		binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)

		register_live = (selector, context, evt, f, h) ->
			$(context).bind(evt, h)
				.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h

		unregister_live = (selector, context, e, f) ->
			$c = $(context)
			$c.each ->
				a = (@__alive__ or= {})
				b = (a[selector] or= {})
				c = (b[e] or= {})
				$c.unbind(e, c[f])
				delete c[f]

		triggerReady = $.once ->
			$(document).trigger("ready").unbind("ready")
			document.removeEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.removeEventListener?("load", triggerReady, false)
		bindReady = $.once ->
			document.addEventListener?("DOMContentLoaded", triggerReady, false)
			$.global.addEventListener?("load", triggerReady, false)
		bindReady()

		ret = {
			bind: (e, f) ->
				c = (e or "").split(EVENTSEP_RE)
				h = (evt) ->
					ret = f.apply @, arguments
					if ret is false
						evt.preventAll()
					ret
				@each -> (@addEventListener i, h, false) for i in c

			unbind: (e, f) ->
				c = (e or "").split EVENTSEP_RE
				@each -> (@removeEventListener i, f, null) for i in c

			trigger: (evt, args = {}) ->
				args = $.extend
					bubbles: true
					cancelable: true
				, args

				for evt_i in (evt or "").split(EVENTSEP_RE)
						e = document.createEvent "MouseEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							button: 0,
							relatedTarget: null
						, args
						e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.button, args.relatedTarget

						e = document.createEvent "UIEvents"
						e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1

						e = document.createEvent "TouchEvents"
						args = $.extend
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							touches: [],
							targetTouches: [],
							changedTouches: [],
							scale: 1.0,
							rotation: 0.0
						, args
						e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)

						e = document.createEvent "GestureEvents"
						args = $.extend {
							detail: 1,
							screenX: 0,
							screenY: 0,
							clientX: 0,
							clientY: 0,
							ctrlKey: false,
							altKey: false,
							shiftKey: false,
							metaKey: false,
							target: null,
							scale: 1.0,
							rotation: 0.0
						}, args
						e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
							args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
							args.target, args.scale, args.rotation

					else
						e = document.createEvent "Events"
						e.initEvent evt_i, args.bubbles, args.cancelable
						try
							e = $.extend e, args
						catch err

					if not e
						continue
					else
						try
							@each -> @dispatchEvent e
						catch err
							$.log "dispatchEvent error:", err
				@

			live: (e, f) ->
				selector = @selector
				context = @context
				handler = (evt) ->
					$(selector, context)
						.intersect($(evt.target).parents().first().union($(evt.target)))
						.each -> f.call(evt.target = @, evt)
				register_live selector, context, e, f, handler
				@

			die: (e, f) ->
				$(@context).unbind e, unregister_live(@selector, @context, e, f)
				@

			click: (f = {}) ->
				if @css("cursor") in ["auto",""]
					@css "cursor", "pointer"
				if $.is "function", f then @bind 'click', f
				else @trigger 'click', f
				@

			ready: (f) ->
				return (f.call @) if triggerReady.exhausted
				@bind "ready", f
		}

		events.forEach (x) -> ret[x] = binder(x)
		return ret
)(Bling)


(($) ->
	$.plugin
		provides: "bus"
		depends: "socket"
	, ->
		routes = {}
		clients = {}
		$:
			bus:
				connect: (url) ->
					send: (address, message) ->
					recv: (address, message) ->
				listen: (port) ->
					server = require("websocket-server")
						.createServer()
						.addListener("connection", (client) ->
							clients[client.id] = client
						)
						.addListener("close", (client) ->
							delete clients[client.id]
						)
						.listen(port)

)(Bling)
(($) ->
	$.plugin
		depends: "experimental"
	, ->
		pruners = {}
		register = (type, f) -> (pruners[type] = f)
		lookup = (obj) -> pruners[obj.t or obj.type]
		stack = []

		$.type.extend null,        { compact: (o) -> $.toString(o) }
		$.type.extend "undefined", { compact: (o) -> "" }
		$.type.extend "null",      { compact: (o) -> "" }
		$.type.extend "string",    { compact: $.identity }
		$.type.extend "array",     { compact: (o) -> (Object.Compact(x) for x in o).join("") }
		$.type.extend "bling",     { compact: (o) -> o.map(Object.Compact).join("") }
		$.type.extend "object",    { compact: (o) -> Object.Compact(lookup(o)?.call o, o) }

		Object.Compact = (o) ->
			stack.push(o)
			$.type.lookup(o)?.compact(o)
			stack.pop()
		$.extend Object.Compact,
			register: register
			lookup: lookup

		register 'page', -> [
			"<!DOCTYPE html><html><head>",
				@head,
			"</head><body>",
				@body,
			"</body></html>"
		]
		register 'text', -> @EN
		register 'link', ->
			a = $(["<a"])
			a.extend(" ",k,"='",@[k],"'") for k in ["href","name","target"] when k of @
			a.extend(">",node.content,"</a>")

		$.assert(Object.Compact({ t: "page", head: [], body: {type: "text", EN: "Hello World"} }) is
			"<!DOCTYPE html><html><head></head><body>Hello World</body></html>")

		return { name: "Compact" }
)(Bling)

(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'ClientRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts

				post: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "POST"
					$.http url, opts

				get: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "GET"
					$.http url, opts
		}
)(Bling)
(($) ->
		operatorHtml = "<span class='opr'>$&</span>"
		keywords = /\b[Ff]unction\b|\bvar\b|\.prototype\b|\.__proto__\b|\bString\b|\bArray\b|\bNumber\b|\bObject\b|\bbreak\b|\bcase\b|\bcontinue\b|\bdelete\b|\bdo\b|\bif\b|\belse\b|\bfinally\b|\binstanceof\b|\breturn\b|\bthrow\b|\btry\b|\btypeof\b|\btrue\b|\bfalse\b/g
		keywordHtml = "<span class='kwd'>$&</span>"
		allNumbers = /\d+\.*\d*/g
		numberHtml = "<span class='num'>$&</span>"
		blingSymbol = /\$(\(|\.)/g
		blingHtml = "<span class='bln'>$$</span>$1"
		tabs = /\t/g
		tabHtml = "&nbsp;&nbsp;"
		singlelineComment = /\/\/.*?(?:\n|$)/
		multilineComment = /\/\*(?:.|\n)*?\*\//
		commentHtml = (comment) ->
		quotedHtml = (quoted) ->

			a = s.indexOf('"', i)
			b = s.indexOf("'", i)
			a = s.length if a is -1
			b = s.length if b is -1
			return [null, -1] if a is b
			return ['"', a] if a < b
			return ["'", b]
			r = s.indexOf(q, i)
			while( s.charAt(r-1) is "\\" and 0 < r < s.length)
				r = s.indexOf(q, r+1)
			r
			i = 0
			n = s.length
			ret = []
			if not Object.IsString(s)
				if not Object.IsFunction(s.toString)
					throw TypeError("invalid string argument to split_quoted")
				else
					s = s.toString()
					n = s.length
			while( i < n )
				q = firstQuote(s, i)
				j = q[1]
				if( j is -1 )
					ret.push(s.substring(i))
					break
				ret.push(s.substring(i,j))
				k = closingQuote(s, j+1, q[0])
				if( k is -1 )
					throw Error("unclosed quote: "+q[0]+" starting at "+j)
				ret.push(s.substring(j, k+1))
				i = k+1
			ret

		firstComment = (s) ->
			a = s.match(singlelineComment)
			b = s.match(multilineComment)
			return [-1, null] if a is b
			return [b.index, b[0]] if a == null and b != null
			return [a.index, a[0]] if a != null && b == null
			return [b.index, b[0]] if b.index < a.index
			return [a.index, a[0]]

		splitComments = (s) ->
			ret = []
			i = 0
			n = s.length
			while( i < n )
				ss = s.substring(i)
				q = firstComment(ss)
				j = q[0]
				if( j > -1 )
					ret.push(ss.substring(0,j))
					ret.push(q[1])
					i += j + q[1].length
				else
					ret.push(ss)
					break
			ret

		foldCodeAndQuoted = (code, quoted) ->
			code.replace(operators, operatorHtml).replace(allNumbers, numberHtml).replace(keywords, keywordHtml).replace(blingSymbol, blingHtml).replace(tabs, tabHtml) + quotedHtml(quoted)

		foldTextAndComments = (text, comment) ->
			$(splitQuoted(text)).fold(foldCodeAndQuoted).join('') + commentHtml(comment)

		return {
			name: "PrettyPrint"
			$:
				prettyPrint: (js, colors) ->
					js = js.toString() if Object.IsFunction(js)
					if not Object.IsString(js)
						throw TypeError("prettyPrint requires a function or string to format, not '"+Object.Type(js)+"'")
						css = "code.pp .bln { font-size: 17px; } "
						colors = Object.Extend(
						, colors)
						for cls of colors
							.text(css)
							.appendTo("head")
					ret = "<code class='pp'>" + ($(splitComments(js)).fold(foldTextAndComments).join('')) + "</code>"
		}

)(Bling)
require "./dist/bling"

len = (o) -> o?.length | 0

indices = $.memoize (str, substr) ->
	switch len(substr)
		when 0 then $.range 0, len(str)
		when 1
			i = -1
			i while (i = str.indexOf substr, i+1) > -1
		else
			subsub = substr[0...len(substr)-1]
			indices(str, subsub).filter (x) -> str.indexOf(substr,x) is x

commonSubstrings = (a,b,min_length=3,limit=10) ->
	a = a.toLowerCase()
	b = b.toLowerCase()
	ret = {}
	for i in [0...len(b)]
		for j in [0...len(b)]
			if (j - i) < min_length-1 then continue
			c = b[i..j]
			if len(indices a,c) > 0
				ret[c] = 1
	return Object.keys(ret).sort((x,y) -> len(y) - len(x))[0...limit]

a = "The quick brown dog jumped over the lazy red fox."
b = "Jumper pumped the quick fake, and jumped toward the basket."
$.log commonSubstrings(a, b, 3, 10)

ld = $.memoize (s, t) ->
	switch true
		when not s then len(t)
		when not t then len(s)
		when s is t then 0
		when s[0] is t[0] then ld(s[1..],t[1..])
		else 1 + Math.min(
			ld(s, t[1..]),
			ld(s[1..], t),
			ld(s[1..], t[1..])
		)

$.log ld "kitten", "sitting"

(($) ->

	$.plugin () ->

		Dialog = (selector, opts) ->
			opts = $.extend({
				autoOpen: false
				draggable: true
			}, opts)
			dialog = $(selector)
				.addClass("dialog")
			if opts.draggable
				dialog.draggable()
			if opts.autoOpen
				dialog.show().center()
			dialog
				.find("button.close, .close-button")
				.bind "click touchstart", () ->
					dialog.hide()
					false
			dialog
		
		Draggable = (selector, opts) ->
			opts = $.extend({
				handleCSS: {}
			}, opts)

			opts.handleCSS = $.extend({
				position: "absolute"
				top: "0px"
				left: "0px"
				width: "100%"
				height: "6px"
			}, opts.handleCSS)

			dragObject = $(selector)
			moving = false
			oX = oY = 0
			handle = $
				.synth("div.handle")
				.defaultCss({
					height: "6px"
					"border-radius": "3px"
					cursor: "move"
				})
				.css(opts.handleCSS)
				.bind 'mousedown, touchstart', (evt) ->
					moving = true
					oX or= evt.pageX
					oY or= evt.pageY
					false
			$(document)
			.bind 'mousemove, touchmove', (evt) ->
				if moving
					dX = (evt.pageX - oX)
					dY = (evt.pageY - oY)
					dragObject.transform({
						translate: [ dX, dY ]
					}, 0)
					.trigger 'drag', {
						dragObject: dragObject
					}
					false
			.bind 'mouseup, touchend', (evt) ->
				if moving
					moving = false
					pos = handle.position()[0]
					$(document.elementFromPoint(pos.left, pos.top - 1))
					.trigger 'drop',
						dropObject: dragObject

			dragObject
				.addClass("draggable")
				.css {
					position: "relative"
					"padding-top": dragObject.css("padding-top")
						.map(Number.AtLeast(parseInt(opts.handleCSS.height,10)))
						.px().first()
				}
				.append(handle)

		ProgressBar = (selector, opts) ->
			opts = $.extend({
				change: null
				barColor: "rgba(0,128,0,0.5)"
				textColor: "white"
				reset: false
			}, opts)

			node = $(selector)
				.addClass('progress-bar')
				_bg = node.css("background").first()
				_color = node.css("color").first()

			node.zap 'updateProgress', (pct) ->
				while pct < 1.0
					pct *= 100.0
					node.css
						background: _bg
						color: _color
				else
					node.css
						background:"""
						"""
						color: opts.textColor
				if $.is "function", opts.change
					opts.change pct

		Accordion = (selector, opts) ->
			opts = $.extend({
				exclusive: false
				sticky: false
			}, opts)
			node = $(selector).addClass("accordion")
			selectedChild = null

			initRow = (n) ->
				t = $(n).children().first().filter("*")
				if( t.len() isnt 2 )
				title = t.eq(0).addClass("title")
				body = t.eq(1).addClass("body").hide()
				bodyVisible = false
				title.click () ->
					if opts.exclusive
						node.find(".body").hide()
					if bodyVisible
						if not opts.sticky
							body.hide().removeClass("visible")
							title.removeClass("selected").trigger("deselect")
							bodyVisible = false
						else
							body.show().addClass("visible")
							title.addClass("selected").trigger("select")
							bodyVisible = true
					else
						body.show().addClass("visible")
						title.addClass("selected").trigger("select")
						bodyVisible = true

			node.bind "DOMNodeInserted", (evt) ->
				directChildren = node.children().first().filter("*")
				parentsOfInserted = $(evt.target).parents().first()
				initRow(parentsOfInserted.intersect(directChildren))

			node.children().first()
				.map(initRow)

			return node

		ViewStack = (selector, opts) ->
			items = $(selector)
				.css {
					position: "relative"
					top: "0px"
					left: "0px"
				}
				.hide()
				.map($)
			active = 0
			items[active].show()
			items.next = () ->
				items[active].hide()
				active = (++active % items.length)
				items[active].show()
			items.activate = (k) ->
				items[active].hide()
				active = k
				items[k].show()
			for j in [0...items.len()]
				items[j]
				.zap("_viewIndex", j)
				.zap "activate", ->
					items.activate(this._viewIndex)
			items

		Tabs = (selector, views) ->
			tabs = $(selector)
			views = $(views).viewStack()
			nn = tabs.len()
			tabs._tabIndex = i for i in [0..nn]
			$(tabs[0]).addClass("active")
			tabs.click () ->
				tabs.removeClass("active")
				views.activate(this._tabIndex)
				$(this).addClass("active")

		return {
			$:
				UI:
					Draggable: Draggable
					ProgressBar: ProgressBar
					ViewStack: ViewStack
					Tabs: Tabs
					Accordion: Accordion

			dialog: (opts) -> Dialog(this, opts)
			progressBar: (opts) -> ProgressBar(this, opts)
			viewStack: (opts) -> ViewStack(this, opts)
			tabs: (views) -> Tabs(this, views)
			accordion: (opts) -> Accordion(this, opts)
			draggable: (opts) -> Draggable(this, opts)
		}

)(Bling)


	units = ["px","pt","pc","em","%","in","cm","mm","ex",""]
	UNIT_RE = /(\d+\.*\d*)(px|pt|pc|em|%|in|cm|mm|ex)/

	parseUnits = (s) -> UNIT_RE.exec(s)[2] if UNIT_RE.test(s) else ""

	conv = (a,b) -> conv[a][b]()
	for a in units
		for b in units
			(conv[a] or= {})[b] = trick +(a is b or a is "" or b is "")
	conv.in.pt = -> 72
	conv.in.px = -> 96
	conv.in.cm = -> 2.54
	conv.pc.pt = -> 12
	conv.cm.mm = -> 10
	conv.em.px = ->
		x = $("<span style='font-size:1em;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.px = ->
		x = $("<span style='font-size:1ex;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.em = -> 2
	fillIn = ->
		for a in units
			for b in units
				if not conv(a,b) and conv(b,a)
					conv[a][b] = trick 1.0/conv(b,a)
				for c in units
					if not conv(a,c) and conv(a,b) and conv(b,c)
						conv[a][c] = trick conv(a,b) * conv(b,c)
	fillIn(); fillIn()
	
	convertUnits = (number, unit) -> parseFloat(number) * conv[parseUnits(number)][unit]() + unit

	$.assert(convertUnits("300px", "cm") == "10cm")

	convertAll = (to, a) ->
		for i in [0...a.length]
			a[i] = convertTo(to, a[i])

	Object.Type.register "units",
		match: (x) -> UNIT_RE.test(x)

	unit_scalar = (f) ->
		(a...) ->
			convertAll( unit = parseUnits(@[0]), @)
			(f.apply @, a) + unit
	unit_vector = (f) ->
		(a...) ->
			u = @map parseUnits
			f.apply(@floats(), a).map ->

	{
		min: unit_scalar -> @reduce (a) -> Math.min parseFloat(@), a
		max: unit_scalar -> @reduce (a) -> Math.max parseFloat(@), a
		sum: unit_scalar -> @reduce (a) -> parseFloat(@) + a
		mean: unit_scalar -> parseFloat(@sum()) / @length
		magnitude: unit_scalar -> Math.sqrt @floats().squares().sum()
		squares: -> @map -> (x=parseFloat(@)) * x
		scale: (n) -> @map -> n * parseFloat(@)
		add: (d) -> @map -> d + @
		normalize: -> @scale(1/@magnitude())
	}


	EOF = -> "EOF"

	BackgroundQueue = (opts) ->
		opts = extend {
			item: -> EOF
			action: Function.Identity
			latency: 10
		}, opts

		return extend new $.EventEmitter(), {
			run: ->
				r = () =>
					if (item = opts.action(opts.item())) isnt EOF
						@emit("data", item)
						setTimeout r, opts.latency
				setTimeout r, opts.latency
		}

	data = x for x in [0...1000]
	i = 0
	BackgroundQueue
		item: ->
			return data[i++] if i < data.length else EOF
		action: (item) -> (item*item) - 1
		latency: 10
	.on "data", (x) -> console.log "data:", x
	.on "error", (x) -> console.log "error:", x
	
(($) ->
	$.plugin ->
		$:
			histogram: (data, bucket_width=1, output_width=80) ->
				buckets = $()
				len = 0
				for x in data
					i = Math.floor( x / bucket_width )
					buckets[i] ?= 0
					buckets[i] += 1
					len = Math.max(len, i+1)
				buckets.length = len

				max = buckets.max()
				buckets = buckets.map((x) -> x or 0)
					.scale(1/max)
					.scale(output_width)
				sum = buckets.sum()

				ret = ""
				for n in [0...len] by 1
					end = (n+1) * bucket_width
					pct = (buckets[n]*100/sum).toFixed(0)
				ret
)(Bling)
(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'XMLHttpRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					xhr = new XMLHttpRequest()
					if $.is "function", opts
						opts = success: $.bound(xhr, opts)
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts
					opts.state = $.bound(xhr, opts.state)
					opts.success = $.bound(xhr, opts.success)
					opts.error = $.bound(xhr, opts.error)
					if opts.data and opts.method is "GET"
						url += "?" + formencode(opts.data)
					else if opts.data and opts.method is "POST"
						opts.data = formencode(opts.data)
					xhr.open(opts.method, url, opts.async)
					xhr = $.extend xhr,
						asBlob: opts.asBlob
						timeout: opts.timeout
						followRedirects: opts.followRedirects
						withCredentials: opts.withCredentials
						onreadystatechange: ->
							opts.state?()
							if xhr.readyState is 4
								if xhr.status is 200
									opts.success xhr.responseText
								else
									opts.error xhr.status, xhr.statusText
					xhr.send opts.data
					return $(xhr)

				post: (url, opts = {}) ->
					if $.is("function",opts)
						opts = success: opts
					opts.method = "POST"
					$.http(url, opts)

				get: (url, opts = {}) ->
					if( $.is("function",opts) )
						opts = success: opts
					opts.method = "GET"
					$.http(url, opts)
		}
)(Bling)
(($) ->

	$.plugin
		depends: "dom"
		provides: "lazy"
	, ->
		lazy_load = (elementName, props) ->
			$("head").append $.extend document.createElement(elementName), props
		$:
			script: (src) ->
				lazy_load "script", { src: src }
			style: (src) ->
				lazy_load "link", { href: src, rel: "stylesheet" }

)(Bling)
(($) ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""

		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615

		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)

			index = (index + 1) % 624
			(y + a) / b

		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()

		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
	)()

	$.plugin
		provides: "random"
	, ->
		$:
			random: random

)(Bling)
(($) ->
	$.plugin
		provides: "sendgrid"
		depends: "config"
	, ->
		try
			nodemailer = require 'nodemailer'
		catch err
			`return`
		transport = nodemailer.createTransport 'SMTP',
			service: 'SendGrid'
			auth:
				user: $.config.get 'SENDGRID_USERNAME'

		$:
			sendMail: (mail, callback) ->
				mail.transport ?= transport
				mail.from ?= $.config.get 'EMAILS_FROM'
				mail.bcc ?= $.config.get 'EMAILS_BCC'

				if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
					nodemailer.sendMail mail, callback
				else
)(Bling)
(($) ->
	$.plugin
		provides: "StateMachine"
	, ->
		$: StateMachine: class StateMachine
			constructor: (stateTable) ->
				@debug = false
				@reset()
				@table = stateTable
				Object.defineProperty @, "modeline",
					get: -> @table[@_mode]
				Object.defineProperty @, "mode",
					set: (m) ->
						@_lastMode = @_mode
						@_mode = m
						if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
							ret = @modeline['enter'].call @
							while $.is("function",ret)
								ret = ret.call @
						m
					get: -> @_mode

			reset: ->
				@_mode = null
				@_lastMode = null

			GO: (m) -> -> @mode = m
			@GO: (m) -> -> @mode = m
			
			tick: (c) ->
				row = @modeline
				if not row?
					ret = null
				else if c of row
					ret = row[c]
				else if 'def' of row
					ret = row['def']
				while $.is "function",ret
					ret = ret.call @, c
				ret

			run: (inputs) ->
				@mode = 0
				for c in inputs
					ret = @tick(c)
				if $.is "function",@modeline?.eof
					ret = @modeline.eof.call @
				while $.is "function",ret
					ret = ret.call @
				@reset()
				return @

	$.plugin
		provides: "synth"
		depends: "StateMachine"
	, ->
		class SynthMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: ->
						@tag = @id = @cls = @attr = @val = @text = ""
						@attrs = {}
						@GO 1
				},
					def: (c) -> @tag += c
					eof: @GO 13
				},
					".": @GO(3), "[": @GO(4), " ": @GO(9), "+": @GO(11), ",": @GO(10),
					def: (c) -> @id += c
					eof: @GO 13
				},
					enter: -> @cls += " " if @cls.length > 0
					def: (c) -> @cls += c
					eof: @GO 13
				},
					"=": @GO 5
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @attr += c
					eof: @GO 12
				},
					"]": -> @attrs[@attr] = @val; @GO 1
					def: (c) -> @val += c
					eof: @GO 12
				},
					'"': @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					"'": @GO 8
					def: (c) -> @text += c
					eof: @GO 12
				},
					enter: ->
						@emitText()
						@GO 0
				},
					enter: ->
						@emitNode()
						@GO 0
				},
					enter: ->
						@emitNode()
						@parent = null
						@GO 0
				},
					enter: ->
						@emitNode()
						@parent = @parent?.parentNode
						@GO 0
				},
				},
					enter: ->
						@emitNode() if @tag.length
						@emitText() if @text.length
				}
			]
			constructor: ->
				super(SynthMachine.STATE_TABLE)
				@fragment = @parent = document.createDocumentFragment()
			emitNode: ->
				node = document.createElement(@tag)
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@parent.appendChild node
				@parent = node
			emitText: ->
				@parent.appendChild $.type.lookup("<html>").node(@text)
				@text = ""

		return {
			$:
				synth: (expr) ->
					s = new SynthMachine()
					s.run(expr)
					if s.fragment.childNodes.length == 1
						$(s.fragment.childNodes[0])
					else
						$(s.fragment)
		}

)(Bling)
(($) ->


		current_engine = null
		engines = {}

		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine

		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()

		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop]
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1

	$.template.register_engine 'pythonic', (() ->

		chunk_re = /%[\(\/]/

		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n]
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}

			if not cache?
			n = cache.length

			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""

		return render
	)()

		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()


)(Bling)
(($) ->
		parseOne = (data) ->
			i = data.indexOf ":"
			if i > 0
				len = parseInt data[0...i], 10
				item = data[i+1...i+1+len]
				type = data[i+1+len]
				extra = data[i+len+2...]
				item = switch type
					when "'" then String(item)
					when "!" then (item is "true")
					when "~" then null
					when "]" then parseArray(item)
					when "}" then parseObject(item)
				return [item, extra]
			return undefined
		parseArray = (x) ->
			data = []
			while x.length > 0
				[one, x] = parseOne(x)
				data.push(one)
			data
		parseObject = (x) ->
			data = {}
			while x.length > 0
				[key, x] = parseOne(x)
				[value, x] = parseOne(x)
				data[key] = value
			data
		$:
			TNET:
				stringify: (x) ->
					[data, type] = switch $.type x
						when "string" then [x, "'"]
						when "function" then [String(x), "'"]
						when "boolean" then [String(not not x), "!"]
						when "null" then ["", "~"]
						when "undefined" then ["", "~"]
						when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
						when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
					return (data.length|0) + ":" + data + type
				parse: (x) ->
					parseOne(x)?[0]
)(Bling)
(($) ->

	$.plugin
		provides: "trace"
		depends: "function,type"
	, ->
		$.type.extend
			unknown: { trace: $.identity }
			function:
				trace: (label, f, tracer) ->
					label or= f.name
					r = (a...) ->
						f.apply @, a
					r
		return $: trace: (label, o, tracer) ->
			if not $.is "string", label
				[tracer, o] = [o, label]
			tracer or= $.log
			label or= ""
			$.type.lookup(o).trace(label, o, tracer)

)(Bling)
(($) ->
	$.plugin
		depends: "dom"
	, ->
		COMMASEP = ", "
			"slow": 700
			"medium": 500
			"normal": 300
			"fast": 100
			"instant": 0
			"now": 0
		accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
		testStyle = document.createElement("div").style

		transformProperty = "transform"
		transitionProperty = "transition-property"
		transitionDuration = "transition-duration"
		transitionTiming = "transition-timing-function"

		if "WebkitTransform" of testStyle
			transformProperty = "-webkit-transform"
			transitionProperty = "-webkit-transition-property"
			transitionDuration = "-webkit-transition-duration"
			transitionTiming = "-webkit-transition-timing-function"
		else if "MozTransform" of testStyle
			transformProperty = "-moz-transform"
			transitionProperty = "-moz-transition-property"
			transitionDuration = "-moz-transition-duration"
			transitionTiming = "-moz-transition-timing-function"
		else if "OTransform" of testStyle
			transformProperty = "-o-transform"
			transitionProperty = "-o-transition-property"
			transitionDuration = "-o-transition-duration"
			transitionTiming = "-o-transition-timing-function"

		return {
			$:
				duration: (speed) ->
					d = speeds[speed]
					return d if d?
					return parseFloat speed

			transform: (end_css, speed, easing, callback) ->

				if $.is("function",speed)
					callback = speed
					speed = easing = null
				else if $.is("function",easing)
					callback = easing
					easing = null
				speed ?= "normal"
				easing or= "ease"
				duration = $.duration(speed) + "ms"
				props = []
				trans = ""
				css = {}
				for i of end_css
					if accel_props_re.test(i)
						ii = end_css[i]
						if ii.join
							ii = $(ii).px().join COMMASEP
						else if ii.toString
							ii = ii.toString()
						trans += " " + i + "(" + ii + ")"
					else css[i] = end_css[i]
				(props.push i) for i of css
				if trans
					props.push transformProperty

				css[transitionProperty] = props.join COMMASEP
				css[transitionDuration] = props.map(-> duration).join COMMASEP
				css[transitionTiming] = props.map(-> easing).join COMMASEP

				if trans
					css[transformProperty] = trans
				@css css
				@delay duration, callback

				@each ->
					if @style
						if @style.display is not "none"
							@_display = @syle.display
						@style.display = "none"
				.trigger "hide"
				.delay updateDelay, callback

				@each ->
					if @style
						@style.display = @_display
						delete @_display
				.trigger "show"
				.delay updateDelay, callback

				@weave(@css("display"))
					.fold (display, node) ->
						if display is "none"
							node.style.display = node._display or ""
							delete node._display
							$(node).trigger "show"
						else
							node._display = display
							node.style.display = "none"
							$(node).trigger "hide"
						node
					.delay(updateDelay, callback)

				@.css('opacity','0.0')
					.show ->
						@transform {
							opacity:"1.0",
							translate3d: [0,0,0]
						}, speed, callback
				@transform {
					opacity:"0.0",
					translate3d:[x,y,0.0]
				}, speed, -> @hide(callback)
			fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
			fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
			fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
			fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
		}
)(Bling)
(($) ->
	$.plugin
		provides: "unittest"
		depends: "core,function"
	, ->
		testCount = passCount = failCount = 0
		failed = []
		invokeTest = (group, name, func) ->
			return if not $.is "function", func
			shouldFail = name.toLowerCase().indexOf("fail") isnt -1
			done = $.once (err) ->
				testCount--
				if (!!err isnt shouldFail)
					failCount++
					failed.push name
				else
					_log "pass"
					passCount++
					$.provide name
			f = (done) ->
				try func(done)
				catch err then done(err)
				finally
					if name.toLowerCase().indexOf("async") is -1 then done()
			testCount++
			try f(done)
			catch err then done(err)

		testReport = $.once ->

		$:
			approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
			assertEqual: (a, b, label) ->
				if a isnt b
			assertArrayEqual: (a, b, label) ->
				for i in [0...a.length] by 1
					try
						$.assertEqual(a[i], b[i], label)
					catch err
			testGroup: (name, funcs) ->
				interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
				for k,func of funcs
					invokeTest(name, k, func)
		assertEqual: (args...) ->
					if $.is "function", x then x.call(@,@) else x
				a = args[0]
				for i in [1...args.length]
					$.assertEqual a, args[i]
			return @
)(Bling)
require('./common')

$.testGroup "Object",
	keys: -> $.assertArrayEqual Object.keys({a: 1, b: 2}), ['a','b']

$.testGroup "Type",
	string: -> $.assertEqual $.type(""), "string"
	number:-> $.assertEqual $.type(42), "number"
	undef: -> $.assertEqual $.type(), "undefined"
	null: -> $.assertEqual $.type(null), "null"
	array: -> $.assertEqual $.type([]), "array"
	function: -> $.assertEqual $.type(() -> null), "function"
	bool: -> $.assertEqual $.type(true), "bool"
	regexp: -> $.assertEqual $.type(//), "regexp"
	window: -> $.assertEqual $.type(window), "global"
	is: ->
		$.assert($.is "function", ->)
		$.assert($.is "array", [])
	inherit: ->
		a = { a: 1 }
		b = { b: 2 }
		$.inherit a, b
		$.assertEqual(b.__proto__, a)
		$.assertEqual(b.a, 1)
		$.assert( not b.hasOwnProperty("a") )
	extend: -> $.assertArrayEqual Object.keys($.extend({A:1},{B:2})), ['A','B']
	defineProperty: ->
		a = {}
		$.defineProperty a, "b",
			get: -> 2
		$.assert( "b" of a )
	isType1: ->
		$.assert( $.isType(Array, []) )
	isType2: ->
		$.assert( $.isType('Array', []) )
	isType3: ->
		class Foo
		f = new Foo()
		$.assert( $.isType Foo, f )
	isSimple1: -> $.assert( $.isSimple "" )
	isSimple2: -> $.assert( $.isSimple 42.0 )
	isSimple3: -> $.assert( $.isSimple false )
	isSimple4: -> $.assert( not $.isSimple {} )
	isEmpty1: -> $.assert( $.isEmpty "" )
	isEmpty2: -> $.assert( $.isEmpty null )
	isEmpty3: -> $.assert( $.isEmpty undefined )
	toArray1: ->
		a = $([1,2,3])
		b = a.toArray()
		$.assert b.constructor.name is "Array", "constructor name is Array"
		$.assert b[1] is 2, "still has data"
		$.assert b.length is 3, "length is preserved"
		$.assert not b.zap, "has shed bling"
	as1: ->
		$.log $.as "number", "1234"

$.testGroup "Function",
	identity1: -> $.assertEqual $.type($.identity), "function"
	identity2: -> $.assertEqual( $.identity(a = {}), a)
	bound: ->
		f = -> @value
		a = { value: 'a' }
		b = { value: 'b' }
		g = $.bound(a, f)
		h = $.bound(b, f)
		$.assertEqual(g(), 'a')
		$.assertEqual(h(), 'b')
	trace: ->
		f = -> 42
		g = []
		h = $.trace "label", f, (a...) ->
			g.push a.join ''
		$.assertArrayEqual(g, [ "global.label('one','two')" ])

$.testGroup "String",
	Px1: -> $.assertEqual($.px(100), "100px")
	Px2: -> $.assertEqual($.px(-100.0), "-100px")
	Px3: -> $.assertEqual $.px("100.0px"), "100px"
	PadLeft1: -> $.assertEqual($.padLeft("foo", 5), "  foo")
	PadLeft2: -> $.assertEqual($.padLeft("foo", 3), "foo")
	PadLeft3: -> $.assertEqual($.padLeft("foo", 2), "foo")
	PadLeft4: -> $.assertEqual($.padLeft("foo", 5, "X"), "XXfoo")
	PadRight1: -> $.assertEqual($.padRight("foo", 5), "foo  ")
	PadRight2: -> $.assertEqual($.padRight("foo", 3), "foo")
	PadRight3: -> $.assertEqual($.padRight("foo", 2), "foo")
	PadRight4: -> $.assertEqual($.padRight("foo", 5, "X"), "fooXX")
	Splice1: -> $.assertEqual($.stringSplice("foobar",3,3,"baz"), "foobazbar")
	Splice2: -> $.assertEqual($.stringSplice("foobar",1,5,"baz"), "fbazr")
	Splice3: -> $.assertEqual($.stringSplice("foobar",0,6,"baz"), "baz")
	Splice4: -> $.assertEqual($.stringSplice("foobar",0,0,"baz"), "bazfoobar")
	Checksum2: -> $.assertEqual($.checksum("foobarbaz"), 310051767)
	ToString: -> $.assertEqual $([2,3,4]).toString(), "$([2, 3, 4])"
	ToString2: -> $.assertEqual $.toString(-> $.log), "function () { ... }"

$.testGroup "Plugins",
	new_plugin: ->
		$.plugin ->
			$:
				testGlobal: -> 9
			testOp: -> 42
		$.assertEqual $.testGlobal?(), 9
		$.assertEqual $().testOp?(), 42
		$.assertEqual $.testOp?(), 42

$.testGroup "Symbol",
	exists: -> $.assert( Bling?, "bling should exist")
	current: ->
		Bling.assertEqual( Bling.symbol, "$" )
		Bling.assertEqual( $, Bling )
	set: ->
		Bling.symbol = "_"
		Bling.assertEqual( _, Bling )
	preserve: ->
		Bling.global.$ = "before"
		Bling.symbol = "$"
		Bling.assertEqual(Bling.global.$, Bling)
		Bling.symbol = "_"
		Bling.assertEqual(Bling.global.$, "before")
	reset: ->
		Bling.symbol = "$"
		Bling.assertEqual($, Bling)
	noConflict: ->
		Bling.global.noConflictTest = "magic"
		Bling.symbol = "noConflictTest"
		Bling.assert Bling.global.noConflictTest is Bling, 1
		foo = Bling.noConflict()
		Bling.assert Bling.symbol = "Bling", 2
		Bling.assert Bling.global[Bling.symbol] is Bling, 3
		Bling.assert foo is Bling, 4
		Bling.assert Bling.global.noConflictTest is "magic", 5
		Bling.symbol = "$"

$.testGroup "Math",
	sum0: -> $.assertEqual($([]).sum(), 0)
	sum1: -> $.assertEqual($([1,2,3,4,5]).sum(), 15)
	sum2: -> $.assertEqual($([1,2,NaN,3]).sum(), 6)
	range1: -> $.assertEqual($.range(1,6).toRepr(), '$([1, 2, 3, 4, 5])')
	range2: -> $.assertEqual($.range(5).toRepr(), '$([0, 1, 2, 3, 4])')
	zeros1: -> $.assertEqual($.zeros(10).sum(), 0)
	zeros2: -> $.assertEqual($.zeros(5).toRepr(), '$([0, 0, 0, 0, 0])')
	ones: -> $.assertEqual($.ones(10).sum(), 10)
	floats: -> $.assertEqual($(["12.1","29.9"]).floats().sum(), 42)
	ints: -> $.assertEqual($(["12.1","29.9px"]).ints().sum(), 41)
	px: -> $.assertEqual( $(["12.1", "29.9"]).px(2).toRepr(), "$(['14px', '31px'])" )
	min1: -> $.assertEqual( $([12.1, 29.9]).min(), 12.1)
	min2: -> $.assertEqual( $([12.1, NaN, 29.9]).min(), 12.1)
	max1: -> $.assertEqual( $([12.1, 29.9]).max(), 29.9)
	max2: -> $.assertEqual( $([12.1, NaN, 29.9]).max(), 29.9)

$.testGroup "Random",
	random: ->
		$.assert 0.0 < $.random() < 1.0
	real: ->
		$.assert 10.0 < $.random.real(10,100) < 100.0
	integer: ->
		r = $.random.integer(3,9)
		$.assert 3 <= r <= 9, "r is in range"
		$.assert Math.floor(r) is r, "r is an integer"
	string: ->
		s = $.random.string(16)
		$.assert $.type(s) is "string", "s is a string"
		$.assert s.length is 16, "s has the right length"
	seed: ->
		$.random.seed = 42
		r = $.random.string(16)
		$.random.seed = 43
		s = $.random.string(16)
		$.random.seed = 42
		t = $.random.string(16)
		$.assert r is t, "same seed produces same output"
		$.assert r isnt s, "different seed produces different output"

$.testGroup "Hash",
	number: -> $.assert $.hash(42) isnt $.hash(43)
	string: -> $.assert $.hash("foo") isnt $.hash("bar")
	array:  -> $.assert $.hash("poop") isnt $.hash(["poop"])
	array_order: -> $.assert $.hash(["a","b"]) isnt $.hash(["b","a"])
	object: -> $.assert ($.hash a:1) isnt ($.hash a:2)
	object2: -> $.assert $.is "number", $.hash a:1
	bling:  -> $.assert ($.hash $)?
	bling_order: -> $.assert $.hash($(["a","b"])) isnt $.hash($(["b","a"]))

document.body.innerHTML = """
<table>
	<tr><td>1,1</td><td>1,2</td></tr>
	<tr><td>2,1</td><td>2,2</td></tr>
	<tr><td>3,1</td><td class='d'>3,2</td></tr>
	<tr><td>4,1</td><td>4,2</td></tr>
</table>
<div class='c'>C</div>
<p><span>foobar</span></p>
"""
$.testGroup "Core",
	new1: ->
		b = $([1,2,3])
		$.assertEqual(b[0], 1)
		$.assertEqual(b[1], 2)
		$.assertEqual(b[2], 3)
		$.assertEqual(b.constructor.name, "Bling")
	pipe1: ->
		$.pipe('unit-test').append (x) -> x += 2
		$.pipe('unit-test').prepend (x) -> x *= 2
		$.assertEqual( $.pipe('unit-test', 4), 10)
	eq: -> $.assertEqual($([1,2,3]).eq(1)[0], 2)
	each: ->
		sum = 0
		$([1,2,3,4]).each ->
			sum += @
		$.assertEqual(sum, 10)
	map: -> $.assertArrayEqual( $([1,2,3,4]).map( (x) -> x * x ), [1,4,9,16] )
	map2: ->
		d = [1,2,3,4,5]
		$.assertArrayEqual($(d).map(-> @ * 2), [2,4,6,8,10])
		$.assertArrayEqual($(d).map(-> @ * 2), [2,4,6,8,10])
	coalesce1: -> $.assertEqual($.coalesce(null, 42, 22), 42)
	coalesce2: -> $.assertEqual($.coalesce([null, 14, 42]), 14)
	coalesce3: -> $.assertEqual($.coalesce([null, [null, 14], 42]), 14)
	reduce: -> $.assertEqual( $([1,2,3,4]).reduce( (a,x) -> a + x ), 10)
	union: -> $.assertArrayEqual($([1,2,3,4]).union([2,3,4,5]), [1,2,3,4,5])
	intersect: -> $.assertArrayEqual($([1,2,3,4]).intersect([2,3,4,5]), [2,3,4])
	distinct: -> $.assertArrayEqual($([1,2,2,3,4,3]).distinct(), [1,2,3,4])
	contains1: -> $.assert $([1,2,3,4]).contains(3)
	contains2: -> $.assert $(["foo","bar","baz"]).contains("bar")
	count: -> $.assertEqual( $([1,2,2,3,4,3]).count(3), 2 )
	select: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).select('id'), [1,2,3])
	select1: -> $.assertArrayEqual($([
		{a:{b:2}},
		{a:{b:4}},
		{a:{b:6}}
	]).select("a.b"), [2,4,6])
	select2: -> $.assertArrayEqual($([
		{a:[{b:3}]},
		{a:[{b:6}]},
		{a:[{b:9}]}
	]).select("a.0.b"), [3,6,9])
	select3: -> $.assertArrayEqual($([
		{a:{b:{c:4}}},
		{a:{b:{c:5}}},
		{a:{b:{c:6}}}
	]).select("a.b.c"), [4,5,6])
	zap: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).zap('id', 13).select('id'), [13,13,13])
	zapf: -> $.assertArrayEqual($([ {id:1}, {id:2}, {id:3} ]).zap('id', () -> @ * 2).select('id'), [2,4,6])
	zapf2: -> $.assertArrayEqual( $([ {sub:{id:1}}, {sub:{id:2}}, {sub:{id:3}} ]).zap('sub.id', -> @*2).select('sub.id'), [2,4,6])
	take3: -> $.assertArrayEqual($([1,2,3,4]).take(0), [])
	take4: -> $.assertArrayEqual($([1,2,3,4]).take(1), [1])
	take5: -> $.assertArrayEqual($([1,2,3,4]).take(2), [1,2])
	take6: -> $.assertArrayEqual($([1,2,3,4]).take(3), [1,2,3])
	take7: -> $.assertArrayEqual($([1,2,3,4]).take(4), [1,2,3,4])
	take8: -> $.assertArrayEqual($([1,2,3,4]).take(5), [1,2,3,4])
	skip2: -> $.assertArrayEqual($([1,2,3,4]).skip(0), [1,2,3,4])
	skip3: -> $.assertArrayEqual($([1,2,3,4]).skip(1), [2,3,4])
	skip4: -> $.assertArrayEqual($([1,2,3,4]).skip(2), [3,4])
	skip5: -> $.assertArrayEqual($([1,2,3,4]).skip(3), [4])
	skip6: -> $.assertArrayEqual($([1,2,3,4]).skip(4), [])
	skip7: -> $.assertArrayEqual($([1,2,3,4]).skip(5), [])
	first1: -> $.assertEqual($([1,2,3,4]).first(), 1)
	first2: -> $.assertArrayEqual($([1,2,3,4]).first(5), [1,2,3,4])
	first3: -> $.assertArrayEqual($([1,2,3,4]).first(2), [1,2])
	first4: -> $.assertArrayEqual($([1,2,3,4]).first(0), [])
	last1: -> $.assertEqual($([1,2,3,4]).last(), 4)
	last2: -> $.assertArrayEqual($([1,2,3,4]).last(5), [1,2,3,4])
	last3: -> $.assertArrayEqual($([1,2,3,4]).last(2), [3,4])
	last4: -> $.assertArrayEqual($([1,2,3,4]).last(0), [])
	slice1: -> $.assertArrayEqual($([1,2,3,4,5]).slice(0,5), [1,2,3,4,5])
	slice2: -> $.assertArrayEqual($([1,2,3,4,5]).slice(1,5), [2,3,4,5])
	slice3: -> $.assertArrayEqual($([1,2,3,4,5]).slice(2,5), [3,4,5])
	slice4: -> $.assertArrayEqual($([1,2,3,4,5]).slice(3,5), [4,5])
	slice5: -> $.assertArrayEqual($([1,2,3,4,5]).slice(4,5), [5])
	slice6: -> $.assertArrayEqual($([1,2,3,4,5]).slice(1,-2), [2,3])
	slice7: -> $.assertArrayEqual($([1,2,3,4,5]).slice(-1,-3), [5,4])
	slice8: -> $.assertArrayEqual($([1,2,3,4,5]).slice(-1,-4), [5,4,3])
	push: -> $.assertArrayEqual($([1,2,3]).push(4), [1,2,3,4])
	filter1: -> $.assertArrayEqual($([1,2,3,4,5]).filter((x) -> x % 2), [1,3,5])
	filter2: -> $.assertArrayEqual($(["foo","bar","baz"]).filter(/^ba/), ["bar","baz"])
	filter3: -> $.assertArrayEqual($("*").filter("td").length, 8)
	filter4: -> $.assertEqual($("*").filter("td").filter(".d").length, 1)
	filter5: -> $.assertEqual($("*").filter("td").filter(".none").length, 0)
	filter6: -> $.assertArrayEqual($(["one","two","three"]).filter(-> String(@) isnt "three"), ["one", "two"])
	matches: -> $.assertArrayEqual($("td").matches(".d"), [false,false,false,false,false,true,false,false])
	querySelectorAll: -> $.assertArrayEqual($("tr").querySelectorAll("td.d")[0].className, "d")
	weave1: -> $.assertArrayEqual($([1,1,1]).weave([2,2,2]), [2,1,2,1,2,1])
	weave2: -> $.assertArrayEqual($([1,1,1]).weave($([2,2,2])), [2,1,2,1,2,1])
	fold: -> $.assertArrayEqual($([1,1,1]).weave([2,2,2]).fold( (a,b) -> a+b ), [3,3,3])
	flatten: -> $.assertArrayEqual($([[1,2],[3,4]]).flatten(), [1,2,3,4])
	call: -> $.assertArrayEqual($([((x) -> x*2), ((x) -> x*x)]).call(4), [8, 16])
	apply: -> $.assertArrayEqual($([((x) -> @+x), ((x) -> @*x)]).apply(4,[2]), [6, 8])
	corrected_length: ->
		$.assertEqual(Array(10).length,10)
		$.assertEqual(Bling(10).length, 0)

$.testGroup "DOM",
	parse: ->
		d = $.HTML.parse "<div><a></a><b></b><c></c></div>"
		$.assertEqual $.type(d), "node"
		$.assertEqual d.nodeName, "DIV"
	stringify: -> $.assertEqual $.HTML.stringify($.HTML.parse(h = "<div><a/><b/><c/></div>")), h
	select_childNodes: -> $.assertEqual( $("<div><a></a><b></b><c></c></div>").select("childNodes").flatten().map($.type).toRepr(), "$(['node', 'node', 'node'])" )
	child: -> i = 0; d = $("<div><a></a><b></b><c></c></div>"); $.assertEqual( d.select('childNodes').flatten().map( () -> d.child(i++) ).toRepr(), "$([$([<a/>]), $([<b/>]), $([<c/>])])")
	child2: -> $.assertEqual($("tr").child(0).select('nodeName').toRepr(), "$(['TD', 'TD', 'TD', 'TD'])")
	textData: ->
		d = $("<div>&nbsp;</div>")
		$.assertEqual d.toRepr(), "$([<div>&nbsp;</div>])"
		t = d.child 0
		$.assertEqual t.toRepr(), "$([&nbsp;])"
		t.zap 'data', '<p>'
		$.assertEqual d.select('innerHTML').first(), '&lt;p&gt;'
	escape: -> $.assertEqual $.HTML.escape("<p>"), "&lt;p&gt;"
	dashName1: -> $.assertEqual $.dashize("fooBar"), "foo-bar"
	dashName2: -> $.assertEqual $.dashize("FooBar"), "-foo-bar"
	html: -> $.assertEqual $("tr").html().first(), "<td>1,1</td><td>1,2</td>"
	append: ->
		try
			$.assertEqual($("tr td.d").append("<span>Hi</span>").html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	appendTo1:-> $.assertEqual($("<span>Hi</span>").toRepr(), "$([<span>Hi</span>])")
	appendTo2:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").toRepr(), "$([<span>Hi</span>])")
		finally
			$("tr td.d span").remove()
	appendTo3:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').toRepr(), '$([<td class="d">3,2<span>Hi</span></td>])')
		finally
			$("tr td.d span").remove()
	appendTo4:->
		try
			$.assertEqual($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	prepend: ->
		try
			$.assertEqual($("tr td.d").prepend("<span>Hi</span>").html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	prependTo: ->
		try
			$.assertEqual($("<span>Hi</span>").prependTo("tr td.d").select('parentNode').html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	before: -> $.assertEqual($("<a><b></b></a>").find("b").before("<c></c>").select('parentNode').toRepr(), "$([<a><c/><b/></a>])")
	after1: -> $.assertEqual($("<a><b></b></a>").find("b").after("<c></c>").select('parentNode').toRepr(), "$([<a><b/><c/></a>])")
	after2: -> $.assertEqual($("<b></b>").after("<c></c>").select('parentNode').toRepr(), "$([<b/><c/>])")
	wrap: -> $.assertEqual($("<b></b>").wrap("<a></a>").select('parentNode').toRepr(), "$([<a><b/></a>])")
	unwrap: -> $.assertEqual($("<a><b/></a>").find("b").unwrap().first().parentNode, null)
	replace: -> $.assertEqual($("<a><b/><c/><b/></a>").find("b").replace("<p/>").eq(0).select('parentNode').toRepr(), "$([<a><p/><c/><p/></a>])")
	removeClass: -> $.assertEqual($("<a class='test'></a>").removeClass('test').toRepr(), "$([<a/>])")
	removeClass2: -> $.assertEqual($("<a></a>").removeClass('test').toRepr(), "$([<a/>])")
	addClass: -> $.assertEqual($("<a></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	addClass2: -> $.assertEqual($("<a class='test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	addClass3: -> $.assertEqual($("<a class='test test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	toggleClass: -> $.assertEqual($("<a class='on'></a>").toggleClass("on").toRepr(), "$([<a/>])")
	toggleClass2: -> $.assertEqual($("<a class='off'></a>").toggleClass("on").toRepr(), '$([<a class="off on"/>])')
	toggleClass3: -> $.assertEqual($("<a class=''></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	toggleClass4: -> $.assertEqual($("<a></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	hasClass: -> $.assertEqual($("<a class='foo'></a>").hasClass("foo").first(), true)
	hasClass2: -> $.assertEqual($("<a class='bar'></a>").hasClass("foo").first(), false)
	text1: -> $.assertEqual($("<a>Hello<b>World</b></a>").select('innerText').toRepr(), "$(['HelloWorld'])")
	text3: -> $.assertEqual($("<a>Hello<b>World</b></a>").text().toRepr(), "$(['HelloWorld'])")
	text2: -> $.assertEqual($("<a>Hello<b>World</b></a>").text("Goodbye").toRepr(), "$([<a>Goodbye</a>])")
	value1: -> $.assertEqual($("<input type='text' value='foo'/>").val().toRepr(), "$(['foo'])")
	value2: -> $.assertEqual($("<input />").val().toRepr(), "$([''])")
	value3: -> $.assertEqual($("<input type='checkbox' checked />").val().toRepr(), "$(['on'])")
	parents: -> $.assertEqual($("td.d").parents().first().select('nodeName').toRepr(), "$(['TR', 'TABLE', 'BODY', 'HTML'])")
	remove: ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
		b = a.find(".x")
			.assertEqual(2, -> @length)
			.assertEqual("$(['B', 'C'])", -> @select('nodeName').toRepr())
			.remove()
			.assertEqual("$([null, null])", -> @select('parentNode').toRepr() )
		$.assertEqual a.toRepr(), '$([<a><d/></a>])'
	find: ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
			.find(".x")
			.assertEqual(2, -> @length)
			.assertEqual("$(['B', 'C'])", -> @select('nodeName').toRepr())
	clone: ->
		c = $("div.c").clone()[0]
		d = $("div.c")[0]
		c.a = "magic"
		$.assertEqual( typeof d.a, "undefined")
		$.assertEqual( typeof c.a, "string")
	toFragment: ->
		$.assertEqual($("td").clone().toFragment().childNodes.length, 8)

$.testGroup "EventEmitter",
	basic: ->
		v = null
		$().on("change", (data) -> v = data)
			.emit("change", "foo")
		$.assertEqual v, "foo"

$.testGroup "Date",
	stamp: ->
		$.assert $.date.stamp(new Date(1000000), "ms") is 1000000
	stamp_sec: ->
		$.assert $.date.stamp(new Date(1000000), "s") is 1000
	unstamp: ->
		d1 = new Date(1000000)
		d2 = $.date.unstamp $.date.stamp d1
		$.assert d1.toString() is d2.toString()
	convert: ->
		$.assert $.date.convert(1000000, "ms", "s") is 1000
	midnight: ->
		d2 = $.date.unstamp $.date.midnight new Date 1000000000
		$.assert d2.toString().indexOf("19:00:00 GMT-0500") > -1
	format: ->
		d1 = new Date(1000000000)
		d2 = new Date(1000000)
		$.assertEqual $.date.format(d1, "yyyy-mm-dd HH:MM:SS"), "1970-01-12 13:46:40"
		$.assertEqual $.date.format(d2, "yyyy-mm-dd HH:MM:SS"), "1970-01-01 00:16:40"
	parse: ->
		$.assert $.date.parse("1970-01-12 13:46:40", "yyyy-mm-dd HH:MM:SS", "ms") is 1000000000
	range: ->
		$.assertEqual $($.date.range(1000, 1000000, 3))
			.unstamp()
			.select("getUTCDate").call()
	chain_format: ->
		$.assertEqual $($.date.range 1000, 1000000, 3)
			.dateFormat("dd")
			.ints().sum(), 35
	chain_midnight: ->
		$.assertEqual $($.date.range 1000, 1000000, 3)
			.midnight()
			.dateFormat("HHMMSS")
			.ints().sum(), 0

$.testGroup "TNET",
	basic: ->
		obj = $.TNET.parse $.TNET.stringify a:1,b:[2,3]
		$.assert obj.a is 1, "1"
		$.assert obj.b[0] is 2, "2"
		$.assert obj.b[1] is 3, "3"
	basic2: ->
		a = $()

$.testGroup "StateMachine",
	hello: ->
		class TestMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: ->
						@output = "<"
						@GO(1)
				}
					def: (c) -> @output += c.toUpperCase()
					eof: @GO(2)
				}
					enter: -> @output += ">"
				}
			]
			constructor: ->
				super(TestMachine.STATE_TABLE)
				@output = ""
		m = new TestMachine()
		$.assertEqual(m.run("hello").output, "<HELLO>")
		$.assertEqual(m.run("hi").output, "<HI>")

$.testGroup "Synth",
	basic_node: -> $.assertEqual $.synth("style").toString(), "$([<style/>])"
	class_node: -> $.assertEqual $.synth('style.specClass').toString(), '$([<style class="specClass"/>])'
	attr_node: -> $.assertEqual $.synth('style[foo=bar]').toString(), '$([<style foo="bar"/>])'
	text: -> $.assertEqual $.synth("style 'text'").toString(), "$([<style>text</style>])"
	entity1: -> $.assertEqual $.synth("style 'text&amp;stuff'").toString(), "$([<style>text&amp;stuff</style>])"
	entity2: -> $.assertEqual $.synth("style 'text&stuff'").toString(), "$([<style>text&stuff</style>])"

$.testGroup "Delay",
	delayAsync: (callback) ->
		t = $.now
		ferry_errors = (callback, f) ->
			return (a...) ->
				try f(a...)
				catch err
					callback err
		$.delay 1000, ferry_errors callback, ->
			delta = Math.abs(($.now - t) - 1000)
			callback false

require("coffee-script")
dom = require("jldom")
dom.registerGlobals(global)
global.document = dom.createDocument()
global.window = global
require("../dist/bling.js")

$.testGroup "Test Internals",
	true: -> true
	trueFail: (cb) -> cb true
	trueAsync: (cb) -> setTimeout (-> cb false), 100
	trueAsyncFail: (cb) -> setTimeout (-> cb true), 200
	assert: -> $.assert true, "this will not display"
	asyncFail: (callback) ->
		setTimeout (->callback new Error("delayed error")), 500
	assertFail: (cb) ->
		$.assert false, "this will throw an exception, but is expected"
	async1: (callback) ->
		setTimeout (-> callback false), 300
	asyncDepends: (callback) ->
		$.depends 'async1', -> callback false

require "./common"

$.depends "math, random, unittest", ->
	$.testGroup "random",
		coin: ->
			$.assert $.approx $($.random.coin() for _ in [0...1000]).mean(), .5, .05
		ints: ->
			$.assert $.approx $($.random.int(0,10) for _ in [0...20000]).mean(), 5, .7
		gauss: ->
			$.assert $.approx $($.random.gaussian() for _ in [0...1000]).mean(), .5

coffeekup = require './src/coffeekup'
jade = require 'jade'
ejs = require 'ejs'
eco = require 'eco'
haml = require 'haml'
log = console.log

data = 
  title: 'test'
  inspired: no
  users: [
    {email: 'house@gmail.com', name: 'house'}
    {email: 'cuddy@gmail.com', name: 'cuddy'}
    {email: 'wilson@gmail.com', name: 'wilson'}
  ]

coffeekup_template = ->
  doctype 5
  html lang: 'en', ->
    head ->
      meta charset: 'utf-8'
      title @title
      style '''
        body {font-family: "sans-serif"}
        section, header {display: block}
      '''
    body ->
      section ->
        header ->
          h1 @title
        if @inspired
          p 'Create a witty example'
        else
          p 'Go meta'
        ul ->
          for user in @users
            li user.name

coffeekup_string_template = """
  doctype 5
  html lang: 'en', ->
    head ->
      meta charset: 'utf-8'
      title @title
      style '''
        body {font-family: "sans-serif"}
        section, header {display: block}
      '''
    body ->
      section ->
        header ->
          h1 @title
        if @inspired
          p 'Create a witty example'
        else
          p 'Go meta'
        ul ->
          for user in @users
            li user.name
"""

coffeekup_compiled_template = coffeekup.compile coffeekup_template

jade_template = '''
  !!! 5
  html(lang="en")
    head
      meta(charset="utf-8")
      title= title
      style
        | body {font-family: "sans-serif"}
        | section, header {display: block}
    body
      section
        header
          h1= title
        - if (inspired)
          p Create a witty example
        - else
          p Go meta
        ul
          - each user in users
            li= user.name
            li
              a(href="mailto:"+user.email)= user.email
'''

jade_compiled_template = jade.compile jade_template

ejs_template = '''
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8">
      <title><%= title %></title>
      <style>
        body {font-family: "sans-serif"}
        section, header {display: block}
      </style>
    </head>
    <body>
      <section>
        <header>
          <h1><%= title %></h1>
        </header>
        <% if (inspired) { %>
          <p>Create a witty example</p>
        <% } else { %>
          <p>Go meta</p>
        <% } %>
        <ul>
          <% for (user in users) { %>
            <li><%= user.name %></li>
            <li><a href="mailto:<%= user.email %>"><%= user.email %></a></li>
          <% } %>
        </ul>
      </section>
    </body>
  </html>
'''

eco_template = '''
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="utf-8">
      <title><%= @title %></title>
      <style>
        body {font-family: "sans-serif"}
        section, header {display: block}
      </style>
    </head>
    <body>
      <section>
        <header>
          <h1><%= @title %></h1>
        </header>
        <% if @inspired: %>
          <p>Create a witty example</p>
        <% else: %>
          <p>Go meta</p>
        <% end %>
        <ul>
          <% for user in @users: %>
            <li><%= user.name %></li>
            <li><a href="mailto:<%= user.email %>"><%= user.email %></a></li>
          <% end %>
        </ul>
      </section>
    </body>
  </html>
'''

haml_template = '''
  !!! 5
  %html{lang: "en"}
    %head
      %meta{charset: "utf-8"}
      %title= title
      :css
        body {font-family: "sans-serif"}
        section, header {display: block}
    %body
      %section
        %header
          %h1= title
        :if inspired
          %p Create a witty example
        :if !inspired
          %p Go meta
        %ul
          :each user in users
            %li= user.name
            %li
'''

haml_template_compiled = haml(haml_template)

benchmark = (title, code) ->
  start = new Date
  for i in [1..5000]
    code()

@run = ->
  benchmark 'CoffeeKup (precompiled)', -> coffeekup_compiled_template data
  benchmark 'Jade (precompiled)', -> jade_compiled_template data
  benchmark 'haml-js (precompiled)', -> haml_template_compiled data
  benchmark 'Eco', -> eco.render eco_template, data

  console.log '\n'

  benchmark 'CoffeeKup (function, cache on)', -> coffeekup.render coffeekup_template, data, cache: on
  benchmark 'CoffeeKup (string, cache on)', -> coffeekup.render coffeekup_string_template, data, cache: on
  benchmark 'Jade (cache on)', -> jade.render jade_template, locals: data, cache: on, filename: 'test'
  benchmark 'ejs (cache on)', -> ejs.render ejs_template, locals: data, cache: on, filename: 'test'

  console.log '\n'

  benchmark 'CoffeeKup (function, cache off)', -> coffeekup.render coffeekup_template, data
  benchmark 'CoffeeKup (string, cache off)', -> coffeekup.render coffeekup_string_template, data, cache: off
  benchmark 'Jade (cache off)', -> jade.render jade_template, locals: data
  benchmark 'haml-js', -> haml.render haml_template, locals: data
  benchmark 'ejs (cache off)', -> ejs.render ejs_template, locals: data
ul ->
  for guy in @stooges
    li guy
$().ready ->
  $('body').append templates.template(stooges: ['moe', 'larry', 'curly'])
ul ->
  for guy in @stooges
    li guy
app = require('express').createServer()

coffeekup = require '../../src/coffeekup'

app.set 'view engine', 'coffee'
app.register '.coffee', coffeekup.adapters.express

app.get '/', (req, res) ->
  res.render 'index'

app.get '/login', (req, res) ->
  res.render 'login', foo: 'bar', locals: {ping: 'pong'}

app.get '/inline', (req, res) ->
  res.send coffeekup.render ->
    h1 'This is an inline template.'

app.listen 3000

console.log "Listening on 3000..."
@title = 'Chunky Bacon!'
@canonical = 'http://chunky.bacon'

h1 @title

p 'This is the home page.'

p "Let's count to 10: "


partial 'partial', [1..10]doctype 5
html ->
  head ->
    meta charset: 'utf-8'

    meta(name: 'description', content: @description) if @description?
    link(rel: 'canonical', href: @canonical) if @canonical?

    link rel: 'icon', href: '/favicon.png'
    link rel: 'stylesheet', href: '/app.css'

    script src: 'http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js'
    script src: '/app.js'

    coffeescript ->
      $(document).ready ->
        alert 'hi!'        

    style '''
      header, nav, section, article, aside, footer {display: block}
      nav li {display: inline}
      nav.sub {float: right}
    '''
  body ->
    header ->
      a href: '/', title: 'Home', -> 'Home'

      nav ->
        ul ->
          for item in ['About', 'Pricing', 'Contact']
            
          li -> a href: '/about', title: 'About', -> 'About'
          li -> a href: '/pricing', title: 'Pricing', -> 'Pricing'
          li -> a href: '/contact', title: 'Contact Us', -> 'Contact Us'

    div id: 'content', ->
      @body

    footer ->
      p -> a href: '/privacy', -> 'Privacy Policy'
@title = 'Log In'

h1 @title


form action: '/', method: 'post', ->
  div class: 'field', ->
    label for: 'username', -> 'Username: '
    input id: 'username', name: 'username'

  div class: 'field', ->
    label for: 'password', -> 'Password: '
    input id: 'password', name: 'password'
p 'Express partial'meryl = require 'meryl'
coffeekup = require '../../src/coffeekup'

meryl.h 'GET /', (req, resp) ->
  people = ['bob', 'alice', 'meryl']
  resp.render 'layout', content: 'index', context: {people: people}

meryl.run
  templateDir: 'templates'
  templateExt: '.coffee'
  templateFunc: coffeekup.adapters.meryl

console.log 'Listening on 3000...'
h1 'Meryl example'
ul ->
  for name in @people
    li name
doctype 5
html ->
  head ->
    title 'Meryl example'
  body ->
    @render @content, @context
require('zappa') ->
  enable 'default layout'
  
  get '/': ->
    @franks = ['miller', 'oz', 'sinatra', 'zappa']
    render 'index'

  view index: ->
    @title = 'Zappa example'
    h1 @title
    ul ->
      for f in @franks
        li f
coffeekup = require './coffeekup'
fs = require 'fs'
path = require 'path'
puts = console.log
{OptionParser} = require 'coffee-script/lib/optparse'

argv = process.argv[2..]
options = null

handle_error = (err) -> console.log err.stack if err

compile = (input_path, output_directory, js, namespace = 'templates') ->
  fs.readFile input_path, 'utf-8', (err, contents) ->
    handle_error err

    name = path.basename input_path, path.extname(input_path)

    if not js
      output = coffeekup.render contents, options
      ext = '.html'
    else
      func = coffeekup.compile contents, options
      output = """
        (function(){ 
        }).call(this);
      """
      ext = '.js'

    write input_path, name, output, output_directory, ext

write = (input_path, name, contents, output_directory, ext) ->
  filename = name + ext
  dir = output_directory or path.dirname input_path
  path.exists dir, (exists) ->
    unless exists then fs.mkdirSync dir, 0777
    
    output_path = path.join dir, filename
    contents = ' ' if contents.length <= 0
    fs.writeFile output_path, contents, (err) ->
      handle_error err
      puts contents if options.print

usage = '''
  Usage:
    coffeekup [options] path/to/template.coffee
'''

switches = [
  ['--js', 'compile template to js function']
  ['-n', '--namespace [name]', 'global object holding the templates (default: "templates")']
  ['-w', '--watch', 'watch templates for changes, and recompile']
  ['-o', '--output [dir]', 'set the directory for compiled html']
  ['-p', '--print', 'print the compiled html to stdout']
  ['-f', '--format', 'apply line breaks and indentation to html output']
  ['-u', '--utils', 'add helper locals (currently only "render")']
  ['-v', '--version', 'display CoffeeKup version']
  ['-h', '--help', 'display this help message']
]

@run = ->
  parser = new OptionParser switches, usage
  options = parser.parse argv
  args = options.arguments
  delete options.arguments

  puts parser.help() if options.help or argv.length is 0
  puts coffeekup.version if options.version
  if options.utils
    options.locals ?= {}
    options.locals.render = (file) ->
      contents = fs.readFileSync file, 'utf-8'
      coffeekup.render contents, options

  if args.length > 0
    file = args[0]

    if options.watch
      fs.watchFile file, {persistent: true, interval: 500}, (curr, prev) ->
        return if curr.size is prev.size and curr.mtime.getTime() is prev.mtime.getTime()
        compile file, options.output, options.js, options.namespace
    
    compile file, options.output, options.js, options.namespace

if window?
  coffeekup = window.CoffeeKup = {}
  coffee = if CoffeeScript? then CoffeeScript else null
else
  coffeekup = exports
  coffee = require 'coffee-script'

coffeekup.version = '0.3.1'

coffeekup.doctypes =
  'default': '<!DOCTYPE html>'
  '5': '<!DOCTYPE html>'
  'xml': '<?xml version="1.0" encoding="utf-8" ?>'
  'transitional': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">'
  'strict': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">'
  'frameset': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">'
  '1.1': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">',
  'basic': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">'
  'mobile': '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">'
  'ce': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "ce-html-1.0-transitional.dtd">'

coffeescript_helpers = """
  var __slice = Array.prototype.slice;
  var __hasProp = Object.prototype.hasOwnProperty;
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };
  var __extends = function(child, parent) {
    for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype;
    return child; };
  var __indexOf = Array.prototype.indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (this[i] === item) return i;
    } return -1; };
""".replace /\n/g, ''

elements =
  regular: 'a abbr address article aside audio b bdi bdo blockquote body button
 canvas caption cite code colgroup datalist dd del details dfn div dl dt em
 fieldset figcaption figure footer form h1 h2 h3 h4 h5 h6 head header hgroup
 html i iframe ins kbd label legend li map mark menu meter nav noscript object
 ol optgroup option output p pre progress q rp rt ruby s samp script section
 select small span strong style sub summary sup table tbody td textarea tfoot
 th thead time title tr u ul video'

  void: 'area base br col command embed hr img input keygen link meta param
 source track wbr'

  obsolete: 'applet acronym bgsound dir frameset noframes isindex listing
 nextid noembed plaintext rb strike xmp big blink center font marquee multicol
 nobr spacer tt'

  obsolete_void: 'basefont frame'

merge_elements = (args...) ->
  result = []
  for a in args
    for element in elements[a].split ' '
      result.push element unless element in result
  result

coffeekup.tags = merge_elements 'regular', 'obsolete', 'void', 'obsolete_void'

coffeekup.self_closing = merge_elements 'void', 'obsolete_void'

skeleton = (data = {}) ->
  data.format ?= off

  data.autoescape ?= off

  __ck =
    buffer: []
      
    esc: (txt) ->
      if data.autoescape then h(txt) else String(txt)

    tabs: 0

    repeat: (string, count) -> Array(count + 1).join string

    indent: -> text @repeat('  ', @tabs) if data.format

    tag: (name, args) ->
      combo = [name]
      combo.push i for i in args
      tag.apply data, combo

    render_idclass: (str) ->
      classes = []
        
      for i in str.split '.'
        else
          classes.push i unless i is ''
            
      
      if classes.length > 0
        text " class=\""
        for c in classes
          text ' ' unless c is classes[0]
          text c
        text '"'

    render_attrs: (obj, prefix = '') ->
      for k, v of obj
        v = k if typeof v is 'boolean' and v
        

        if typeof v is 'object' and v not instanceof Array
          @render_attrs(v, prefix + k + '-')
        else if v

    render_contents: (contents) ->
      switch typeof contents
        when 'string', 'number', 'boolean'
          text @esc(contents)
        when 'function'
          text '\n' if data.format
          @tabs++
          result = contents.call data
          if typeof result is 'string'
            @indent()
            text @esc(result)
            text '\n' if data.format
          @tabs--
          @indent()

    render_tag: (name, idclass, attrs, contents) ->
      @indent()
    
      @render_idclass(idclass) if idclass
      @render_attrs(attrs) if attrs
  
      if name in @self_closing
        text ' />'
        text '\n' if data.format
      else
        text '>'
  
        @render_contents(contents)

        text '\n' if data.format
  
      null

  tag = (name, args...) ->
    for a in args
      switch typeof a
        when 'function'
          contents = a
        when 'object'
          attrs = a
        when 'number', 'boolean'
          contents = a
        when 'string'
          if args.length is 1
            contents = a
          else
            if a is args[0]
              idclass = a
            else
              contents = a

    __ck.render_tag(name, idclass, attrs, contents)

  yield = (f) ->
    temp_buffer = []
    old_buffer = __ck.buffer
    __ck.buffer = temp_buffer
    f()
    __ck.buffer = old_buffer
    temp_buffer.join ''

  h = (txt) ->
    String(txt).replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
    
  doctype = (type = 'default') ->
    text __ck.doctypes[type]
    text '\n' if data.format
    
  text = (txt) ->
    __ck.buffer.push String(txt)
    null

  comment = (cmt) ->
    text '\n' if data.format
  
  coffeescript = (param) ->
    switch typeof param
      when 'function'
      when 'string'
        script type: 'text/coffeescript', -> param
      when 'object'
        param.type = 'text/coffeescript'
        script param
  
  ie = (condition, contents) ->
    __ck.indent()
    
    __ck.render_contents(contents)
    text "<![endif]-->"
    text '\n' if data.format

  null

skeleton = String(skeleton)
  .replace(/function\s*\(.*\)\s*\{/, '')
  .replace(/return null;\s*\}$/, '')

skeleton = coffeescript_helpers + skeleton

coffeekup.compile = (template, options = {}) ->
  if typeof template is 'function' then template = String(template)
  else if typeof template is 'string' and coffee?
    template = coffee.compile template, bare: yes

  hardcoded_locals = ''
  
  if options.hardcode
    for k, v of options.hardcode
      if typeof v is 'function'

  tag_functions = ''
  tags_used = []
  
  for t in coffeekup.tags
    if template.indexOf(t) > -1 or hardcoded_locals.indexOf(t) > -1
      tags_used.push t
      
  for t in tags_used

  code = tag_functions + hardcoded_locals + skeleton


  code += 'with(data.locals){' if options.locals
  code += '}' if options.locals
  code += "return __ck.buffer.join('');"
  
  new Function('data', code)

cache = {}

coffeekup.render = (template, data = {}, options = {}) ->
  data[k] = v for k, v of options
  data.cache ?= off

  if data.cache and cache[template]? then tpl = cache[template]
  else if data.cache then tpl = cache[template] = coffeekup.compile(template, data)
  else tpl = coffeekup.compile(template, data)
  tpl(data)

unless window?
  coffeekup.adapters =
    simple: coffeekup.render
    meryl: coffeekup.render
    
    express:
      TemplateError: class extends Error
        constructor: (@message) ->
          Error.call this, @message
          Error.captureStackTrace this, arguments.callee
        name: 'TemplateError'
        
      compile: (template, data) -> 
        data.hardcode ?= {}
        data.hardcode.partial = ->
          text @partial.apply @, arguments
        
        TemplateError = @TemplateError
        try tpl = coffeekup.compile(template, data)
        
        return ->
          try tpl arguments...
  'Literal text':
    template: "text 'Just text'"
    expected: 'Just text'

  'Default DOCTYPE':
    template: "doctype()"
    expected: '<!DOCTYPE html>'

  'DOCTYPE':
    template: "doctype 'xml'"
    expected: '<?xml version="1.0" encoding="utf-8" ?>'

  'Custom tag':
    template: "tag 'custom'"
    expected: '<custom></custom>'

  'Custom tag with attributes':
    template: "tag 'custom', foo: 'bar', ping: 'pong'"
    expected: '<custom foo="bar" ping="pong"></custom>'

  'Custom tag with attributes and inner content':
    template: "tag 'custom', foo: 'bar', ping: 'pong', -> 'zag'"
    expected: '<custom foo="bar" ping="pong">zag</custom>'

  'Self-closing tags':
    template: "img src: 'icon.png', alt: 'Icon'"
    expected: '<img src="icon.png" alt="Icon" />'

  'Common tag':
    template: "p 'hi'"
    expected: '<p>hi</p>'

  'Attributes':
    template: "a href: '/', title: 'Home'"
    expected: '<a href="/" title="Home"></a>'

  'HereDocs':
    template: '''
      script """
        $(document).ready(function(){
          alert('test');
        });
      """
    '''
    expected: "<script>$(document).ready(function(){\n  alert('test');\n});</script>"

  'CoffeeScript helper (function)':
    template: "coffeescript -> alert 'hi'"
    expected: "<script>var __slice = Array.prototype.slice;var __hasProp = Object.prototype.hasOwnProperty;var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };var __extends = function(child, parent) {  for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; }  function ctor() { this.constructor = child; }  ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype;  return child; };var __indexOf = Array.prototype.indexOf || function(item) {  for (var i = 0, l = this.length; i < l; i++) {    if (this[i] === item) return i;  } return -1; };(function () {\n  return alert('hi');\n}).call(this);</script>"

  'CoffeeScript helper (string)':
    template: "coffeescript \"alert 'hi'\""
    expected: "<script type=\"text/coffeescript\">alert 'hi'</script>"

  'CoffeeScript helper (object)':
    template: "coffeescript src: 'script.coffee'"
    expected: "<script src=\"script.coffee\" type=\"text/coffeescript\"></script>"

  'Context vars':
    template: "h1 @foo"
    expected: '<h1>bar</h1>'
    params: {foo: 'bar'}

  'Local vars, hardcoded':
    template: 'h1 "harcoded: " + obj.foo'
    run: ->
      obj = {foo: 'bar'}
      @compiled = ck.compile(@template, hardcode: {obj})
      @expected = '<h1>harcoded: bar</h1>'
      @result = @compiled()
      @success = @result is @expected
      if @success
        obj.foo = 'baz'
        @result = @compiled()
        @success = @result is @expected

  'Local vars, hard-coded (functions)':
    expected: '<h1>The sum is: 3</h1>'
    params: {hardcode: {sum: (a, b) -> a + b}}

  'Local vars, hard-coded ("helpers")':
    template: "textbox id: 'foo'"
    expected: '<input id="foo" name="foo" type="text" />'
    params:
      hardcode:
        textbox: (attrs) ->
          attrs.name = attrs.id
          attrs.type = 'text'
          tag 'input', attrs

  'Local vars':
    template: 'h1 "dynamic: " + obj.foo'
    run: ->
      obj = {foo: 'bar'}
      @expected = '<h1>dynamic: bar</h1>'
      @result = render(@template, locals: {obj: obj})
      @success = @result is @expected
      if @success
        obj.foo = 'baz'
        @expected = '<h1>dynamic: baz</h1>'
        @result = render(@template, locals: {obj: obj})
        @success = @result is @expected

  'Comments':
    template: "comment 'Comment'"
    expected: '<!--Comment-->'

  'Escaping':
    template: "h1 h(\"<script>alert('\\\"pwned\\\" by c&a &copy;')</script>\")"
    expected: "<h1>&lt;script&gt;alert('&quot;pwned&quot; by c&amp;a &amp;copy;')&lt;/script&gt;</h1>"

  'Autoescaping':
    template: "h1 \"<script>alert('\\\"pwned\\\" by c&a &copy;')</script>\""
    expected: "<h1>&lt;script&gt;alert('&quot;pwned&quot; by c&amp;a &amp;copy;')&lt;/script&gt;</h1>"
    params: {autoescape: yes}

  'ID/class shortcut (combo)':
    expected: '<div id="myid" class="myclass1 myclass2">foo</div>'

  'ID/class shortcut (ID only)':
    expected: '<div id="myid">foo</div>'

  'ID/class shortcut (one class only)':
    template: "div '.myclass', 'foo'"
    expected: '<div class="myclass">foo</div>'

  'ID/class shortcut (multiple classes)':
    template: "div '.myclass.myclass2.myclass3', 'foo'"
    expected: '<div class="myclass myclass2 myclass3">foo</div>'

  'ID/class shortcut (no string contents)':
    expected: '<img id="myid" class="myclass" src="/pic.png" />'
      
  'Attribute values':
    template: "br vrai: yes, faux: no, undef: @foo, nil: null, str: 'str', num: 42, arr: [1, 2, 3], obj: {foo: 'bar'}, func: ->"
    expected: '<br vrai="vrai" str="str" num="42" arr="1,2,3" obj-foo="bar" func="(function () {}).call(this);" />'
    
  'IE conditionals':
    template: """
      html ->
        head ->
          title 'test'
          ie 'gte IE8', ->
            link href: 'ie.css', rel: 'stylesheet'
    """
    expected: '''
      <html>
        <head>
          <title>test</title>
          <!--[if gte IE8]>
            <link href="ie.css" rel="stylesheet" />
          <![endif]-->
        </head>
      </html>
      
    '''
    params: {format: yes}
    
  'yield':
    expected: '<p>This text could use <strong><a href="/">a link</a></strong>.</p>'

ck = require './src/coffeekup'
render = ck.render

@run = ->
  {print} = require 'sys'
  colors = {red: "\033[31m", redder: "\033[91m", green: "\033[32m", normal: "\033[0m"}
  printc = (color, str) -> print colors[color] + str + colors.normal

  [total, passed, failed, errors] = [0, [], [], []]

  for name, test of tests
    total++
    try
      test.original_params = JSON.stringify test.params

      if test.run
        test.run()
      else
        test.result = ck.render(test.template, test.params)
        test.success = test.result is test.expected
        
      if test.success
        passed.push name
      else
        failed.push name
    catch ex
      test.result = ex
      errors.push name

  
  if failed.length > 0
    printc 'red', "FAILED:\n\n"

    for name in failed
      t = tests[name]
      print t.template + "\n"
      print t.original_params + "\n" if t.params
      printc 'green', t.expected + "\n"
      printc 'red', t.result + "\n\n"

  if errors.length > 0
    printc 'redder', "ERRORS:\n\n"

    for name in errors
      t = tests[name]
      print t.template + "\n"
      printc 'green', t.expected + "\n"
      printc 'redder', t.result.stack + "\n\n"request = require("request")
require "bling"

defaultHandler = (callback) ->
	(err, resp, body) ->
		return callback(err, null) if err
		try return callback(null, JSON.parse(body))
		catch err
			return callback(err, null)

exports.init = (baseUrl) ->
	getDecisions: (apikey, sessionCode, ownerCode, agentCode, pointCode, callback) ->
		request(
			method: "GET"
			url: [baseUrl, ownerCode, agentCode, "decision"].join "/"
			qs:
				point: pointCode
			headers:
				"x-mpath-apikey": apikey
				"x-mpath-session": sessionCode
		, defaultHandler callback)
	sendReward: (apikey, sessionCode, ownerCode, agentCode, goalCode, callback) ->
		request(
			method: "POST"
			url: [baseUrl, ownerCode, agentCode, "goal", goalCode].join "/"
			headers:
				"x-mpath-apikey": apikey
				"x-mpath-session": sessionCode
		, defaultHandler callback)
	expireSession: (apikey, ownerCode, sessionCode, callback) ->
		request(
			method: "GET"
			url: [baseUrl, ownerCode, agentCode, "expire"].join "/"
			headers:
				"x-mpath-apikey": apikey
				"x-mpath-session": sessionCode
		, defaultHandler callback)
	createAgent: (apikey, ownerCode, agentCode, agentJson, callback) ->
		request(
			method: "PUT"
			url: [baseUrl, ownerCode, agentCode].join "/"
			headers:
				"x-mpath-apikey": apikey
			json: agentJson
		, defaultHandler callback)
	createApiKey: (rootKey, rootOwner, email, ownerCode, callback) ->
		if not ownerCode
			ownerCode = "owner_" + $.random.string 9
		request(
			method: "PUT"
			url: [baseUrl,ownerCode,"create-key",email].join "/"
			headers:
				"x-mpath-apikey": rootKey
				"x-mpath-owner": rootOwner
		, defaultHandler callback)
global.assert = (c, msg) ->
	if not c
		throw Error msg
global.assertEqual = (a, b, label) ->
	if a != b
global.assertArrayEqual = (a, b, label) ->
	for i in [0...a.length]
		try
			assertEqual(a[i], b[i], label)
		catch err

UI =
		output: (a...) -> console.log.apply console, a
		red: ""
		green: ""
		yellow: ""
		normal: ""
		output: (a...) -> console.log.apply console, a
		red: "[0;31;40m"
		green: "[0;32;40m"
		yellow: "[0;33;40m"
		normal: "[0;37;40m"
		output: (a...) -> document.write a.join(' ')+"<br>"
		red: "<font color='red'>"
		green: "<font color='green'>"
		yellow: "<font color='yellow'>"
		normal: "</font>"

global.ui = switch process?.env.TERM
	when "dumb" then UI.dumb
	when undefined then UI.html
	else UI.cterm

argv = process?.argv
if argv and argv.length > 2
	test_to_run = argv[2]
else
	test_to_run = "*"

total = [0,0,0]
failures = []
global.testGroup = (name, tests) ->
	failed = passed = 0
	for test_name of tests
		if test_to_run in ["*", test_name, name]
			test = tests[test_name]
			total[0] += 1
			try
				if test_to_run isnt "*"
					console.log "Running test:"
					console.log test.toString()
				test()
				passed += 1
				total[1] += 1
			catch err
				failed += 1
				total[2] += 1
				failures.push(test_name)
				if test_to_run isnt "*"
					throw err
global.testReport = () ->

testGroup("Testing Framework"
	pass: () -> true
)
require "./common"
{config} = require("../../common")
baseUrl = config.get "MPATH_URL", "http://localhost:8080"

testGroup "Client",
	init: ->
		driver = require("../index").init baseUrl
		assert typeof driver.createApiKey is "function"
	api: ->
		driver = require("../index").init baseUrl
		assert typeof driver.createApiKey is "function"
		driver.createApiKey "jesse@conductrics.com", null, (err, json) ->
			throw err if err
			assert "key" of json
			assert "owner" of json
			apikey = json.key
			ownerCode = json.owner
			sessionCode = $.random.string(16)
			driver.getDecisions apikey, sessionCode, ownerCode, "agent-1", "point-1", (err, json) ->
				throw err if err
				
		
	
require 'bling'
coffeekup = require 'coffeekup'
rootKey = $.config.get "SIGNUP_MPATH_APIKEY"
rootOwner = $.config.get "SIGNUP_OWNER", "mpath-signup"
mpathUrl = $.config.get "SIGNUP_MPATH_URL", "http://localhost:8080"
signupUrl = $.config.get "SIGNUP_SELF_URL", "http://localhost:3000"
adminUrl = $.config.get "SIGNUP_ADMIN_URL", "http://localhost:3001"
client = require('mpath-client').init mpathUrl
{routeHandler} = require '../decorators'

helpers =
	code: (str) -> div class:'row', ->	div class:'span9', ->
		pre str
	json: (str) -> div class:'row', -> div class:'span7', ->
		pre class:@pretty ? 'prettyprint', -> str
	ready: (str) -> script type:'text/javascript', ->

defaults = ->
	hardcode: helpers
	title: 'mPath'
	jquery: true
	signupUrl: signupUrl
	mpathUrl: mpathUrl
	imageRoot: signupUrl + '/img/'

exports.index = (req, res) ->
	res.render 'index', $.extend defaults(),
		lofty: true

exports.index_submit = routeHandler (req, res) ->
	client.createApiKey rootKey, rootOwner, req.body.email, null, (err, reply) ->
		$.log "client.createApiKey response:", err, reply
		res.endWithError err if err
		res.endWithErorr "Could not sign you up at this time, we apologize for the inconvenience." if not (reply.key? and reply.owner?)
		context =
			apiKey: reply.key
			owner: reply.owner
			password: reply.password
			email:
				to: req.body.email
				subject: "mPath Signup - Your API key"
		sendApiWelcomeEmail context, (err) ->
			throw err if err
			res.render 'thanks', $.extend defaults(),
				title: 'Thanks!'
				jquery: false
				email: req.body.email
				err: err

exports.welcome_dev = (req, res) ->
  res.render 'intro-dev-cheat', $.extend defaults(),
		title: 'API Cheat Sheet'
		apikey: req.query.apikey
		owner: req.params.owner
		agent: req.params.agent
		baseurl: signupUrl
		bootstrap: true
		prettify: true

render = (file, options, callback) ->
	fs = require('fs')
	fs.readFile file, (err, templateContent) ->
		throw err if err
		callback(false, coffeekup.render templateContent.toString(), options)

exports.test_email = (req, res) ->
	context = {
		apiKey: "apikey12345678"
		owner: "owner1234"
		password: "password1234"
		email:
			to: "joe@mama.com"
			subject: "mPath Signup - Your API key"
	}
	renderWelcomeEmail context, (err, context) ->
		res.write context.email.html
		res.end()

renderWelcomeEmailHTML = (context, callback) ->
	render './views/lofty-email.coffee',
		($.extend defaults(), context),
		callback

renderWelcomeEmailText = (context, callback) ->
	callback false, """Welcome to Conductrics!

renderWelcomeEmail = (context, callback) ->
	context = $.extend {
		jquery: false
	}, context
	renderWelcomeEmailHTML context, (err, html) ->
		throw err if err
		context.email.html = html
		renderWelcomeEmailText context, (err, text) ->
			throw err if err
			context.email.text = text
			callback false, context

sendApiWelcomeEmail = (context, callback) ->
	renderWelcomeEmail context, (err, context) ->
		$.sendMail context.email, (err) ->
			throw err if err
			callback false
doctype 5
html ->
	head ->
		title "Thanks for signing up!"
	body ->
		h2 "Thanks for signing up!"
		p "Hi there! We're happy you've decided to check us out."
		p "You can get started here: ", ->
			a href:@welcomeUrl, -> @welcomeUrldiv id:'HeroContainer', ->
  div id:'Hero', ->
    div id:'HeroText', ->
      img src: '/img/conductrics-logo.png', alt: 'Conductrics'
      h1 'Learn From Everything'
      p 'Test and optimize any content, layout or functionality change. Conductrics learns what converts best for which users.'
      h2 'Real-Time Optimization'
      p 'With Conductrics, your site can optimize itself, actively selecting the best option for each user. In real time, automatically.'
      p class:'Button', ->
          strong "Sign Up"
          text " for the Beta"
    div id:'HeroImage', ->
      strong 'Contact:'
      text '&nbsp;'
      a '.Email', href: 'mailto:info@conductrics.com'
      text '&nbsp;'
      a '.Twitter', href: 'http://www.twitter.com/conductrics', target: '_blank'
div id:'MainContainer', ->
  div class:'Benefit', id:'ABTesting', ->
    h3 'Go Beyond A/B Testing'
    p 'Because Conductrics automatically learns and optimizes your content in real-time, you can spend your valuable time focusing on making your site, or app, awesome.'
  div class:'Benefit', id:'Audience', ->
    h3 'Targeting Your Audience'
    p 'There isn\'t one best option for everyone - content can resonate with one group more than another. Conductrics will learn and display the best performing option for each.'
  div class:'Benefit', id:'Systems', ->
    h3 'Integrate With Your Systems'
    p 'The Conductrics two-step REST API brings real-time learning into reach of teams of any size, using any programming language. It fits in now, and can grow with you.'
  div id:'Topics', ->
    p ->
      text 'AB/Split and Multivariate Tests'
      em '&bull;'
      text 'Adaptive Optimization'
      em '&bull;'
      text 'User Targeting'
      em '&bull;'
      text 'Decision Attribution In Complex, Multi-Step Decisions'
  div id:'LowerContent', ->
    h2 'Your Applications Learn and Maximize Their Value Automatically'
    div class:'Vertical', ->
      h3 'Commerce and Content Sites'
      p 'Use proven Data Science to improve user experience across all your digital properties and maximize online Key Performance Indicators (KPIs).'
    div class:'Vertical', ->
      h3 'Digital Marketing Agencies'
      p 'Add value for your clients by building self-learning, customer-targeted digital marketing applications, all with with a few simple API calls.'
    div class:'Vertical', ->
      h3 'Startups and MVPs'
      p 'Use automated lean development methods to learn what features your users are using and dynamically shed the ones that under-perform.'
    div id:'SignUp', ->
      p ->
        strong 'Sign Up'
        text ' for the Conductrics Beta'
      form action:'/', method: 'post', ->
        input class: 'OptionalInput', type: 'text', name: 'email', title: 'Email Address'
        input type: 'submit', name: 'submit', value: 'Sign Up'
  div id:'Footer', ->
    div id:'Copyright', 'Copyright &copy; 2012 Conductrics. All Rights Reserved.'
    div id:'Contact', ->
      strong 'Contact:'
      a href: 'mailto:info@conductrics.com', 'info@conductrics.com'
div class:"navbar navbar-fixed-top", id:"navbar", ->
	div class:"navbar-inner", ->
		div class:"container", -> 
			a class:"brand", "API Cheat Sheet"
			ul class:"nav", ->
				li ->
				li ->
				li ->
				li ->

div class:'container', ->

	section id:'intro', ->
		h1 "Learning API Cheat Sheet"
		p class:"lead", "Our API chooses from a set of options, and learns which option leads to the most success."
		p "There are two basic steps:"
		ol ->
			li ->
				strong "Getting a Decision"
				text ", which makes a selection from a set of options and returns the chosen one."
			li ->
				strong "Sending a Reward"
				text ", so we can learn how often each option leads to success in the real world."
		p "You can wire these two steps into any web or mobile app."
		p ->
			text "The result is that your app \"learns\" what works most often, and favors the \"best\" option most of the time. "
			text "We can cross-reference this learning with \"targeting\" data like geo-location or user segment, because the best option for one type of visitor might not be the best for another."

	section id:'intro', ->
		h1 "About Learning Agents"
		p class:"lead", "Cute little success trackers that love to serve."
		div class:'row', ->
			div class:'span4', ->
				h3 "Agents are Your Friends"
				p "We use the term 'agent' to refer to a learning project. You can create as many agents as you wish." 
				p "The idea is that each agent learns about a different set of options. So, you might have one agent trying out different content options, and another trying out layout options or whether to display some special feature."
			div class:'span4', ->
				h3 "Agents Live to Track Success"
				p "So, each agent has a list of options that it will try out for each person that uses your site or app. It also tracks <strong>goals</strong> (or lack thereof) achieved by each person after an option is tried out."
				p "Each agent continually updates its internal statistics about how often each option has lead to success over time, which means it always knows the 'best' option to show to a new person."
			div class:'span4', ->
				h3 "Created on the Fly"
	section id:"decision", ->
		div class:"page-header", ->
			h2 ->
				text "Getting a Decision"
				small " about which option to present in your app"

		p "This is the key method in our Learning API."
		p "Remember that an agent cares about tracking success for each option in a set of options."
		p "Whenever one of your visitors or users encounters a spot in your site or app where one of those options should appear, you use this method to get a 'decision' from your agent."
		p -> strong "To get a decision from an agent, just GET from its decision URL:"

		p "Usually, your agent will choose the 'best' option, if it has enough data on hand to do so. Otherwise, it will choose one at random and track whether it leads to a goal later on."
		p "In either case, the response from your agent looks like this. The most important part is the 'decision' part, which tells you which selection your agent made:"
		json """
		{
		  "session":"12345",
		  "decision":"b"
		}"""
		p "It's now up to you to actually display that option to the person using your site or app."
		
		div class: 'alert alert-info alert-block', ->
			h4 '.alert-heading', "Ball's In Your Court! "
			"In the example above, you can see that the agent selected option 'b', so you would display the 'b' version of your content or whatever is appropriate. Or, you might be testing out whether to present some new feature, in which case you might use option codes like 'on' or 'off' instead of 'a' and 'b' to keep things easy to remember."

		div class:'alert alert-block', ->
			h4 '.alert-heading', "Providing Your API Key: "
			text "Yep, you have to provide your API key to any of the methods in our Learning API. You can provide it as a URL param called 'apikey' as shown above, or you can pass it in a HTTP Header called 'x-mpath-apikey' if you want to keep it out of the query string."

		h4 "Giving us the options"
		p "The example above seems to imply that the available options are 'a' and 'b'. Where did those come from?"
		p "The options are defined by URL you use when you first get a decision from your agent."

		ul style:'list-style-type:none', ->
			li ->
				text "If you provide nothing, we assume two options called 'a' and 'b'."
			li ->
				text 'If you provide a list of little codes, those become the options we select from for this agent.<br/> '
				text 'So, if the "decision" you want to get back should be "rock" or "paper" or "scissors":'
			li -> 
				text 'If you provide a number, we make up that number of codes numerically, starting at zero. <br/>'
				text 'If you use /4 as shown below, the "decision" you get back will be 0, 1, 2, or 3:'

		div '.alert', ->
			h4 '.alert-heading', "Changing the Options:"
			text "At this time, you can't change the available options once the agent has been created. We'll be providing that flexibility in the near future. For now just use a different agent code to get a different number of options or to use different option codes, or delete the agent and start over."


	section id:"goal", ->
		div class:"page-header", ->
			h2 ->
				text "Sending a Reward"
				small " to indicate that a decision has led to success"

		p "Great. Your agent is making decisions for you and you're showing the appropriate content or functionality to your users."	
		p "The only thing that's left is to let your agent know when a goal is achieved, so your agent can 'credit' the option it selected as having led to success." 	
		p -> strong "To reward your agent, just POST to its goal URL, like so:"
		p "The response from us looks like the following. You generally don't need to do anything with the response (conceptually just \"fire and forget\"):"
		json """
		{
		  "session":"12345",
		  "reward":"1"
		}
		"""

		div class:'alert alert-info alert-block', ->
			h4 '.alert-heading', "Goals For The Win! "
			text "Goals are what empower your agent to learn. If an agent never receives any goals at all, it won't ever be able to update its internal beliefs about what works best for whom. Please make sure you send them! :)"

	section id:"more-stuff", ->
		div class:"page-header", ->
			h2 "More Stuff"

		h3 "Visitor Sessions"
		p "You've probably noticed the 'session' identifier in the example responses above. "
		p "When a goal occurs, your agent needs to know what decision was made before it. That's how it learns. "
		p "In order to connect those dots, we need a session identifier that represents each of your user's 'sessions'. "
		p "We can make the session identifier up for you, or you can pass it to us:"
		ul ->
			li 'To pass us the session ID, send it as a query parameter called "session" or a header called "x-mpath-session". In many cases you can just send whatever session id you already have on hand (or a hash of it). Our response will include the same id back for clarity. '
			li "If you don't pass us a session ID, we'll make one up and return it in our response. We will also attempt to set a cookie, so if the call is coming from a browser, we should get the same cookie back on subsequent calls so should all be good on our side. "

	section id:"administrative", ->
		h3 "Administrative Tasks"

		p "Sometimes you might need to let us know that a session has expired or left your app, which you can do like so:"

		p "To get a JSON representation of your agent:"

		p "To get a list of agent codes:"

		p "You can get some basic data about what your agent learned during March 2012 like this:"


	section id:"multi-facet", ->
		h3 ->
			text "Multi-Faceted Decisions"
			small " for when your learning needs get more complex"
		p ->
			"The simple examples you've seen so far assume that you only want to make one decision (that is, your agent should only make one selection at a time from a single list of options)."
		ul ->
			li ->
				strong "Use multiple agents. "
				text "Simply use a new agent code per set of options that you want to learn over (you'll make a separate HTTP request for each). "
				text "Internally, each agent is basically doing simple A/B testing for you, favoring the 'winner' most of the time. "
				text "We won't learn anything about how the options may or may not affect each other, but it keeps things nice and simple. "
			li ->
				strong "Use multiple decisions. "
				text "You can set up a single agent to make multiple decisions at the same time. "
				text "What this means is that we're basically doing MVT (multivariate) testing for you, tracking the success of <i>combinations of options</i> rather than each option individually."
			li ->
				strong "Use multiple decision points. "
				text "You can set up a single agent to make decisions at different \"points\" in your application. "
				text "For instance, you might have one set of options on a Home page, and another set of options on a Signup page. "
				text "One user may arrive at one page first, another may arrive at the other first, and another may only encounter one or the other. "
				text "The same basic idea applies to multiple screens or moments in a mobile app."


script type:'text/javascript', src:'/js/bootstrap-scrollspy.js'
doctype 5
html ->
	head ->
		link rel:'stylesheet', href:'/stylesheets/style.css'
	if @jquery
		script type:'text/javascript', src:'/js/jquery.js' 
	if @bootstrap
		link rel:'stylesheet', href:'/stylesheets/bootstrap.css'
		link rel:'stylesheet', href:'/stylesheets/bootstrap-responsive.css'
	if @prettify
		link rel:'stylesheet', href:'/js/google-code-prettify/prettify.css'
		script type:'text/javascript', src:'/js/google-code-prettify/prettify.js'
		ready 'prettyPrint();'
	if @lofty
		link rel:'stylesheet', href:'/stylesheets/lofty-core.css', media:'screen'
		link rel:'stylesheet', href:'/stylesheets/lofty-core.css', media:'print'
		script type:'text/javascript', src:'/js/lofty-global.js'
	body 'data-spy':'scroll', ->
		@body
doctype 'transitional'
html ->
  head ->
    meta 'http-equiv': 'Content-Type', content: 'text/html; charset=UTF-8'
    title @email.subject
  body leftmargin: '0', marginwidth: '0', topmargin: '0', marginheight: '0', offset: '0', ->
    center ->
      table id:'backgroundTable', border: '0', cellpadding: '0', cellspacing: '0', height: '100%', width: '100%', ->
        tr ->
          td valign: 'top', align: 'center', ->
            table border: '0', cellpadding: '0', cellspacing: '0', width: '600px', align: 'center', ->
              br()
              comment 'Header'
              tr ->
                td width: '100%', align: 'center', ->
                  table cellpadding: '0', cellspacing: '0', border: '0', ->
                    tr ->
                      td width: '276', valign: 'top', align: 'left', ->
                        br()
                        img src: @imageRoot + 'email-logo.png', alt: 'Condutrics', border: '0'
                        img src: @imageRoot + 'email-headline-thank-you.png', alt: 'Thank You!', border: '0'
                      td width: '243', align: 'right', ->
                        img align: 'right', src: @imageRoot + 'email-logo-icon.png', border: '0'
              comment 'End Header'
              comment 'Content'
              tr ->
                td width: '100%', align: 'center', ->
                  table cellpadding: '0', cellspacing: '0', border: '0', ->
                    tr ->
                        table cellpadding: '0', cellspacing: '0', border: '0', width: '100%', ->
                          tr ->
                            td style: 'padding:30px', align: 'left', ->
                              comment 'Main Content'
                                strong "Hello !"
                                text "Welcome to Conductrics. We've created your account. "
                                text "We're excited to put our automated agents to work on your site or app, giving it the power to learn what works best in real time, automatically."
                                text "Here's some account information you'll want to keep:"
                                strong ->
                                  text @owner
                                strong ->
                                  text @password
                                strong ->
                                  text @apiKey
                                text "You'll need these codes to connect your site or app to our service."

                                text "Visit the Conductrics Console for "
                                strong " Reports, Tools, and help: "
                              p style: 'margin-top: 20px;', ->
                                    strong 'Console '
                                    text 'Login'
                                text "Note: You'll use your \"Master Password\" above when logging in."

                              table cellpadding: '0', cellspacing: '0', border: '0', width: '100%', ->
                                tr ->
                                  td width: '350', ->
                                      strong "What's Next? "
                                      text "If you're a developer, or just want to know what's next, check out our "
                                      text ' which will get you up to speed quickly.'
                                  td align: 'right', ->
                                    img src: @imageRoot + 'email-icon-gears.gif', alt: 'Gears Icon', border: '0'
                              comment 'End Main Content'
              comment 'End Content'
              comment 'Footer'
              tr ->
                td align: 'center', valign: 'top', ->
                  table id:'templateFooter', border: '0', cellpadding: '10', cellspacing: '0', width: '600', ->
                    tr ->
                      td class: 'footerContent', valign: 'top', style: 'padding:10px 41px 10px 39px', ->
                        table border: '0', cellpadding: '10', cellspacing: '0', width: '100%', ->
                          tr ->
                            td width: '320', ->
                                text '&copy; 2012 &nbsp;'
                                img align: 'absmiddle', src: @imageRoot + 'email-footer-logo.png', alt: 'Conductrics', border: '0', style: 'margin-top: -5px;'
                                text '&nbsp;All Rights Reserved'
              comment 'End Content'
div class:"hero-unit span8 offset1", ->
	h2 "Thanks!"
	p "Click the link in that email to get started."
	div class:'alert alert-info', ->
		text "If you don't end up getting the email, you can always "
		a href:"/", ->
			"Start Over"
		text " and try again."
	if @err
		div class:'error', @err
	if @body
		div class:'body', @body

escodegen = require "escodegen"


console.log escodegen.generate
	type: 'FunctionDeclaration'
	id: { name: "hello" }
	params: [
		{ name: 'a' }
		{ name: 'b' }
	]
	body:
		type: 'BlockStatement'
		body: [
			type: 'ReturnStatement'
			argument:
				type: 'BinaryExpression'
				operator: '+'
				left: { type: 'Identifier', name: 'a' }
				right: { type: 'Literal', value: 2 }
		]

dom = require('../dom')

assign_and_output = () ->
	document = dom.createDocument()
	document.body.innerHTML = "<div class='content' id='content'>Hello World.</div>"
	return document.toString()

output = () ->
	node = (name, attrs = {}, children) ->
		attrs = (' '+k+'="'+attrs[k]+'"' for k of attrs).join('')
		if children.join
			children = children.join('')
	html = (children = []) -> node('html', {}, children)
	head = (attrs = {}, children = []) -> node('head', attrs, children)
	body = (attrs = {}, children = []) -> node('body', attrs, children)
	div = (attrs = {}, children = []) -> node('div', attrs, children)
	p = (attrs = {}, children = []) -> node('p', attrs, children)
	span = (attrs = {}, children = []) -> node('span', attrs, children)

	html([head(), body(null, div({id:'content','class':'content'}, "Hello World."))])

measure = (f, n) ->
	start = Date.now()
	for i in [0..n]
		f()
	return (Date.now() - start)

run = (f, n, interval) ->
	sum = 0
	sum_n = 0
	for i in [0...n] by interval
		ms = measure(f, interval)
		rps = interval * 1000 / ms
		sum += rps
		sum_n += 1
	console.log "Avg. requests per sec:", (sum/sum_n)

console.log "Using domjs"
console.log assign_and_output()
run assign_and_output, 1000,200

console.log "Using a raw tree"
console.log output()
run output, 100000, 20000

tag = (name, attrs = {}, children) ->
	attrs = (' '+k+'="'+attrs[k]+'"' for k of attrs).join('')
	if children.join
		children = children.join('')
a = (attrs = {}, children = []) -> tag('a', attrs, children)
area = (attrs = {}, children = []) -> tag('area', attrs, children)
audio = (attrs = {}, children = []) -> tag('audio', attrs, children)
base = (attrs = {}, children = []) -> tag('base', attrs, children)
blockquote = (attrs = {}, children = []) -> tag('blockquote', attrs, children)
body = (attrs = {}, children = []) -> tag('body', attrs, children)
br = (attrs = {}, children = []) -> tag('br', attrs, children)
button = (attrs = {}, children = []) -> tag('button', attrs, children)
canvas = (attrs = {}, children = []) -> tag('canvas', attrs, children)
caption = (attrs = {}, children = []) -> tag('caption', attrs, children)
col = (attrs = {}, children = []) -> tag('col', attrs, children)
colgroup = (attrs = {}, children = []) -> tag('colgroup', attrs, children)
del = (attrs = {}, children = []) -> tag('del', attrs, children)
details = (attrs = {}, children = []) -> tag('details', attrs, children)
div = (attrs = {}, children = []) -> tag('div', attrs, children)
dl = (attrs = {}, children = []) -> tag('dl', attrs, children)
embed = (attrs = {}, children = []) -> tag('embed', attrs, children)
fieldSet = (attrs = {}, children = []) -> tag('fieldSet', attrs, children)
form = (attrs = {}, children = []) -> tag('form', attrs, children)
h1 = (attrs = {}, children = []) -> tag('h1', attrs, children)
h2 = (attrs = {}, children = []) -> tag('h2', attrs, children)
h3 = (attrs = {}, children = []) -> tag('h3', attrs, children)
h4 = (attrs = {}, children = []) -> tag('h4', attrs, children)
h5 = (attrs = {}, children = []) -> tag('h5', attrs, children)
h6 = (attrs = {}, children = []) -> tag('h6', attrs, children)
head = (attrs = {}, children = []) -> tag('head', attrs, children)
hr = (attrs = {}, children = []) -> tag('hr', attrs, children)
html = (attrs = {}, children = []) -> tag('html', attrs, children)
iframe = (attrs = {}, children = []) -> tag('iframe', attrs, children)
image = (attrs = {}, children = []) -> tag('image', attrs, children)
input = (attrs = {}, children = []) -> tag('input', attrs, children)
ins = (attrs = {}, children = []) -> tag('ins', attrs, children)
keygen = (attrs = {}, children = []) -> tag('keygen', attrs, children)
label = (attrs = {}, children = []) -> tag('label', attrs, children)
legend = (attrs = {}, children = []) -> tag('legend', attrs, children)
li = (attrs = {}, children = []) -> tag('li', attrs, children)
link = (attrs = {}, children = []) -> tag('link', attrs, children)
map = (attrs = {}, children = []) -> tag('map', attrs, children)
menu = (attrs = {}, children = []) -> tag('menu', attrs, children)
meta = (attrs = {}, children = []) -> tag('meta', attrs, children)
meter = (attrs = {}, children = []) -> tag('meter', attrs, children)
object = (attrs = {}, children = []) -> tag('object', attrs, children)
ol = (attrs = {}, children = []) -> tag('ol', attrs, children)
optgroup = (attrs = {}, children = []) -> tag('optgroup', attrs, children)
option = (attrs = {}, children = []) -> tag('option', attrs, children)
output = (attrs = {}, children = []) -> tag('output', attrs, children)
p = (attrs = {}, children = []) -> tag('p', attrs, children)
param = (attrs = {}, children = []) -> tag('param', attrs, children)
pre = (attrs = {}, children = []) -> tag('pre', attrs, children)
progress = (attrs = {}, children = []) -> tag('progress', attrs, children)
quote = (attrs = {}, children = []) -> tag('quote', attrs, children)
script = (attrs = {}, children = []) -> tag('script', attrs, children)
select = (attrs = {}, children = []) -> tag('select', attrs, children)
source = (attrs = {}, children = []) -> tag('source', attrs, children)
style = (attrs = {}, children = []) -> tag('style', attrs, children)
table = (attrs = {}, children = []) -> tag('table', attrs, children)
thead = (attrs = {}, children = []) -> tag('thead', attrs, children)
tbody = (attrs = {}, children = []) -> tag('tbody', attrs, children)
tfoot = (attrs = {}, children = []) -> tag('tfoot', attrs, children)
td = (attrs = {}, children = []) -> tag('td', attrs, children)
th = (attrs = {}, children = []) -> tag('th', attrs, children)
tr = (attrs = {}, children = []) -> tag('tr', attrs, children)
textarea = (attrs = {}, children = []) -> tag('textarea', attrs, children)
title = (attrs = {}, children = []) -> tag('title', attrs, children)
ul = (attrs = {}, children = []) -> tag('ul', attrs, children)
video = (attrs = {}, children = []) -> tag('video', attrs, children)
Copyright (c) 2011 Jesse Dailey <jesse.dailey@gmail.com>
License: MIT License - http://www.opensource.org/licenses/mit-license.php
parser = require("./html/parser")
htmlparse = parser.parse
htmlescape = parser.escape
htmlunescape = parser.unescape
matcher = require("./css/nwmatcher")

NotSupported = () ->
	throw Error "NOT_SUPPORTED"

repeat = (s, n) ->
	n = Math.max(0, n)
	switch n
		when 0 then ""
		when 1 then s
		else s + repeat(s, n-1)

extend = (o, p) ->
	o ?= {}
	for k of p
		o[k] = p[k]
	return o

class Event
	@CAPTURING_PHASE = 1
	@AT_TARGET = 2
	@BUBBLING_PHASE = 3
	constructor: () ->
		@type = null
		@target = null
		@currentTarget = null
		@eventPhase = 0
		@bubbles = false
		@cancelable = true
		@timeStamp = 0
	stopPropagation: () ->
	preventDefault: () ->
	initEvent: (type, canBubble, cancelable) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@timeStamp = new Date().getTime()

class MutationEvent extends Event
	@MODIFICATION = 1
	@ADDITION = 2
	@REMOVAL = 3
	constructor: () ->
		@relatedNode = null
		@prevValue = null
		@newValue = null
		@attrName = null
		@attrChange = 0
	initMutationEvent: (type, canBubble, cancelable, relatedNode, prevValue, newValue, attrName, attrChange) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@relatedNode = relatedNode
		@prevValue = prevValue
		@newValue = newValue
		@attrName = attrName
		@attrChange = attrChange

class Node
	@ELEMENT_NODE = 1
	@ATTRIBUTE_NODE = 2
	@TEXT_NODE = 3
	@CDATA_SECTION_NODE = 4
	@ENTITY_REFERENCE_NODE = 5
	@ENTITY_NODE = 6
	@PROCESSING_INSTRUCTION_NODE = 7
	@COMMENT_NODE = 8
	@DOCUMENT_NODE = 9
	@DOCUMENT_TYPE_NODE = 10
	@DOCUMENT_FRAGMENT_NODE = 11
	@NOTATION_NODE = 12

	@DOCUMENT_POSITION_DISCONNECTED = 1
	@DOCUMENT_POSITION_PRECEDING = 2
	@DOCUMENT_POSITION_FOLLOWING = 4
	@DOCUMENT_POSITION_CONTAINS = 8
	@DOCUMENT_POSITION_CONTAINED_BY = 16
	@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32

	constructor: (name, value = null, type = 1, ownerDocument = null) ->
		@_private =
			nodeName: null
			parentNode: null
			childIndex: -1
			classes: []
		@nodeName = name
		@nodeValue = value
		@nodeType = type
		@ownerDocument = ownerDocument
		@childNodes = []
		@attributes = { }
		@listeners =
			true: {}
			false: {}

	addEventListener: (type, listener, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		if not listener in list
			list.push listener
	removeEventListener: (type, listener = null, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		i = list.indexOf listener
		list.splice(i,1)
	dispatchEvent: (evt) ->
		prevented = false
		stopped = false
		evt.preventDefault = () ->
			if evt.cancelable
				prevented = true
		evt.stopPropagation = () ->
			stopped = true
		evt.target = @
		evt.eventPhase = Event.CAPTURING_PHASE
		chain = [@]
		while chain[0].parentNode isnt @ownerDocument
			chain.unshift chain[0].parentNode
		chain.unshift @ownerDocument
		for ancestor in chain
			evt.currentTarget = ancestor
			list = ancestor.listeners[true][evt.type]
			handler(evt) for handler in list if list
			break if stopped

		evt.eventPhase = Event.AT_TARGET
		evt.currentTarget = evt.target
		list = @listeners[true][evt.type]
		handler(evt) for handler in list if list
		list = @listeners[false][evt.type]
		handler(evt) for handler in list if list

		if evt.bubbles
			for ancestor in chain.reverse()
				evt.currentTarget = ancestor
				list = ancestor.listeners[false][evt.type]
				handler(evt) for handler in list if list


	cloneNode: (deep = false) ->
		ret = new Node(@nodeName, @nodeValue, @nodeType, @ownerDocument)
		for a of @_private
			ret._private[a] = @_private[a]
		for a of @attributes
			ret.attributes[a] = @attributes[a]
		if deep
			for c in @childNodes
				ret.childNodes.push c.cloneNode(true)
		ret
	hasAttributes: () ->
		for a of @attributes
			return true
		return false
	isSameNode: (node) ->
		node is @
	hasChildNodes: () ->
		@childNodes.length > 0
	insertBefore: (newNode, refNode) ->
		if not refNode?
			return @appendChild(newNode)
		if refNode.parentNode isnt @
			throw Error "Cannot insertBefore a non-child."
		if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in newNode.childNodes
				@insertBefore(c, refNode)
		else
			i = refNode._private.childIndex
			if i > -1
				@childNodes.splice(i, 0, newNode)
				newNode._private.childIndex = i
				newNode._private.parentNode = @
				refNode._private.childIndex = i + 1
				i = 0
				for c in @childNodes
					c._private.childIndex = i++
		newNode
	appendChild: (node) ->
		if not node?
			return
		if node.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in node.childNodes
				@appendChild(c)
		else
			node._private.parentNode = @
			node._private.childIndex = @childNodes.length
			@childNodes.push node
	removeChild: (node) ->
		if( typeof node is "number" )
			node = @childNodes[node]
		i = node._private.childIndex
		if i > -1 and node.parentNode is @
			node._private.parentNode = null
			node._private.childIndex = -1
			@childNodes.splice(i, 1)
			i = 0
				c._private.childIndex = i++
		else
			throw Error "Cannot removeChild a non-child."
		node
	replaceChild: (newNode, oldNode) ->
		if oldNode.parentNode isnt @
			throw Error "Cannot replaceChild a non-child."
		i = oldNode._private.childIndex
		if i < 0
			throw Error "DOM tree corruption, childIndex is < 0"
		if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in @childNodes
				@insertBefore(c, oldNode)
			return @removeChild(oldNode)
		newNode._private.parentNode = @
		newNode._private.childIndex = i
		oldNode._private.parentNode = null
		oldNode._private.childIndex = -1
		@childNodes.splice(i, 1, newNode)
		oldNode
	toString: (pretty=false,deep=true,indentLevel=0) ->
		if pretty
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		switch @nodeType
			when Node.TEXT_NODE
			when Node.ELEMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.ATTRIBUTE_NODE
				if @nodeValue isnt ""
			when Node.CDATA_SECTION_NODE
			when Node.COMMENT_NODE
			when Node.DOCUMENT_TYPE_NODE
			when Node.DOCUMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.DOCUMENT_FRAGMENT_NODE

Node::__defineGetter__ 'nodeName', () -> @_private.nodeName
Node::__defineSetter__ 'nodeName', (v) -> @_private.nodeName = v?.toUpperCase()
Node::__defineGetter__ 'previousSibling', () -> @parentNode?.childNodes[@_private.childIndex-1]
Node::__defineSetter__ 'nextSibling', () -> @parentNode?.childNodes[@_private.childIndex+1]
Node::__defineGetter__ 'parentNode', () -> @_private.parentNode
Node::__defineSetter__ 'parentNode', (v) ->
	if v isnt null
		throw Error "Must use one of appendChild, insertBefore, etc. to give a Node a new parent."
	@_private.parentNode?.removeChild @
	@_private.parentNode = null
	@_private.childIndex = -1
Node::__defineGetter__ 'firstChild', () -> @childNodes[0]
Node::__defineGetter__ 'lastChild', () -> @childNodes[-1]

class Entity extends Node
	constructor: (a...) ->
		a[2] ?= Node.ENTITY_NODE
		super a...

class Element extends Node
	constructor: (a...) ->
		a[2] ?= Node.ELEMENT_NODE
		super a...
		@style = {}
	getElementsByClassName: (name) ->
		ret = []
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if name is "*" or name in c._private.classes
					ret.push c
				for i in c.getElementsByClassName(name)
					ret.push i
		return ret
	getElementsByTagName: (name) ->
		ret = []
		uname = name.toUpperCase()
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if uname in ["*", c.tagName]
					ret.push c
				for i in c.getElementsByTagName(uname)
					ret.push i
		return ret
	getAttribute: (name) ->
		@attributes[name] or ""
	getAttributeNode: (name) ->
		n = new Attr(name, @getAttribute(name))
		n.ownerElement = @
		n.ownerDocument = @.ownerDocument
		n
	hasAttribute: (name) ->
		name of @attributes
	setAttribute: (name, value) ->
		if not value?
			@removeAttribute(name)
			when "class"
				@className = value
			when "id"
				@id = value
			else
				@attributes[name] = value
	removeAttribute: (name) ->
		delete @attributes[name]
		switch name
			when "class"
				@_private.classes = []
			when "id"
				delete @ownerDocument?._private.idMap[@id]
	matchesSelector: (selector) ->
		@ownerDocument?._private.matcher.match(@, selector)
	querySelector: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)[0]
	querySelectorAll: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)
	scrollByLines: NotSupported
	scrollByPages: NotSupported
	scrollIntoView: NotSupported
	scrollIntoViewIfNeeded: NotSupported
	getBoundingClientRect: NotSupported
	getClientRects: NotSupported
	focus: NotSupported
	blur: NotSupported
	toString: (pretty=false, deep=true, indentLevel = 0) ->
		name = @nodeName?.toLowerCase()
		if pretty and deep
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		len = @childNodes.length
		end = switch len
			when 0 then "/"
			else ""
		r = 1
		if deep
			for c in @childNodes
				ret[r++] = c.toString pretty, deep, indentLevel + 1
		else if len > 0
		if len > 0
		ret.join('')

	_: class HTMLElement extends Element
		constructor: (a...) ->
			super a...
	a: class HTMLAnchorElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "A"
			super a...
	area: class HTMLAreaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "AREA"
			super a...
	audio: class HTMLAudioElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "AUDIO"
			super a...
	base: class HTMLBaseElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BASE"
			super a...
	blockquote: class HTMLBlockquoteElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BLOCKQUOTE"
			super a...
	body: class HTMLBodyElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BODY"
			super a...
	br: class HTMLBRElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BR"
			super a...
	button: class HTMLButtonElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BUTTON"
			super a...
	canvas: class HTMLCanvasElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "CANVAS"
			super a...
	caption: class HTMLTableCaptionElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "CAPTION"
			super a...
	col: class HTMLTableColElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "COL"
			super a...
	colgroup: class HTMLTableColElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "COLGROUP"
			super a...
	del: class HTMLDelElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DEL"
			super a...
	details: class HTMLDetailsElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DETAILS"
			super a...
	div: class HTMLDivElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DIV"
			super a...
	dl: class HTMLDListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DL"
			super a...
	embed: class HTMLEmbedElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "EMBED"
			super a...
	fieldSet: class HTMLFieldSetElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "FIELDSET"
			super a...
	form: class HTMLFormElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "FORM"
			super a...
	h1: class HTMLHeadingElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h2: class HTMLHeading2Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h3: class HTMLHeading3Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h4: class HTMLHeading4Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h5: class HTMLHeading5Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h6: class HTMLHeading6Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H6"
			super a...
	head: class HTMLHeadElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HEAD"
			super a...
	hr: class HTMLHRElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HR"
			super a...
	html: class HTMLHtmlElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HTML"
			super a...
	iframe: class HTMLIFrameElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "IFRAME"
			super a...
	image: class HTMLImageElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "IMAGE"
			super a...
	input: class HTMLInputElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "INPUT"
			super a...
	ins: class HTMLInsElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "INS"
			super a...
	keygen: class HTMLKeygenElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "KEYGEN"
			super a...
	label: class HTMLLabelElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LABEL"
			super a...
	legend: class HTMLLegendElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LEGEND"
			super a...
	li: class HTMLLIElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LI"
			super a...
	link: class HTMLLinkElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LINK"
			super a...
	map: class HTMLMapElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "MAP"
			super a...
	menu: class HTMLMenuElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "MENU"
			super a...
	meta: class HTMLMetaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "META"
			super a...
	meter: class HTMLMeterElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "METER"
			super a...
	object: class HTMLObjectElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OBJECT"
			super a...
	ol: class HTMLOListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OL"
			super a...
	optgroup: class HTMLOptGroupElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OPTGROUP"
			super a...
	option: class HTMLOptionElement extends HTMLInputElement
		constructor: (a...) ->
			a[0] = "OPTION"
			super a...
	output: class HTMLOutputElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OUTPUT"
			super a...
	p: class HTMLParagraphElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "P"
			super a...
	param: class HTMLParamElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PARAM"
			super a...
	pre: class HTMLPreElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PRE"
			super a...
	progress: class HTMLProgressElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PROGRESS"
			super a...
	quote: class HTMLQuoteElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "QUOTE"
			super a...
	script: class HTMLScriptElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "SCRIPT"
			super a...
	select: class HTMLSelectElement extends HTMLInputElement
		constructor: (a...) ->
			a[0] = "SELECT"
			super a...
	source: class HTMLSourceElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "SOURCE"
			super a...
	style: class HTMLStyleElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "STYLE"
			super a...
	table: class HTMLTableElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TABLE"
			super a...
	thead: class HTMLTableHeadElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "THEAD"
			super a...
	tbody: class HTMLTableBodyElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TBODY"
			super a...
	tfoot: class HTMLTableFootElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TFOOT"
			super a...
	td: class HTMLTableCellElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TD"
			super a...
	th: class HTMLTableHeadElement extends HTMLTableCellElement
		constructor: (a...) ->
			a[0] = "TH"
			super a...
	tr: class HTMLTableRowElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TR"
			super a...
	textarea: class HTMLTextAreaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TEXTAREA"
			super a...
	title: class HTMLTitleElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TITLE"
			super a...
	ul: class HTMLUListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "UL"
			super a...
	video: class HTMLVideoElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "VIDEO"
			super a...
}

Element::__defineGetter__ 'tagName', () -> @nodeName
Element::__defineGetter__ 'innerHTML', () ->
	h = []
	for c in @childNodes
		h.push c.toString()
	return h.join('')
Element::__defineSetter__ 'innerHTML', (v) ->
	fragment = htmlparse(v, @ownerDocument)
	for c in @childNodes
		c._private.parentNode = null
		c._private.childIndex = -1
	@childNodes.length = 0
	@appendChild fragment

getInnerText = () ->
	t = []
	for c in @childNodes
		if c.nodeType in [Node.TEXT_NODE, Node.CDATA_SECTION_NODE]
			t.push c.toString(false, false)
		else if c.nodeType isnt Node.COMMENT_NODE
			t.push getInnerText.apply c
	return t.join ''
setInnerText = (text) ->
	while @hasChildNodes()
		@removeChild(0)
	@appendChild(new Text(text, @))
	
Element::__defineGetter__ 'innerText', getInnerText
Element::__defineGetter__ 'textContent', getInnerText
Element::__defineSetter__ 'innerText', setInnerText
Element::__defineSetter__ 'textContent', setInnerText
Element::__defineGetter__ 'id', () -> @attributes['id']
Element::__defineSetter__ 'id', (value) ->
	o = @ownerDocument?
	if o
		if @attributes.id?
			delete @ownerDocument._private.idMap[@attributes.id]
	if value in [null, undefined, "undefined"]
		delete @attributes.id
	else
		if o
			@ownerDocument._private.idMap[value] = @
		@attributes.id = value
Element::__defineGetter__ 'className', () -> @attributes['class'] or ""
Element::__defineSetter__ 'className', (value) ->
	if value in [null, undefined, "undefined"]
		delete @attributes.class
		@_private.classes.length = 0
	else
		@attributes['class'] = value
		@_private.classes = value.split(' ')

HTMLInputElement::__defineGetter__ 'value', () -> @attributes.value or (if @attributes.type in ['checkbox','radio'] then "on") or ""
HTMLInputElement::__defineSetter__ 'value', (v) -> @setAttribute('value',v)

HTMLInputElement::__defineGetter__ 'checked', () -> @hasAttribute('checked')
HTMLInputElement::__defineSetter__ 'checked', (v) ->
	if v? then @setAttribute('checked','checked')
	else @removeAttribute('checked')
HTMLInputElement::__defineGetter__ 'selected', () -> @hasAttribute('selected')
HTMLInputElement::__defineSetter__ 'selected', (v) ->
	if v? then @setAttribute('selected','selected')
	else @removeAttribute('selected')

HTMLSelectElement::__defineGetter__ 'selectedIndex', () ->
	if not (@_private.selectedIndex? and @_private.selectedIndex < @childNodes.length)
		for index in [0...@childNodes.length]
			if @childNodes[index].hasAttribute 'selected'
				@_private.selectedIndex = index
	return @_private.selectedIndex or 0
HTMLSelectElement::__defineSetter__ 'selectedIndex', (v) ->
	if v < @childNodes.length
		for index in [0...@childNodes.length]
			if index is v
				@childNodes[index].setAttribute('selected','selected')
			else
				@childNodes[index].removeAttribute('selected')
		@_private.selectedIndex = v
	return @_private.selectedIndex or 0

HTMLOptionElement::__defineGetter__ 'value', () -> if @hasAttribute('value') then @getAttribute('value') else @innerText
HTMLOptionElement::__defineSetter__ 'value', (v) -> @setAttribute('value',v)

HTMLSelectElement::__defineGetter__ 'value', () -> @childNodes[@selectedIndex]?.value
HTMLSelectElement::__defineSetter__ 'value', (v) ->
	for index in [0...@childNodes.length]
		child = @childNodes[index]
		if child.value is v
			@selectedIndex = index

class Attr extends Node
	constructor: (name, value) ->
		super name, value, Node.ATTRIBUTE_NODE, null
		@name = @nodeName
		@value = @nodeValue
		@ownerElement = null

class CData extends Node
	constructor: (value, owner) ->

class Comment extends Node
	constructor: (value, owner) ->

class Text extends Node
	constructor: (value, owner) ->
Text::__defineSetter__ 'data', (v) -> @nodeValue = htmlescape(v)

class DocumentFragment extends Node
	constructor: (owner) ->
	toString: (pretty=false, deep=true) ->
		ret = []; r = 0
		for c in @childNodes
			ret[r++] = c.toString pretty, deep
		return ret.join('')

DocumentFragment::__defineSetter__ 'parentNode', (v) ->
	throw Error "DocumentFragment cannot have a parentNode"

class Document extends Element
	constructor: (a...) ->
		a[2] = Node.DOCUMENT_NODE
		super a...
		@documentElement = @
		@documentURI = null
		@_private = extend @_private, {
			idMap: {}
		}
	createCDATASection: (value) -> new CData(value, @)
	createComment: (value) -> new Comment(value, @)
	createDocumentFragment: () -> new DocumentFragment(@)
	createElement: (name) ->
		nodeClass = ELEMENT_MAP[name?.toLowerCase()]
		if not nodeClass?
			new ELEMENT_MAP['_'](name.toUpperCase())
		else
			new nodeClass(name.toUpperCase(),null,null,@)
	createEntityReference: NotSupported
	createEvent: (type) ->
		switch type
			when "MutationEvents" then new MutationEvent()
			else new Event()
	createTextNode: (text) -> new Text(text, @)
	getElementById: (id) -> @_private.idMap[id]

class HTMLDocument extends Document
	constructor: () ->
		super "HTML", null, Node.DOCUMENT_NODE, @
		Document::appendChild.call @,@createElement('head')
		Document::appendChild.call @,@createElement('body')
		@head = @childNodes[0]
		@body = @childNodes[1]
		@_private = extend @_private, {
			matcher: matcher.init(global, @)
		}
	hasChildNodes: () -> true
	insertBefore: NotSupported
	appendChild: NotSupported
	removeChild: NotSupported
	replaceChild: NotSupported
	write: NotSupported
	writeln: NotSupported

exports.createDocument = () ->
	new HTMLDocument()

exports.registerGlobals = (g) ->
	g.Element = Element
	g.Node = Node
	g.Document = Document
	g.DocumentFragment = DocumentFragment
	g.Event = Event
	for tagName of ELEMENT_MAP
		c = ELEMENT_MAP[tagName]
		g[c.name] = c


clear = (a...) ->
	for i in a
		i.length = 0
get = (a) -> a.join("")
void_elements = [ "AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"]
parse = (input, document) ->
	i = 0
	mode = 0
	fragment = document.createDocumentFragment()
	cursor = fragment
	tagName = []
	attrName = []
	attrVal = []
	text = []
	attributes = {}
	closeNode = () ->
		t = get(tagName).toUpperCase()
		clear(tagName)
		if t in void_elements
			return
		cursor = cursor.parentNode
	emitNode = (closing) -> () ->
		if tagName.length > 0
			node = document.createElement(get(tagName))
			for a of attributes
				node.setAttribute(a, attributes[a])
			cursor.appendChild(node)
			cursor = node
			clear(text, tagName, attrName, attrVal)
			for a of attributes
				delete attributes[a]
			if closing or node.nodeName in void_elements
				closeNode()
	emitAttr = () ->
		k = get(attrName)
		v = get(attrVal)
		if k?
			k = k.replace(/^\s+/,'')
		if k isnt ""
			attributes[k] = v or ""
		clear(attrName, attrVal)
	emitText = () ->
		if text.length > 0
			cursor.appendChild(document.createTextNode(get(text)))
			clear(text)
	emitComment = () ->
		if text.length > 0
			cursor.appendChild(document.createComment(get(text)))
			clear(text)
			"<": [emitText, 1]
			"": [text, 0]
			" ": [3]
			"/": [8]
			">": [emitNode(false), 0]
			"": [tagName]
			"=": [4]
			" ": [emitAttr, 3]
			"/": [emitAttr, 8]
			">": [emitAttr, emitNode(false), 0]
			"": [attrName]
			'"': [5]
			"'": [6]
			"": [attrVal, 7]
			'"': [emitAttr, 2]
			"": [attrVal]
			"'": [emitAttr, 2]
			"": [attrVal]
			" ": [emitAttr, 2]
			">": [emitAttr, emitNode(false), 0]
			"/": [emitAttr, 8]
			"": [attrVal]
			">": [emitNode(true), 0]
			"": [parseError("state 8: failed to properly close a /> tag"), 0]
			">": [closeNode, 0]
			"": [tagName]
			"": [parseError("state 11: unknown <! tag"), 0]
			"-": [12]
			"": [parseError("state 12: invalid <!-- tag"), 0]
			"-": [ 13 ]
			"": [text, 12]
	]
	while c = input[i++]
		m = states[mode]
		result = m[c] or m[""] or []
		for x in result
			if x.call
				x()
				mode = x
			else if x.push
				x.push c
	emitText()
	emitNode()
	return cursor

entity_table =
	"€": "&euro;"
	" ": "&nbsp;"
	'"': "&quot;"
	"<": "&lt;"
	">": "&gt;"
	"¡": "&iexcl;"
	"¢": "&cent;"
	"£": "&pound;"
	"¤": "&curren;"
	"¥": "&yen;"
	"¦": "&brvbar;"
	"§": "&sect;"
	"¨": "&uml;"
	"©": "&copy;"
	"ª": "&ordf;"
	"«": "&laquo;"
	"¬": "&not;"
	"¯": "&shy;"
	"®": "&reg;"
	"¯": "&macr;"
	"°": "&deg;"
	"±": "&plusmn;"
	"²": "&sup2;"
	"³": "&sup3;"
	"´": "&acute;"
	"µ": "&micro;"
	"¶": "&para;"
	"·": "&middot;"
	"¸": "&cedil;"
	"¹": "&sup1;"
	"º": "&ordm;"
	"»": "&raquo;"
	"¼": "&frac14;"
	"½": "&frac12;"
	"¾": "&frac34;"
	"¿": "&iquest;"
	"À": "&Agrave;"
	"Á": "&Aacute;"
	"Â": "&Acirc;"
	"Ã": "&Atilde;"
	"Ä": "&Auml;"
	"Å": "&Aring;"
	"Æ": "&AElig;"
	"Ç": "&Ccedil;"
	"È": "&Egrave;"
	"É": "&Eacute;"
	"Ê": "&Ecirc;"
	"Ë": "&Euml;"
	"Ì": "&Igrave;"
	"Í": "&Iacute;"
	"Î": "&Icirc;"
	"Ï": "&Iuml;"
	"Ð": "&ETH;"
	"Ñ": "&Ntilde;"
	"Ò": "&Ograve;"
	"Ó": "&Oacute;"
	"Ô": "&Ocirc;"
	"Õ": "&Otilde;"
	"Ö": "&Ouml;"
	"×": "&times;"
	"Ø": "&Oslash;"
	"Ù": "&Ugrave;"
	"Ú": "&Uacute;"
	"Û": "&Ucirc;"
	"Ü": "&Uuml;"
	"Ý": "&Yacute;"
	"Þ": "&THORN;"
	"ß": "&szlig;"
	"à": "&agrave;"
	"á": "&aacute;"
	"â": "&acirc;"
	"ã": "&atilde;"
	"ä": "&auml;"
	"å": "&aring;"
	"æ": "&aelig;"
	"ç": "&ccedil;"
	"è": "&egrave;"
	"é": "&eacute;"
	"ê": "&ecirc;"
	"ë": "&euml;"
	"ì": "&igrave;"
	"í": "&iacute;"
	"î": "&icirc;"
	"ï": "&iuml;"
	"ð": "&eth;"
	"ñ": "&ntilde;"
	"ò": "&ograve;"
	"ó": "&oacute;"
	"ô": "&ocirc;"
	"õ": "&otilde;"
	"ö": "&ouml;"
	"÷": "&divide;"
	"ø": "&oslash;"
	"ù": "&ugrave;"
	"ú": "&uacute;"
	"û": "&ucirc;"
	"ü": "&uuml;"
	"ý": "&yacute;"
	"þ": "&thorn;"

escape = (input) ->
	input = unescape input
	for c of entity_table
		input = input.replace(c, entity_table[c])
	input

unescape = (input) ->
	for c of entity_table
		input = input.replace entity_table[c], c
	input

if exports
	exports.parse = parse
	exports.escape = escape
	exports.unescape = unescape

global.assert = (c, msg) ->
	if not c
		throw Error msg
global.assertEqual = (a, b, label) ->
	if a != b
global.assertArrayEqual = (a, b, label) ->
	for i in [0...a.length]
		try
			assertEqual(a[i], b[i], label)
		catch err

UI =
		output: (a...) -> console.log.apply console, a
		red: ""
		green: ""
		yellow: ""
		normal: ""
		output: (a...) -> console.log.apply console, a
		red: "[0;31;40m"
		green: "[0;32;40m"
		yellow: "[0;33;40m"
		normal: "[0;37;40m"
		output: (a...) -> document.write a.join(' ')+"<br>"
		red: "<font color='red'>"
		green: "<font color='green'>"
		yellow: "<font color='yellow'>"
		normal: "</font>"

global.ui = switch process?.env.TERM
	when "dumb" then UI.dumb
	when undefined then UI.html
	else UI.cterm

argv = process?.argv
if argv and argv.length > 2
	test_to_run = argv[2]
else
	test_to_run = "*"

total = [0,0,0]
failures = []
global.TestGroup = (name, tests) ->
	failed = passed = 0
	for test_name of tests
		if test_to_run in ["*", test_name, name]
			test = tests[test_name]
			total[0] += 1
			try
				test()
				passed += 1
				total[1] += 1
			catch err
				failed += 1
				total[2] += 1
				failures.push(test_name)
				if test_to_run isnt "*"
					throw err
global.TestReport = () ->

TestGroup("testing"
	framework: () -> true
)

dom = require "../dom"
dom.registerGlobals global
global.dom = dom
global.document = dom.createDocument()
global.window = global
require "./common"

testSelector = (s, output) ->
	x = document.querySelectorAll(s)
	assertEqual x.toString(), output, s


TestGroup 'document', {
	exists: () -> assert(document?, "document should exist")
	head1: () -> assert(document.head?, "document.head should exist")
	body1: () -> assert(document.body?, "document.body should exist")
	type: () -> assertEqual(document.nodeType, 9, "document.nodeType")
	createElement1: () -> assertEqual(document.createElement('div').nodeType, 1)
	createElement2: () -> assertEqual(document.createElement('div').nodeName, "DIV")
	createElement3: () -> assert(document.createElement('div').style)
	appendChild: () ->
		document.body.appendChild(document.createElement('div'))
		assertEqual document.body.childNodes.length, 1
	nodesByTagName: () ->
		document.body.appendChild(document.createElement('div'))
		assert document.body.getElementsByTagName('DIV').length > 1
	attribute_dict: () ->
		div = document.createElement("div")
		div.id = "testId"
		assertEqual(div.attributes['id'], div.id)
	attribute_get_set: () ->
		div = document.createElement("div")
		div.setAttribute("name", "foo")
		assertEqual div.getAttribute("name"), "foo", "div.getAttribute('foo')"
	attribute_has1: () ->
		div = document.createElement("div")
		div.setAttribute("name", "foo")
		assertEqual div.hasAttribute("name"), true, "div.hasAttribute"
	attribute_has2: () ->
		div = document.createElement("div")
		div.setAttribute("name", "")
		assertEqual div.hasAttribute("name"), true, "div.hasAttribute"
	attribute_node: () ->
		div = document.createElement("div")
		div.setAttribute("name", "foo")
		attr = div.getAttributeNode("name")
		assertEqual attr.value, "foo", "attr.value"
		assertEqual attr.nodeValue, "foo", "attr.nodeValue"
	getElementById: () ->
		div = document.createElement("div")
		div.id = "getElemId"
		document.body.appendChild(div)
		assertEqual document.getElementById("getElemId"), div, "nodeById"
	subChildren: () ->
		div = document.createElement("div")
		div.id = "subChildren_parent"
		document.body.appendChild(div)
		span = document.createElement("span")
		div.appendChild(span)
		assertEqual div.childNodes.length, 1, "div.childNodes.length"
		nodesByTagName = div.getElementsByTagName("span")
		assertEqual nodesByTagName.length, 1, "nodesByTagName"
		assertEqual nodesByTagName[0], span, "nodesByTagName[0]"
	getElementsByClassName: () ->
		div = document.createElement("div")
		div.id = "getElemClass_parent"
		document.body.appendChild(div)
		p = document.createElement("p")
		p.id = 'classTest'
		p.className = "alpha beta"
		div.appendChild(p)
		alphaNodes = div.getElementsByClassName("alpha")
		betaNodes = div.getElementsByClassName("beta")
		assertEqual alphaNodes.length, 1, "alphaNodes.length"
		assertEqual betaNodes.length, 1, "betaNodes.length"
		assertEqual alphaNodes[0], p, "alphaNodes[0]"
		assertEqual betaNodes[0], p, "betaNodes[0]"
	fragment: () ->
		fragment_doc = global.dom.createDocument()
		fragment = fragment_doc.createDocumentFragment()
		fragment.appendChild(fragment_doc.createElement("div"))
		fragment.appendChild(fragment_doc.createElement("p"))
		assertEqual fragment.childNodes.length, 2, "fragment.childNodes.length"
		assertEqual fragment.toString(), "<div/><p/>", "fragment.toString()"
		div = fragment_doc.createElement("div")
		div.id = "fragment_test"
		fragment_doc.body.appendChild(div)
		div.appendChild(fragment)
		assertEqual fragment_doc.toString(), '<html><head/><body><div id="fragment_test"><div/><p/></div></body></html>'
	text_nodeValue: () ->
		text = document.createTextNode("Harro!")
		assertEqual(text.nodeValue, "Harro!", "text.nodeValue")
	text_data_plain: () ->
		text = document.createTextNode("Harro!")
		text.data = "BB"
		assertEqual(text.nodeValue, "BB", "text.nodeValue")
	text_data_html: () ->
		text = document.createTextNode("Harro!")
		text.data = "<p>"
		assertEqual(text.nodeValue, "&lt;p&gt;", "text.nodeValue")
	text_appendChild: () ->
		text = document.createTextNode("Harro!")
		text.data = "<p>"
		div = document.createElement("div")
		div.appendChild(text)
		assertEqual(div.innerHTML, "&lt;p&gt;")
		text.data = "Goodbye!"
		assertEqual(div.innerHTML, "Goodbye!")
	text_appendChild_multiple: () ->
		text = document.createTextNode("&nbsp;")
		div = document.createElement("div")
		div.appendChild(text)
		assertEqual(div.innerHTML, "&nbsp;")
		assertEqual(div.innerText, "&nbsp;")
		span = document.createElement("span")
		text2 = document.createTextNode("hello")
		span.appendChild(text2)
		assertEqual(span.innerText, "hello")
		div.appendChild(span)
		assertEqual(div.innerText, "&nbsp;hello")
	input_value: () ->
		input = document.createElement("input")
		input.value = 'bar'
		input.setAttribute('value', 'foo')
		assertEqual input.value, 'foo', 'input.value'
		assertEqual input.value, input.getAttribute('value'), 'input.getAttribute("value")'
	input_select: () ->
		select = document.createElement("select")
		optionA = document.createElement("option")
		optionB = document.createElement("option")
		assertEqual optionA.constructor.name, "HTMLOptionElement"
		assertEqual optionA.constructor.__super__.constructor.name, "HTMLInputElement"
		optionA.value = '1'
		optionA.innerText = 'A'
		optionB.innerText = 'B'
		assertEqual optionA.value, '1', 'optionA.value'
		assertEqual optionB.value, 'B', 'optionB.value'
		select.appendChild(optionA)
		select.appendChild(optionB)
		assertEqual select.selectedIndex, 0, 'select.selectedIndex'
		assertEqual select.value, '1', 'select.value'
		select.selectedIndex = 1
		assertEqual select.selectedIndex, 1, 'select.selectedIndex * 2'
		assertEqual select.value, 'B', 'select.value'
	input_radio: () ->
		test_doc = global.dom.createDocument()
		test_doc.body.innerHTML = "<input type='radio' selected>"
		input = test_doc.body.childNodes[0]
		assertEqual input.constructor.name, "HTMLInputElement"
		assertEqual input.hasAttribute('selected'), true, 'input.hasAttr'
		assertEqual input.getAttribute('selected'), ''
		assertEqual input.selected, true, 'input.selected'
		input.removeAttribute('selected')
		assertEqual input.selected, false, 'input.selected'
		assertEqual input.value, "on"
	input_checkbox: () ->
		test_doc = global.dom.createDocument()
		test_doc.body.innerHTML = "<input type='checkbox' checked >"
		input = test_doc.body.childNodes[0]
		assertEqual input.checked, true, 'input.checked'
		assertEqual input.value, "on"
	comment: () ->
		comment_doc = global.dom.createDocument()
		comment = comment_doc.createComment("comment text")
		assertEqual comment.nodeValue, "comment text"
		comment_doc.body.appendChild(comment)
		assertEqual comment_doc.body.toString(), '<body><!--comment text--></body>'
	selector_id: () ->
	selector_class: () ->
		testSelector "p.alpha.beta", '<p id="classTest" class="alpha beta"/>'
	selector_tag: () ->
		testSelector "p", '<p id="classTest" class="alpha beta"/>'
	selector_star: () ->
		testSelector "div *", '<span/>,<p id="classTest" class="alpha beta"/>'
}

TestReport()

require "./common"
html = require('../html/parser')

test_parse = (input, output, debug = false) ->
	message = ""
	try
		result = html.parse(input, document, debug).toString(false, true)
		output ?= input
	catch err
		throw err
	if result isnt output
		throw Error result+" !== "+output

test_escape = (input, output) ->
	result = html.escape(input)
	if result isnt output
		throw Error result+" !== "+output

TestGroup 'parse', {
	div: () -> test_parse "<div/>"
	div_text1: () -> test_parse "<div>Harro?</div>"
	div_text2: () -> test_parse "<div>foo</div>", "<div>foo</div>"
	div_text3: () -> test_parse '<div>1,2</div>', '<div>1,2</div>'
	div_p_text: () -> test_parse "<div><p>Hi.</p></div>"
	div_p_span_text: () -> test_parse "<div><p><span>Bye.</span></p></div>"
	div_closed: () -> test_parse "<div />", "<div/>"
	div_p_closed: () -> test_parse "<div><p/></div>","<div><p/></div>"
	div_p_closed2: () -> test_parse "<div><p /></div>","<div><p/></div>"
	div_p_closed3: () -> test_parse "<div><p  /></div>","<div><p/></div>"
	div_attr1: () -> test_parse "<div key='val'></div>", '<div key="val"/>'
	div_attr2: () -> test_parse "<div key='val' ></div>", '<div key="val"/>'
	div_attr3: () -> test_parse "<div key='val'/>", '<div key="val"/>'
	div_attr4: () -> test_parse "<div key='val' />", '<div key="val"/>'
	div_attr5: () -> test_parse '<div id="test_parse"></div>', '<div id="test_parse"/>'
	div_attr_empty: () -> test_parse '<input checked/>'
	text_complex: () -> test_parse '<eval>CurrencyFormat(Application.User.balance)</eval>'
	p: () -> test_parse '<p>','<p/>'
	comment: () -> test_parse '<body><!-- comment --><span>foo</span></body>'
	text_broken: () -> test_parse '<a>Hello<b>World</b></a>'
	meta1: () -> test_parse '<head><meta charset="utf-8"><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'
	meta2: () -> test_parse '<head><meta charset="utf-8"/><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'
	meta3: () -> test_parse '<head><meta charset="utf-8"></meta><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'
}

TestGroup 'escape', {
	p: () -> test_escape '<p>', '&lt;p&gt;'
	amp: () -> test_escape '&amp;', '&amp;'
	mixed: () -> test_escape '?input=foo&amp;bar&key=value', '?input=foo&amp;bar&key=value',
}

TestReport()

require "./common"

nw_doc = global.dom.createDocument()
nw_doc.body.innerHTML = "<div><p id='pId' class='c'><span class='c'>C</span></p><input name='foo' /></div>"

nw = require("../css/nwmatcher")
matcher = nw.init(global, nw_doc)

TestGroup 'nwmatcher', {
	id: () -> assertEqual matcher.byId('pId').constructor.name, "HTMLParagraphElement"
	class: () ->
		c = matcher.byClass('c')
		assertEqual c.constructor.name, "Array"
		assertEqual c.length, 2
		assert matcher.match(c[0], '.c')
		assert matcher.match(c[1], '.c')
		assert !matcher.match(c[1], 'c')
	name: () ->
		f = matcher.byName('foo')
		assertEqual f.constructor.name, "Array"
		assertEqual f.length, 1
	tag: () ->
		s = matcher.byTag('span')
		assertEqual s.constructor.name, "Array"
		assertEqual s.length, 1
	sibling: () ->
		x = matcher.select('p + input')
		assertEqual x.constructor.name, "Array"
		assertEqual x.length, 1
	star: () ->
		a = matcher.select('*')
		assertEqual a.constructor.name, "Array"
		assertEqual a.length, 6
}

TestReport()

dom = require('../dom')

assign_and_output = () ->
	document = dom.createDocument()
	document.body.innerHTML = "<div class='content' id='content'>Hello World.</div>"
	return document.toString()

output = () ->
	node = (name, attrs = {}, children) ->
		attrs = (' '+k+'="'+attrs[k]+'"' for k of attrs).join('')
		if children.join
			children = children.join('')
	html = (children = []) -> node('html', {}, children)
	head = (attrs = {}, children = []) -> node('head', attrs, children)
	body = (attrs = {}, children = []) -> node('body', attrs, children)
	div = (attrs = {}, children = []) -> node('div', attrs, children)
	p = (attrs = {}, children = []) -> node('p', attrs, children)
	span = (attrs = {}, children = []) -> node('span', attrs, children)

	html([head(), body(null, div({id:'content','class':'content'}, "Hello World."))])

measure = (f, n) ->
	start = Date.now()
	for i in [0..n]
		f()
	return (Date.now() - start)

run = (f, n, interval) ->
	sum = 0
	sum_n = 0
	for i in [0...n] by interval
		ms = measure(f, interval)
		rps = interval * 1000 / ms
		sum += rps
		sum_n += 1
	console.log "Avg. requests per sec:", (sum/sum_n)

console.log "Using domjs"
console.log assign_and_output()
run assign_and_output, 1000,200

console.log "Using a raw tree"
console.log output()
run output, 100000, 20000

tag = (name, attrs = {}, children) ->
	attrs = (' '+k+'="'+attrs[k]+'"' for k of attrs).join('')
	if children.join
		children = children.join('')
a = (attrs = {}, children = []) -> tag('a', attrs, children)
area = (attrs = {}, children = []) -> tag('area', attrs, children)
audio = (attrs = {}, children = []) -> tag('audio', attrs, children)
base = (attrs = {}, children = []) -> tag('base', attrs, children)
blockquote = (attrs = {}, children = []) -> tag('blockquote', attrs, children)
body = (attrs = {}, children = []) -> tag('body', attrs, children)
br = (attrs = {}, children = []) -> tag('br', attrs, children)
button = (attrs = {}, children = []) -> tag('button', attrs, children)
canvas = (attrs = {}, children = []) -> tag('canvas', attrs, children)
caption = (attrs = {}, children = []) -> tag('caption', attrs, children)
col = (attrs = {}, children = []) -> tag('col', attrs, children)
colgroup = (attrs = {}, children = []) -> tag('colgroup', attrs, children)
del = (attrs = {}, children = []) -> tag('del', attrs, children)
details = (attrs = {}, children = []) -> tag('details', attrs, children)
div = (attrs = {}, children = []) -> tag('div', attrs, children)
dl = (attrs = {}, children = []) -> tag('dl', attrs, children)
embed = (attrs = {}, children = []) -> tag('embed', attrs, children)
fieldSet = (attrs = {}, children = []) -> tag('fieldSet', attrs, children)
form = (attrs = {}, children = []) -> tag('form', attrs, children)
h1 = (attrs = {}, children = []) -> tag('h1', attrs, children)
h2 = (attrs = {}, children = []) -> tag('h2', attrs, children)
h3 = (attrs = {}, children = []) -> tag('h3', attrs, children)
h4 = (attrs = {}, children = []) -> tag('h4', attrs, children)
h5 = (attrs = {}, children = []) -> tag('h5', attrs, children)
h6 = (attrs = {}, children = []) -> tag('h6', attrs, children)
head = (attrs = {}, children = []) -> tag('head', attrs, children)
hr = (attrs = {}, children = []) -> tag('hr', attrs, children)
html = (attrs = {}, children = []) -> tag('html', attrs, children)
iframe = (attrs = {}, children = []) -> tag('iframe', attrs, children)
image = (attrs = {}, children = []) -> tag('image', attrs, children)
input = (attrs = {}, children = []) -> tag('input', attrs, children)
ins = (attrs = {}, children = []) -> tag('ins', attrs, children)
keygen = (attrs = {}, children = []) -> tag('keygen', attrs, children)
label = (attrs = {}, children = []) -> tag('label', attrs, children)
legend = (attrs = {}, children = []) -> tag('legend', attrs, children)
li = (attrs = {}, children = []) -> tag('li', attrs, children)
link = (attrs = {}, children = []) -> tag('link', attrs, children)
map = (attrs = {}, children = []) -> tag('map', attrs, children)
menu = (attrs = {}, children = []) -> tag('menu', attrs, children)
meta = (attrs = {}, children = []) -> tag('meta', attrs, children)
meter = (attrs = {}, children = []) -> tag('meter', attrs, children)
object = (attrs = {}, children = []) -> tag('object', attrs, children)
ol = (attrs = {}, children = []) -> tag('ol', attrs, children)
optgroup = (attrs = {}, children = []) -> tag('optgroup', attrs, children)
option = (attrs = {}, children = []) -> tag('option', attrs, children)
output = (attrs = {}, children = []) -> tag('output', attrs, children)
p = (attrs = {}, children = []) -> tag('p', attrs, children)
param = (attrs = {}, children = []) -> tag('param', attrs, children)
pre = (attrs = {}, children = []) -> tag('pre', attrs, children)
progress = (attrs = {}, children = []) -> tag('progress', attrs, children)
quote = (attrs = {}, children = []) -> tag('quote', attrs, children)
script = (attrs = {}, children = []) -> tag('script', attrs, children)
select = (attrs = {}, children = []) -> tag('select', attrs, children)
source = (attrs = {}, children = []) -> tag('source', attrs, children)
style = (attrs = {}, children = []) -> tag('style', attrs, children)
table = (attrs = {}, children = []) -> tag('table', attrs, children)
thead = (attrs = {}, children = []) -> tag('thead', attrs, children)
tbody = (attrs = {}, children = []) -> tag('tbody', attrs, children)
tfoot = (attrs = {}, children = []) -> tag('tfoot', attrs, children)
td = (attrs = {}, children = []) -> tag('td', attrs, children)
th = (attrs = {}, children = []) -> tag('th', attrs, children)
tr = (attrs = {}, children = []) -> tag('tr', attrs, children)
textarea = (attrs = {}, children = []) -> tag('textarea', attrs, children)
title = (attrs = {}, children = []) -> tag('title', attrs, children)
ul = (attrs = {}, children = []) -> tag('ul', attrs, children)
video = (attrs = {}, children = []) -> tag('video', attrs, children)
Copyright (c) 2011 Jesse Dailey <jesse.dailey@gmail.com>
License: MIT License - http://www.opensource.org/licenses/mit-license.php
parser = require("./html/parser")
htmlparse = parser.parse
htmlescape = parser.escape
htmlunescape = parser.unescape
matcher = require("./css/nwmatcher")

NotSupported = () ->
	throw Error "NOT_SUPPORTED"

repeat = (s, n) ->
	n = Math.max(0, n)
	switch n
		when 0 then ""
		when 1 then s
		else s + repeat(s, n-1)

extend = (o, p) ->
	o ?= {}
	for k of p
		o[k] = p[k]
	return o

class Event
	@CAPTURING_PHASE = 1
	@AT_TARGET = 2
	@BUBBLING_PHASE = 3
	constructor: () ->
		@type = null
		@target = null
		@currentTarget = null
		@eventPhase = 0
		@bubbles = false
		@cancelable = true
		@timeStamp = 0
	stopPropagation: () ->
	preventDefault: () ->
	initEvent: (type, canBubble, cancelable) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@timeStamp = new Date().getTime()

class MutationEvent extends Event
	@MODIFICATION = 1
	@ADDITION = 2
	@REMOVAL = 3
	constructor: () ->
		@relatedNode = null
		@prevValue = null
		@newValue = null
		@attrName = null
		@attrChange = 0
	initMutationEvent: (type, canBubble, cancelable, relatedNode, prevValue, newValue, attrName, attrChange) ->
		@type = type
		@bubbles = canBubble
		@cancelable = cancelable
		@relatedNode = relatedNode
		@prevValue = prevValue
		@newValue = newValue
		@attrName = attrName
		@attrChange = attrChange

class Node
	@ELEMENT_NODE = 1
	@ATTRIBUTE_NODE = 2
	@TEXT_NODE = 3
	@CDATA_SECTION_NODE = 4
	@ENTITY_REFERENCE_NODE = 5
	@ENTITY_NODE = 6
	@PROCESSING_INSTRUCTION_NODE = 7
	@COMMENT_NODE = 8
	@DOCUMENT_NODE = 9
	@DOCUMENT_TYPE_NODE = 10
	@DOCUMENT_FRAGMENT_NODE = 11
	@NOTATION_NODE = 12

	@DOCUMENT_POSITION_DISCONNECTED = 1
	@DOCUMENT_POSITION_PRECEDING = 2
	@DOCUMENT_POSITION_FOLLOWING = 4
	@DOCUMENT_POSITION_CONTAINS = 8
	@DOCUMENT_POSITION_CONTAINED_BY = 16
	@DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32

	constructor: (name, value = null, type = 1, ownerDocument = null) ->
		@_private =
			nodeName: null
			parentNode: null
			childIndex: -1
			classes: []
		@nodeName = name
		@nodeValue = value
		@nodeType = type
		@ownerDocument = ownerDocument
		@childNodes = []
		@attributes = { }
		@listeners =
			true: {}
			false: {}

	addEventListener: (type, listener, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		if not listener in list
			list.push listener
	removeEventListener: (type, listener = null, useCapture = false) ->
		list = (@listeners[useCapture][type] ?= [])
		i = list.indexOf listener
		list.splice(i,1)
	dispatchEvent: (evt) ->
		prevented = false
		stopped = false
		evt.preventDefault = () ->
			if evt.cancelable
				prevented = true
		evt.stopPropagation = () ->
			stopped = true
		evt.target = @
		evt.eventPhase = Event.CAPTURING_PHASE
		chain = [@]
		while chain[0].parentNode isnt @ownerDocument
			chain.unshift chain[0].parentNode
		chain.unshift @ownerDocument
		for ancestor in chain
			evt.currentTarget = ancestor
			list = ancestor.listeners[true][evt.type]
			handler(evt) for handler in list if list
			break if stopped

		evt.eventPhase = Event.AT_TARGET
		evt.currentTarget = evt.target
		list = @listeners[true][evt.type]
		handler(evt) for handler in list if list
		list = @listeners[false][evt.type]
		handler(evt) for handler in list if list

		if evt.bubbles
			for ancestor in chain.reverse()
				evt.currentTarget = ancestor
				list = ancestor.listeners[false][evt.type]
				handler(evt) for handler in list if list


	cloneNode: (deep = false) ->
		ret = new Node(@nodeName, @nodeValue, @nodeType, @ownerDocument)
		for a of @_private
			ret._private[a] = @_private[a]
		for a of @attributes
			ret.attributes[a] = @attributes[a]
		if deep
			for c in @childNodes
				ret.childNodes.push c.cloneNode(true)
		ret
	hasAttributes: () ->
		for a of @attributes
			return true
		return false
	isSameNode: (node) ->
		node is @
	hasChildNodes: () ->
		@childNodes.length > 0
	insertBefore: (newNode, refNode) ->
		if not refNode?
			return @appendChild(newNode)
		if refNode.parentNode isnt @
			throw Error "Cannot insertBefore a non-child."
		if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in newNode.childNodes
				@insertBefore(c, refNode)
		else
			i = refNode._private.childIndex
			if i > -1
				@childNodes.splice(i, 0, newNode)
				newNode._private.childIndex = i
				newNode._private.parentNode = @
				refNode._private.childIndex = i + 1
				i = 0
				for c in @childNodes
					c._private.childIndex = i++
		newNode
	appendChild: (node) ->
		if not node?
			return
		if node.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in node.childNodes
				@appendChild(c)
		else
			node._private.parentNode = @
			node._private.childIndex = @childNodes.length
			@childNodes.push node
	removeChild: (node) ->
		if( typeof node is "number" )
			node = @childNodes[node]
		i = node._private.childIndex
		if i > -1 and node.parentNode is @
			node._private.parentNode = null
			node._private.childIndex = -1
			@childNodes.splice(i, 1)
			i = 0
				c._private.childIndex = i++
		else
			throw Error "Cannot removeChild a non-child."
		node
	replaceChild: (newNode, oldNode) ->
		if oldNode.parentNode isnt @
			throw Error "Cannot replaceChild a non-child."
		i = oldNode._private.childIndex
		if i < 0
			throw Error "DOM tree corruption, childIndex is < 0"
		if newNode.nodeType is Node.DOCUMENT_FRAGMENT_NODE
			for c in @childNodes
				@insertBefore(c, oldNode)
			return @removeChild(oldNode)
		newNode._private.parentNode = @
		newNode._private.childIndex = i
		oldNode._private.parentNode = null
		oldNode._private.childIndex = -1
		@childNodes.splice(i, 1, newNode)
		oldNode
	toString: (pretty=false,deep=true,indentLevel=0) ->
		if pretty
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		switch @nodeType
			when Node.TEXT_NODE
			when Node.ELEMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.ATTRIBUTE_NODE
				if @nodeValue isnt ""
			when Node.CDATA_SECTION_NODE
			when Node.COMMENT_NODE
				body = ""
					body = '>'+newline+(c.toString(pretty, deep, indentLevel+1) for c in @childNodes).join('')
					body += indent+"<![endif]"
			when Node.DOCUMENT_TYPE_NODE
			when Node.DOCUMENT_NODE
				Element::toString.call @, pretty, deep, indentLevel
			when Node.DOCUMENT_FRAGMENT_NODE

Node::__defineGetter__ 'nodeName', () -> @_private.nodeName
Node::__defineSetter__ 'nodeName', (v) -> @_private.nodeName = v?.toUpperCase()
Node::__defineGetter__ 'previousSibling', () -> @parentNode?.childNodes[@_private.childIndex-1]
Node::__defineSetter__ 'nextSibling', () -> @parentNode?.childNodes[@_private.childIndex+1]
Node::__defineGetter__ 'parentNode', () -> @_private.parentNode
Node::__defineSetter__ 'parentNode', (v) ->
	if v isnt null
		throw Error "Must use one of appendChild, insertBefore, etc. to give a Node a new parent."
	@_private.parentNode?.removeChild @
	@_private.parentNode = null
	@_private.childIndex = -1
Node::__defineGetter__ 'firstChild', () -> @childNodes[0]
Node::__defineGetter__ 'lastChild', () -> @childNodes[-1]

class Entity extends Node
	constructor: (a...) ->
		a[2] ?= Node.ENTITY_NODE
		super a...

class Element extends Node
	constructor: (a...) ->
		a[2] ?= Node.ELEMENT_NODE
		super a...
		@style = {}
	getElementsByClassName: (name) ->
		ret = []
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if name is "*" or name in c._private.classes
					ret.push c
				for i in c.getElementsByClassName(name)
					ret.push i
		return ret
	getElementsByTagName: (name) ->
		ret = []
		uname = name.toUpperCase()
		for c in @childNodes
			if c.nodeType is Node.ELEMENT_NODE
				if uname in ["*", c.tagName]
					ret.push c
				for i in c.getElementsByTagName(uname)
					ret.push i
		return ret
	getAttribute: (name) ->
		@attributes[name] or ""
	getAttributeNode: (name) ->
		n = new Attr(name, @getAttribute(name))
		n.ownerElement = @
		n.ownerDocument = @.ownerDocument
		n
	hasAttribute: (name) ->
		name of @attributes
	setAttribute: (name, value) ->
		if not value?
			@removeAttribute(name)
			when "class"
				@className = value
			when "id"
				@id = value
			else
				@attributes[name] = value
	removeAttribute: (name) ->
		delete @attributes[name]
		switch name
			when "class"
				@_private.classes = []
			when "id"
				delete @ownerDocument?._private.idMap[@id]
	matchesSelector: (selector) ->
		@ownerDocument?._private.matcher.match(@, selector)
	querySelector: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)[0]
	querySelectorAll: (selector) ->
		@ownerDocument?._private.matcher.select(selector, @)
	scrollByLines: NotSupported
	scrollByPages: NotSupported
	scrollIntoView: NotSupported
	scrollIntoViewIfNeeded: NotSupported
	getBoundingClientRect: NotSupported
	getClientRects: NotSupported
	focus: NotSupported
	blur: NotSupported
	toString: (pretty=false, deep=true, indentLevel = 0) ->
		name = @nodeName?.toLowerCase()
		if pretty and deep
			indent = repeat("  ", indentLevel)
			newline = "\n"
		else
			indent = ""
			newline = ""
		len = @childNodes.length
		end = switch len
			when 0 then "/"
			else ""
		r = 1
		if deep
			for c in @childNodes
				ret[r++] = c.toString pretty, deep, indentLevel + 1
		else if len > 0
		if len > 0
		ret.join('')

	_: class HTMLElement extends Element
		constructor: (a...) ->
			super a...
	a: class HTMLAnchorElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "A"
			super a...
	area: class HTMLAreaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "AREA"
			super a...
	audio: class HTMLAudioElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "AUDIO"
			super a...
	base: class HTMLBaseElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BASE"
			super a...
	blockquote: class HTMLBlockquoteElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BLOCKQUOTE"
			super a...
	body: class HTMLBodyElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BODY"
			super a...
	br: class HTMLBRElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BR"
			super a...
	button: class HTMLButtonElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "BUTTON"
			super a...
	canvas: class HTMLCanvasElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "CANVAS"
			super a...
	caption: class HTMLTableCaptionElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "CAPTION"
			super a...
	col: class HTMLTableColElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "COL"
			super a...
	colgroup: class HTMLTableColElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "COLGROUP"
			super a...
	del: class HTMLDelElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DEL"
			super a...
	details: class HTMLDetailsElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DETAILS"
			super a...
	div: class HTMLDivElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DIV"
			super a...
	dl: class HTMLDListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "DL"
			super a...
	embed: class HTMLEmbedElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "EMBED"
			super a...
	fieldSet: class HTMLFieldSetElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "FIELDSET"
			super a...
	form: class HTMLFormElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "FORM"
			super a...
	h1: class HTMLHeadingElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h2: class HTMLHeading2Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h3: class HTMLHeading3Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h4: class HTMLHeading4Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h5: class HTMLHeading5Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H1"
			super a...
	h6: class HTMLHeading6Element extends HTMLHeadingElement
		constructor: (a...) ->
			a[0] = "H6"
			super a...
	head: class HTMLHeadElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HEAD"
			super a...
	hr: class HTMLHRElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HR"
			super a...
	html: class HTMLHtmlElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "HTML"
			super a...
	iframe: class HTMLIFrameElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "IFRAME"
			super a...
	image: class HTMLImageElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "IMAGE"
			super a...
	input: class HTMLInputElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "INPUT"
			super a...
	ins: class HTMLInsElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "INS"
			super a...
	keygen: class HTMLKeygenElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "KEYGEN"
			super a...
	label: class HTMLLabelElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LABEL"
			super a...
	legend: class HTMLLegendElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LEGEND"
			super a...
	li: class HTMLLIElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LI"
			super a...
	link: class HTMLLinkElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "LINK"
			super a...
	map: class HTMLMapElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "MAP"
			super a...
	menu: class HTMLMenuElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "MENU"
			super a...
	meta: class HTMLMetaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "META"
			super a...
	meter: class HTMLMeterElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "METER"
			super a...
	object: class HTMLObjectElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OBJECT"
			super a...
	ol: class HTMLOListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OL"
			super a...
	optgroup: class HTMLOptGroupElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OPTGROUP"
			super a...
	option: class HTMLOptionElement extends HTMLInputElement
		constructor: (a...) ->
			a[0] = "OPTION"
			super a...
	output: class HTMLOutputElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "OUTPUT"
			super a...
	p: class HTMLParagraphElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "P"
			super a...
	param: class HTMLParamElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PARAM"
			super a...
	pre: class HTMLPreElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PRE"
			super a...
	progress: class HTMLProgressElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "PROGRESS"
			super a...
	quote: class HTMLQuoteElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "QUOTE"
			super a...
	script: class HTMLScriptElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "SCRIPT"
			super a...
	select: class HTMLSelectElement extends HTMLInputElement
		constructor: (a...) ->
			a[0] = "SELECT"
			super a...
	source: class HTMLSourceElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "SOURCE"
			super a...
	style: class HTMLStyleElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "STYLE"
			super a...
	table: class HTMLTableElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TABLE"
			super a...
	thead: class HTMLTableHeadElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "THEAD"
			super a...
	tbody: class HTMLTableBodyElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TBODY"
			super a...
	tfoot: class HTMLTableFootElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TFOOT"
			super a...
	td: class HTMLTableCellElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TD"
			super a...
	th: class HTMLTableHeadElement extends HTMLTableCellElement
		constructor: (a...) ->
			a[0] = "TH"
			super a...
	tr: class HTMLTableRowElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TR"
			super a...
	textarea: class HTMLTextAreaElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TEXTAREA"
			super a...
	title: class HTMLTitleElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "TITLE"
			super a...
	ul: class HTMLUListElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "UL"
			super a...
	video: class HTMLVideoElement extends HTMLElement
		constructor: (a...) ->
			a[0] = "VIDEO"
			super a...
}

Element::__defineGetter__ 'tagName', () -> @nodeName
Element::__defineGetter__ 'innerHTML', () ->
	h = []
	for c in @childNodes
		h.push c.toString()
	return h.join('')
Element::__defineSetter__ 'innerHTML', (v) ->
	fragment = htmlparse(v, @ownerDocument)
	for c in @childNodes
		c._private.parentNode = null
		c._private.childIndex = -1
	@childNodes.length = 0
	@appendChild fragment

getInnerText = () ->
	t = []
	for c in @childNodes
		if c.nodeType in [Node.TEXT_NODE, Node.CDATA_SECTION_NODE]
			t.push c.toString(false, false)
		else if c.nodeType isnt Node.COMMENT_NODE
			t.push getInnerText.apply c
	return t.join ''
setInnerText = (text) ->
	while @hasChildNodes()
		@removeChild(0)
	@appendChild(new Text(text, @))
	
Element::__defineGetter__ 'innerText', getInnerText
Element::__defineGetter__ 'textContent', getInnerText
Element::__defineSetter__ 'innerText', setInnerText
Element::__defineSetter__ 'textContent', setInnerText
Element::__defineGetter__ 'id', () -> @attributes['id']
Element::__defineSetter__ 'id', (value) ->
	o = @ownerDocument?
	if o
		if @attributes.id?
			delete @ownerDocument._private.idMap[@attributes.id]
	if value in [null, undefined, "undefined"]
		delete @attributes.id
	else
		if o
			@ownerDocument._private.idMap[value] = @
		@attributes.id = value
Element::__defineGetter__ 'className', () -> @attributes['class'] or ""
Element::__defineSetter__ 'className', (value) ->
	if value in [null, undefined, "undefined"]
		delete @attributes.class
		@_private.classes.length = 0
	else
		@attributes['class'] = value
		@_private.classes = value.split(' ')

HTMLInputElement::__defineGetter__ 'value', () -> @attributes.value or (if @attributes.type in ['checkbox','radio'] then "on") or ""
HTMLInputElement::__defineSetter__ 'value', (v) -> @setAttribute('value',v)

HTMLInputElement::__defineGetter__ 'checked', () -> @hasAttribute('checked')
HTMLInputElement::__defineSetter__ 'checked', (v) ->
	if v? then @setAttribute('checked','checked')
	else @removeAttribute('checked')
HTMLInputElement::__defineGetter__ 'selected', () -> @hasAttribute('selected')
HTMLInputElement::__defineSetter__ 'selected', (v) ->
	if v? then @setAttribute('selected','selected')
	else @removeAttribute('selected')

HTMLSelectElement::__defineGetter__ 'selectedIndex', () ->
	if not (@_private.selectedIndex? and @_private.selectedIndex < @childNodes.length)
		for index in [0...@childNodes.length]
			if @childNodes[index].hasAttribute 'selected'
				@_private.selectedIndex = index
	return @_private.selectedIndex or 0
HTMLSelectElement::__defineSetter__ 'selectedIndex', (v) ->
	if v < @childNodes.length
		for index in [0...@childNodes.length]
			if index is v
				@childNodes[index].setAttribute('selected','selected')
			else
				@childNodes[index].removeAttribute('selected')
		@_private.selectedIndex = v
	return @_private.selectedIndex or 0

HTMLOptionElement::__defineGetter__ 'value', () -> if @hasAttribute('value') then @getAttribute('value') else @innerText
HTMLOptionElement::__defineSetter__ 'value', (v) -> @setAttribute('value',v)

HTMLSelectElement::__defineGetter__ 'value', () -> @childNodes[@selectedIndex]?.value
HTMLSelectElement::__defineSetter__ 'value', (v) ->
	for index in [0...@childNodes.length]
		child = @childNodes[index]
		if child.value is v
			@selectedIndex = index

class Attr extends Node
	constructor: (name, value) ->
		super name, value, Node.ATTRIBUTE_NODE, null
		@name = @nodeName
		@value = @nodeValue
		@ownerElement = null

class CData extends Node
	constructor: (value, owner) ->

class Comment extends Node
	constructor: (value, owner) ->

class CComment extends Node
	constructor: (value, owner) ->

class Text extends Node
	constructor: (value, owner) ->
Text::__defineSetter__ 'data', (v) -> @nodeValue = htmlescape(v)

class DocumentFragment extends Node
	constructor: (owner) ->
	toString: (pretty=false, deep=true) ->
		ret = []; r = 0
		for c in @childNodes
			ret[r++] = c.toString pretty, deep
		return ret.join('')

DocumentFragment::__defineSetter__ 'parentNode', (v) ->
	throw Error "DocumentFragment cannot have a parentNode"

class Document extends Element
	constructor: (a...) ->
		a[2] = Node.DOCUMENT_NODE
		super a...
		@documentElement = @
		@documentURI = null
		@_private = extend @_private, {
			idMap: {}
		}
	createCDATASection: (value) -> new CData(value, @)
	createComment: (value) -> new Comment(value, @)
	createCComment: (value) -> new CComment(value, @)
	createDocumentFragment: () -> new DocumentFragment(@)
	createElement: (name) ->
		nodeClass = ELEMENT_MAP[name?.toLowerCase()]
		if not nodeClass?
			new ELEMENT_MAP['_'](name.toUpperCase())
		else
			new nodeClass(name.toUpperCase(),null,null,@)
	createEntityReference: NotSupported
	createEvent: (type) ->
		switch type
			when "MutationEvents" then new MutationEvent()
			else new Event()
	createTextNode: (text) -> new Text(text, @)
	getElementById: (id) -> @_private.idMap[id]

class HTMLDocument extends Document
	constructor: () ->
		super "HTML", null, Node.DOCUMENT_NODE, @
		Document::appendChild.call @,@createElement('head')
		Document::appendChild.call @,@createElement('body')
		@head = @childNodes[0]
		@body = @childNodes[1]
		@_private = extend @_private, {
			matcher: matcher.init(global, @)
		}
	hasChildNodes: () -> true
	insertBefore: NotSupported
	appendChild: NotSupported
	removeChild: NotSupported
	replaceChild: NotSupported
	write: NotSupported
	writeln: NotSupported

exports.createDocument = () ->
	new HTMLDocument()

exports.registerGlobals = (g) ->
	g.Element = Element
	g.Node = Node
	g.Document = Document
	g.DocumentFragment = DocumentFragment
	g.Event = Event
	for tagName of ELEMENT_MAP
		c = ELEMENT_MAP[tagName]
		g[c.name] = c


clear = (a...) ->
	for i in a
		i.length = 0
get = (a) -> a.join("")
void_elements = [ "AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "META", "PARAM", "SOURCE", "TRACK", "WBR"]
parse = (input, document) ->
	i = 0
	mode = 0
	fragment = document.createDocumentFragment()
	cursor = fragment
	tagName = []
	attrName = []
	attrVal = []
	text = []
	attributes = {}
	closeNode = () ->
		t = get(tagName).toUpperCase()
		clear(tagName)
		if t in void_elements
			return
		cursor = cursor.parentNode
	emitNode = (closing) -> () ->
		if tagName.length > 0
			node = document.createElement(get(tagName))
			for a of attributes
				node.setAttribute(a, attributes[a])
			cursor.appendChild(node)
			cursor = node
			clear(text, tagName, attrName, attrVal)
			for a of attributes
				delete attributes[a]
			if closing or node.nodeName in void_elements
				closeNode()
	emitAttr = () ->
		k = get(attrName)
		v = get(attrVal)
		if k?
			k = k.replace(/^\s+/,'')
		if k isnt ""
			attributes[k] = v or ""
		clear(attrName, attrVal)
	emitText = () ->
		if text.length > 0
			cursor.appendChild(document.createTextNode(get(text)))
			clear(text)
	emitComment = () ->
		if text.length > 0
			cursor.appendChild(document.createComment(get(text)))
			clear(text)
			"<": [emitText, 1]
			"": [text, 0]
			" ": [3]
			"/": [8]
			">": [emitNode(false), 0]
			"": [tagName]
			"=": [4]
			" ": [emitAttr, 3]
			"/": [emitAttr, 8]
			">": [emitAttr, emitNode(false), 0]
			"": [attrName]
			'"': [5]
			"'": [6]
			"": [attrVal, 7]
			'"': [emitAttr, 2]
			"": [attrVal]
			"'": [emitAttr, 2]
			"": [attrVal]
			" ": [emitAttr, 2]
			">": [emitAttr, emitNode(false), 0]
			"/": [emitAttr, 8]
			"": [attrVal]
			">": [emitNode(true), 0]
			"": [parseError("state 8: failed to properly close a /> tag"), 0]
			">": [closeNode, 0]
			"": [tagName]
			"": [parseError("state 11: unknown <! tag"), 0]
			"-": [12]
			"": [parseError("state 12: invalid <!-- tag"), 0]
			"-": [ 13 ]
			"": [text, 12]
	]
	while c = input[i++]
		m = states[mode]
		result = m[c] or m[""] or []
		for x in result
			if x.call
				x()
				mode = x
			else if x.push
				x.push c
	emitText()
	emitNode()
	return cursor

entity_table =
	"€": "&euro;"
	" ": "&nbsp;"
	'"': "&quot;"
	"<": "&lt;"
	">": "&gt;"
	"¡": "&iexcl;"
	"¢": "&cent;"
	"£": "&pound;"
	"¤": "&curren;"
	"¥": "&yen;"
	"¦": "&brvbar;"
	"§": "&sect;"
	"¨": "&uml;"
	"©": "&copy;"
	"ª": "&ordf;"
	"«": "&laquo;"
	"¬": "&not;"
	"¯": "&shy;"
	"®": "&reg;"
	"¯": "&macr;"
	"°": "&deg;"
	"±": "&plusmn;"
	"²": "&sup2;"
	"³": "&sup3;"
	"´": "&acute;"
	"µ": "&micro;"
	"¶": "&para;"
	"·": "&middot;"
	"¸": "&cedil;"
	"¹": "&sup1;"
	"º": "&ordm;"
	"»": "&raquo;"
	"¼": "&frac14;"
	"½": "&frac12;"
	"¾": "&frac34;"
	"¿": "&iquest;"
	"À": "&Agrave;"
	"Á": "&Aacute;"
	"Â": "&Acirc;"
	"Ã": "&Atilde;"
	"Ä": "&Auml;"
	"Å": "&Aring;"
	"Æ": "&AElig;"
	"Ç": "&Ccedil;"
	"È": "&Egrave;"
	"É": "&Eacute;"
	"Ê": "&Ecirc;"
	"Ë": "&Euml;"
	"Ì": "&Igrave;"
	"Í": "&Iacute;"
	"Î": "&Icirc;"
	"Ï": "&Iuml;"
	"Ð": "&ETH;"
	"Ñ": "&Ntilde;"
	"Ò": "&Ograve;"
	"Ó": "&Oacute;"
	"Ô": "&Ocirc;"
	"Õ": "&Otilde;"
	"Ö": "&Ouml;"
	"×": "&times;"
	"Ø": "&Oslash;"
	"Ù": "&Ugrave;"
	"Ú": "&Uacute;"
	"Û": "&Ucirc;"
	"Ü": "&Uuml;"
	"Ý": "&Yacute;"
	"Þ": "&THORN;"
	"ß": "&szlig;"
	"à": "&agrave;"
	"á": "&aacute;"
	"â": "&acirc;"
	"ã": "&atilde;"
	"ä": "&auml;"
	"å": "&aring;"
	"æ": "&aelig;"
	"ç": "&ccedil;"
	"è": "&egrave;"
	"é": "&eacute;"
	"ê": "&ecirc;"
	"ë": "&euml;"
	"ì": "&igrave;"
	"í": "&iacute;"
	"î": "&icirc;"
	"ï": "&iuml;"
	"ð": "&eth;"
	"ñ": "&ntilde;"
	"ò": "&ograve;"
	"ó": "&oacute;"
	"ô": "&ocirc;"
	"õ": "&otilde;"
	"ö": "&ouml;"
	"÷": "&divide;"
	"ø": "&oslash;"
	"ù": "&ugrave;"
	"ú": "&uacute;"
	"û": "&ucirc;"
	"ü": "&uuml;"
	"ý": "&yacute;"
	"þ": "&thorn;"

escape = (input) ->
	input = unescape input
	for c of entity_table
		input = input.replace(c, entity_table[c])
	input

unescape = (input) ->
	for c of entity_table
		input = input.replace entity_table[c], c
	input

if exports
	exports.parse = parse
	exports.escape = escape
	exports.unescape = unescape

global.assert = (c, msg) ->
	if not c
		throw Error msg
global.assertEqual = (a, b, label) ->
	if a != b
global.assertArrayEqual = (a, b, label) ->
	for i in [0...a.length]
		try
			assertEqual(a[i], b[i], label)
		catch err

UI =
		output: (a...) -> console.log.apply console, a
		red: ""
		green: ""
		yellow: ""
		normal: ""
		output: (a...) -> console.log.apply console, a
		red: "[0;31;40m"
		green: "[0;32;40m"
		yellow: "[0;33;40m"
		normal: "[0;37;40m"
		output: (a...) -> document.write a.join(' ')+"<br>"
		red: "<font color='red'>"
		green: "<font color='green'>"
		yellow: "<font color='yellow'>"
		normal: "</font>"

global.ui = switch process?.env.TERM
	when "dumb" then UI.dumb
	when undefined then UI.html
	else UI.cterm

argv = process?.argv
if argv and argv.length > 2
	test_to_run = argv[2]
else
	test_to_run = "*"

total = [0,0,0]
failures = []
global.TestGroup = (name, tests) ->
	failed = passed = 0
	for test_name of tests
		if test_to_run in ["*", test_name, name]
			test = tests[test_name]
			total[0] += 1
			try
				test()
				passed += 1
				total[1] += 1
			catch err
				failed += 1
				total[2] += 1
				failures.push(test_name)
				if test_to_run isnt "*"
					throw err
global.TestReport = () ->

TestGroup("testing"
	framework: () -> true
)

dom = require "../dom"
dom.registerGlobals global
global.dom = dom
global.document = dom.createDocument()
global.window = global
require "./common"

testSelector = (s, output) ->
	x = document.querySelectorAll(s)
	assertEqual x.toString(), output, s


TestGroup 'document', {
	exists: () -> assert(document?, "document should exist")
	head1: () -> assert(document.head?, "document.head should exist")
	body1: () -> assert(document.body?, "document.body should exist")
	type: () -> assertEqual(document.nodeType, 9, "document.nodeType")
	createElement1: () -> assertEqual(document.createElement('div').nodeType, 1)
	createElement2: () -> assertEqual(document.createElement('div').nodeName, "DIV")
	createElement3: () -> assert(document.createElement('div').style)
	appendChild: () ->
		document.body.appendChild(document.createElement('div'))
		assertEqual document.body.childNodes.length, 1
	nodesByTagName: () ->
		document.body.appendChild(document.createElement('div'))
		assert document.body.getElementsByTagName('DIV').length > 1
	attribute_dict: () ->
		div = document.createElement("div")
		div.id = "testId"
		assertEqual(div.attributes['id'], div.id)
	attribute_get_set: () ->
		div = document.createElement("div")
		div.setAttribute("name", "foo")
		assertEqual div.getAttribute("name"), "foo", "div.getAttribute('foo')"
	attribute_has1: () ->
		div = document.createElement("div")
		div.setAttribute("name", "foo")
		assertEqual div.hasAttribute("name"), true, "div.hasAttribute"
	attribute_has2: () ->
		div = document.createElement("div")
		div.setAttribute("name", "")
		assertEqual div.hasAttribute("name"), true, "div.hasAttribute"
	attribute_node: () ->
		div = document.createElement("div")
		div.setAttribute("name", "foo")
		attr = div.getAttributeNode("name")
		assertEqual attr.value, "foo", "attr.value"
		assertEqual attr.nodeValue, "foo", "attr.nodeValue"
	getElementById: () ->
		div = document.createElement("div")
		div.id = "getElemId"
		document.body.appendChild(div)
		assertEqual document.getElementById("getElemId"), div, "nodeById"
	subChildren: () ->
		div = document.createElement("div")
		div.id = "subChildren_parent"
		document.body.appendChild(div)
		span = document.createElement("span")
		div.appendChild(span)
		assertEqual div.childNodes.length, 1, "div.childNodes.length"
		nodesByTagName = div.getElementsByTagName("span")
		assertEqual nodesByTagName.length, 1, "nodesByTagName"
		assertEqual nodesByTagName[0], span, "nodesByTagName[0]"
	getElementsByClassName: () ->
		div = document.createElement("div")
		div.id = "getElemClass_parent"
		document.body.appendChild(div)
		p = document.createElement("p")
		p.id = 'classTest'
		p.className = "alpha beta"
		div.appendChild(p)
		alphaNodes = div.getElementsByClassName("alpha")
		betaNodes = div.getElementsByClassName("beta")
		assertEqual alphaNodes.length, 1, "alphaNodes.length"
		assertEqual betaNodes.length, 1, "betaNodes.length"
		assertEqual alphaNodes[0], p, "alphaNodes[0]"
		assertEqual betaNodes[0], p, "betaNodes[0]"
	fragment: () ->
		fragment_doc = global.dom.createDocument()
		fragment = fragment_doc.createDocumentFragment()
		fragment.appendChild(fragment_doc.createElement("div"))
		fragment.appendChild(fragment_doc.createElement("p"))
		assertEqual fragment.childNodes.length, 2, "fragment.childNodes.length"
		assertEqual fragment.toString(), "<div/><p/>", "fragment.toString()"
		div = fragment_doc.createElement("div")
		div.id = "fragment_test"
		fragment_doc.body.appendChild(div)
		div.appendChild(fragment)
		assertEqual fragment_doc.toString(), '<html><head/><body><div id="fragment_test"><div/><p/></div></body></html>'
	text_nodeValue: () ->
		text = document.createTextNode("Harro!")
		assertEqual(text.nodeValue, "Harro!", "text.nodeValue")
	text_data_plain: () ->
		text = document.createTextNode("Harro!")
		text.data = "BB"
		assertEqual(text.nodeValue, "BB", "text.nodeValue")
	text_data_html: () ->
		text = document.createTextNode("Harro!")
		text.data = "<p>"
		assertEqual(text.nodeValue, "&lt;p&gt;", "text.nodeValue")
	text_appendChild: () ->
		text = document.createTextNode("Harro!")
		text.data = "<p>"
		div = document.createElement("div")
		div.appendChild(text)
		assertEqual(div.innerHTML, "&lt;p&gt;")
		text.data = "Goodbye!"
		assertEqual(div.innerHTML, "Goodbye!")
	text_appendChild_multiple: () ->
		text = document.createTextNode("&nbsp;")
		div = document.createElement("div")
		div.appendChild(text)
		assertEqual(div.innerHTML, "&nbsp;")
		assertEqual(div.innerText, "&nbsp;")
		span = document.createElement("span")
		text2 = document.createTextNode("hello")
		span.appendChild(text2)
		assertEqual(span.innerText, "hello")
		div.appendChild(span)
		assertEqual(div.innerText, "&nbsp;hello")
	input_value: () ->
		input = document.createElement("input")
		input.value = 'bar'
		input.setAttribute('value', 'foo')
		assertEqual input.value, 'foo', 'input.value'
		assertEqual input.value, input.getAttribute('value'), 'input.getAttribute("value")'
	input_select: () ->
		select = document.createElement("select")
		optionA = document.createElement("option")
		optionB = document.createElement("option")
		assertEqual optionA.constructor.name, "HTMLOptionElement"
		assertEqual optionA.constructor.__super__.constructor.name, "HTMLInputElement"
		optionA.value = '1'
		optionA.innerText = 'A'
		optionB.innerText = 'B'
		assertEqual optionA.value, '1', 'optionA.value'
		assertEqual optionB.value, 'B', 'optionB.value'
		select.appendChild(optionA)
		select.appendChild(optionB)
		assertEqual select.selectedIndex, 0, 'select.selectedIndex'
		assertEqual select.value, '1', 'select.value'
		select.selectedIndex = 1
		assertEqual select.selectedIndex, 1, 'select.selectedIndex * 2'
		assertEqual select.value, 'B', 'select.value'
	input_radio: () ->
		test_doc = global.dom.createDocument()
		test_doc.body.innerHTML = "<input type='radio' selected>"
		input = test_doc.body.childNodes[0]
		assertEqual input.constructor.name, "HTMLInputElement"
		assertEqual input.hasAttribute('selected'), true, 'input.hasAttr'
		assertEqual input.getAttribute('selected'), ''
		assertEqual input.selected, true, 'input.selected'
		input.removeAttribute('selected')
		assertEqual input.selected, false, 'input.selected'
		assertEqual input.value, "on"
	input_checkbox: () ->
		test_doc = global.dom.createDocument()
		test_doc.body.innerHTML = "<input type='checkbox' checked >"
		input = test_doc.body.childNodes[0]
		assertEqual input.checked, true, 'input.checked'
		assertEqual input.value, "on"
	comment: () ->
		comment_doc = global.dom.createDocument()
		comment = comment_doc.createComment("comment text")
		assertEqual comment.nodeValue, "comment text"
		comment_doc.body.appendChild(comment)
		assertEqual comment_doc.body.toString(), '<body><!--comment text--></body>'
	conditional: () ->
		doc = global.dom.createDocument()
		comment = doc.createCComment("if lt IE 9")
		script = doc.createElement('script')
		script.setAttribute('src', 'ie.js')
		comment.appendChild script
		doc.body.appendChild(comment)
		assertEqual doc.body.toString(), '<body><!--[if lt IE 9]><script src="ie.js"/><![endif]--></body>'
	selector_id: () ->
	selector_class: () ->
		testSelector "p.alpha.beta", '<p id="classTest" class="alpha beta"/>'
	selector_tag: () ->
		testSelector "p", '<p id="classTest" class="alpha beta"/>'
	selector_star: () ->
		testSelector "div *", '<span/>,<p id="classTest" class="alpha beta"/>'
}

TestReport()

require "./common"
html = require('../html/parser')

test_parse = (input, output, debug = false) ->
	message = ""
	try
		result = html.parse(input, document, debug).toString(false, true)
		output ?= input
	catch err
		throw err
	if result isnt output
		throw Error result+" !== "+output

test_escape = (input, output) ->
	result = html.escape(input)
	if result isnt output
		throw Error result+" !== "+output

TestGroup 'parse', {
	div: () -> test_parse "<div/>"
	div_text1: () -> test_parse "<div>Harro?</div>"
	div_text2: () -> test_parse "<div>foo</div>", "<div>foo</div>"
	div_text3: () -> test_parse '<div>1,2</div>', '<div>1,2</div>'
	div_p_text: () -> test_parse "<div><p>Hi.</p></div>"
	div_p_span_text: () -> test_parse "<div><p><span>Bye.</span></p></div>"
	div_closed: () -> test_parse "<div />", "<div/>"
	div_p_closed: () -> test_parse "<div><p/></div>","<div><p/></div>"
	div_p_closed2: () -> test_parse "<div><p /></div>","<div><p/></div>"
	div_p_closed3: () -> test_parse "<div><p  /></div>","<div><p/></div>"
	div_attr1: () -> test_parse "<div key='val'></div>", '<div key="val"/>'
	div_attr2: () -> test_parse "<div key='val' ></div>", '<div key="val"/>'
	div_attr3: () -> test_parse "<div key='val'/>", '<div key="val"/>'
	div_attr4: () -> test_parse "<div key='val' />", '<div key="val"/>'
	div_attr5: () -> test_parse '<div id="test_parse"></div>', '<div id="test_parse"/>'
	div_attr_empty: () -> test_parse '<input checked/>'
	text_complex: () -> test_parse '<eval>CurrencyFormat(Application.User.balance)</eval>'
	p: () -> test_parse '<p>','<p/>'
	comment: () -> test_parse '<body><!-- comment --><span>foo</span></body>'
	text_broken: () -> test_parse '<a>Hello<b>World</b></a>'
	meta1: () -> test_parse '<head><meta charset="utf-8"><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'
	meta2: () -> test_parse '<head><meta charset="utf-8"/><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'
	meta3: () -> test_parse '<head><meta charset="utf-8"></meta><span>foo</span></head>', '<head><meta charset="utf-8"/><span>foo</span></head>'
}

TestGroup 'escape', {
	p: () -> test_escape '<p>', '&lt;p&gt;'
	amp: () -> test_escape '&amp;', '&amp;'
	mixed: () -> test_escape '?input=foo&amp;bar&key=value', '?input=foo&amp;bar&key=value',
}

TestReport()

require "./common"

nw_doc = global.dom.createDocument()
nw_doc.body.innerHTML = "<div><p id='pId' class='c'><span class='c'>C</span></p><input name='foo' /></div>"

nw = require("../css/nwmatcher")
matcher = nw.init(global, nw_doc)

TestGroup 'nwmatcher', {
	id: () -> assertEqual matcher.byId('pId').constructor.name, "HTMLParagraphElement"
	class: () ->
		c = matcher.byClass('c')
		assertEqual c.constructor.name, "Array"
		assertEqual c.length, 2
		assert matcher.match(c[0], '.c')
		assert matcher.match(c[1], '.c')
		assert !matcher.match(c[1], 'c')
	name: () ->
		f = matcher.byName('foo')
		assertEqual f.constructor.name, "Array"
		assertEqual f.length, 1
	tag: () ->
		s = matcher.byTag('span')
		assertEqual s.constructor.name, "Array"
		assertEqual s.length, 1
	sibling: () ->
		x = matcher.select('p + input')
		assertEqual x.constructor.name, "Array"
		assertEqual x.length, 1
	star: () ->
		a = matcher.select('*')
		assertEqual a.constructor.name, "Array"
		assertEqual a.length, 6
}

TestReport()


	x = f?.apply c, a
	if typeof x is "function"
		return applyAll x, c, a
	return x

	(next) ->
		() =>
			applyAll f, @, a
			@jmp next

	return def if not o?
	dot = key.indexOf '.'
	if dot isnt -1
		return get(get(o, key.substring(0,dot)), key.substring(dot+1), def)
	try
		if key of o
			return o[key]
	catch e
		return def
	return def

class StateMachine
	constructor: () -> @reset()
	reset: () ->
		console.log "reset." if @debug > 0
		@state = 0
		@entered = false
		@stack = []
		if document?
			@document = document
		else
			@document = require("domjs/dom").createDocument()
	jmp: (state) ->
		() =>
			@entered = (@state is state)
			@state = state
	call: (state, next) ->
		() =>
			@stack.push (next or @state)
			@jmp state
	called: (f) ->
		(a...) =>
			next = @stack.pop()
			f.apply @, a
			@jmp next
	push: (a) ->
		(c) =>
			@stack.push a or c
	runOne: (c) ->
		modeline = @table[@state]
		args = [c]
		if not @entered
			@entered = true
			applyAll modeline.enter, @, args
				@runOne(c)
		applyAll modeline.every, @, args
			@runOne(c)
		if c of modeline
			applyAll modeline[c], @, args
		else
			applyAll modeline[""], @, args
	eval: (input) ->
		for c in input
			if @debug > 0
			@runOne(c)
		applyAll @table[@state]?.eof, @
	getOutput: () -> @stack.join('')
	run: (input) ->
		@eval(input)
		@getOutput()

class Synth extends StateMachine
	constructor: (context = {}) ->
		super()
		INIT = "INIT"
		READ_TAG = "READ_TAG"
		READ_CLASS = "READ_CLASS"
		READ_ID = "READ_ID"
		READ_KEY = "READ_KEY"
		START_VAL = "START_VAL"
		START_VAR = "START_VAR"
		READ_VAR = "READ_VAR"
		READ_UQ_VAL = "READ_UQ_VAL"
		READ_DQ_VAL = "READ_DQ_VAL"
		READ_SQ_VAL = "READ_SQ_VAL"
		ESCAPED = "ESCAPED"
		END_ATTR = "END_ATTR"
		END_VAL = "END_VAL"
		READ_SQ_TEXT = "READ_SQ_TEXT"
		READ_DQ_TEXT = "READ_DQ_TEXT"
		START_COMMENT = "START_COMMENT"
		CONT_COMMENT = "CONT_COMMENT"
		READ_COMMENT = "READ_COMMENT"
		READ_CONDITION = "READ_CONDITION"
		COUNT_TABS = "COUNT_TABS"
		START_TABS = "START_TABS"
		INIT_TABS = "INIT_TABS"
		READ_CLASS = "READ_CLASS"
		FINAL = "FINAL"
		@state = INIT
		@table = {
			INIT: {
				enter: () ->
					@reset()
					@root = @document.createDocumentFragment()
					@cursor = @root
					@attr = { key: null, val: undefined }
					@contextStack = [context]
					@jmp INIT_TABS
			}
			READ_TAG: {
				""  : @push()
				" " : () ->
					@tabs?.prev += 1
					@endTag READ_TAG
				'"' : @endTag READ_DQ_TEXT
				"'" : @endTag READ_SQ_TEXT
				"." : @endTag READ_CLASS
				"[" : @endTag READ_KEY
				"!" : @endTag START_COMMENT
				"\r": @endTag START_TABS
				"\n": @endTag START_TABS
				eof : @endTag FINAL
			}
			START_COMMENT: {
				"-" : @jmp CONT_COMMENT
				"?" : @jmp READ_CONDITION
			}
			CONT_COMMENT: {
				"-" : @jmp READ_COMMENT
				""  : @err("syntax: expected -")
			}
			READ_COMMENT: {
				""  : @push()
				"\n": @endComment START_TABS
				"\r": @endComment START_TABS
				eof : @endComment FINAL
			}
			READ_CONDITION: {
				""  : @push()
				"\n": @endCondition START_TABS
				"\r": @endCondition START_TABS
				eof : @endCondition FINAL
			}
			READ_DQ_TEXT: {
				""  : @push()
				"\\": @call ESCAPED
				"@": @call START_VAR
				'"' : @endText READ_TAG
			}
			READ_SQ_TEXT: {
				""  : @push()
				"\\": @call ESCAPED
				"@": @call START_VAR
				"'" : @endText READ_TAG
				eof : @err("syntax: unclosed single-quote")
			}
			START_VAR: {
				enter: () ->
					@sp = @stack.length
				"{": @jmp READ_VAR
			}
			READ_VAR: {
				"": @push()
				"}": @endVar()
				eof: @err "syntax: unexpected EOF in @{} variable"
			}
			READ_CLASS: {
				""  : @push()
				" " : @endClass READ_TAG
				"." : @endClass READ_CLASS
				"[" : @endClass READ_KEY
				"\r": @endClass START_TABS
				"\n": @endClass START_TABS
				eof : @endClass FINAL
			}
			READ_ID: {
				""  : @push()
				" " : @endId READ_TAG
				"." : @endId READ_CLASS
				"[" : @endId READ_KEY
				"\r": @endId START_TABS
				"\n": @endId START_TABS
				eof : @endId FINAL
			}
			READ_KEY: {
				""  : @push()
				"=" : @endKey START_VAL
				"]" : @endKey READ_TAG
				eof : @err("syntax: unclosed attribute block, expected ] or =")
			}
			START_VAL: {
				""  : (c) -> @stack.push(c); @jmp(READ_UQ_VAL)
				"@" : @call START_VAR, READ_UQ_VAL
				'"' : @jmp READ_DQ_VAL
				"'" : @jmp READ_SQ_VAL
				"]" : @endVal READ_TAG
				eof : @err("syntax: unclosed attribute block, expected ] or value")
			}
			READ_UQ_VAL: {
				""  : @push()
				"]" : @endVal READ_TAG
				eof : @err "syntax: unclosed unquoted attribute value"
			}
			READ_DQ_VAL: {
				""  : @push()
				"\\": @call ESCAPED
				'"' : @endVal END_ATTR
				eof : @err "syntax: unclosed double-quoted attribute value"
			}
			READ_SQ_VAL: {
				""  : @push()
				"\\": @call ESCAPED
				"'" : @endVal END_ATTR
				eof : @err "syntax: unclosed single-quoted attribute value"
			}
			ESCAPED: {
				"n" : @called () -> @stack.push("\n")
				"r" : @called () -> @stack.push("\r")
				"t" : @called () -> @stack.push("\t")
				""  : @called (c) -> @stack.push(c)
				eof : @err "syntax: unterminated string ended on an escape char '\\'"
			}
			END_VAL: {
				enter: @endVal END_ATTR
			}
			END_ATTR: {
				"]" : @endAttr READ_TAG
				""  : @err 'syntax: expected closing ]'
				eof : @err 'syntax: expected closing ]'
			}
			INIT_TABS: {
				enter: ()->
					@tabs =
						prev: -1
						curr: 0
						delt: 1
				"\t": ()-> @tabs.prev += 1
				""  : @jmp READ_TAG
			}
			START_TABS: {
				enter: ()->
					@tabs.curr = 0
					@jmp COUNT_TABS
			}
			COUNT_TABS: {
				"\r": () -> @tabs.curr = 0
				"\n": () -> @tabs.curr = 0
				"\t": () -> @tabs.curr += 1
				'"' : @endTabs READ_DQ_TEXT
				"'" : @endTabs READ_SQ_TEXT
				"!" : @endTabs START_COMMENT
				""  : (c) ->
					@stack.push c
					@endTabs READ_TAG
				eof : @endTag FINAL
			}
			FINAL: {
				enter: () ->
					console.log "FINAL" if @debug > 0
			}
		}
	getVar: (name) ->
		for i in [@contextStack.length-1..0]
			v = get(@contextStack[i], name)
			if v?
				return v
	setVar: (name, value) ->
		@contextStack[@contextStack.length - 1][name] = value
	appendChild: (child) ->
		if @cursor?
			if @tabs.delt isnt 1
				n = (-@tabs.delt) + 1
				while n-- > 0
					@cursor = @cursor.parentNode
			console.log "appending child" if @debug > 2
			@cursor.appendChild child
		else
			console.log "no cursor?" if @debug > 0
		@cursor = child
	endTag: operator (tagName) ->
		if tagName?.length > 0
			@appendChild @document.createElement(tagName)
	, 'endTag'
	endComment: operator (commentBody) ->
		if commentBody?.length > 0
			@appendChild @document.createComment(commentBody)
	, 'endComment'
	endCondition: operator (condition) ->
		if condition?.length > 0
			condition = condition.replace(/^if /, "").replace(/^ +/, "")
			condition = "if " + condition
			@appendChild @document.createCComment(condition)
	, 'endCondition'
	endClass: operator (className) ->
		if @cursor? and className?.length > 0
			if @cursor.className.length > 0
				@cursor.className += " " + className
			else
				@cursor.className += className
	, 'endClass'
	endId: operator (id) ->
		if @cursor? and id?.length > 0
			@cursor.id = id
	, 'endId'
	endKey: operator (key) ->
		if key?.length > 0
			@attr.key = key
	, 'endKey'
	endVal: operator (val) ->
		@attr.val = val
		@endAttr()()
	, 'endVal'
	endAttr: operator () ->
		if @cursor? and @attr.key?.length > 0
			@cursor.setAttribute(@attr.key, @attr.val)
			@attr = { key: null, val: undefined }
	, 'endAttr'
	endTabs: operator () ->
		@tabs.prev += (@tabs.delt = @tabs.curr - @tabs.prev)
	, 'endTabs'
	endText: operator (text) ->
		@appendChild @document.createTextNode(text)
	, 'endText'
	endVar: () ->
		() =>
			name = (@stack.slice @sp, @stack.length).join ''
			@stack = @stack.slice 0, @sp
			next = @stack.pop()
			@stack.push @getVar(name)
			@jmp next
	, 'endVar'
	getOutput: () ->
		return @root

synth = (text, context = {}, debug = 0) ->
	m = new Synth(context)
	m.debug = debug
	return m.run(text).toString(true)

exports?.synth = synth
window?.synth = synth

if not exports? and process?.argv.length > 2
	fs = require('fs')
	rethrow = (f) ->
		(err, data) ->
			throw err if err?
			f.call @, data
	argv = process.argv.splice(2)
	for f in argv
		fs.readFile f, rethrow (data) ->
			console.log synth(data.toString(),{},0).toString()
			fs.writeFile outputFile, output, 'utf8', rethrow () ->
global.assert = (c, msg) ->
	if not c
		throw Error msg
global.assertEqual = (a, b, label) ->
	if a != b
global.assertArrayEqual = (a, b, label) ->
	for i in [0...a.length]
		try
			assertEqual(a[i], b[i], label)
		catch err

UI =
		output: (a...) -> console.log.apply console, a
		red: ""
		green: ""
		yellow: ""
		normal: ""
		output: (a...) -> console.log.apply console, a
		red: "[0;31;40m"
		green: "[0;32;40m"
		yellow: "[0;33;40m"
		normal: "[0;37;40m"
		output: (a...) -> document.write a.join(' ')+"<br>"
		red: "<font color='red'>"
		green: "<font color='green'>"
		yellow: "<font color='yellow'>"
		normal: "</font>"

global.ui = switch process?.env.TERM
	when "dumb" then UI.dumb
	when undefined then UI.html
	else UI.cterm

argv = process?.argv
if argv and argv.length > 2
	test_to_run = argv[2]
else
	test_to_run = "*"

total = [0,0,0]
failures = []
global.testGroup = (name, tests) ->
	failed = passed = 0
	for test_name of tests
		if test_to_run in ["*", test_name, name]
			test = tests[test_name]
			total[0] += 1
			try
				test()
				passed += 1
				total[1] += 1
			catch err
				failed += 1
				total[2] += 1
				failures.push(test_name)
				if test_to_run isnt "*"
					throw err
global.testReport = () ->

testGroup("Testing Framework"
	pass: () -> true
)
require("./common")
synth = require("../synth").synth
fs = require('fs')

testPattern = (patt, expected, context = {}, debug = 0) ->
	() ->
		try
			output = synth(patt,context,debug).toString()
		catch e
			output = "SHIT"
		assertEqual(output, expected)

fs.readdir './tests', (err, files) ->
	throw err if err?
	tests = {}
	for f in files
		if /\.in$/.test(f)
			(() ->
				testname = f.replace /\.in$/, ''
				infile = './tests/' + testname + ".in"
				outfile = './tests/' + testname + ".out"
				datafile = './tests/' + testname + ".data"
				tests[testname] = () ->
					input = fs.readFileSync infile, 'utf8'
					expected = fs.readFileSync outfile, 'utf8'
					try
						data = fs.readFileSync datafile, 'utf8'
					catch e
						data = "{}"
					context = eval data
					output = synth input, context
					assertEqual output, expected
			)()

	testGroup("Synth", tests)
	testReport()


require "bling"
a = $([1,2,3])

$.assert a.constructor.name is "Bling"

$.log a[0]
a.__proto__ = Array.prototype

$.log a.emit
$.log a.zap
$.log a[0]
fs = require 'fs'

module.exports = (name, version) ->
  unless name
    console.log "Usage: bots NAME"
    process.exit -1

  fs.mkdir name, '0755', (err) ->
    throw err if err
var bots = require('bots');



  msg.say('pong from ' + this.name);
});

  this.get('http://search.twitter.com/search.json?lang=en&q=' + msg.match[1], function(body) {
    body.results.forEach(function(tweet) {
      msg.say(tweet.text);
    });
  });
});

  console.log("Try typing 'help' or 'ping'.");
});


""", (err) ->
      throw err if err
{
  "version": "0.0.0",
  "description": "",
  "author": "",
  "main": "./index",
  "engines": {
    "node": "0.4"
  },
  "dependencies": {
  },
  "scripts": {
    "start": "node index.js"
  }
}

""", (err) ->
        throw err if err


    npm install


    npm start


  """, (err) ->
          throw err if err
          console.log "...done"
{EventEmitter} = require 'events'
request = require 'request'
fs = require 'fs'

exports.version = JSON.parse(fs.readFileSync(__dirname + "/../package.json")).version

exports.createBot = (name) ->
  new Bot name

exports.Bot = class Bot extends EventEmitter

  constructor: (@name) ->
    @handlers = []
    @interfaces = []
    @descriptions = {}

  setup: (nickname, callback) ->
    if typeof(nickname) is 'function'
      callback = nickname
    else
      @nickname = nickname

    callback @desc, @hear

  desc: (phrase, functionality) =>
    @descriptions[phrase] = functionality

  hear: (pattern, callback) =>
    @handlers.push [pattern, callback]

  use: (interface) ->
    @interfaces.push interface
    interface.on 'message', @dispatch

  dispatch: (message) =>
    for pair in @handlers
      if @nickname
      [ pattern, handler ] = pair
      handler.call(@, message) if message.match = message.body.match(pattern)

  start: ->
    interface.listen() for interface in @interfaces
    @hear /help/, @help
    @emit 'start'

  stop: (finished) ->
    closing = @interfaces.length
    for interface in @interfaces
      interface.close ->
        finished() if --closing is 0

  reset: (callback) ->
    @handlers = []
    @descriptions = []
    callback?()

  get: (uri, body, callback) ->
    @request('GET', uri, body, callback)

  post: (uri, body, callback) ->
    @request('POST', uri, body, callback)

  help: (message) ->
    if Object.keys(@descriptions).length is 0
      return message.say "I do not have any actions yet."
    message.say "I listen for the following…", =>
      for phrase, functionality of @descriptions
        if functionality
          output =  phrase + ": " + functionality
        else
          output = phrase
        message.say output

  request: (method, uri, body, callback) ->
    options = { method: method, uri: uri }

    options.headers = { 'User-Agent': @name }

    if typeof(body) is 'function' and not callback
      callback = body
      body = null

    if typeof body is 'string'
      options.body = body
    else
      options.json = body

    request options, (err, response, body) ->
      try
        body = JSON.parse body
      catch e

      callback? body, response

exports.cli = ->
  Cli = require './interfaces/cli'
  new Cli

exports.campfire = (args...) ->
  Campfire = require './interfaces/campfire'
  new Campfire args...

exports.xmpp = (args...) ->
  Xmpp = require './interfaces/xmpp'
  new Xmpp args...

exports.generate = require './generator'
{EventEmitter} = require 'events'
ranger = require 'ranger'

module.exports = class Campfire extends EventEmitter
  constructor: (@options = {}) ->
    @client = ranger.createClient(@options.account, @options.apiKey)

  listen: ->
    @client.room @options.roomId, @joinRoom

  joinRoom: (room) =>
    @room = room
    @room.join()
    @room.listen @handle

  close: (done) ->
    @room.leave done

  log: (message) ->

  handle: (message) =>
    if message.type is 'TextMessage' and message.userId isnt @options.userId
      @log message
      message.say = (text, callback) => @room.speak text, callback
      @emit 'message', message
{EventEmitter} = require 'events'

module.exports = class Cli extends EventEmitter
  listen: ->
    if command = process.argv.slice(2).join(' ')
      @handle command
    else
      process.stdin.resume()
      process.stdin.setEncoding 'utf8'
      process.stdin.on 'data', @handle

  handle: (chunk) =>
    message =
      body: chunk.toString()
      say: (thing, callback) ->
        console.log thing
        callback?()

    @emit 'message', message
{EventEmitter} = require 'events'
{puts}         = require 'util'
xmpp           = require 'node-xmpp'

module.exports = class XMPP extends EventEmitter
  constructor: (@jid, @password) ->

  listen: ->
    @client = new xmpp.Client
      jid: @jid
      password: @password

    @client.on 'online', @updatePresence
    @client.on 'stanza', @handle
    @client.on 'error', (err) -> console.warn(err)

  close: (done) ->
    @client.end()
    done()

  updatePresence: =>
    puts "XMPP Connected"
    @client.send new xmpp.Element('presence', {}).c('show').t('chat').up()
      .c('status').t('Happily echoing your <message /> stanzas')

  handle: (stanza) =>
    if stanza.is('message') and stanza.attrs.type isnt 'error'
      message =
        say: (thing, callback) =>
          @client.send @createReply(stanza.attrs.from, thing)
          callback?()

      for child in stanza.children
        message.body = child.children.join('\n') if child.name is 'body'

      @emit 'message', message if message.body

  createReply: (to, text) ->
    new xmpp.Element('message', to: to, type: 'chat')
      .c('body').t(text)

bots = require '../src'
robot = bots.createBot 'robot'
{testCase} = require 'nodeunit'

module.exports = testCase
  setUp: (next) ->
    robot.reset next

  'test making robots': (test) ->
    test.expect 12
    test.equal 0, robot.handlers.length
    test.equal 0, Object.keys(robot.descriptions).length

    robot.desc 'testing', 'no-op for testing'
    test.equal 1, Object.keys(robot.descriptions).length

    robot.hear /testing/, ->
    test.equal 1, robot.handlers.length

    robot.desc 'hello', 'a friendly hello'
    test.equal 2, Object.keys(robot.descriptions).length

    robot.hear /hello/, (msg) -> msg.say('hello!')
    test.equal 2, robot.handlers.length

    for handler in robot.handlers
      test.ok Array.isArray(handler)
      test.equal 2, handler.length
      test.ok handler[0].exec

    test.done()

  'test adding interfaces': (test) ->
    robot.use bots.cli()
    test.equal 1, robot.interfaces.length
    test.done()

  'test dispatching simple commands': (test) ->
    test.expect(1)
    robot.interfaces = []
    robot.hear /hello/, (msg) ->
      test.equal 'hello', msg.match[0]
      test.done()

    robot.dispatch body: 'hello there'

  'test dispatching commands with matches': (test) ->
    robot.hear /where is (.+)/, (msg) ->
      test.ok msg.body.match(/where is/)
      test.equal 'wally', msg.match[1]
      test.done()

    robot.dispatch body: 'not this one'
    robot.dispatch body: 'where is wally'

  'test bot start event': (test) ->
    robot.on 'start', ->
      test.done()

    robot.start()

class window.Road extends Modular
	draw: (ctx) ->
		mid = (@h/2)
		shoulderWidth = @h/16
		bottomShoulder = @h-shoulderWidth
		lineWidth = @h/20
		stopLineOffset = 11
		stopLineWidth = 4
		crosswalkOffsetA = 3
		crosswalkOffsetB = 7
		ctx.translate 0,-mid
		ctx.fillRect 0,0,@w,@h
		ctx.beginPath()
		ctx.strokeStyle = white
		ctx.lineWidth = lineWidth
		ctx.moveTo shoulderWidth*crosswalkOffsetB, shoulderWidth
		ctx.lineTo @w-shoulderWidth*crosswalkOffsetB, shoulderWidth
		ctx.moveTo shoulderWidth*crosswalkOffsetB, bottomShoulder
		ctx.lineTo @w-shoulderWidth*crosswalkOffsetB, bottomShoulder
		ctx.moveTo (shoulderWidth*crosswalkOffsetA), 0
		ctx.lineTo (shoulderWidth*crosswalkOffsetA), @h
		ctx.moveTo (shoulderWidth*crosswalkOffsetB), shoulderWidth
		ctx.lineTo (shoulderWidth*crosswalkOffsetB), bottomShoulder

		ctx.moveTo (@w-shoulderWidth*crosswalkOffsetB), shoulderWidth
		ctx.lineTo (@w-shoulderWidth*crosswalkOffsetB), bottomShoulder
		ctx.moveTo (@w-shoulderWidth*crosswalkOffsetA),0
		ctx.lineTo (@w-shoulderWidth*crosswalkOffsetA),@h
		ctx.stroke()
		ctx.closePath()

		ctx.beginPath()
		ctx.lineWidth = lineWidth*stopLineWidth
		ctx.moveTo shoulderWidth*stopLineOffset,shoulderWidth
		ctx.lineTo shoulderWidth*stopLineOffset,mid*1.02
		ctx.moveTo @w-shoulderWidth*stopLineOffset,mid*0.98
		ctx.lineTo @w-shoulderWidth*stopLineOffset,bottomShoulder
		ctx.stroke()
		ctx.closePath()

		ctx.beginPath()
		ctx.setLineDash [5,5]
		ctx.lineWidth = lineWidth
		ctx.moveTo shoulderWidth*stopLineOffset,mid
		ctx.lineTo @w - shoulderWidth*stopLineOffset,mid
		ctx.stroke()
		ctx.closePath()
	@mixin Drawable
	@mixin Quality

class window.LightCone extends Modular
	tick: (dt) ->
		@stroke null
		@fill null
	draw: (ctx) ->
		gradient = ctx.createRadialGradient( @w/2,0, 1, @w/2,0, @w/2 )
		gradient.addColorStop 0, LIGHT_COLOR(@quality*.9)
		gradient.addColorStop 1, LIGHT_COLOR(0)
		ctx.fillStyle = gradient
		ctx.fillRect 0,0,@w,@h
	@mixin Drawable
	@mixin Quality

class window.StreetLight extends Modular
	tick: (dt) ->
		@quality = $.random.coin(.995)
		@strokeStyle = null
		@fillStyle = null
	draw: (ctx) ->
		ctx.beginPath()
		ctx.moveTo x1,0
		ctx.lineTo x2,y1
		ctx.lineTo x2,4
		ctx.lineWidth = 2
		ctx.strokeStyle = "rgba(0,0,0,.8)"
		ctx.stroke()
		ctx.closePath()

		ctx.beginPath()
		ctx.moveTo x1+1,0
		ctx.lineTo x2-2,y1+2
		ctx.lineTo x2-2,4
		ctx.strokeStyle = LIGHT_COLOR(@quality*.6)
		ctx.stroke()
		ctx.closePath()

		ctx.beginPath()
		ctx.strokeStyle = LIGHT_COLOR(@quality)
		ctx.lineWidth = 4
		ctx.arc x2,0,y2,0,Math.PI
		ctx.closePath()
		ctx.stroke()
	@mixin LightCone

class window.Sidewalk extends Modular
	draw: (ctx) ->
		ctx.fillStyle = "lightgrey"
		ctx.fillRect 0,0,@w,@h
		ctx.beginPath()
		ctx.lineWidth = 1
		ctx.strokeStyle = "darkgrey"
		for i in [@h...@w] by @h*1.3
			ctx.moveTo i,0
			ctx.lineTo i,@h
		ctx.stroke()
		ctx.closePath()
	@mixin Drawable

class window.PineTree extends Modular
	draw: (ctx) ->
		unless @gradient
			@gradient = g = ctx.createRadialGradient()
			g.addColorStop 0, "rgb(10,50,10)"
			g.addColorStop 1, "forestgreen"
		ctx.translate @w/2,@h/2
		ctx.beginPath()
		ctx.moveTo -2, 0
		ctx.lineTo 2, -@h/2
		ctx.lineTo 3, 0
		ctx.lineTo -2, 0
		ctx.fillStyle = "rgb(100,10,10)"
		ctx.fill()
		ctx.closePath()

	@mixin Managed

class window.Grass extends Modular
	drawUncached: (ctx) ->
		@ttl -1
		ctx.fillStyle = "rgb(150,255,150)"
		ctx.fillRect 0,0,@w,@h
		ctx.beginPath()
		ctx.lineWidth = 1
		scatter = [2, 5]
		for x in [0...@w] by $.random.integer 8,13
			for y in [0...@h] by $.random.integer 8,13
				x = $.random.integer 0,@w
				y = $.random.integer 0,@h

				ctx.beginPath()
				ctx.strokeStyle = "rgb(100,10,10)"
				ctx.moveTo x,y
				ctx.lineTo x,y-4
				ctx.stroke()
				ctx.closePath()

				ctx.beginPath()
				ctx.strokeStyle = "rgb(10,100,10)"
				ctx.moveTo x, y-19
				ctx.lineTo x-3, y
				ctx.moveTo x, y-19
				ctx.lineTo x+3, y
				ctx.stroke()

		ctx.closePath()
		
	@mixin Managed
	@mixin Quality
	@mixin Cached
	@mixin Elapsed

class Intersection extends Modular
	draw: (ctx) ->
		ctx.translate -@w,-@h/2
		ctx.fillRect 0,0,@w,@h
	@mixin Drawable
	@mixin Quality


class Clock extends $.EventEmitter
	requestInterval = window.requestAnimationFrame or
		window.mozRequestAnimationFrame or
		window.webkitRequestAnimationFrame or
		window.msRequestAnimationFrame or
		(f) -> window.setTimeout f, 1000/60

	cancelInterval = window.cancelAnimationFrame or
		window.mozCancelAnimationFrame or
		window.webkitCancelAnimationFrame or
		window.msCancelAnimationFrame or
		window.clearTimeout

	constructor: ->
		@interval = null
	start: ->
		return if @interval
		t = $.now
		ticker = =>
			t += (dt = $.now - t)
			@emit 'tick', dt
			interval = requestInterval ticker
		interval = requestInterval ticker
		@
	stop: ->
		return unless @interval
		cancelInterval @interval
		@interval = null
		@
	toggle: ->
		if @interval then @stop() else @start()




class Game extends Clock

	constructor: (opts) ->
		$.extend @, $.extend {
			w: 640
			h: 480
		}, opts
		@objects = $()
		@on 'tick', (dt) ->
			obj.tick(dt) for obj in @objects
			@remove(@dying.pop()) while @dying.length > 0
			obj.draw() for obj in @objects
			null
	add: (items...) ->
		for item in items then do (item) ->
			item.on 'death', =>
				@dying.push(item)
			@objects.splice ($.sortedIndex @objects, item, 'z'), 0, item
			@objects.emit 'birth', item
		@
	remove: (item) ->
		if (i = @objects.indexOf item) > -1
			@objects.splice i, 1
			@objects.emit 'death', item

$(document).ready ->
	window.game = new Game w: window.innerWidth, h: window.innerHeight

	game.tick(16.66)
class Label extends GameObject
	constructor: -> super @
	text: chain (text) ->
		@label = text
	draw: (ctx) ->
		ctx.fillText @label, @pos...
try require 'bling'

$.mixin = (a, b) ->
	for field,func of b
		continue if field in $.mixin.reservedWords
		continue unless $.is 'function', func
		a[field] = Aspects a[field], func
	a
$.mixin.reservedWords = [ 'constructor', '__super__' ]
Function::mixin = (obj) ->
	$.mixin @::, obj::
	@

emptyArray = []
Aspects = (funcs...) ->
	funcs = $(funcs).filter(-> $.is 'function', @)
	ret = $.extend ( (args...) ->
		x = null
		for func in funcs
			x = func.apply(@, args) or x
			if x?.constructor is Aspects.Op
				switch x.op
					when "arguments" then args = x.value
					when "abort" then return null
		x
	),
		chain: funcs
	for i in [0...funcs.length] by 1
		if funcs[i].chain
			a = funcs[i].chain.length - 1
			funcs.splice i, 1, funcs[i].chain...
			i += a
	for func in funcs
		p = ret::
		for k,v of (func::) when $.is 'function', v
			if k of p
				p[k] = Aspects p[k], v
			else
				p[k] = v
	ret
	constructor: (@op, @value) ->

if module?
	$.extend module.exports, {Aspects}



Object.keys or= (o) -> (k for k of o)

Object.values or= (o) -> (o[k] for k of o)

extend = (a, b) ->
	if b then a[k] = v for k,v of b when v?
	a






	constructor: (args...) ->
		return Bling.hook "bling-init", args

Bling.prototype = []
Bling.prototype.constructor = Bling
Bling.global = if window? then window else global





Bling.plugin = (opts, constructor) ->
	if not constructor
		constructor = opts
		opts = {}

	if "depends" of opts
		return @depends opts.depends, =>
			@plugin { provides: opts.provides }, constructor
	try
		if (plugin = constructor?.call @,@)
			extend @, plugin?.$
			['$','name'].forEach (k) -> delete plugin[k]
			extend @::, plugin
			for key of plugin then do (key) =>
				@[key] or= (a...) => (@::[key].apply Bling(a[0]), a[1...])
			if opts.provides? then @provide opts.provides
	catch error
	@


do ->
	dep =
		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)

	Bling.depends = (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else
			dep.q.push (need) ->
				(needs.splice i, 1) if (i = needs.indexOf need) > -1
				return (needs.length is 0 and f)
		f

	Bling.provide = (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data


$ = Bling
Object.keys or= (o) -> (k for k of o)
Object.values or= (o) -> (o[k] for k of o)
extend = (a, b) ->
	if b then a[k] = v for k,v of b when v?
	a
	constructor: (args...) ->
		return Bling.hook "bling-init", args
Bling.prototype = []
Bling.prototype.constructor = Bling
Bling.global = if window? then window else global
Bling.plugin = (opts, constructor) ->
	if not constructor
		constructor = opts
		opts = {}
	if "depends" of opts
		return @depends opts.depends, =>
			@plugin { provides: opts.provides }, constructor
	try
		if (plugin = constructor?.call @,@)
			extend @, plugin?.$
			['$','name'].forEach (k) -> delete plugin[k]
			extend @::, plugin
			for key of plugin then do (key) =>
				@[key] or= (a...) => (@::[key].apply Bling(a[0]), a[1...])
			if opts.provides? then @provide opts.provides
	catch error
	@
do ->
	dep =
		q: []
		done: {}
		filter: (n) ->
			(if (typeof n) is "string" then n.split /, */ else n)
			.filter (x) -> not (x of dep.done)
	Bling.depends = (needs, f) ->
		if (needs = dep.filter needs).length is 0 then f()
		else
			dep.q.push (need) ->
				(needs.splice i, 1) if (i = needs.indexOf need) > -1
				return (needs.length is 0 and f)
		f
	Bling.provide = (needs, data) ->
		for need in dep.filter needs
			dep.done[need] = i = 0
			while i < dep.q.length
				if (f = dep.q[i] need)
					dep.q.splice i,1
					f data
				else i++
		data
$ = Bling
$.plugin
	provides: "EventEmitter"
	depends: "type,hook"
, ->
	$: EventEmitter: $.hook("bling-init").append (obj = Object.create(null)) ->
		listeners = {}
		list = (e) -> (listeners[e] or= [])
		$.inherit {
			emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
			addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
			on:                 (e, h) -> @addListener e, h
			removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
			removeAllListeners: (e) -> listeners[e] = []
			listeners:          (e) -> list(e).slice 0
		}, obj
$.plugin
	provides: "cartesian"
, ->
	$:
		cartesian: (sets...) ->
			n = sets.length
			ret = []
			helper = (cur, i) ->
				(return ret.push cur) if ++i >= n
				for x in sets[i]
					helper (cur.concat x), i
				null
			helper [], -1
			return $(ret)
$.plugin ->
	String::trimLeft or= -> @replace(/^\s+/, "")
	String::split or= (sep) ->
		a = []; i = 0
		while (j = @indexOf sep,i) > -1
			a.push @substring(i,j)
			i = j + 1
		a
	String::lastIndexOf or= (s, c, i = -1) ->
		j = -1
		j = i while (i = s.indexOf c, i+1) > -1
		j
	Array::join or= (sep = '') ->
		n = @length
		return "" if n is 0
		s = @[n-1]
		while --n > 0
			s = @[n-1] + sep + s
		s
	if Event?
		Event::preventAll = () ->
			@preventDefault()
			@stopPropagation()
			@cancelBubble = true
	if Element?
		Element::matchesSelector = Element::webkitMatchesSelector or
			Element::mozMatchesSelector or
			Element::matchesSelector
		if Element::cloneNode.length is 0
			oldClone = Element::cloneNode
			Element::cloneNode = (deep = false) ->
				n = oldClone.call(@)
				if deep
					for i in @childNodes
						n.appendChild i.cloneNode true
				return n
	return { }
$.plugin
	provides: 'config'
	depends: 'type'
, ->
	get = (name, def) -> process.env[name] ? def
	$: config: $.extend(get, get: get)
$.plugin
	provides: "core"
	depends: "string"
, ->
	$.defineProperty $, "now",
		get: -> +new Date
	index = (i, o) ->
		i += o.length while i < 0
		Math.min i, o.length
	baseTime = $.now
	return {
		$:
			log: $.extend((a...) ->
				if prefix.length > $.log.prefixSize + 2
				if a.length and $.is "string", a[0]
				else
					a.unshift prefix
				console.log a...
				return a[a.length-1] if a.length
			, prefixSize: 5)
			coalesce: (a...) -> $(a).coalesce()
			keysOf: (o) -> $(k for k of o)
			valuesOf: (o) -> $.keysOf(o).map (k)->
				return try o[k] catch err then err
		eq: (i) -> $([@[index i, @]])
		each: (f) -> (f.call(t,t) for t in @); @
		map: (f) ->
			b = $()
			for t in @
				b.push f.call t,t
			b
		filterMap: (f) ->
			b = $()
			for t in @
				v = f.call t,t
				if v?
					b.push v
			b
		replaceWith: (array) ->
			for i in [0...array.length] by 1
				@[i] = array[i]
		reduce: (f, a) ->
			i = 0; n = @length
			a = @[i++] if not a?
			(a = f.call @[x], a, @[x]) for x in [i...n] by 1
			return a
		union: (other, strict = true) ->
			ret = $()
			ret.push(x) for x in @ when not ret.contains(x, strict)
			ret.push(x) for x in other when not ret.contains(x, strict)
			ret
		distinct: (strict = true) -> @union @, strict
		contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
		count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
		coalesce: ->
			for i in @
				if $.is('array',i) or $.is('bling',i) then i = $(i).coalesce()
				if i? then return i
			null
		swap: (i,j) ->
			i = index i, @
			j = index j, @
			if i isnt j
				[@[i],@[j]] = [@[j],@[i]]
			@
		shuffle: ->
			i = @length-1
			while i >= 0
				@swap --i, Math.floor(Math.random() * i)
			@
		select: (->
			getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
			select = (p) ->
				if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
				else @map(getter p)
		)()
		or: (x) -> @[i] or= x for i in [0...@length]; @
		zap: (p, v) ->
			i = p.lastIndexOf "."
			if i > 0
				head = p.substr 0,i
				tail = p.substr i+1
				@select(head).zap tail, v
				return @
			switch $.type(v)
				when "array","bling" then @each -> @[p] = v[++i % v.length]
				when "function" then @zap p, @select(p).map(v)
				else @each -> @[p] = v
			@
		clean: (prop) -> @each -> delete @[prop]
		take: (n = 1) ->
			end = Math.min n, @length
			$( @[i] for i in [0...end] by 1 )
		skip: (n = 0) ->
			start = Math.max 0, n|0
			$( @[i] for i in [start...@length] by 1 )
		first: (n = 1) -> if n is 1 then @[0] else @take(n)
		last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)
		slice: (start=0, end=@length) ->
			start = index start, @
			end = index end, @
			$( @[i] for i in [start...end] )
		extend: (b) -> @.push(i) for i in b; @
		push: (b) -> Array::push.call(@, b); @
		filter: (f) ->
			g = switch $.type f
				when "string" then (x) -> x.matchesSelector(f)
				when "regexp" then (x) -> f.test(x)
				when "function" then f
			$( it for it in @ when g.call(it,it) )
		matches: (expr) ->
			switch $.type expr
				when "string" then @select('matchesSelector').call(expr)
				when "regexp" then @map (x) -> expr.test x
		querySelectorAll: (expr) ->
			@filter("*")
			.reduce (a, i) ->
				a.extend i.querySelectorAll expr
			, $()
		weave: (b) ->
			c = $()
			for i in [@length-1..0] by -1
				c[(i*2)+1] = @[i]
			for i in [0...b.length] by 1
				c[i*2] = b[i]
			c
		fold: (f) ->
			n = @length
			b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
			if (n%2) is 1
				b.push( f.call @, @[n-1], undefined )
			b
		flatten: ->
			b = $()
			(b.push(j) for j in i) for i in @
			b
		call: -> @apply(null, arguments)
		apply: (context, args) ->
			@filterMap ->
				if $.is 'function', @ then @apply(context, args)
				else null
		log: (label) ->
			if label
				$.log(label, @toString(), @length + " items")
			else
				$.log(@toString(), @length + " items")
			@
		toArray: ->
			@__proto__ = Array::
	}
$.plugin
	provides: 'date'
	depends: 'type'
, ->
	[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]
	units = {
		ms, s, m, h, d,
		sec: s
		second: s
		seconds: s
		min: m
		minute: m
		minutes: m
		hr: h
		hour: h
		hours: h
		day: d
		days: d
	}
	formats =
		yyyy: Date::getUTCFullYear
		mm: -> @getUTCMonth() + 1
		dd: Date::getUTCDate
		HH: Date::getUTCHours
		MM: Date::getUTCMinutes
		SS: Date::getUTCSeconds
		MS: Date::getUTCMilliseconds
	format_keys = Object.keys(formats).sort().reverse()
	parsers =
		yyyy: Date::setUTCFullYear
		mm: (x) -> @setUTCMonth(x - 1)
		dd: Date::setUTCDate
		HH: Date::setUTCHours
		MM: Date::setUTCMinutes
		SS: Date::setUTCSeconds
		MS: Date::setUTCMilliseconds
	parser_keys = Object.keys(parsers).sort().reverse()
	floor = Math.floor
	$.type.register "date",
		match: (o) -> $.isType Date, o
		array: (o) -> [o]
		string: (o, fmt, unit) -> $.date.format o, fmt, unit
		number: (o, unit) -> $.date.stamp o, unit
	$.type.extend 'string', date: (o, fmt = $.date.defaultFormat) -> new Date $.date.parse o, fmt, "ms"
	$.type.extend 'number', date: (o, unit) -> $.date.unstamp o, unit
	adder = (key) ->
		(stamp, delta, stamp_unit = $.date.defaultUnit) ->
			date = $.date.unstamp(stamp, stamp_unit)
			parsers[key].call date, (formats[key].call date) + delta
			$.date.stamp date, stamp_unit
	$:
		date:
			defaultUnit: "s"
			defaultFormat: "yyyy-mm-dd HH:MM:SS"
			stamp: (date = new Date, unit = $.date.defaultUnit) ->
				floor (date / units[unit])
			unstamp: (stamp, unit = $.date.defaultUnit) ->
				new Date floor(stamp * units[unit])
			convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
				(floor stamp * units[from] / units[to])
			midnight: (stamp, unit = $.date.defaultUnit) ->
				$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
			format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
				date = $.date.unstamp stamp, unit
				for k in format_keys
					fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
				fmt
			parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
				date = new Date(0)
				for i in [0...fmt.length] by 1
					for k in parser_keys
						if fmt.indexOf(k, i) is i
							try
								parsers[k].call date,
									parseInt dateString[i...i+k.length], 10
							catch err
				$.date.stamp date, to
			addMilliseconds: adder("MS")
			addSeconds: adder("SS")
			addMinutes: adder("MM")
			addHours: adder("HH")
			addDays: adder("dd")
			addMonths: adder("mm")
			addYears: adder("yyyy")
			range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
				add = adder(interval_unit)
				ret = [from]
				while (cur = ret[ret.length-1]) < to
					ret.push add(cur, interval, stamp_unit)
				ret
	midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
	unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
	stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
	dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
	dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)
$.plugin
	provides: "delay"
	depends: "function"
, ->
	$:
		delay: (->
			timeoutQueue = $.extend [], (->
				next = (a) -> -> a.shift()() if a.length
				add: (f, n) ->
					f.order = n + $.now
					for i in [0..@length] by 1
						if i is @length or @[i].order > f.order
							@splice i,0,f
							break
					setTimeout next(@), n
					@
				cancel: (f) ->
					for i in [0...@length] by 1
						if @[i] == f
							@splice i, 1
							break
					@
			)()
			(n, f) ->
				if $.is("function",f) then timeoutQueue.add(f, n)
				cancel: -> timeoutQueue.cancel(f)
		)()
	delay: (n, f, c=@) ->
		$.delay n, $.bound(c, f)
		@
	interval: (n, f, c=@) ->
		g = $.bound c, f
		h = -> g(); $.delay n, h
		$.delay n, h
		@
if $.global.document?
	$.plugin
		depends: "function,type"
		provides: "dom"
	, ->
		$.type.register "nodelist",
			match:  (o) -> o? and $.isType "NodeList", o
			hash:   (o) -> $($.hash(i) for i in x).sum()
			array:  $.identity
			string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
			node:   (o) -> $(o).toFragment()
		$.type.register "node",
			match:  (o) -> o?.nodeType > 0
			hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "fragment",
			match:  (o) -> o?.nodeType is 11
			hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "html",
			match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
			node:   (h) ->
				(node = document.createElement('div')).innerHTML = h
				if n = (childNodes = node.childNodes).length is 1
					return node.removeChild(childNodes[0])
				df = document.createDocumentFragment()
				df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
				df
			array:  (o) -> $.type.lookup(h = Bling.HTML.parse o).array h
			repr:   (o) -> '"' + o + '"'
		$.type.extend
			unknown:  { node: -> null }
			bling:    { node: (o) -> o.toFragment() }
			node:     { html: (n) ->
				d = document.createElement "div"
				d.appendChild (n = n.cloneNode true)
				ret = d.innerHTML
				ret
			}
			string:
				node:  (o) -> $(o).toFragment()
				array: (o) -> document.querySelectorAll? o
			function: { node: (o) -> $(o.toString()).toFragment() }
		toFrag = (a) ->
			if not a.parentNode?
				df = document.createDocumentFragment()
				df.appendChild a
			a
		before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
		after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
		toNode = (x) -> $.type.lookup(x).node x
		escaper = false
		parser = false
		computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue k
		getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select p
		selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )
		return {
			$:
				HTML:
					parse: (h) -> $.type.lookup(h).node h
					stringify: (n) -> $.type.lookup(n).html n
					escape: (h) ->
						escaper or= $("<div>&nbsp;</div>").child 0
						ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
						escaper.zap('data', '')
						ret
			html: (h) ->
				return switch $.type h
					when "undefined","null" then @select 'innerHTML'
					when "string","html" then @zap 'innerHTML', h
					when "bling" then @html h.toFragment()
					when "node"
							@replaceChild @childNodes[0], h
							while @childNodes.length > 1
								@removeChild @childNodes[1]
				@each -> @appendChild x.cloneNode true
				clones = @map( -> @cloneNode true)
				i = 0
				$(x).each -> @appendChild clones[i++]
				clones
				if x?
					x = toNode x
					@take(1).each ->
						before @childNodes[0], x
					@skip(1).each ->
						before @childNodes[0], x.cloneNode true
				@
				if x?
					$(x).prepend(@)
				@
				if x?
					x = toNode x
					@take(1).each -> before @, x
					@skip(1).each -> before @, x.cloneNode true
				@
				if x?
					x = toNode x
					@take(1).each -> after @, x
					@skip(1).each -> after @, x.cloneNode true
				@
				parent = toNode parent
				if $.is "fragment", parent
					throw new Error("cannot call .wrap() with a fragment as the parent")
				@each (child) ->
					if ($.is "fragment", child) or not child.parentNode
						return parent.appendChild child
					grandpa = child.parentNode
					marker = document.createElement "dummy"
					parent.appendChild grandpa.replaceChild marker, child
					grandpa.replaceChild parent, marker
				@each ->
					if @parentNode and @parentNode.parentNode
						@parentNode.parentNode.replaceChild(@, @parentNode)
					else if @parentNode
						@parentNode.removeChild(@)
				n = toNode n
				clones = @map(-> n.cloneNode true)
				for i in [0...clones.length] by 1
					@[i].parentNode?.replaceChild clones[i], @[i]
				clones
				return switch v
					when undefined then @select("getAttribute").call(a, v)
					when null then @select("removeAttribute").call(a, v)
					else
						@select("setAttribute").call(a, v)
						@
				notempty = (y) -> y isnt ""
				@removeClass(x).each ->
					c = @className.split(" ").filter notempty
					c.push x
					@className = c.join " "
				notx = (y) -> y != x
				@each ->
					c = @className.split(" ").filter(notx).join(" ")
					if c.length is 0
						@removeAttribute('class')
				notx = (y) -> y isnt x
				@each ->
					cls = @className.split(" ")
					filter = $.not $.isEmpty
					if( cls.indexOf(x) > -1 )
						filter = $.and notx, filter
					else
						cls.push x
					c = cls.filter(filter).join(" ")
					@className = c
					if c.length is 0
						@removeAttribute('class')
				@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1
				return @zap('textContent', t) if t?
				return @select('textContent')
				return @zap('value', v) if v?
				return @select('value')
			css: (k,v) ->
				if v? or $.is "object", k
					setter = @select 'style.setProperty'
					if $.is "object", k then setter.call i, k[i], "" for i of k
					else if $.is "string", v then setter.call k, v, ""
					else if $.is "array", v
						setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
					return @
				else
					cv = @map computeCSSProperty k
					ov = @select('style').select k
					ov.weave(cv).fold (x,y) -> x or y
			defaultCss: (k, v) ->
				sel = @selector
				style = ""
				if $.is "string", k
					if $.is "string", v
					else throw Error("defaultCss requires a value with a string key")
				else if $.is "object", k
					"} "
				$("<style></style>").text(style).appendTo("head")
				@
			rect: -> @select('getBoundingClientRect').call()
			width: getOrSetRect("width")
			height: getOrSetRect("height")
			top: getOrSetRect("top")
			left: getOrSetRect("left")
			bottom: getOrSetRect("bottom")
			right: getOrSetRect("right")
			position: (left, top) ->
				switch true
					when not left? then @rect()
					when not top? then @css("left", $.px(left))
					else @css({top: $.px(top), left: $.px(left)})
			scrollToCenter: ->
				document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
				@
			child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]
			parents: selectChain('parentNode')
			prev: selectChain('previousSibling')
			next: selectChain('nextSibling')
			remove: -> @each -> @parentNode?.removeChild(@)
			find: (css) ->
				@filter("*")
					.map( -> $(css, @) )
					.flatten()
			clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @
			toFragment: ->
				if @length > 1
					df = document.createDocumentFragment()
					(@map toNode).map $.bound df, df.appendChild
					return df
				return toNode @[0]
		}
$.plugin
	depends: "dom,function,core"
	provides: "event"
, ->
	EVENTSEP_RE = /,* +/
	events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
		'load','unload','reset','submit','keyup','keydown','change',
		'abort','cut','copy','paste','selection','drag','drop','orientationchange',
		'touchstart','touchmove','touchend','touchcancel',
		'gesturestart','gestureend','gesturecancel',
		'hashchange'
	]
	binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)
	register_live = (selector, context, evt, f, h) ->
		$(context).bind(evt, h)
			.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h
	unregister_live = (selector, context, e, f) ->
		$c = $(context)
		$c.each ->
			a = (@__alive__ or= {})
			b = (a[selector] or= {})
			c = (b[e] or= {})
			$c.unbind(e, c[f])
			delete c[f]
	triggerReady = $.once ->
		$(document).trigger("ready").unbind("ready")
		document.removeEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.removeEventListener?("load", triggerReady, false)
	bindReady = $.once ->
		document.addEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.addEventListener?("load", triggerReady, false)
	bindReady()
	ret = {
		bind: (e, f) ->
			c = (e or "").split(EVENTSEP_RE)
			h = (evt) ->
				ret = f.apply @, arguments
				if ret is false
					evt.preventAll()
				ret
			@each -> (@addEventListener i, h, false) for i in c
		unbind: (e, f) ->
			c = (e or "").split EVENTSEP_RE
			@each -> (@removeEventListener i, f, null) for i in c
		trigger: (evt, args = {}) ->
			args = $.extend
				bubbles: true
				cancelable: true
			, args
			for evt_i in (evt or "").split(EVENTSEP_RE)
					e = document.createEvent "MouseEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						button: 0,
						relatedTarget: null
					, args
					e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.button, args.relatedTarget
					e = document.createEvent "UIEvents"
					e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1
					e = document.createEvent "TouchEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						touches: [],
						targetTouches: [],
						changedTouches: [],
						scale: 1.0,
						rotation: 0.0
					, args
					e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)
					e = document.createEvent "GestureEvents"
					args = $.extend {
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						target: null,
						scale: 1.0,
						rotation: 0.0
					}, args
					e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.target, args.scale, args.rotation
				else
					e = document.createEvent "Events"
					e.initEvent evt_i, args.bubbles, args.cancelable
					try
						e = $.extend e, args
					catch err
				if not e
					continue
				else
					try
						@each -> @dispatchEvent e
					catch err
						$.log "dispatchEvent error:", err
			@
		live: (e, f) ->
			selector = @selector
			context = @context
			handler = (evt) ->
				$(selector, context)
					.intersect($(evt.target).parents().first().union($(evt.target)))
					.each -> f.call(evt.target = @, evt)
			register_live selector, context, e, f, handler
			@
		die: (e, f) ->
			$(@context).unbind e, unregister_live(@selector, @context, e, f)
			@
		click: (f = {}) ->
			if @css("cursor") in ["auto",""]
				@css "cursor", "pointer"
			if $.is "function", f then @bind 'click', f
			else @trigger 'click', f
			@
		ready: (f) ->
			return (f.call @) if triggerReady.exhausted
			@bind "ready", f
	}
	events.forEach (x) -> ret[x] = binder(x)
	return ret
$.plugin
	provides: "function"
	depends: "hash"
, ->
	$:
		identity: (o) -> o
		not: (f) -> -> not f.apply @, arguments
		compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
		and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
		once: (f, n=1) ->
			$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
				"exhausted",
					get: -> n <= 0
		cycle: (f...) ->
			i = -1
			-> f[i = ++i % f.length].apply @, arguments
		bound: (t, f, args = []) ->
			if $.is "function", f.bind
				args.splice 0, 0, t
				r = f.bind.apply f, args
			else
				r = (a...) -> f.apply t, (args if args.length else a)
		memoize: (f) ->
			cache = {}
		E: (callback) -> (f) -> (err, data) ->
			return f(data) unless err
			callback err, data
$.plugin
	provides: "groupBy"
, ->
	groupBy: (key) ->
		groups = {}
		switch $.type key
			when 'array','bling'
				@each ->
					c = (@[k] for k in key).join ","
					(groups[c] or= $()).push @
			else @each -> (groups[@[key]] or= $()).push @
		return $.valuesOf groups
$.plugin
	provides: "hash"
	depends: "type"
, ->
	$.type.extend
		unknown: { hash: (o) -> $.checksum $.toString o }
		object:  { hash: (o) ->
			$.hash(Object) +
				$($.hash(o[k]) for k of o).sum() +
				$.hash Object.keys o
		}
		array:   { hash: (o) ->
			$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
				(a*a)+(x|0)
			, 1
		}
		bool:    { hash: (o) -> parseInt(1 if o) }
	return {
		$:
			hash: (x) -> $.type.lookup(x).hash(x)
		hash: -> $.hash @
	}
$.plugin ->
	$:
		histogram: (data, bucket_width=1, output_width=80) ->
			buckets = $()
			len = 0
			for x in data
				i = Math.floor( x / bucket_width )
				buckets[i] ?= 0
				buckets[i] += 1
				len = Math.max(len, i+1)
			buckets.length = len
			max = buckets.max()
			buckets = buckets.map((x) -> x or 0)
				.scale(1/max)
				.scale(output_width)
			sum = buckets.sum()
			ret = ""
			pct_sum = 0
			for n in [0...len] by 1
				end = (n+1) * bucket_width
				pct = (buckets[n]*100/sum)
				pct_sum += pct
			ret
	histogram: -> $.histogram @
$.plugin
	provides: "hook"
	depends: "type"
, ->
	hooks = {}
	hook = (name, args) ->
		p = (hooks[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args
	hook("bling-init").prepend (args) ->
		if args.length is 1
			args = $.type.lookup(args[0]).array(args[0])
		$.inherit Bling, args
	$: hook: hook
$.plugin
	depends: "dom"
	provides: "http"
, ->
	$.type.register "http",
		match: (o) -> $.isType 'XMLHttpRequest', o
		array: (o) -> [o]
	return {
		$:
			http: (url, opts = {}) ->
				xhr = new XMLHttpRequest()
				if $.is "function", opts
					opts = success: $.bound(xhr, opts)
				opts = $.extend {
					method: "GET"
					data: null
					async: true
					asBlob: false
					followRedirects: false
					withCredentials: false
				}, opts
				opts.state = $.bound(xhr, opts.state)
				opts.success = $.bound(xhr, opts.success)
				opts.error = $.bound(xhr, opts.error)
				if opts.data and opts.method is "GET"
					url += "?" + formencode(opts.data)
				else if opts.data and opts.method is "POST"
					opts.data = formencode(opts.data)
				xhr.open(opts.method, url, opts.async)
				xhr = $.extend xhr,
					asBlob: opts.asBlob
					timeout: opts.timeout
					followRedirects: opts.followRedirects
					withCredentials: opts.withCredentials
					onreadystatechange: ->
						opts.state?()
						if xhr.readyState is 4
							if xhr.status is 200
								opts.success xhr.responseText
							else
								opts.error xhr.status, xhr.statusText
				xhr.send opts.data
				return $(xhr)
			post: (url, opts = {}) ->
				if $.is("function",opts)
					opts = success: opts
				opts.method = "POST"
				$.http(url, opts)
			get: (url, opts = {}) ->
				if( $.is("function",opts) )
					opts = success: opts
				opts.method = "GET"
				$.http(url, opts)
	}
$.depends 'hook', ->
	$.hook('bling-init').append (obj) ->
		map = Object.create(null)
		keyMakers = []
		$.inherit {
			index: (keyFunc) ->
				if keyMakers.indexOf(keyFunc) is -1
					keyMakers.push keyFunc
					map[keyFunc] = Object.create(null)
				@each (x) ->
					map[keyFunc][keyFunc(x)] = x
			query: (criteria) ->
				for keyMaker in keyMakers
					key = keyMaker(criteria)
					return map[keyMaker][key] if key of map[keyMaker]
				null
		}, obj
$.plugin
	depends: "dom"
	provides: "lazy"
, ->
	lazy_load = (elementName, props) ->
		$("head").append $.extend document.createElement(elementName), props
	$:
		script: (src) ->
			lazy_load "script", { src: src }
		style: (src) ->
			lazy_load "link", { href: src, rel: "stylesheet" }
$.plugin
	provides: "math"
	depends: "core"
, ->
	$.type.extend
		bool: { number: (o) -> if o then 1 else 0 }
		number: { bool: (o) -> not not o }
	_By = (cmp) ->
		(field) ->
			valueOf = switch $.type field
				when "string" then (o) -> o[field]
				when "function" then field
				else throw new Error ".maxBy first argument should be a string or function"
			x = @first()
			@skip(1).each ->
				if cmp valueOf(@), valueOf(x)
					x = @
			return x
	$:
		range: (start, end, step = 1) ->
			if not end? then (end = start; start = 0)
			$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
		zeros: (n) -> $( 0 for i in [0...n] )
		ones: (n) -> $( 1 for i in [0...n] )
		deg2rad: (n) -> n * Math.PI / 180
		rad2deg: (n) -> n * 180 / Math.PI
	floats: -> @map parseFloat
	ints: -> @map -> parseInt @, 10
	px: (delta) -> @ints().map -> $.px @,delta
	min: -> @filter( isFinite ).reduce Math.min
	max: -> @filter( isFinite ).reduce Math.max
	maxBy: _By (a,b) -> a > b
	minBy: _By (a,b) -> a < b
	mean: mean = -> if not @length then 0 else @sum() / @length
	avg: mean
	sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
	product: -> @filter( isFinite ).reduce (a) -> a * @
	squares: -> @pow(2)
	pow: (n) -> @map -> Math.pow @, n
	magnitude: -> Math.sqrt @floats().squares().sum()
	scale: (r) -> @map -> r * @
	add: add = (d) -> switch $.type(d)
		when "number" then @map -> d + @
		when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
	plus: add
	vecAdd: (v) ->
		d = $()
		for i in [0...@length] by 1
			d[i] = @[i] + v[i]
		d
	normalize: -> @scale 1 / @magnitude()
	deg2rad: -> @filter( isFinite ).map -> @ * Math.PI / 180
	rad2deg: -> @filter( isFinite ).map -> @ * 180 / Math.PI
$.plugin
	provides: "pubsub"
, ->
	$:
		publish: (e, args...) ->
			f.apply null, args for f in (subscribers[e] or= [])
			args
		publisher: (e, func) ->
			(args...) ->
				$.publish e, func.apply @, args
		subscribe: (e, func) ->
			(subscribers[e] or= []).push func
			func
		unsubscribe: (e, func) ->
			if not func?
				subscribers[e] = []
			else
				a = (subscribers[e] or= [])
				if (i = a.indexOf func)  > -1
					a.splice(i,i)
$.plugin
	provides: 'random'
	depends: 'type'
, ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""
		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615
		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)
			index = (index + 1) % 624
			(y + a) / b
		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()
		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u
$.plugin
	provides: "sendgrid"
	depends: "config"
, ->
	try
		nodemailer = require 'nodemailer'
	catch err
		`return`
	transport = nodemailer.createTransport 'SMTP',
		service: 'SendGrid'
		auth:
			user: $.config.get 'SENDGRID_USERNAME'
	$:
		sendMail: (mail, callback) ->
			mail.transport ?= transport
			mail.from ?= $.config.get 'EMAILS_FROM'
			mail.bcc ?= $.config.get 'EMAILS_BCC'
			if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
				nodemailer.sendMail mail, callback
			else
$.plugin
	provides: "sortBy,sortedIndex"
, ->
	$:
		sortedIndex: (array, item, iterator) ->
			cmp = switch $.type iterator
				when "string" then (a,b) -> a[iterator] - b[iterator]
				when "function" then (a,b) -> iterator(a) - iterator(b)
				else (a,b) -> a - b
				if cmp(array[i], item) > 0
					return i
			return array.length
	sortBy: (iterator) ->
		a = $()
		for item in @
			n = $.sortedIndex a, item, iterator
			a.splice n, 0, item
		a
		
$.plugin
	provides: "string"
	depends: "function"
, ->
	safer = (f) ->
		(a...) ->
			try return f(a...)
	$.type.extend
		unknown:
			string: safer (o) -> o.toString?() ? String(o)
			repr: safer (o) -> $.type.lookup(o).string(o)
			number: safer (o) -> parseFloat String o
		null: { string: -> "null" }
		undefined: { string: -> "undefined" }
		string:
			number: safer parseFloat
		array:  { string: safer (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
		object: { string: safer (o) ->
			ret = []
			for k of o
				try
					v = o[k]
				catch err
			"{" + ret.join(', ') + "}"
		}
		function:
			string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
		number:
			repr:   (n) -> String(n)
			string: safer (n) ->
				switch true
					when n.precision? then n.toPrecision(n.precision)
					when n.fixed? then n.toFixed(n.fixed)
					else String(n)
	return {
		$:
			toString: (x) ->
				if not x? then "function Bling(selector, context) { [ ... ] }"
				else
					try
						$.type.lookup(x).string(x)
					catch err
			toRepr: (x) -> $.type.lookup(x).repr(x)
			px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"
			capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")
			dashize: (name) ->
				ret = ""
				for i in [0...(name?.length|0)]
					c = name.charCodeAt i
					if 91 > c > 64
						c += 32
						ret += '-'
					ret += String.fromCharCode(c)
				ret
			camelize: (name) ->
				name.split('-')
				while (i = name?.indexOf('-')) > -1
					name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
				name
			padLeft: (s, n, c = " ") ->
				while s.length < n
					s = c + s
				s
			padRight: (s, n, c = " ") ->
				while s.length < n
					s = s + c
				s
			stringTruncate: (s, n, c = "...") ->
				s = s.split(' ')
				r = []
				while n > 0
					x = s.shift()
					n -= x.length
					if n >= 0
						r.push x
				r.join('') + c
			stringCount: (s, x, i = 0, n = 0) ->
				if (j = s.indexOf x,i) > i-1
					$.stringCount s, x, j+1, n+1
				else n
			stringSplice: (s, i, j, n) ->
				nn = s.length
				end = j
				if end < 0
					end += nn
				start = i
				if start < 0
					start += nn
				s.substring(0,start) + n + s.substring(end)
			checksum: (s) ->
				a = 1; b = 0
				for i in [0...s.length]
					a = (a + s.charCodeAt(i)) % 65521
					b = (b + a) % 65521
				(b << 16) | a
			repeat: (x, n=2) ->
				switch true
					when n is 1 then x
					when n < 1 then ""
					when $.is "string", x then x + $.repeat(x, n-1)
					else $(x).extend $.repeat(x, n-1)
			stringBuilder: ->
				if $.is("global", @) then return new $.stringBuilder()
				items = []
				@length   = 0
				@append   = (s) => items.push s; @length += s?.toString().length|0
				@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
				@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
				@toString = ( ) => items.join("")
				@
		toString: -> $.toString @
		toRepr: -> $.toRepr @
	}
$.plugin
	provides: "symbol"
	depends: "type"
, ->
	symbol = null
	cache = {}
	g = $.global
	g.Bling = Bling
	if module?
		module.exports = Bling
	$.defineProperty $, "symbol",
		set: (v) ->
			g[symbol] = cache[symbol]
			cache[symbol = v] = g[v]
			g[v] = Bling
		get: -> symbol
	return $:
		symbol: "$"
		noConflict: ->
			Bling.symbol = "Bling"
			Bling
$.plugin
	provides: "StateMachine"
, ->
	$: StateMachine: class StateMachine
		constructor: (stateTable) ->
			@debug = false
			@reset()
			@table = stateTable
			Object.defineProperty @, "modeline",
				get: -> @table[@_mode]
			Object.defineProperty @, "mode",
				set: (m) ->
					@_lastMode = @_mode
					@_mode = m
					if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
						ret = @modeline['enter'].call @
						while $.is("function",ret)
							ret = ret.call @
					m
				get: -> @_mode
		reset: ->
			@_mode = null
			@_lastMode = null
		GO: (m) -> -> @mode = m
		@GO: (m) -> -> @mode = m
		
		tick: (c) ->
			row = @modeline
			if not row?
				ret = null
			else if c of row
				ret = row[c]
			else if 'def' of row
				ret = row['def']
			while $.is "function",ret
				ret = ret.call @, c
			ret
		run: (inputs) ->
			@mode = 0
			for c in inputs
				ret = @tick(c)
			if $.is "function",@modeline?.eof
				ret = @modeline.eof.call @
			while $.is "function",ret
				ret = ret.call @
			@reset()
			return @
$.plugin
	provides: "synth"
	depends: "StateMachine, type"
, ->
	class SynthMachine extends $.StateMachine
		basic =
			".": @GO 3
			"[": @GO 4
			'"': @GO 6
			"'": @GO 7
			" ": @GO 8
			",": @GO 10
			"+": @GO 11
			eof: @GO 13
		@STATE_TABLE = [
				enter: ->
					@tag = @id = @cls = @attr = @val = @text = ""
					@attrs = {}
					@GO 1
			},
				def: (c) -> @tag += c
			}, basic),
				def: (c) -> @id += c
			}, basic),
				enter: -> @cls += " " if @cls.length > 0
				def: (c) -> @cls += c
			}, basic),
				"=": @GO 5
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @attr += c
				eof: @GO 12
			},
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @val += c
				eof: @GO 12
			},
				'"': @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				"'": @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = null
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = @cursor?.parentNode
					@GO 0
			},
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
			}
		]
		constructor: ->
			super(SynthMachine.STATE_TABLE)
			@fragment = @cursor = document.createDocumentFragment()
		emitNode: ->
			if @tag
				node = document.createElement @tag
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@cursor.appendChild node
				@cursor = node
		emitText: ->
			@cursor.appendChild $.type.lookup("<html>").node(@text)
			@text = ""
	return {
		$:
			synth: (expr) ->
				s = new SynthMachine()
				s.run(expr)
				if s.fragment.childNodes.length == 1
					$(s.fragment.childNodes[0])
				else
					$(s.fragment)
	}
do ($ = Bling) ->
		current_engine = null
		engines = {}
		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine
		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()
		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop] by 1
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1
	$.template.register_engine 'pythonic', (() ->
		chunk_re = /%[\(\/]/
		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n] by 1
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}
			if not cache?
			n = cache.length
			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""
		return render
	)()
		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
$.plugin
	provides: "throttle"
	depends: "core"
, ->
	$:
		throttle: (ms, f) ->
			last = 0
			(a...) ->
				gap = $.now - last
				if gap > ms
					last += gap
					return f.apply @,a
				null
		debounce: (ms, f) ->
			last = 0
			(a...) ->
				last += (gap = $.now - last)
				return f.apply @,a if gap > ms else null
	parseOne = (data) ->
		i = data.indexOf ":"
		if i > 0
			len = parseInt data[0...i], 10
			item = data[i+1...i+1+len]
			type = data[i+1+len]
			extra = data[i+len+2...]
			item = switch type
				when "'" then String(item)
				when "!" then (item is "true")
				when "~" then null
				when "]" then parseArray(item)
				when "}" then parseObject(item)
			return [item, extra]
		return undefined
	parseArray = (x) ->
		data = []
		while x.length > 0
			[one, x] = parseOne(x)
			data.push(one)
		data
	parseObject = (x) ->
		data = {}
		while x.length > 0
			[key, x] = parseOne(x)
			[value, x] = parseOne(x)
			data[key] = value
		data
	$:
		TNET:
			stringify: (x) ->
				[data, type] = switch $.type x
					when "string" then [x, "'"]
					when "function" then [String(x), "'"]
					when "boolean" then [String(not not x), "!"]
					when "null" then ["", "~"]
					when "undefined" then ["", "~"]
					when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
					when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
				return (data.length|0) + ":" + data + type
			parse: (x) ->
				parseOne(x)?[0]
$.plugin
	provides: "trace"
	depends: "function,type"
, ->
	$.type.extend
		unknown: { trace: $.identity }
		function:
			trace: (label, f, tracer) ->
				label or= f.name
				r = (a...) ->
					f.apply @, a
				r
	return $: trace: (label, o, tracer) ->
		if not $.is "string", label
			[tracer, o] = [o, label]
		tracer or= $.log
		label or= ""
		$.type.lookup(o).trace(label, o, tracer)
$.plugin
	depends: "dom"
, ->
	COMMASEP = ", "
		"slow": 700
		"medium": 500
		"normal": 300
		"fast": 100
		"instant": 0
		"now": 0
	accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
	testStyle = document.createElement("div").style
	transformProperty = "transform"
	transitionProperty = "transition-property"
	transitionDuration = "transition-duration"
	transitionTiming = "transition-timing-function"
	if "WebkitTransform" of testStyle
		transformProperty = "-webkit-transform"
		transitionProperty = "-webkit-transition-property"
		transitionDuration = "-webkit-transition-duration"
		transitionTiming = "-webkit-transition-timing-function"
	else if "MozTransform" of testStyle
		transformProperty = "-moz-transform"
		transitionProperty = "-moz-transition-property"
		transitionDuration = "-moz-transition-duration"
		transitionTiming = "-moz-transition-timing-function"
	else if "OTransform" of testStyle
		transformProperty = "-o-transform"
		transitionProperty = "-o-transition-property"
		transitionDuration = "-o-transition-duration"
		transitionTiming = "-o-transition-timing-function"
	return {
		$:
			duration: (speed) ->
				d = speeds[speed]
				return d if d?
				return parseFloat speed
		transform: (end_css, speed, easing, callback) ->
			if $.is("function",speed)
				callback = speed
				speed = easing = null
			else if $.is("function",easing)
				callback = easing
				easing = null
			speed ?= "normal"
			easing or= "ease"
			duration = $.duration(speed) + "ms"
			props = []
			trans = ""
			css = {}
			for i of end_css
				if accel_props_re.test(i)
					ii = end_css[i]
					if ii.join
						ii = $(ii).px().join COMMASEP
					else if ii.toString
						ii = ii.toString()
					trans += " " + i + "(" + ii + ")"
				else css[i] = end_css[i]
			(props.push i) for i of css
			if trans
				props.push transformProperty
			css[transitionProperty] = props.join COMMASEP
			css[transitionDuration] = props.map(-> duration).join COMMASEP
			css[transitionTiming] = props.map(-> easing).join COMMASEP
			if trans
				css[transformProperty] = trans
			@css css
			@delay duration, callback
			@each ->
				if @style
					if @style.display is not "none"
						@_display = @syle.display
					@style.display = "none"
			.trigger "hide"
			.delay updateDelay, callback
			@each ->
				if @style
					@style.display = @_display
					delete @_display
			.trigger "show"
			.delay updateDelay, callback
			@weave(@css("display"))
				.fold (display, node) ->
					if display is "none"
						node.style.display = node._display or ""
						delete node._display
						$(node).trigger "show"
					else
						node._display = display
						node.style.display = "none"
						$(node).trigger "hide"
					node
				.delay(updateDelay, callback)
			@.css('opacity','0.0')
				.show ->
					@transform {
						opacity:"1.0",
						translate3d: [0,0,0]
					}, speed, callback
			@transform {
				opacity:"0.0",
				translate3d:[x,y,0.0]
			}, speed, -> @hide(callback)
		fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
		fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
		fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
		fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
	}
$.plugin
	provides: "type"
, ->
	isType = (T, o) ->
		if not o? then T in [o,"null","undefined"]
		else o.constructor is T or
			o.constructor.name is T or
	inherit = (parent, obj) ->
		if typeof parent is "function"
			parent = parent.prototype
		if parent.__proto__ is Object.prototype
			parent.__proto__ = obj.__proto__
		obj.__proto__ = parent
		obj
	_type = do ->
		cache = {}
		base =
			name: 'unknown'
			match: (o) -> true
		order = []
		register = (name, data) ->
			order.unshift name if not (name of cache)
			cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
			cache[name][name] = (o) -> o
		_extend = (name, data) ->
			if typeof name is "string"
				cache[name] ?= register name, {}
				cache[name] = extend cache[name], data
			else if typeof name is "object"
				(_extend k, name[k]) for k of name
		lookup = (obj) ->
			for name in order
				if cache[name]?.match.call obj, obj
					return cache[name]
		register "unknown",   base
		register "object",    match: -> typeof @ is "object"
		register "error",     match: -> isType 'Error', @
		register "regexp",    match: -> isType 'RegExp', @
		register "string",    match: -> typeof @ is "string" or isType String, @
		register "number",    match: -> (isType Number, @) and @ isnt NaN
		register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
		register "array",     match: -> Array.isArray?(@) or isType Array, @
		register "function",  match: -> typeof @ is "function"
		register "undefined", match: (x) -> x is undefined
		register "null",      match: (x) -> x is null
		return extend ((o) -> lookup(o).name),
			register: register
			lookup: lookup
			extend: _extend
			is: (t, o) -> cache[t]?.match.call o, o
			as: (t, o, rest...) -> lookup(o)[t]?(o, rest...)
	_type.extend
		unknown:   { array: (o) -> [o] }
		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }
	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) -> o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"
	$:
		inherit: inherit
		extend: extend
		defineProperty: (o, name, opts) ->
			Object.defineProperty o, name, extend({ configurable: true, enumerable: true }, opts)
			o
		isType: isType
		type: _type
		is: _type.is
		as: _type.as
		isSimple: (o) -> _type(o) in ["string", "number", "bool"]
		isEmpty: (o) -> o in ["", null, undefined] or o.length is 0 or (typeof o is "object" and Object.keys(o).length is 0)
	defineProperty: (name, opts) -> @each -> $.defineProperty @, name, opts
$.plugin
	provides: "unittest"
	depends: "core,function"
, ->
	testCount = passCount = failCount = 0
	failed = []
	invokeTest = (group, name, func) ->
		return if not $.is "function", func
		shouldFail = name.toLowerCase().indexOf("fail") isnt -1
		done = $.once (err) ->
			testCount--
			if (!!err isnt shouldFail)
				failCount++
				failed.push name
			else
				_log "pass"
				passCount++
				$.provide name
		f = (done) ->
			try func(done)
			catch err then done(err)
			finally
				if name.toLowerCase().indexOf("async") is -1 then done()
		testCount++
		try f(done)
		catch err then done(err)
	testReport = $.once ->
		if failCount > 0
			try process.exit(failCount)
	$:
		approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
		assertEqual: (a, b, label) ->
			if a isnt b
		assertArrayEqual: (a, b, label) ->
			for i in [0...a.length] by 1
				try
					$.assertEqual(a[i], b[i], label)
				catch err
		testGroup: (name, funcs) ->
			interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
			for k,func of funcs
				invokeTest(name, k, func)
	assertEqual: (args...) ->
				if $.is "function", x then x.call(@,@) else x
			a = args[0]
			for i in [1...args.length]
				$.assertEqual a, args[i]
		return @
$.plugin
	provides: "cartesian"
, ->
	$:
		cartesian: (sets...) ->
			n = sets.length
			ret = []
			helper = (cur, i) ->
				(return ret.push cur) if ++i >= n
				for x in sets[i]
					helper (cur.concat x), i
				null
			helper [], -1
			return $(ret)
$.plugin ->
	String::trimLeft or= -> @replace(/^\s+/, "")
	String::split or= (sep) ->
		a = []; i = 0
		while (j = @indexOf sep,i) > -1
			a.push @substring(i,j)
			i = j + 1
		a
	String::lastIndexOf or= (s, c, i = -1) ->
		j = -1
		j = i while (i = s.indexOf c, i+1) > -1
		j

	Array::join or= (sep = '') ->
		n = @length
		return "" if n is 0
		s = @[n-1]
		while --n > 0
			s = @[n-1] + sep + s
		s

	if Event?
		Event::preventAll = () ->
			@preventDefault()
			@stopPropagation()
			@cancelBubble = true

	if Element?
		Element::matchesSelector = Element::webkitMatchesSelector or
			Element::mozMatchesSelector or
			Element::matchesSelector
		if Element::cloneNode.length is 0
			oldClone = Element::cloneNode
			Element::cloneNode = (deep = false) ->
				n = oldClone.call(@)
				if deep
					for i in @childNodes
						n.appendChild i.cloneNode true
				return n

	return { }
$.plugin
	provides: 'config'
	depends: 'type'
, ->
	get = (name, def) -> process.env[name] ? def
	$: config: $.extend(get, get: get)

$.plugin
	provides: "core"
	depends: "string"
, ->

	$.defineProperty $, "now",
		get: -> +new Date

	index = (i, o) ->
		i += o.length while i < 0
		Math.min i, o.length

	baseTime = $.now
	return {
		$:
			log: $.extend((a...) ->
				if prefix.length > $.log.prefixSize + 2
				if a.length and $.is "string", a[0]
				else
					a.unshift prefix
				console.log a...
				return a[a.length-1] if a.length
			, prefixSize: 5)
			coalesce: (a...) -> $(a).coalesce()
			keysOf: (o) -> $(k for k of o)
			valuesOf: (o) -> $.keysOf(o).map (k)->
				return try o[k] catch err then err

		eq: (i) -> $([@[index i, @]])

		each: (f) -> (f.call(t,t) for t in @); @

		map: (f) ->
			b = $()
			for t in @
				b.push f.call t,t
			b

		filterMap: (f) ->
			b = $()
			for t in @
				v = f.call t,t
				if v?
					b.push v
			b

		replaceWith: (array) ->
			for i in [0...array.length] by 1
				@[i] = array[i]

		reduce: (f, a) ->
			i = 0; n = @length
			a = @[i++] if not a?
			(a = f.call @[x], a, @[x]) for x in [i...n] by 1
			return a
		union: (other, strict = true) ->
			ret = $()
			ret.push(x) for x in @ when not ret.contains(x, strict)
			ret.push(x) for x in other when not ret.contains(x, strict)
			ret
		distinct: (strict = true) -> @union @, strict
		contains: (item, strict = true) -> ((strict and t is item) or (not strict and `t == item`) for t in @).reduce ((a,x) -> a or x), false
		count: (item, strict = true) -> $(1 for t in @ when (item is undefined) or (strict and t is item) or (not strict and `t == item`)).sum()
		coalesce: ->
			for i in @
				if $.is('array',i) or $.is('bling',i) then i = $(i).coalesce()
				if i? then return i
			null
		swap: (i,j) ->
			i = index i, @
			j = index j, @
			if i isnt j
				[@[i],@[j]] = [@[j],@[i]]
			@
		shuffle: ->
			i = @length-1
			while i >= 0
				@swap --i, Math.floor(Math.random() * i)
			@

		select: (->
			getter = (prop) -> -> if $.is("function",v = @[prop]) then $.bound(@,v) else v
			select = (p) ->
				if (i = p.indexOf '.') > -1 then @select(p.substr 0,i).select(p.substr i+1)
				else @map(getter p)
		)()

		or: (x) -> @[i] or= x for i in [0...@length]; @

		zap: (p, v) ->

			i = p.lastIndexOf "."

			if i > 0
				head = p.substr 0,i
				tail = p.substr i+1
				@select(head).zap tail, v
				return @

			switch $.type(v)
				when "array","bling" then @each -> @[p] = v[++i % v.length]
				when "function" then @zap p, @select(p).map(v)
				else @each -> @[p] = v
			@

		clean: (prop) -> @each -> delete @[prop]

		take: (n = 1) ->
			end = Math.min n, @length
			$( @[i] for i in [0...end] by 1 )

		skip: (n = 0) ->
			start = Math.max 0, n|0
			$( @[i] for i in [start...@length] by 1 )

		first: (n = 1) -> if n is 1 then @[0] else @take(n)

		last: (n = 1) -> if n is 1 then @[@length - 1] else @skip(@length - n)

		slice: (start=0, end=@length) ->
			start = index start, @
			end = index end, @
			$( @[i] for i in [start...end] )

		extend: (b) -> @.push(i) for i in b; @

		push: (b) -> Array::push.call(@, b); @

		filter: (f) ->
			g = switch $.type f
				when "string" then (x) -> x.matchesSelector(f)
				when "regexp" then (x) -> f.test(x)
				when "function" then f
			$( it for it in @ when g.call(it,it) )

		matches: (expr) ->
			switch $.type expr
				when "string" then @select('matchesSelector').call(expr)
				when "regexp" then @map (x) -> expr.test x

		querySelectorAll: (expr) ->
			@filter("*")
			.reduce (a, i) ->
				a.extend i.querySelectorAll expr
			, $()

		weave: (b) ->
			c = $()
			for i in [@length-1..0] by -1
				c[(i*2)+1] = @[i]
			for i in [0...b.length] by 1
				c[i*2] = b[i]
			c

		fold: (f) ->
			n = @length
			b = $( f.call @, @[i], @[i+1] for i in [0...n-1] by 2 )
			if (n%2) is 1
				b.push( f.call @, @[n-1], undefined )
			b

		flatten: ->
			b = $()
			(b.push(j) for j in i) for i in @
			b

		call: -> @apply(null, arguments)

		apply: (context, args) ->
			@filterMap ->
				if $.is 'function', @ then @apply(context, args)
				else null

		log: (label) ->
			if label
				$.log(label, @toString(), @length + " items")
			else
				$.log(@toString(), @length + " items")
			@

		toArray: ->
			@__proto__ = Array::
	}
$.plugin
	provides: 'date'
	depends: 'type'
, ->
	[ms,s,m,h,d] = [1,1000,1000*60,1000*60*60,1000*60*60*24]

	units = {
		ms, s, m, h, d,
		sec: s
		second: s
		seconds: s
		min: m
		minute: m
		minutes: m
		hr: h
		hour: h
		hours: h
		day: d
		days: d
	}

	formats =
		yyyy: Date::getUTCFullYear
		mm: -> @getUTCMonth() + 1
		dd: Date::getUTCDate
		HH: Date::getUTCHours
		MM: Date::getUTCMinutes
		SS: Date::getUTCSeconds
		MS: Date::getUTCMilliseconds
	format_keys = Object.keys(formats).sort().reverse()

	parsers =
		yyyy: Date::setUTCFullYear
		mm: (x) -> @setUTCMonth(x - 1)
		dd: Date::setUTCDate
		HH: Date::setUTCHours
		MM: Date::setUTCMinutes
		SS: Date::setUTCSeconds
		MS: Date::setUTCMilliseconds
	parser_keys = Object.keys(parsers).sort().reverse()

	floor = Math.floor

	$.type.register "date",
		match: (o) -> $.isType Date, o
		array: (o) -> [o]
		string: (o, fmt, unit) -> $.date.format o, fmt, unit
		number: (o, unit) -> $.date.stamp o, unit

	$.type.extend 'string', date: (o, fmt = $.date.defaultFormat) -> new Date $.date.parse o, fmt, "ms"
	$.type.extend 'number', date: (o, unit) -> $.date.unstamp o, unit

	adder = (key) ->
		(stamp, delta, stamp_unit = $.date.defaultUnit) ->
			date = $.date.unstamp(stamp, stamp_unit)
			parsers[key].call date, (formats[key].call date) + delta
			$.date.stamp date, stamp_unit

	$:
		date:
			defaultUnit: "s"
			defaultFormat: "yyyy-mm-dd HH:MM:SS"
			stamp: (date = new Date, unit = $.date.defaultUnit) ->
				floor (date / units[unit])
			unstamp: (stamp, unit = $.date.defaultUnit) ->
				new Date floor(stamp * units[unit])
			convert: (stamp, from = $.date.defaultUnit, to = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, from)
				(floor stamp * units[from] / units[to])
			midnight: (stamp, unit = $.date.defaultUnit) ->
				$.date.convert ($.date.convert stamp, unit, "d"), "d", unit
			format: (stamp, fmt = $.date.defaultFormat, unit = $.date.defaultUnit) ->
				if $.is "date", stamp then stamp = $.date.stamp(stamp, unit)
				date = $.date.unstamp stamp, unit
				for k in format_keys
					fmt = fmt.replace k, ($.padLeft ""+formats[k].call(date), k.length, "0")
				fmt
			parse: (dateString, fmt = $.date.defaultFormat, to = $.date.defaultUnit) ->
				date = new Date(0)
				for i in [0...fmt.length] by 1
					for k in parser_keys
						if fmt.indexOf(k, i) is i
							try
								parsers[k].call date,
									parseInt dateString[i...i+k.length], 10
							catch err
				$.date.stamp date, to
			addMilliseconds: adder("MS")
			addSeconds: adder("SS")
			addMinutes: adder("MM")
			addHours: adder("HH")
			addDays: adder("dd")
			addMonths: adder("mm")
			addYears: adder("yyyy")
			range: (from, to, interval=1, interval_unit="dd", stamp_unit = $.date.defaultUnit) ->
				add = adder(interval_unit)
				ret = [from]
				while (cur = ret[ret.length-1]) < to
					ret.push add(cur, interval, stamp_unit)
				ret

	midnight: (unit = $.date.defaultUnit) -> @map(-> $.date.midnight @, unit)
	unstamp: (unit = $.date.defaultUnit) -> @map(-> $.date.unstamp @, unit)
	stamp: (unit = $.date.defaultUnit) -> @map(-> $.date.stamp @, unit)
	dateFormat: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.format @, fmt, unit)
	dateParse: (fmt = $.date.defaultFormat, unit = $.date.defaultUnit) -> @map(-> $.date.parse @, fmt, unit)


$.plugin
	provides: "delay"
	depends: "function"
, ->
	$:
		delay: (->
			timeoutQueue = $.extend [], (->
				next = (a) -> -> a.shift()() if a.length
				add: (f, n) ->
					f.order = n + $.now
					for i in [0..@length] by 1
						if i is @length or @[i].order > f.order
							@splice i,0,f
							break
					setTimeout next(@), n
					@
				cancel: (f) ->
					for i in [0...@length] by 1
						if @[i] == f
							@splice i, 1
							break
					@
			)()

			(n, f) ->
				if $.is("function",f) then timeoutQueue.add(f, n)
				cancel: -> timeoutQueue.cancel(f)

		)()

	delay: (n, f, c=@) ->
		$.delay n, $.bound(c, f)
		@
	interval: (n, f, c=@) ->
		g = $.bound c, f
		h = -> g(); $.delay n, h
		$.delay n, h
		@
if $.global.document?
	$.plugin
		depends: "function,type"
		provides: "dom"
	, ->
		$.type.register "nodelist",
			match:  (o) -> o? and $.isType "NodeList", o
			hash:   (o) -> $($.hash(i) for i in x).sum()
			array:  $.identity
			string: (o) -> "{Nodelist:["+$(o).select('nodeName').join(",")+"]}"
			node:   (o) -> $(o).toFragment()
		$.type.register "node",
			match:  (o) -> o?.nodeType > 0
			hash:   (o) -> $.checksum(o.nodeName) + $.hash(o.attributes) + $.checksum(o.innerHTML)
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "fragment",
			match:  (o) -> o?.nodeType is 11
			hash:   (o) -> $($.hash(x) for x in o.childNodes).sum()
			string: (o) -> o.toString()
			node:   $.identity
		$.type.register "html",
			match:  (o) -> typeof o is "string" and (s=o.trimLeft())[0] == "<" and s[s.length-1] == ">"
			node:   (h) ->
				(node = document.createElement('div')).innerHTML = h
				if n = (childNodes = node.childNodes).length is 1
					return node.removeChild(childNodes[0])
				df = document.createDocumentFragment()
				df.appendChild(node.removeChild(childNodes[0])) for i in [0...n] by 1
				df
			array:  (o) -> $.type.lookup(h = Bling.HTML.parse o).array h
			repr:   (o) -> '"' + o + '"'
		$.type.extend
			unknown:  { node: -> null }
			bling:    { node: (o) -> o.toFragment() }
			node:     { html: (n) ->
				d = document.createElement "div"
				d.appendChild (n = n.cloneNode true)
				ret = d.innerHTML
				ret
			}
			string:
				node:  (o) -> $(o).toFragment()
				array: (o) -> document.querySelectorAll? o
			function: { node: (o) -> $(o.toString()).toFragment() }

		toFrag = (a) ->
			if not a.parentNode?
				df = document.createDocumentFragment()
				df.appendChild a
			a
		before = (a,b) -> toFrag(a).parentNode.insertBefore b, a
		after = (a,b) -> toFrag(a).parentNode.insertBefore b, a.nextSibling
		toNode = (x) -> $.type.lookup(x).node x
		escaper = false
		parser = false

		computeCSSProperty = (k) -> -> $.global.getComputedStyle(@, null).getPropertyValue k

		getOrSetRect = (p) -> (x) -> if x? then @css(p, x) else @rect().select p

		selectChain = (prop) -> -> @map (p) -> $( p while p = p[prop] )

		return {
			$:

				HTML:
					parse: (h) -> $.type.lookup(h).node h
					stringify: (n) -> $.type.lookup(n).html n
					escape: (h) ->
						escaper or= $("<div>&nbsp;</div>").child 0
						ret = escaper.zap('data', h).select("parentNode.innerHTML").first()
						escaper.zap('data', '')
						ret

			html: (h) ->
				return switch $.type h
					when "undefined","null" then @select 'innerHTML'
					when "string","html" then @zap 'innerHTML', h
					when "bling" then @html h.toFragment()
					when "node"
							@replaceChild @childNodes[0], h
							while @childNodes.length > 1
								@removeChild @childNodes[1]

				@each -> @appendChild x.cloneNode true

				clones = @map( -> @cloneNode true)
				i = 0
				$(x).each -> @appendChild clones[i++]
				clones

				if x?
					x = toNode x
					@take(1).each ->
						before @childNodes[0], x
					@skip(1).each ->
						before @childNodes[0], x.cloneNode true
				@

				if x?
					$(x).prepend(@)
				@

				if x?
					x = toNode x
					@take(1).each -> before @, x
					@skip(1).each -> before @, x.cloneNode true
				@

				if x?
					x = toNode x
					@take(1).each -> after @, x
					@skip(1).each -> after @, x.cloneNode true
				@

				parent = toNode parent
				if $.is "fragment", parent
					throw new Error("cannot call .wrap() with a fragment as the parent")
				@each (child) ->
					if ($.is "fragment", child) or not child.parentNode
						return parent.appendChild child
					grandpa = child.parentNode
					marker = document.createElement "dummy"
					parent.appendChild grandpa.replaceChild marker, child
					grandpa.replaceChild parent, marker

				@each ->
					if @parentNode and @parentNode.parentNode
						@parentNode.parentNode.replaceChild(@, @parentNode)
					else if @parentNode
						@parentNode.removeChild(@)

				n = toNode n
				clones = @map(-> n.cloneNode true)
				for i in [0...clones.length] by 1
					@[i].parentNode?.replaceChild clones[i], @[i]
				clones

				return switch v
					when undefined then @select("getAttribute").call(a, v)
					when null then @select("removeAttribute").call(a, v)
					else
						@select("setAttribute").call(a, v)
						@


				notempty = (y) -> y isnt ""
				@removeClass(x).each ->
					c = @className.split(" ").filter notempty
					c.push x
					@className = c.join " "

				notx = (y) -> y != x
				@each ->
					c = @className.split(" ").filter(notx).join(" ")
					if c.length is 0
						@removeAttribute('class')

				notx = (y) -> y isnt x
				@each ->
					cls = @className.split(" ")
					filter = $.not $.isEmpty
					if( cls.indexOf(x) > -1 )
						filter = $.and notx, filter
					else
						cls.push x
					c = cls.filter(filter).join(" ")
					@className = c
					if c.length is 0
						@removeAttribute('class')

				@select('className.split').call(" ").select('indexOf').call(x).map (x) -> x > -1

				return @zap('textContent', t) if t?
				return @select('textContent')

				return @zap('value', v) if v?
				return @select('value')

			css: (k,v) ->
				if v? or $.is "object", k
					setter = @select 'style.setProperty'
					if $.is "object", k then setter.call i, k[i], "" for i of k
					else if $.is "string", v then setter.call k, v, ""
					else if $.is "array", v
						setter[i%nn] k, v[i%n], "" for i in [0...n = Math.max v.length, nn = setter.len()] by 1
					return @
				else
					cv = @map computeCSSProperty k
					ov = @select('style').select k
					ov.weave(cv).fold (x,y) -> x or y

			defaultCss: (k, v) ->
				sel = @selector
				style = ""
				if $.is "string", k
					if $.is "string", v
					else throw Error("defaultCss requires a value with a string key")
				else if $.is "object", k
					"} "
				$("<style></style>").text(style).appendTo("head")
				@

			rect: -> @select('getBoundingClientRect').call()

			width: getOrSetRect("width")

			height: getOrSetRect("height")

			top: getOrSetRect("top")

			left: getOrSetRect("left")

			bottom: getOrSetRect("bottom")

			right: getOrSetRect("right")

			position: (left, top) ->
				switch true
					when not left? then @rect()
					when not top? then @css("left", $.px(left))
					else @css({top: $.px(top), left: $.px(left)})

			scrollToCenter: ->
				document.body.scrollTop = @[0].offsetTop - ($.global.innerHeight / 2)
				@

			child: (n) -> @select('childNodes').map -> @[ if n < 0 then (n+@length) else n ]

			parents: selectChain('parentNode')

			prev: selectChain('previousSibling')

			next: selectChain('nextSibling')

			remove: -> @each -> @parentNode?.removeChild(@)

			find: (css) ->
				@filter("*")
					.map( -> $(css, @) )
					.flatten()

			clone: (deep=true) -> @map -> (@cloneNode deep) if $.is "node", @

			toFragment: ->
				if @length > 1
					df = document.createDocumentFragment()
					(@map toNode).map $.bound df, df.appendChild
					return df
				return toNode @[0]
		}
$.plugin
	provides: "EventEmitter"
	depends: "type,hook"
, ->
	$: EventEmitter: $.hook("bling-init").append (obj = Object.create(null)) ->
		listeners = {}
		list = (e) -> (listeners[e] or= [])
		$.inherit {
			emit:               (e, a...) -> (f.apply(@, a) for f in list(e)); @
			addListener:        (e, h) -> list(e).push(h); @emit('newListener', e, h)
			on:                 (e, h) -> @addListener e, h
			removeListener:     (e, h) -> (list(e).splice i, 1) if (i = list(e).indexOf h) > -1
			removeAllListeners: (e) -> listeners[e] = []
			listeners:          (e) -> list(e).slice 0
		}, obj
$.plugin
	depends: "dom,function,core"
	provides: "event"
, ->
	EVENTSEP_RE = /,* +/
	events = ['mousemove','mousedown','mouseup','mouseover','mouseout','blur','focus',
		'load','unload','reset','submit','keyup','keydown','change',
		'abort','cut','copy','paste','selection','drag','drop','orientationchange',
		'touchstart','touchmove','touchend','touchcancel',
		'gesturestart','gestureend','gesturecancel',
		'hashchange'
	]

	binder = (e) -> (f) -> @bind(e, f) if $.is "function", f else @trigger(e, f)

	register_live = (selector, context, evt, f, h) ->
		$(context).bind(evt, h)
			.each -> (((@__alive__ or= {})[selector] or= {})[evt] or= {})[f] = h

	unregister_live = (selector, context, e, f) ->
		$c = $(context)
		$c.each ->
			a = (@__alive__ or= {})
			b = (a[selector] or= {})
			c = (b[e] or= {})
			$c.unbind(e, c[f])
			delete c[f]

	triggerReady = $.once ->
		$(document).trigger("ready").unbind("ready")
		document.removeEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.removeEventListener?("load", triggerReady, false)
	bindReady = $.once ->
		document.addEventListener?("DOMContentLoaded", triggerReady, false)
		$.global.addEventListener?("load", triggerReady, false)
	bindReady()

	ret = {
		bind: (e, f) ->
			c = (e or "").split(EVENTSEP_RE)
			h = (evt) ->
				ret = f.apply @, arguments
				if ret is false
					evt.preventAll()
				ret
			@each -> (@addEventListener i, h, false) for i in c

		unbind: (e, f) ->
			c = (e or "").split EVENTSEP_RE
			@each -> (@removeEventListener i, f, null) for i in c

		trigger: (evt, args = {}) ->
			args = $.extend
				bubbles: true
				cancelable: true
			, args

			for evt_i in (evt or "").split(EVENTSEP_RE)
					e = document.createEvent "MouseEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						button: 0,
						relatedTarget: null
					, args
					e.initMouseEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.button, args.relatedTarget

					e = document.createEvent "UIEvents"
					e.initUIEvent evt_i, args.bubbles, args.cancelable, $.global, 1

					e = document.createEvent "TouchEvents"
					args = $.extend
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						touches: [],
						targetTouches: [],
						changedTouches: [],
						scale: 1.0,
						rotation: 0.0
					, args
					e.initTouchEvent(evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.touches, args.targetTouches, args.changedTouches, args.scale, args.rotation)

					e = document.createEvent "GestureEvents"
					args = $.extend {
						detail: 1,
						screenX: 0,
						screenY: 0,
						clientX: 0,
						clientY: 0,
						ctrlKey: false,
						altKey: false,
						shiftKey: false,
						metaKey: false,
						target: null,
						scale: 1.0,
						rotation: 0.0
					}, args
					e.initGestureEvent evt_i, args.bubbles, args.cancelable, $.global, args.detail, args.screenX, args.screenY,
						args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey,
						args.target, args.scale, args.rotation

				else
					e = document.createEvent "Events"
					e.initEvent evt_i, args.bubbles, args.cancelable
					try
						e = $.extend e, args
					catch err

				if not e
					continue
				else
					try
						@each -> @dispatchEvent e
					catch err
						$.log "dispatchEvent error:", err
			@

		live: (e, f) ->
			selector = @selector
			context = @context
			handler = (evt) ->
				$(selector, context)
					.intersect($(evt.target).parents().first().union($(evt.target)))
					.each -> f.call(evt.target = @, evt)
			register_live selector, context, e, f, handler
			@

		die: (e, f) ->
			$(@context).unbind e, unregister_live(@selector, @context, e, f)
			@

		click: (f = {}) ->
			if @css("cursor") in ["auto",""]
				@css "cursor", "pointer"
			if $.is "function", f then @bind 'click', f
			else @trigger 'click', f
			@

		ready: (f) ->
			return (f.call @) if triggerReady.exhausted
			@bind "ready", f
	}

	events.forEach (x) -> ret[x] = binder(x)
	return ret

(($) ->
	$.plugin
		depends: "experimental"
	, ->
		pruners = {}
		register = (type, f) -> (pruners[type] = f)
		lookup = (obj) -> pruners[obj.t or obj.type]
		stack = []

		$.type.extend null,        { compact: (o) -> $.toString(o) }
		$.type.extend "undefined", { compact: (o) -> "" }
		$.type.extend "null",      { compact: (o) -> "" }
		$.type.extend "string",    { compact: $.identity }
		$.type.extend "array",     { compact: (o) -> (Object.Compact(x) for x in o).join("") }
		$.type.extend "bling",     { compact: (o) -> o.map(Object.Compact).join("") }
		$.type.extend "object",    { compact: (o) -> Object.Compact(lookup(o)?.call o, o) }

		Object.Compact = (o) ->
			stack.push(o)
			$.type.lookup(o)?.compact(o)
			stack.pop()
		$.extend Object.Compact,
			register: register
			lookup: lookup

		register 'page', -> [
			"<!DOCTYPE html><html><head>",
				@head,
			"</head><body>",
				@body,
			"</body></html>"
		]
		register 'text', -> @EN
		register 'link', ->
			a = $(["<a"])
			a.extend(" ",k,"='",@[k],"'") for k in ["href","name","target"] when k of @
			a.extend(">",node.content,"</a>")

		$.assert(Object.Compact({ t: "page", head: [], body: {type: "text", EN: "Hello World"} }) is
			"<!DOCTYPE html><html><head></head><body>Hello World</body></html>")

		return { name: "Compact" }
)(Bling)

(($) ->
	$.plugin
		depends: "dom"
		provides: "http"
	, ->

		$.type.register "http",
			match: (o) -> $.isType 'ClientRequest', o
			array: (o) -> [o]

		return {
			$:
				http: (url, opts = {}) ->
					opts = $.extend {
						method: "GET"
						data: null
						async: true
						asBlob: false
						followRedirects: false
						withCredentials: false
					}, opts

				post: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "POST"
					$.http url, opts

				get: (url, opts = {}) ->
					if $.is "function", opts
						opts = success: opts
					opts.method = "GET"
					$.http url, opts
		}
)(Bling)
(($) ->
		operatorHtml = "<span class='opr'>$&</span>"
		keywords = /\b[Ff]unction\b|\bvar\b|\.prototype\b|\.__proto__\b|\bString\b|\bArray\b|\bNumber\b|\bObject\b|\bbreak\b|\bcase\b|\bcontinue\b|\bdelete\b|\bdo\b|\bif\b|\belse\b|\bfinally\b|\binstanceof\b|\breturn\b|\bthrow\b|\btry\b|\btypeof\b|\btrue\b|\bfalse\b/g
		keywordHtml = "<span class='kwd'>$&</span>"
		allNumbers = /\d+\.*\d*/g
		numberHtml = "<span class='num'>$&</span>"
		blingSymbol = /\$(\(|\.)/g
		blingHtml = "<span class='bln'>$$</span>$1"
		tabs = /\t/g
		tabHtml = "&nbsp;&nbsp;"
		singlelineComment = /\/\/.*?(?:\n|$)/
		multilineComment = /\/\*(?:.|\n)*?\*\//
		commentHtml = (comment) ->
		quotedHtml = (quoted) ->

			a = s.indexOf('"', i)
			b = s.indexOf("'", i)
			a = s.length if a is -1
			b = s.length if b is -1
			return [null, -1] if a is b
			return ['"', a] if a < b
			return ["'", b]
			r = s.indexOf(q, i)
			while( s.charAt(r-1) is "\\" and 0 < r < s.length)
				r = s.indexOf(q, r+1)
			r
			i = 0
			n = s.length
			ret = []
			if not Object.IsString(s)
				if not Object.IsFunction(s.toString)
					throw TypeError("invalid string argument to split_quoted")
				else
					s = s.toString()
					n = s.length
			while( i < n )
				q = firstQuote(s, i)
				j = q[1]
				if( j is -1 )
					ret.push(s.substring(i))
					break
				ret.push(s.substring(i,j))
				k = closingQuote(s, j+1, q[0])
				if( k is -1 )
					throw Error("unclosed quote: "+q[0]+" starting at "+j)
				ret.push(s.substring(j, k+1))
				i = k+1
			ret

		firstComment = (s) ->
			a = s.match(singlelineComment)
			b = s.match(multilineComment)
			return [-1, null] if a is b
			return [b.index, b[0]] if a == null and b != null
			return [a.index, a[0]] if a != null && b == null
			return [b.index, b[0]] if b.index < a.index
			return [a.index, a[0]]

		splitComments = (s) ->
			ret = []
			i = 0
			n = s.length
			while( i < n )
				ss = s.substring(i)
				q = firstComment(ss)
				j = q[0]
				if( j > -1 )
					ret.push(ss.substring(0,j))
					ret.push(q[1])
					i += j + q[1].length
				else
					ret.push(ss)
					break
			ret

		foldCodeAndQuoted = (code, quoted) ->
			code.replace(operators, operatorHtml).replace(allNumbers, numberHtml).replace(keywords, keywordHtml).replace(blingSymbol, blingHtml).replace(tabs, tabHtml) + quotedHtml(quoted)

		foldTextAndComments = (text, comment) ->
			$(splitQuoted(text)).fold(foldCodeAndQuoted).join('') + commentHtml(comment)

		return {
			name: "PrettyPrint"
			$:
				prettyPrint: (js, colors) ->
					js = js.toString() if Object.IsFunction(js)
					if not Object.IsString(js)
						throw TypeError("prettyPrint requires a function or string to format, not '"+Object.Type(js)+"'")
						css = "code.pp .bln { font-size: 17px; } "
						colors = Object.Extend(
						, colors)
						for cls of colors
							.text(css)
							.appendTo("head")
					ret = "<code class='pp'>" + ($(splitComments(js)).fold(foldTextAndComments).join('')) + "</code>"
		}

)(Bling)
require "../../dist/bling"

do ($ = Bling) ->

	$.plugin
		provides: "text-analysis"
	, ->
		indices = $.memoize (str, substr) ->
			switch substr.length
				when 0 then $.range 0, str.length
				when 1
					i = -1
					i while (i = str.indexOf substr, i+1) > -1
				else
					subsub = substr[0...substr.length-1]
					indices(str, subsub).filter (x) -> str.indexOf(substr,x) is x

		ld = $.memoize (s, t) ->
			switch true
				when not s then t.length
				when not t then s.length
				when s is t then 0
				when s[0] is t[0] then ld s[1..],t[1..]
				else 1 + Math.min(
					ld(s, t[1..]),
					ld(s[1..], t),
					ld(s[1..], t[1..])
				)

		commonSubstrings = (a,b,min_length=1,limit=1) ->
			a = a.toLowerCase()
			b = b.toLowerCase()
			ret = {}
			for i in [0...b.length]
				for j in [0...b.length]
					if (j - i) < min_length-1 then continue
					c = b[i..j]
					if (indices a,c).length > 0
							ret[c] = 1
			$(Object.keys ret)
				.sort((x,y) -> y.length - x.length)
				.take(limit)

		$:
			stringDistance: ld
			stringsInCommon: commonSubstrings

(($) ->

	$.plugin () ->

		Dialog = (selector, opts) ->
			opts = $.extend({
				autoOpen: false
				draggable: true
			}, opts)
			dialog = $(selector)
				.addClass("dialog")
			if opts.draggable
				dialog.draggable()
			if opts.autoOpen
				dialog.show().center()
			dialog
				.find("button.close, .close-button")
				.bind "click touchstart", () ->
					dialog.hide()
					false
			dialog
		
		Draggable = (selector, opts) ->
			opts = $.extend({
				handleCSS: {}
			}, opts)

			opts.handleCSS = $.extend({
				position: "absolute"
				top: "0px"
				left: "0px"
				width: "100%"
				height: "6px"
			}, opts.handleCSS)

			dragObject = $(selector)
			moving = false
			oX = oY = 0
			handle = $
				.synth("div.handle")
				.defaultCss({
					height: "6px"
					"border-radius": "3px"
					cursor: "move"
				})
				.css(opts.handleCSS)
				.bind 'mousedown, touchstart', (evt) ->
					moving = true
					oX or= evt.pageX
					oY or= evt.pageY
					false
			$(document)
			.bind 'mousemove, touchmove', (evt) ->
				if moving
					dX = (evt.pageX - oX)
					dY = (evt.pageY - oY)
					dragObject.transform({
						translate: [ dX, dY ]
					}, 0)
					.trigger 'drag', {
						dragObject: dragObject
					}
					false
			.bind 'mouseup, touchend', (evt) ->
				if moving
					moving = false
					pos = handle.position()[0]
					$(document.elementFromPoint(pos.left, pos.top - 1))
					.trigger 'drop',
						dropObject: dragObject

			dragObject
				.addClass("draggable")
				.css {
					position: "relative"
					"padding-top": dragObject.css("padding-top")
						.map(Number.AtLeast(parseInt(opts.handleCSS.height,10)))
						.px().first()
				}
				.append(handle)

		ProgressBar = (selector, opts) ->
			opts = $.extend({
				change: null
				barColor: "rgba(0,128,0,0.5)"
				textColor: "white"
				reset: false
			}, opts)

			node = $(selector)
				.addClass('progress-bar')
				_bg = node.css("background").first()
				_color = node.css("color").first()

			node.zap 'updateProgress', (pct) ->
				while pct < 1.0
					pct *= 100.0
					node.css
						background: _bg
						color: _color
				else
					node.css
						background:"""
						"""
						color: opts.textColor
				if $.is "function", opts.change
					opts.change pct

		Accordion = (selector, opts) ->
			opts = $.extend({
				exclusive: false
				sticky: false
			}, opts)
			node = $(selector).addClass("accordion")
			selectedChild = null

			initRow = (n) ->
				t = $(n).children().first().filter("*")
				if( t.len() isnt 2 )
				title = t.eq(0).addClass("title")
				body = t.eq(1).addClass("body").hide()
				bodyVisible = false
				title.click () ->
					if opts.exclusive
						node.find(".body").hide()
					if bodyVisible
						if not opts.sticky
							body.hide().removeClass("visible")
							title.removeClass("selected").trigger("deselect")
							bodyVisible = false
						else
							body.show().addClass("visible")
							title.addClass("selected").trigger("select")
							bodyVisible = true
					else
						body.show().addClass("visible")
						title.addClass("selected").trigger("select")
						bodyVisible = true

			node.bind "DOMNodeInserted", (evt) ->
				directChildren = node.children().first().filter("*")
				parentsOfInserted = $(evt.target).parents().first()
				initRow(parentsOfInserted.intersect(directChildren))

			node.children().first()
				.map(initRow)

			return node

		ViewStack = (selector, opts) ->
			items = $(selector)
				.css {
					position: "relative"
					top: "0px"
					left: "0px"
				}
				.hide()
				.map($)
			active = 0
			items[active].show()
			items.next = () ->
				items[active].hide()
				active = (++active % items.length)
				items[active].show()
			items.activate = (k) ->
				items[active].hide()
				active = k
				items[k].show()
			for j in [0...items.len()]
				items[j]
				.zap("_viewIndex", j)
				.zap "activate", ->
					items.activate(this._viewIndex)
			items

		Tabs = (selector, views) ->
			tabs = $(selector)
			views = $(views).viewStack()
			nn = tabs.len()
			tabs._tabIndex = i for i in [0..nn]
			$(tabs[0]).addClass("active")
			tabs.click () ->
				tabs.removeClass("active")
				views.activate(this._tabIndex)
				$(this).addClass("active")

		return {
			$:
				UI:
					Draggable: Draggable
					ProgressBar: ProgressBar
					ViewStack: ViewStack
					Tabs: Tabs
					Accordion: Accordion

			dialog: (opts) -> Dialog(this, opts)
			progressBar: (opts) -> ProgressBar(this, opts)
			viewStack: (opts) -> ViewStack(this, opts)
			tabs: (views) -> Tabs(this, views)
			accordion: (opts) -> Accordion(this, opts)
			draggable: (opts) -> Draggable(this, opts)
		}

)(Bling)


	units = ["px","pt","pc","em","%","in","cm","mm","ex",""]
	UNIT_RE = /(\d+\.*\d*)(px|pt|pc|em|%|in|cm|mm|ex)/

	parseUnits = (s) -> UNIT_RE.exec(s)[2] if UNIT_RE.test(s) else ""

	conv = (a,b) -> conv[a][b]()
	for a in units
		for b in units
			(conv[a] or= {})[b] = trick +(a is b or a is "" or b is "")
	conv.in.pt = -> 72
	conv.in.px = -> 96
	conv.in.cm = -> 2.54
	conv.pc.pt = -> 12
	conv.cm.mm = -> 10
	conv.em.px = ->
		x = $("<span style='font-size:1em;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.px = ->
		x = $("<span style='font-size:1ex;visibility:hidden'>x</span>").appendTo("body")
		w = x.width().first()
		x.remove()
		w
	conv.ex.em = -> 2
	fillIn = ->
		for a in units
			for b in units
				if not conv(a,b) and conv(b,a)
					conv[a][b] = trick 1.0/conv(b,a)
				for c in units
					if not conv(a,c) and conv(a,b) and conv(b,c)
						conv[a][c] = trick conv(a,b) * conv(b,c)
	fillIn(); fillIn()
	
	convertUnits = (number, unit) -> parseFloat(number) * conv[parseUnits(number)][unit]() + unit

	$.assert(convertUnits("300px", "cm") == "10cm")

	convertAll = (to, a) ->
		for i in [0...a.length]
			a[i] = convertTo(to, a[i])

	Object.Type.register "units",
		match: (x) -> UNIT_RE.test(x)

	unit_scalar = (f) ->
		(a...) ->
			convertAll( unit = parseUnits(@[0]), @)
			(f.apply @, a) + unit
	unit_vector = (f) ->
		(a...) ->
			u = @map parseUnits
			f.apply(@floats(), a).map ->

	{
		min: unit_scalar -> @reduce (a) -> Math.min parseFloat(@), a
		max: unit_scalar -> @reduce (a) -> Math.max parseFloat(@), a
		sum: unit_scalar -> @reduce (a) -> parseFloat(@) + a
		mean: unit_scalar -> parseFloat(@sum()) / @length
		magnitude: unit_scalar -> Math.sqrt @floats().squares().sum()
		squares: -> @map -> (x=parseFloat(@)) * x
		scale: (n) -> @map -> n * parseFloat(@)
		add: (d) -> @map -> d + @
		normalize: -> @scale(1/@magnitude())
	}


	EOF = -> "EOF"

	BackgroundQueue = (opts) ->
		opts = extend {
			item: -> EOF
			action: Function.Identity
			latency: 10
		}, opts

		return extend new $.EventEmitter(), {
			run: ->
				r = () =>
					if (item = opts.action(opts.item())) isnt EOF
						@emit("data", item)
						setTimeout r, opts.latency
				setTimeout r, opts.latency
		}

	data = x for x in [0...1000]
	i = 0
	BackgroundQueue
		item: ->
			return data[i++] if i < data.length else EOF
		action: (item) -> (item*item) - 1
		latency: 10
	.on "data", (x) -> console.log "data:", x
	.on "error", (x) -> console.log "error:", x
	
$.plugin
	provides: "function"
	depends: "hash"
, ->
	$:
		identity: (o) -> o
		not: (f) -> -> not f.apply @, arguments
		compose: (f,g) -> (x) -> f.call(y, (y = g.call(x,x)))
		and: (f,g) -> (x) -> g.call(@,x) and f.call(@,x)
		once: (f, n=1) ->
			$.defineProperty (-> (f.apply @,arguments) if n-- > 0),
				"exhausted",
					get: -> n <= 0
		cycle: (f...) ->
			i = -1
			-> f[i = ++i % f.length].apply @, arguments
		bound: (t, f, args = []) ->
			if $.is "function", f.bind
				args.splice 0, 0, t
				r = f.bind.apply f, args
			else
				r = (a...) -> f.apply t, (args if args.length else a)
		memoize: (f) ->
			cache = {}
		E: (callback) -> (f) -> (err, data) ->
			return f(data) unless err
			callback err, data

$.plugin
	provides: "groupBy"
, ->
	groupBy: (key) ->
		groups = {}
		switch $.type key
			when 'array','bling'
				@each ->
					c = (@[k] for k in key).join ","
					(groups[c] or= $()).push @
			else @each -> (groups[@[key]] or= $()).push @
		return $.valuesOf groups
$.plugin
	provides: "hash"
	depends: "type"
, ->
	$.type.extend
		unknown: { hash: (o) -> $.checksum $.toString o }
		object:  { hash: (o) ->
			$.hash(Object) +
				$($.hash(o[k]) for k of o).sum() +
				$.hash Object.keys o
		}
		array:   { hash: (o) ->
			$.hash(Array) + $(o.map $.hash).reduce (a,x) ->
				(a*a)+(x|0)
			, 1
		}
		bool:    { hash: (o) -> parseInt(1 if o) }
	return {
		$:
			hash: (x) -> $.type.lookup(x).hash(x)
		hash: -> $.hash @
	}
$.plugin ->
	$:
		histogram: (data, bucket_width=1, output_width=80) ->
			buckets = $()
			len = 0
			for x in data
				i = Math.floor( x / bucket_width )
				buckets[i] ?= 0
				buckets[i] += 1
				len = Math.max(len, i+1)
			buckets.length = len

			max = buckets.max()
			buckets = buckets.map((x) -> x or 0)
				.scale(1/max)
				.scale(output_width)
			sum = buckets.sum()

			ret = ""
			pct_sum = 0
			for n in [0...len] by 1
				end = (n+1) * bucket_width
				pct = (buckets[n]*100/sum)
				pct_sum += pct
			ret
	histogram: -> $.histogram @
$.plugin
	provides: "hook"
	depends: "type"
, ->





	hooks = {}
	hook = (name, args) ->
		p = (hooks[name] or= [])
		if not args
			return {
				prepend: (obj) -> p.unshift(obj); obj
				append: (obj) -> p.push(obj); obj
			}
		for func in p
			args = func.call @, args
		args

	hook("bling-init").prepend (args) ->
		if args.length is 1
			args = $.type.lookup(args[0]).array(args[0])
		$.inherit Bling, args

	$: hook: hook

$.plugin
	depends: "dom"
	provides: "http"
, ->

	$.type.register "http",
		match: (o) -> $.isType 'XMLHttpRequest', o
		array: (o) -> [o]

	return {
		$:
			http: (url, opts = {}) ->
				xhr = new XMLHttpRequest()
				if $.is "function", opts
					opts = success: $.bound(xhr, opts)
				opts = $.extend {
					method: "GET"
					data: null
					async: true
					asBlob: false
					followRedirects: false
					withCredentials: false
				}, opts
				opts.state = $.bound(xhr, opts.state)
				opts.success = $.bound(xhr, opts.success)
				opts.error = $.bound(xhr, opts.error)
				if opts.data and opts.method is "GET"
					url += "?" + formencode(opts.data)
				else if opts.data and opts.method is "POST"
					opts.data = formencode(opts.data)
				xhr.open(opts.method, url, opts.async)
				xhr = $.extend xhr,
					asBlob: opts.asBlob
					timeout: opts.timeout
					followRedirects: opts.followRedirects
					withCredentials: opts.withCredentials
					onreadystatechange: ->
						opts.state?()
						if xhr.readyState is 4
							if xhr.status is 200
								opts.success xhr.responseText
							else
								opts.error xhr.status, xhr.statusText
				xhr.send opts.data
				return $(xhr)

			post: (url, opts = {}) ->
				if $.is("function",opts)
					opts = success: opts
				opts.method = "POST"
				$.http(url, opts)

			get: (url, opts = {}) ->
				if( $.is("function",opts) )
					opts = success: opts
				opts.method = "GET"
				$.http(url, opts)
	}
$.depends 'hook', ->
	$.hook('bling-init').append (obj) ->
		map = Object.create(null)
		keyMakers = []
		$.inherit {
			index: (keyFunc) ->
				if keyMakers.indexOf(keyFunc) is -1
					keyMakers.push keyFunc
					map[keyFunc] = Object.create(null)
				@each (x) ->
					map[keyFunc][keyFunc(x)] = x
			query: (criteria) ->
				for keyMaker in keyMakers
					key = keyMaker(criteria)
					return map[keyMaker][key] if key of map[keyMaker]
				null
		}, obj

$.plugin
	depends: "dom"
	provides: "lazy"
, ->
	lazy_load = (elementName, props) ->
		$("head").append $.extend document.createElement(elementName), props
	$:
		script: (src) ->
			lazy_load "script", { src: src }
		style: (src) ->
			lazy_load "link", { href: src, rel: "stylesheet" }

$.plugin
	provides: "math"
	depends: "core"
, ->
	$.type.extend
		bool: { number: (o) -> if o then 1 else 0 }
		number: { bool: (o) -> not not o }

	_By = (cmp) ->
		(field) ->
			valueOf = switch $.type field
				when "string" then (o) -> o[field]
				when "function" then field
				else throw new Error ".maxBy first argument should be a string or function"
			x = @first()
			@skip(1).each ->
				if cmp valueOf(@), valueOf(x)
					x = @
			return x

	$:
		range: (start, end, step = 1) ->
			if not end? then (end = start; start = 0)
			$( (start + (i*step)) for i in [0...Math.ceil( (end - start) / step )] )
		zeros: (n) -> $( 0 for i in [0...n] )
		ones: (n) -> $( 1 for i in [0...n] )
		deg2rad: (n) -> n * Math.PI / 180
		rad2deg: (n) -> n * 180 / Math.PI
	floats: -> @map parseFloat
	ints: -> @map -> parseInt @, 10
	px: (delta) -> @ints().map -> $.px @,delta
	min: -> @filter( isFinite ).reduce Math.min
	max: -> @filter( isFinite ).reduce Math.max
	maxBy: _By (a,b) -> a > b
	minBy: _By (a,b) -> a < b
	mean: mean = -> if not @length then 0 else @sum() / @length
	avg: mean
	sum: -> @filter( isFinite ).reduce(((a) -> a + @), 0)
	product: -> @filter( isFinite ).reduce (a) -> a * @
	squares: -> @pow(2)
	pow: (n) -> @map -> Math.pow @, n
	magnitude: -> Math.sqrt @floats().squares().sum()
	scale: (r) -> @map -> r * @
	add: add = (d) -> switch $.type(d)
		when "number" then @map -> d + @
		when "bling","array" then $( @[i]+d[i] for i in [0...Math.min(@length,d.length)] )
	plus: add
	vecAdd: (v) ->
		d = $()
		for i in [0...@length] by 1
			d[i] = @[i] + v[i]
		d
	normalize: -> @scale 1 / @magnitude()
	deg2rad: -> @filter( isFinite ).map -> @ * Math.PI / 180
	rad2deg: -> @filter( isFinite ).map -> @ * 180 / Math.PI
$.plugin
	provides: "pubsub"
, ->
	$:
		publish: (e, args...) ->
			f.apply null, args for f in (subscribers[e] or= [])
			args
		publisher: (e, func) ->
			(args...) ->
				$.publish e, func.apply @, args
		subscribe: (e, func) ->
			(subscribers[e] or= []).push func
			func
		unsubscribe: (e, func) ->
			if not func?
				subscribers[e] = []
			else
				a = (subscribers[e] or= [])
				if (i = a.indexOf func)  > -1
					a.splice(i,i)
$.plugin
	provides: 'random'
	depends: 'type'
, ->
	alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".split ""

		MT = new Array(624)
		index = 0
		init_generator = (seed) ->
			index = 0
			MT[0] = seed
			for i in [1..623]
				MT[i] = 0xFFFFFFFF & (1812433253 * (MT[i-1] ^ (MT[i-1] >>> 30)) + i)
		
		generate_numbers = ->
			for i in [0..623]
				y = ((MT[i] & 0x80000000) >>> 31) + (0x7FFFFFFF & MT[ (i+1) % 624 ])
				MT[i] = MT[ (i+397) % 624 ] ^ (y >>> 1)
				if (y%2) is 1
					MT[i] = MT[i] ^ 2567483615

		a = Math.pow(2,31)
		b = a * 2
		next = ->
			if index is 0
				generate_numbers()
			y = MT[index] ^
				(y >>> 11) ^
				((y << 7) and 2636928640) ^
				((y << 15) and 4022730752) ^
				(y >>> 18)

			index = (index + 1) % 624
			(y + a) / b

		$.defineProperty next, "seed",
			set: (v) -> init_generator(v)
		
		next.seed = +new Date()

		return $.extend next,
			real: (min, max) ->
				if not min?
					[min,max] = [0,1.0]
				if not max?
					[min,max] = [0,min]
				($.random() * (max - min)) + min
			integer: (min, max) -> Math.floor $.random.real(min,max)
			string: (len, prefix="") ->
				prefix += $.random.element(alphabet) while prefix.length < len
				prefix
			coin: (balance=.5) -> $.random() <= balance
			element: (arr) -> arr[$.random.integer(0, arr.length)]
				while true
					u = $.random()
					v = 1.7156 * ($.random() - 0.5)
					x = u - 0.449871
					y = Math.abs(v) + 0.386595
					q = (x*x) + y*(0.19600*y-0.25472*x)
					break unless q > 0.27597 and (q > 0.27846 or (v*v) > (-4*Math.log(u)*u*u))
				return mean + ssig*v/u

$.plugin
	provides: "sendgrid"
	depends: "config"
, ->
	try
		nodemailer = require 'nodemailer'
	catch err
		`return`
	transport = nodemailer.createTransport 'SMTP',
		service: 'SendGrid'
		auth:
			user: $.config.get 'SENDGRID_USERNAME'

	$:
		sendMail: (mail, callback) ->
			mail.transport ?= transport
			mail.from ?= $.config.get 'EMAILS_FROM'
			mail.bcc ?= $.config.get 'EMAILS_BCC'

			if $.config.get('SENDGRID_ENABLED', 'true') is 'true'
				nodemailer.sendMail mail, callback
			else
$.plugin
	provides: "sortBy,sortedIndex"
, ->
	$:
		sortedIndex: (array, item, iterator) ->
			cmp = switch $.type iterator
				when "string" then (a,b) -> a[iterator] - b[iterator]
				when "function" then (a,b) -> iterator(a) - iterator(b)
				else (a,b) -> a - b
				if cmp(array[i], item) > 0
					return i
			return array.length
	sortBy: (iterator) ->
		a = $()
		for item in @
			n = $.sortedIndex a, item, iterator
			a.splice n, 0, item
		a

		
$.plugin
	provides: "string"
	depends: "function"
, ->
	safer = (f) ->
		(a...) ->
			try return f(a...)
	$.type.extend
		unknown:
			string: safer (o) -> o.toString?() ? String(o)
			repr: safer (o) -> $.type.lookup(o).string(o)
			number: safer (o) -> parseFloat String o
		null: { string: -> "null" }
		undefined: { string: -> "undefined" }
		string:
			number: safer parseFloat
		array:  { string: safer (a) -> "[" + ($.toString(x) for x in a).join(",") + "]" }
		object: { string: safer (o) ->
			ret = []
			for k of o
				try
					v = o[k]
				catch err
			"{" + ret.join(', ') + "}"
		}
		function:
			string: (f) -> f.toString().replace(/^([^{]*){(?:.|\n|\r)*}$/, '$1{ ... }')
		number:
			repr:   (n) -> String(n)
			string: safer (n) ->
				switch true
					when n.precision? then n.toPrecision(n.precision)
					when n.fixed? then n.toFixed(n.fixed)
					else String(n)

	return {
		$:
			toString: (x) ->
				if not x? then "function Bling(selector, context) { [ ... ] }"
				else
					try
						$.type.lookup(x).string(x)
					catch err

			toRepr: (x) -> $.type.lookup(x).repr(x)

			px: (x, delta=0) -> x? and (parseInt(x,10)+(delta|0))+"px"



			capitalize: (name) -> (name.split(" ").map (x) -> x[0].toUpperCase() + x.substring(1).toLowerCase()).join(" ")

			dashize: (name) ->
				ret = ""
				for i in [0...(name?.length|0)]
					c = name.charCodeAt i
					if 91 > c > 64
						c += 32
						ret += '-'
					ret += String.fromCharCode(c)
				ret

			camelize: (name) ->
				name.split('-')
				while (i = name?.indexOf('-')) > -1
					name = $.stringSplice(name, i, i+2, name[i+1].toUpperCase())
				name

			padLeft: (s, n, c = " ") ->
				while s.length < n
					s = c + s
				s

			padRight: (s, n, c = " ") ->
				while s.length < n
					s = s + c
				s

			stringTruncate: (s, n, c = "...") ->
				s = s.split(' ')
				r = []
				while n > 0
					x = s.shift()
					n -= x.length
					if n >= 0
						r.push x
				r.join('') + c


			stringCount: (s, x, i = 0, n = 0) ->
				if (j = s.indexOf x,i) > i-1
					$.stringCount s, x, j+1, n+1
				else n

			stringSplice: (s, i, j, n) ->
				nn = s.length
				end = j
				if end < 0
					end += nn
				start = i
				if start < 0
					start += nn
				s.substring(0,start) + n + s.substring(end)

			checksum: (s) ->
				a = 1; b = 0
				for i in [0...s.length]
					a = (a + s.charCodeAt(i)) % 65521
					b = (b + a) % 65521
				(b << 16) | a

			repeat: (x, n=2) ->
				switch true
					when n is 1 then x
					when n < 1 then ""
					when $.is "string", x then x + $.repeat(x, n-1)
					else $(x).extend $.repeat(x, n-1)

			stringBuilder: ->
				if $.is("global", @) then return new $.stringBuilder()
				items = []
				@length   = 0
				@append   = (s) => items.push s; @length += s?.toString().length|0
				@prepend  = (s) => items.splice 0,0,s; @length += s?.toString().length|0
				@clear    = ( ) => ret = @toString(); items = []; @length = 0; ret
				@toString = ( ) => items.join("")
				@
		toString: -> $.toString @
		toRepr: -> $.toRepr @
	}


$.plugin
	provides: "symbol"
	depends: "type"
, ->
	symbol = null
	cache = {}
	g = $.global
	g.Bling = Bling
	if module?
		module.exports = Bling
	$.defineProperty $, "symbol",
		set: (v) ->
			g[symbol] = cache[symbol]
			cache[symbol = v] = g[v]
			g[v] = Bling
		get: -> symbol
	return $:
		symbol: "$"
		noConflict: ->
			Bling.symbol = "Bling"
			Bling
$.plugin
	provides: "StateMachine"
, ->
	$: StateMachine: class StateMachine
		constructor: (stateTable) ->
			@debug = false
			@reset()
			@table = stateTable
			Object.defineProperty @, "modeline",
				get: -> @table[@_mode]
			Object.defineProperty @, "mode",
				set: (m) ->
					@_lastMode = @_mode
					@_mode = m
					if @_mode isnt @_lastMode and @modeline? and 'enter' of @modeline
						ret = @modeline['enter'].call @
						while $.is("function",ret)
							ret = ret.call @
					m
				get: -> @_mode

		reset: ->
			@_mode = null
			@_lastMode = null

		GO: (m) -> -> @mode = m
		@GO: (m) -> -> @mode = m
		
		tick: (c) ->
			row = @modeline
			if not row?
				ret = null
			else if c of row
				ret = row[c]
			else if 'def' of row
				ret = row['def']
			while $.is "function",ret
				ret = ret.call @, c
			ret

		run: (inputs) ->
			@mode = 0
			for c in inputs
				ret = @tick(c)
			if $.is "function",@modeline?.eof
				ret = @modeline.eof.call @
			while $.is "function",ret
				ret = ret.call @
			@reset()
			return @

$.plugin
	provides: "synth"
	depends: "StateMachine, type"
, ->
	class SynthMachine extends $.StateMachine
		basic =
			".": @GO 3
			"[": @GO 4
			'"': @GO 6
			"'": @GO 7
			" ": @GO 8
			",": @GO 10
			"+": @GO 11
			eof: @GO 13

		@STATE_TABLE = [
				enter: ->
					@tag = @id = @cls = @attr = @val = @text = ""
					@attrs = {}
					@GO 1
			},
				def: (c) -> @tag += c
			}, basic),
				def: (c) -> @id += c
			}, basic),
				enter: -> @cls += " " if @cls.length > 0
				def: (c) -> @cls += c
			}, basic),
				"=": @GO 5
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @attr += c
				eof: @GO 12
			},
				"]": -> @attrs[@attr] = @val; @attr = @val = ""; @GO 1
				def: (c) -> @val += c
				eof: @GO 12
			},
				'"': @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				"'": @GO 8
				def: (c) -> @text += c
				eof: @GO 12
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = null
					@GO 0
			},
				enter: ->
					@emitNode()
					@cursor = @cursor?.parentNode
					@GO 0
			},
			},
				enter: ->
					@emitNode() if @tag
					@emitText() if @text
			}
		]
		constructor: ->
			super(SynthMachine.STATE_TABLE)
			@fragment = @cursor = document.createDocumentFragment()
		emitNode: ->
			if @tag
				node = document.createElement @tag
				node.id = @id or null
				node.className = @cls or null
				for k of @attrs
					node.setAttribute k, @attrs[k]
				@cursor.appendChild node
				@cursor = node
		emitText: ->
			@cursor.appendChild $.type.lookup("<html>").node(@text)
			@text = ""

	return {
		$:
			synth: (expr) ->
				s = new SynthMachine()
				s.run(expr)
				if s.fragment.childNodes.length == 1
					$(s.fragment.childNodes[0])
				else
					$(s.fragment)
	}
do ($ = Bling) ->

		current_engine = null
		engines = {}

		template = {
			register_engine: (name, render_func) ->
				engines[name] = render_func
				if not current_engine?
					current_engine = name
			render: (text, args) ->
				if current_engine of engines
					engines[current_engine](text, args)
		}
		template.__defineSetter__ 'engine', (v) ->
			if not v of engines
			else
				current_engine = v
		template.__defineGetter__ 'engine', () -> current_engine

		return {
			name: 'Template'
			$:
				template: template
		}
	
	$.template.register_engine 'null', (() ->
		return (text, values) ->
			text
	)()

		count = 1
		if stop < 0
			stop = text.length + 1 + stop
		for i in [start...stop] by 1
			t = text[i]
			if t is against
				count += 1
			else if t is find
				count -= 1
			if count is 0
				return i
		return -1

	$.template.register_engine 'pythonic', (() ->

		chunk_re = /%[\(\/]/

		compile = (text) ->
			chunks = text.split chunk_re
			n = chunks.length
			ret = [chunks[0]]
			for i in [1...n] by 1
				end = match_forward chunks[i], ')', '(', 0, -1
				if end is -1
				key = chunks[i].substring 0, end
				rest = chunks[i].substring end
				match = type_re.exec rest
				if match is null
				rest = match[4]
				ret[j++] = key
				ret[j++] = match[1]|0
				ret[j++] = match[2]|0
				ret[j++] = match[3]
				ret[j++] = rest
			return ret
		compile.cache = {}

			if not cache?
			n = cache.length

			for i in [1..n-5] by 5
				[key, pad, fixed, type, rest] = cache[i..i+4]
				value = values[key]
				if not value?
				switch type
					when 'd'
						output[j++] = "" + parseInt(value, 10)
					when 'f'
						output[j++] = parseFloat(value).toFixed(fixed)
					when 's'
						output[j++] = "" + value
					else
						output[j++] = "" + value
				if pad > 0
					output[j] = String.PadLeft output[j], pad
				output[j++] = rest
			output.join ""

		return render
	)()

		class TemplateMachine extends $.StateMachine
			@STATE_TABLE = [
					enter: () ->
						@data = []
						@GO(1)
				},
				}
			]
			
		return (text, values) ->
			text
	)()
$.plugin
	provides: "throttle"
	depends: "core"
, ->
	$:
		throttle: (ms, f) ->
			last = 0
			(a...) ->
				gap = $.now - last
				if gap > ms
					last += gap
					return f.apply @,a
				null
		debounce: (ms, f) ->
			last = 0
			(a...) ->
				last += (gap = $.now - last)
				return f.apply @,a if gap > ms else null
	parseOne = (data) ->
		i = data.indexOf ":"
		if i > 0
			len = parseInt data[0...i], 10
			item = data[i+1...i+1+len]
			type = data[i+1+len]
			extra = data[i+len+2...]
			item = switch type
				when "'" then String(item)
				when "!" then (item is "true")
				when "~" then null
				when "]" then parseArray(item)
				when "}" then parseObject(item)
			return [item, extra]
		return undefined
	parseArray = (x) ->
		data = []
		while x.length > 0
			[one, x] = parseOne(x)
			data.push(one)
		data
	parseObject = (x) ->
		data = {}
		while x.length > 0
			[key, x] = parseOne(x)
			[value, x] = parseOne(x)
			data[key] = value
		data
	$:
		TNET:
			stringify: (x) ->
				[data, type] = switch $.type x
					when "string" then [x, "'"]
					when "function" then [String(x), "'"]
					when "boolean" then [String(not not x), "!"]
					when "null" then ["", "~"]
					when "undefined" then ["", "~"]
					when "array" then [($.TNET.stringify(y) for y in x).join(''), "]"]
					when "object" then [($.TNET.stringify(y)+$.TNET.stringify(x[y]) for y of x).join(''), "}"]
				return (data.length|0) + ":" + data + type
			parse: (x) ->
				parseOne(x)?[0]
$.plugin
	provides: "trace"
	depends: "function,type"
, ->
	$.type.extend
		unknown: { trace: $.identity }
		function:
			trace: (label, f, tracer) ->
				label or= f.name
				r = (a...) ->
					f.apply @, a
				r
	return $: trace: (label, o, tracer) ->
		if not $.is "string", label
			[tracer, o] = [o, label]
		tracer or= $.log
		label or= ""
		$.type.lookup(o).trace(label, o, tracer)
$.plugin
	depends: "dom"
, ->
	COMMASEP = ", "
		"slow": 700
		"medium": 500
		"normal": 300
		"fast": 100
		"instant": 0
		"now": 0
	accel_props_re = /(?:scale(?:3d)*|translate(?:[XYZ]|3d)*|rotate(?:[XYZ]|3d)*)/
	testStyle = document.createElement("div").style

	transformProperty = "transform"
	transitionProperty = "transition-property"
	transitionDuration = "transition-duration"
	transitionTiming = "transition-timing-function"

	if "WebkitTransform" of testStyle
		transformProperty = "-webkit-transform"
		transitionProperty = "-webkit-transition-property"
		transitionDuration = "-webkit-transition-duration"
		transitionTiming = "-webkit-transition-timing-function"
	else if "MozTransform" of testStyle
		transformProperty = "-moz-transform"
		transitionProperty = "-moz-transition-property"
		transitionDuration = "-moz-transition-duration"
		transitionTiming = "-moz-transition-timing-function"
	else if "OTransform" of testStyle
		transformProperty = "-o-transform"
		transitionProperty = "-o-transition-property"
		transitionDuration = "-o-transition-duration"
		transitionTiming = "-o-transition-timing-function"

	return {
		$:
			duration: (speed) ->
				d = speeds[speed]
				return d if d?
				return parseFloat speed

		transform: (end_css, speed, easing, callback) ->

			if $.is("function",speed)
				callback = speed
				speed = easing = null
			else if $.is("function",easing)
				callback = easing
				easing = null
			speed ?= "normal"
			easing or= "ease"
			duration = $.duration(speed) + "ms"
			props = []
			trans = ""
			css = {}
			for i of end_css
				if accel_props_re.test(i)
					ii = end_css[i]
					if ii.join
						ii = $(ii).px().join COMMASEP
					else if ii.toString
						ii = ii.toString()
					trans += " " + i + "(" + ii + ")"
				else css[i] = end_css[i]
			(props.push i) for i of css
			if trans
				props.push transformProperty

			css[transitionProperty] = props.join COMMASEP
			css[transitionDuration] = props.map(-> duration).join COMMASEP
			css[transitionTiming] = props.map(-> easing).join COMMASEP

			if trans
				css[transformProperty] = trans
			@css css
			@delay duration, callback

			@each ->
				if @style
					if @style.display is not "none"
						@_display = @syle.display
					@style.display = "none"
			.trigger "hide"
			.delay updateDelay, callback

			@each ->
				if @style
					@style.display = @_display
					delete @_display
			.trigger "show"
			.delay updateDelay, callback

			@weave(@css("display"))
				.fold (display, node) ->
					if display is "none"
						node.style.display = node._display or ""
						delete node._display
						$(node).trigger "show"
					else
						node._display = display
						node.style.display = "none"
						$(node).trigger "hide"
					node
				.delay(updateDelay, callback)

			@.css('opacity','0.0')
				.show ->
					@transform {
						opacity:"1.0",
						translate3d: [0,0,0]
					}, speed, callback
			@transform {
				opacity:"0.0",
				translate3d:[x,y,0.0]
			}, speed, -> @hide(callback)
		fadeLeft: (speed, callback) -> @fadeOut speed, callback, "-"+@width().first(), 0.0
		fadeRight: (speed, callback) -> @fadeOut speed, callback, @width().first(), 0.0
		fadeUp: (speed, callback) -> @fadeOut speed, callback, 0.0, "-"+@height().first()
		fadeDown: (speed, callback)  -> @fadeOut speed, callback, 0.0, @height().first()
	}
$.plugin
	provides: "type"
, ->


	isType = (T, o) ->
		if not o? then T in [o,"null","undefined"]
		else o.constructor is T or
			o.constructor.name is T or

	inherit = (parent, obj) ->
		if typeof parent is "function"
			parent = parent.prototype
		if parent.__proto__ is Object.prototype
			parent.__proto__ = obj.__proto__
		obj.__proto__ = parent
		obj

	_type = do ->

		cache = {}

		base =
			name: 'unknown'
			match: (o) -> true

		order = []

		register = (name, data) ->
			order.unshift name if not (name of cache)
			cache[data.name = name] = if (base isnt data) then (inherit base, data) else data
			cache[name][name] = (o) -> o

		_extend = (name, data) ->
			if typeof name is "string"
				cache[name] ?= register name, {}
				cache[name] = extend cache[name], data
			else if typeof name is "object"
				(_extend k, name[k]) for k of name

		lookup = (obj) ->
			for name in order
				if cache[name]?.match.call obj, obj
					return cache[name]

		register "unknown",   base
		register "object",    match: -> typeof @ is "object"
		register "error",     match: -> isType 'Error', @
		register "regexp",    match: -> isType 'RegExp', @
		register "string",    match: -> typeof @ is "string" or isType String, @
		register "number",    match: -> (isType Number, @) and @ isnt NaN
		register "bool",      match: -> typeof @ is "boolean" or String(@) in ["true","false"]
		register "array",     match: -> Array.isArray?(@) or isType Array, @
		register "function",  match: -> typeof @ is "function"
		register "undefined", match: (x) -> x is undefined
		register "null",      match: (x) -> x is null

		return extend ((o) -> lookup(o).name),
			register: register
			lookup: lookup
			extend: _extend
			is: (t, o) -> cache[t]?.match.call o, o
			as: (t, o, rest...) -> lookup(o)[t]?(o, rest...)



	_type.extend
		unknown:   { array: (o) -> [o] }

		null:      { array: (o) -> [] }
		undefined: { array: (o) -> [] }
		array:     { array: (o) -> o }
		number:    { array: (o) -> Bling.extend new Array(o), length: 0 }

	_type.register "bling",
		match:  (o) -> o and isType Bling, o
		array:  (o) -> o.toArray()
		hash:   (o) -> o.map(Bling.hash).reduce (a,x) -> (a*a)+x
		string: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).string(x)).join(", ") + "])"
		repr: (o) -> Bling.symbol + "([" + o.map((x) -> $.type.lookup(x).repr(x)).join(", ") + "])"

	$:
		inherit: inherit
		extend: extend
		defineProperty: (o, name, opts) ->
			Object.defineProperty o, name, extend({ configurable: true, enumerable: true }, opts)
			o
		isType: isType
		type: _type
		is: _type.is
		as: _type.as
		isSimple: (o) -> _type(o) in ["string", "number", "bool"]
		isEmpty: (o) -> o in ["", null, undefined] or o.length is 0 or (typeof o is "object" and Object.keys(o).length is 0)
	defineProperty: (name, opts) -> @each -> $.defineProperty @, name, opts
$.plugin
	provides: "unittest"
	depends: "core,function"
, ->
	testCount = passCount = failCount = 0
	failed = []
	invokeTest = (group, name, func) ->
		return if not $.is "function", func
		shouldFail = name.toLowerCase().indexOf("fail") isnt -1
		done = $.once (err) ->
			testCount--
			if (!!err isnt shouldFail)
				failCount++
				failed.push name
			else
				_log "pass"
				passCount++
				$.provide name
		f = (done) ->
			try func(done)
			catch err then done(err)
			finally
				if name.toLowerCase().indexOf("async") is -1 then done()
		testCount++
		try f(done)
		catch err then done(err)

	testReport = $.once ->
		if failCount > 0
			try process.exit(failCount)

	$:
		approx: (a, b, margin=.1) -> Math.abs(a - b) < margin
		assertEqual: (a, b, label) ->
			if a isnt b
		assertArrayEqual: (a, b, label) ->
			for i in [0...a.length] by 1
				try
					$.assertEqual(a[i], b[i], label)
				catch err
		testGroup: (name, funcs) ->
			interval = setInterval (-> if testCount is 0 then clearInterval(interval); testReport()), 50
			for k,func of funcs
				invokeTest(name, k, func)
	assertEqual: (args...) ->
				if $.is "function", x then x.call(@,@) else x
			a = args[0]
			for i in [1...args.length]
				$.assertEqual a, args[i]
		return @
dom = require("jldom")
dom.registerGlobals(global)
global.document = dom.createDocument()
global.window = global
require "../dist/bling.js"
assert = require 'assert'
document.body.innerHTML = """
	<table>
		<tr><td>1,1</td><td>1,2</td></tr>
		<tr><td>2,1</td><td>2,2</td></tr>
		<tr><td>3,1</td><td class='d'>3,2</td></tr>
		<tr><td>4,1</td><td>4,2</td></tr>
	</table>
	<div class='c'>C</div>
	<p><span>foobar</span></p>
"""

describe "Object", ->
	it "should have a keys method", ->
		assert typeof Object.keys is "function"
	it "should have a values method", ->
		assert typeof Object.values is "function"
	describe ".keys()", ->
		it "should return the list of keys", ->
			assert.deepEqual Object.keys( "a": 1, b: 2 ), ['a', 'b']
	describe ".values()", ->
		it "should return the list of values", ->
			assert.deepEqual Object.values( "a": 1, b: 2 ), [1, 2]

describe "Bling", ->
	it "should have a symbol with side effects", ->
		assert Bling?
		assert.equal Bling.symbol, "$"
		assert.equal global.$, Bling
		Bling.symbol = "_"
		assert.equal global._, Bling
		global.$ = "before"
		Bling.symbol = "$"
		assert.equal global.$, Bling
		Bling.symbol = "_"
		assert.equal global.$, "before"
		Bling.symbol = "$"
		assert.equal global.$, Bling
	it "should be constructable by call (python style)", ->
		b = Bling([1,2,3])
		assert.equal b[0], 1
		assert.equal b[1], 2
		assert.equal b[2], 3
	it "should have have the right constructor name", ->
		assert.equal Bling([1,2]).constructor.name, "Bling"
	it "should correct the length value", ->
		assert.equal(Array(10).length,10)
		assert.equal(Bling(10).length, 0)

	it "can be created from an array", ->
		assert.deepEqual $([1,2,3]), [1,2,3]
	it "can be created from multiple arguments", ->
		assert.deepEqual $(1,2,3), [1,2,3]
	it "can be created from DOM nodes", ->
		assert.equal $("td").length, 8

	describe ".type()", ->
		describe "should classify", ->
			it "'string'", -> assert.equal $.type(''), 'string'
			it "'number'", -> assert.equal $.type(42), 'number'
			it "'undefined'", -> assert.equal $.type(), "undefined"
			it "'null'", -> assert.equal $.type(null), "null"
			it "'array'", -> assert.equal $.type([]), "array"
			it "'function'", -> assert.equal $.type(->), "function"
			it "'bool'", -> assert.equal $.type(true), "bool"
			it "'regexp'", -> assert.equal $.type(//), "regexp"
			it "'window'", -> assert.equal $.type(window), "global"

	describe ".is()", ->
		describe "should identify", ->
			it "'array'", -> assert $.is "array", []
			it "'function'", -> assert $.is "function", ->

	describe ".inherit(a,b)", ->
		a = a: 1
		b = b: 2
		$.inherit a, b
		it "should set b's __proto__ to a", ->
			assert.equal b.__proto__, a
		it "b should inherit properties from a", ->
			assert.equal b.a, 1
		it "but b should not own those properties", ->
			assert not b.hasOwnProperty "a"

	describe ".extend(a,b)", ->
		a = a: 1
		b = b: 2
		c = $.extend a, b
		it "should return the modified a", -> assert.equal c, a
		it "should give a properties from b", -> assert.equal a.b, 2
		it "should copy those properties", ->
			a.b = 3
			assert.equal b.b, 2

	describe ".defineProperty()", ->
		describe "getters", ->
			a = {}
			$.defineProperty a, "getter",
				get: -> 2
			it "should be readable", ->
				assert.equal a.getter, 2
			it "should not be settable", ->
				a.getter = 3
				assert.equal a.getter, 2
			it "should be enumerable", ->
				assert.notEqual -1, Object.keys(a).indexOf("getter")
			it "should be configurable"
		describe "setters", ->
			a = {}
			$.defineProperty a, "setter",
				set: (v) ->
			it "should be settable", ->
				a.setter = 10
			it "should not be gettable", ->
				assert.equal a.setter, undefined
			it "should be enumerable", ->
				assert.notEqual -1, Object.keys(a).indexOf("setter")

	describe ".isType()", ->
		it "should compare against actual types", ->
			assert $.isType Array, []
		it "or against names of constructors", ->
			assert( $.isType('Array', []) )
		it "should work on non-builtin types", ->
			class Foo
			f = new Foo()
			assert $.isType Foo, f

	describe ".isSimple()", ->
		describe "should accept", ->
			it "strings", -> assert $.isSimple ""
			it "numbers", -> assert $.isSimple 42.0
			it "bools", -> assert( $.isSimple false )
		describe "should reject", ->
			it "objects", -> assert not $.isSimple {}
			it "arrays", -> assert not $.isSimple []

	describe ".isEmpty()", ->
		describe "should accept", ->
			it "empty strings", -> assert $.isEmpty ""
			it "nulls", -> assert $.isEmpty null
			it "undefineds", -> assert $.isEmpty undefined
			it "empty arrays", -> assert $.isEmpty []
			it "empty objects", -> assert $.isEmpty {}
		describe "should reject", ->
			it "full strings", -> assert not $.isEmpty "abc"
			it "arrays with items", -> assert not $.isEmpty [1,2,3]
			it "objects with keys", -> assert not $.isEmpty a:1

	describe ".toArray()", ->
		a = $([1,2,3])
		b = a.toArray()
		it "should produce an Array", ->
			assert.equal b.constructor.name, "Array"
		it "should preserve data", ->
			assert.equal b[1], 2
		it "should preserve length", ->
			assert.equal b.length, 3
		it "should not preserve bling functions", ->
			assert not b.zap

	describe ".as()", ->
		describe "should convert", ->
			it "strings to numbers", -> assert.equal ($.as "number", "1234"), 1234

	describe ".identity", ->
		it "should be a function", -> assert $.is "function", $.identity
		it "should echo anything", -> assert.equal $.identity(a = {}), a

	describe ".bound", ->
		f = -> @value
		a = value:'a'
		b = value:'b'
		it "binding to a should return a's value", ->
			assert.equal do $.bound(a, f), 'a'
		it "binding to b should return b's value", ->
			assert.equal do $.bound(b, f), 'b'

	describe ".trace", ->
		f = -> 42
		h = $.trace "label", f, (a...) ->
			g.push a.join ''
		it "should not trace the original function", ->
			f()
		it "should trace the returned function", ->
			assert.deepEqual g, [ "global.label('one','two')" ]

	describe ".px()", ->
		describe "converts ... to pixel strings", ->
			it "integers", -> assert.equal $.px(100), "100px"
			it "floats", -> assert.equal $.px(-100.0), "-100px"
			it "negatives", -> assert.equal $.px(-100.0), "-100px"
			it "pixel strings", -> assert.equal $.px("100.0px"), "100px"

	describe ".padLeft()", ->
		it "adds padding when needed", ->
			assert.equal $.padLeft("foo", 5), "  foo"
		it "does not add padding when not needed", ->
			assert.equal $.padLeft("foo", 2), "foo"
		it "does not add padding when barely not needed", ->
			assert.equal $.padLeft("foo", 3), "foo"
		it "can pad with non-default character", ->
			assert.equal $.padLeft("foo", 5, "X"), "XXfoo"

	describe ".padRight()", ->
		it "adds padding when needed", -> assert.equal $.padRight("foo", 5), "foo  "
		it "doesnt when not", -> assert.equal $.padRight("foo", 2), "foo"
		it "doesnt when not", -> assert.equal $.padRight("foo", 3), "foo"
		it "can pad with non-default character", -> assert.equal $.padRight("foo", 5, "X"), "fooXX"

	describe ".stringSplice()", ->
		it "should insert text", ->
			assert.equal $.stringSplice("foobar",3,3,"baz"), "foobazbar"
		it "should partially replace text", ->
			assert.equal $.stringSplice("foobar",1,5,"baz"), "fbazr"
		it "should completely replace text", ->
			assert.equal $.stringSplice("foobar",0,6,"baz"), "baz"
		it "should prepend text", ->
			assert.equal $.stringSplice("foobar",0,0,"baz"), "bazfoobar"

	describe ".checkSum()", ->
		it "should compute the same hash as adler32", ->
			assert.equal $.checksum("foobar"), 145425018
		it "should not just hash the one thing", ->
			assert.equal $.checksum("foobarbaz"), 310051767

	describe ".toString()", ->
		describe "should output", ->
			it "blings", ->
				assert.equal $([2,3,4]).toString(), "$([2, 3, 4])"
			it "functions", ->
				assert.equal $.toString(-> $.log), "function () { ... }"
			it "objects", ->assert.equal $.toString({a:{b:1}}), "{a:{b:1}}"
		it "should not fail", ->
			obj = a: 1
			$.defineProperty obj, 'xxx',
				get: -> throw new Error "forbidden"
			assert.equal $.toString(obj), "{a:1, xxx:[Error: forbidden]}"

	describe ".stringTruncate()", ->
		it "should truncate long strings and add ellipses", ->
			assert.equal ($.stringTruncate "long string", 6), "long..."

	describe ".plugin()", ->
		describe "creating new plugins", ->
			$.plugin ->
				$:
					testGlobal: -> 9
				testOp: -> 42
			it "should define new globals", ->
				assert.equal $.testGlobal?(), 9
			it "should define new instance methods", ->
				assert.equal $().testOp?(), 42
			it "should provide a default global wrapper", ->
				assert.equal $.testOp?(), 42

	describe ".avg()", ->
		it "average of an empty set is 0", ->
			assert.equal $([]).avg(), 0
		it "should compute the average", ->
			assert.equal $([1,2,3,4]).avg(), 2.5
		it "should be aliased as .mean()", ->
			assert.equal $.prototype.avg, $.prototype.mean

	describe ".sum()", ->
		it "should add an empty set as 0", ->
			assert.equal $([]).sum(), 0
		it "should compute the sum", ->
			assert.equal $([1,2,3,4,5]).sum(), 15
		it "should ignore non-numbers", ->
			assert.equal($([1,2,NaN,3]).sum(), 6)

	describe ".range(start,end)", ->
		it "should produce a sequence of ints from start to end", ->
			assert.equal($.range(1,6).toRepr(), '$([1, 2, 3, 4, 5])')
		it "start is optional, defaults to 0", ->
			assert.equal($.range(5).toRepr(), '$([0, 1, 2, 3, 4])')

	describe ".zeros()", ->
		it "should produce a set", ->
			assert $.is 'bling', $.zeros 10
		it "should produce all zeros", ->
			assert.equal 0, $.zeros(10).sum()

	describe ".ones()", ->
		it "should produce a set of ones", ->
			assert.equal $.ones(10).sum(), 10

	describe ".floats()", ->
		it "should convert everything to floats", ->
			assert.equal $(["12.1","29.9"]).floats().sum(), 42

	describe ".ints()", ->
		it "should convert everything to ints", ->
			assert.equal $(["12.1","29.9px"]).ints().sum(), 41

	describe ".px()", ->
		it "should convert everything to -px strings (for CSS)", ->
			assert.equal $(["12.1", "29.9"]).px(2).toRepr(), "$(['14px', '31px'])"

	describe ".min()", ->
		it "should return the smallest item", ->
			assert.equal $([12.1, 29.9]).min(), 12.1
		it "should ignore non-numbers", ->
			assert.equal( $([12.1, NaN, 29.9]).min(), 12.1)
		it "should return 0 for an empty set?"

	describe ".max()", ->
		it "should return the largest item", -> assert.equal( $([12.1, 29.9]).max(), 29.9)
		it "should ignore non-numbers", -> assert.equal( $([12.1, NaN, 29.9]).max(), 29.9)
		it "should return Infinity for an empty set?"
	
	describe ".maxBy()", ->
		it "should return the largest item", ->
			assert.deepEqual $( {a:1}, {a:3}, {a:2} ).maxBy('a'), a:3
		it "accepts a value function", ->
			assert.deepEqual $( {a:1}, {a:3}, {a:2} ).maxBy((o) -> Math.pow(o.a,2)), a:3
	
	describe ".minBy()", ->
		it "should return the smallest item", ->
			assert.deepEqual $( {a:3}, {a:1}, {a:2} ).minBy('a'), a:1
		it "accepts a value function", ->
			assert.deepEqual $( {a:1}, {a:3}, {a:2} ).minBy((o) -> Math.pow(o.a,2)), a:1
	
	describe ".product()", ->
		it "computes the product of everything (like .sum() with *)", ->
			assert.equal $(2,4,6).product(), 48
	
	describe ".squares()", ->
		it "squares everything", -> assert.deepEqual $(2,4,6).squares(), [4, 16, 36]
	
	describe ".pow(n)", ->
		it "maps Math.pow", -> assert.deepEqual $(2,4,6).pow(3), [8,64,6*6*6]
	
	describe ".magnitude()", ->
		it "computes the vector length", -> assert.equal $(2,4,6).magnitude(), 7.483314773547883
	
	describe ".scale(r)", ->
		it "mulitiplies everything by a constant factor", -> assert.deepEqual $(2,4,6).scale(3), [6,12,18]
	
	describe ".add(n)", ->
		it "does vector addition (with a scalar)", ->
			assert.deepEqual $(2,4,6).add(2), [4,6,8]
		it "adds two vectors", ->
			assert.deepEqual $(2,4,6).add([3,5,9]), [5,9,15]
		it "truncates the longer vector if mis-sized", ->
			assert.deepEqual $(2,4,6,8).add([3,5,9]), [5,9,15]
	
	describe ".normalize()", ->
		it "scales so that .magnitude() is 1", -> assert.equal $(2,4,6).normalize().magnitude(), 1
	
	describe ".deg2rad()", ->
		it "works as a global", -> assert.equal $.deg2rad(180), Math.PI
		it "works on a set", -> assert.deepEqual $(0,180).deg2rad(), [0, Math.PI]
	describe ".rad2deg()", ->
		it "works as a global", -> assert.equal $.rad2deg(Math.PI), 180
		it "works on a set", -> assert.deepEqual $(0,Math.PI).rad2deg(), [0, 180]

	describe ".random()", ->
		assert 0.0 < $.random() < 1.0
		describe ".real()", ->
			r = $.random.real 10,100
			it "should produce a number", ->
				assert $.is 'number', r
			it "is in the range", ->
				assert 10.0 < r < 100.0
		describe ".integer()", ->
			r = $.random.integer(3,9)
			it "should be an integer", ->
				assert.equal Math.floor(r), r
			it "is in the range", ->
				assert 3 <= r <= 9
		describe ".string()", ->
			s = $.random.string(16)
			it "is a string", ->
				assert $.is 'string', s
			it "has the right length", ->
				assert.equal s.length, 16
		describe ".seed()", ->
			$.random.seed = 42
			r = $.random.string(16)
			$.random.seed = 43
			s = $.random.string(16)
			$.random.seed = 42
			t = $.random.string(16)
			it "should produce same output for the same seed", ->
				assert.equal r, t
			it "should produce different output for a new seed", ->
				assert.notEqual r, s

	describe ".hash()", ->
		describe "hashes any type of object", ->
			it "number", -> assert $.hash(42) isnt $.hash(43)
			it "string", -> assert $.hash("foo") isnt $.hash("bar")
			it "array", -> assert $.hash("poop") isnt $.hash(["poop"])
			it "object", -> assert ($.hash a:1) isnt ($.hash a:2)
			it "bling", -> assert ($.hash $)?
		describe "always produces finite hashes", ->
			it "for objects", -> assert isFinite $.hash a:1
			it "for empty objects", -> assert isFinite $.hash {}
		describe "the order of elements matters", ->
			it "in arrays", -> assert.notEqual $.hash(["a","b"]), $.hash(["b","a"])
			it "in objects", -> assert.notEqual $.hash({}), $.hash []
			it "in blings", -> assert.notEqual $.hash($(["a","b"])), $.hash $(["b","a"])

	describe ".hook()", ->
		it "is a function", ->
			assert $.is 'function', $.hook
		it "returns a hook with append/prepend", ->
			p = $.hook('unit-test')
			assert $.is 'function', p.append
			assert $.is 'function', p.prepend
		it "computes values when called", ->
			$.hook('unit-test').append (x) -> x += 2
			$.hook('unit-test').prepend (x) -> x *= 2
			assert.equal $.hook('unit-test', 4), 10

	describe ".eq()", ->
		it "selects a new set with only one element", ->
			assert.equal $([1,2,3]).eq(1)[0], 2

	describe ".each(f)", ->
		it "repeats f for each element", ->
			check = 0
			$([1,2,3]).each -> check += 1
			assert.equal check, 3

	describe ".map(f)", ->
		it "returns a new set", ->
			a = $([1,2,3])
			b = a.map (->)
			assert.notEqual a,b
		it "containing the results of f(each item)", ->
			assert.deepEqual $([1,2,3]).map(->@*@), [1,4,9]
	
	describe ".filterMap(f)", ->
		it "works like map, but can omit some results", ->
			assert.deepEqual $(1,2,3,4).filterMap(->
				if @ % 2 then @*@
				else null
			), [1, 9]
	
	describe ".replaceWith", ->
		it "copies values from array to this", ->
			assert.deepEqual $(1,2,3,4).replaceWith([5,6,7,8]), [5,6,7,8]
		it "does not create a new Bling", ->
			d = $(1,2,3,4)
			e = d.replaceWith([5,6,7])
			assert.deepEqual d, [5,6,7,4]

	describe ".coalesce()", ->
		it "should return the first non-null item", ->
			assert.equal $.coalesce(null, 42, 22), 42
		it "should accept an array as argument", ->
			assert.equal($.coalesce([null, 14, 42]), 14)
		it "should descend arrays if nested", ->
			assert.equal($.coalesce([null, [null, 14], 42]), 14)
		it "should span arrays if given multiple", ->
			assert.equal $.coalesce([null, null], [null, [null, 14], 42]), 14

	describe ".reduce()", ->
		it "applies a combiner to accumulate a single result", ->
			assert.equal $([1,2,3,4]).reduce( (a,x) -> a + x ), 10

	describe ".union()", ->
		it "combines two sets, eliminating duplicates", ->
			assert.deepEqual $([1,2,3,4]).union([2,3,4,5]), [1,2,3,4,5]

	describe ".intersect()", ->
		it "combines two sets, leaving only the duplicates", ->
			assert.deepEqual($([1,2,3,4]).intersect([2,3,4,5]), [2,3,4])

	describe ".distinct()", ->
		it "removes duplicates from a single set", ->
			assert.deepEqual($([1,2,2,3,4,3]).distinct(), [1,2,3,4])

	describe ".contains()", ->
		it "returns true if an item is found in the set", ->
			assert $([1,2,3]).contains 3
		it "returns false if an item is not found", ->
			assert not $([1,2,3]).contains 4

	describe ".count()", ->
		it "returns the number of matching items, if given an item", ->
			assert.equal $([1,2,2,3,4,3]).count(3), 2
		it "returns the total count if no item is given", ->
			assert.equal $([1,2,2,3,4,3]).count(), 6

	describe ".select()", ->
		it "extracts values from properties of items in a set", ->
			assert.deepEqual $([ {id:1}, {id:2}, {id:3} ]).select('id'), [1,2,3]
		it "supports nested property names", ->
			assert.deepEqual $([
				{a:{b:2}},
				{a:{b:4}},
				{a:{b:6}}
			]).select("a.b"), [2,4,6]
		it "supports nesting into arrays", ->
			assert.deepEqual $([
				{a:[{b:3}]},
				{a:[{b:6}]},
				{a:[{b:9}]}
			]).select("a.0.b"), [3,6,9]

	describe ".zap()", ->
		it "assigns values to properties of items in a set", ->
			assert.deepEqual $([ {id:1}, {id:2}, {id:3} ]).zap('id', 13).select('id'), [13,13,13]
		it "supports using a function to compute the assigned values", ->
			assert.deepEqual $([ {id:1}, {id:2}, {id:3} ]).zap('id', -> @ * 2).select('id'), [2,4,6]
		it "supports nested property names", ->
			assert.deepEqual $([ {sub:{id:1}}, {sub:{id:2}}, {sub:{id:3}} ]).zap('sub.id', -> @*2).select('sub.id'), [2,4,6]

	describe ".take()", ->
		it "take0", -> assert.deepEqual $([1,2,3,4]).take(0), []
		it "take1", -> assert.deepEqual $([1,2,3,4]).take(1), [1]
		it "take2", -> assert.deepEqual $([1,2,3,4]).take(2), [1,2]
		it "take3", -> assert.deepEqual $([1,2,3,4]).take(3), [1,2,3]
		it "take4", -> assert.deepEqual $([1,2,3,4]).take(4), [1,2,3,4]
		it "take5", -> assert.deepEqual $([1,2,3,4]).take(5), [1,2,3,4]

	describe ".skip()", ->
		it "skip0", -> assert.deepEqual $([1,2,3,4]).skip(0), [1,2,3,4]
		it "skip1", -> assert.deepEqual $([1,2,3,4]).skip(1), [2,3,4]
		it "skip2", -> assert.deepEqual $([1,2,3,4]).skip(2), [3,4]
		it "skip3", -> assert.deepEqual $([1,2,3,4]).skip(3), [4]
		it "skip4", -> assert.deepEqual $([1,2,3,4]).skip(4), []
		it "skip5", -> assert.deepEqual $([1,2,3,4]).skip(5), []

	describe ".first()", ->
		a = $([1,2,3,4])
		it "returns a single element", -> assert.equal a.first(), 1
		it "acts like take", -> assert.deepEqual a.first(5), [1,2,3,4]
		it "acts like take", -> assert.deepEqual a.first(2), [1,2]
		it "acts like take", -> assert.deepEqual a.first(0), []

	describe ".last()", ->
		a = $([1,2,3,4])
		it "returns last element", -> assert.equal a.last(), 4
		it "returns multiple if asked", -> assert.deepEqual a.last(5), [1,2,3,4]
		it "returns multiple if asked", -> assert.deepEqual a.last(2), [3,4]
		it "returns multiple if asked", -> assert.deepEqual a.last(0), []

	describe ".slice()", ->
		a = $([1,2,3,4,5])
		it "slice1", -> assert.deepEqual $([1,2,3,4,5]).slice(0,5), [1,2,3,4,5]
		it "slice2", -> assert.deepEqual $([1,2,3,4,5]).slice(1,5), [2,3,4,5]
		it "slice3", -> assert.deepEqual $([1,2,3,4,5]).slice(2,5), [3,4,5]
		it "slice4", -> assert.deepEqual $([1,2,3,4,5]).slice(3,5), [4,5]
		it "slice5", -> assert.deepEqual $([1,2,3,4,5]).slice(4,5), [5]
		it "slice6", -> assert.deepEqual $([1,2,3,4,5]).slice(1,-2), [2,3]
		it "slice7", -> assert.deepEqual $([1,2,3,4,5]).slice(-1,-3), [5,4]
		it "slice8", -> assert.deepEqual $([1,2,3,4,5]).slice(-1,-4), [5,4,3]

	describe ".push()", ->
		it "appends to the set", ->
			assert.deepEqual $([1,2]).push(3), [1,2,3]
		it "overrides Array::push()", ->
			assert.notEqual Array::push, Bling::push
		it "returns the resulting set", ->
			assert $.is 'bling', $([1,2]).push(3)

	describe ".filter()", ->
		it "filters by a function", -> assert.deepEqual $([1,2,3,4,5]).filter((x) -> x % 2), [1,3,5]
		it "supports regular expressions", -> assert.deepEqual $(["foo","bar","baz"]).filter(/^ba/), ["bar","baz"]
		it "can chain DOM filters", -> assert.equal $("*").filter("td").filter(".d").length, 1
		it "filters might remove all nodes", -> assert.equal $("*").filter("td").filter(".none").length, 0
		it "filters DOM nodes by CSS selector", -> assert.deepEqual $("*").filter("td").length, 8

	describe ".matches()", ->
		describe "supports", ->
			it "CSS selectors", ->
				assert.deepEqual $("td").matches(".d"), [false,false,false,false,false,true,false,false]
			it "regular expressions", ->
				assert.deepEqual $(["one","two","three"]).matches(/o/), [true, true, false]

	describe ".weave()", ->
		it "interleaves items from two sets", ->
			assert.deepEqual($([1,1,1]).weave([2,2,2]), [2,1,2,1,2,1])
		it "supports blinged arguments", ->
			assert.deepEqual($([1,1,1]).weave($([2,2,2])), [2,1,2,1,2,1])

	describe ".querySelectorAll()", ->
		it "queries children for DOM nodes", ->
			assert.deepEqual($("tr").querySelectorAll("td.d")[0].className, "d")

	describe ".fold()", ->
		it "is like a partial reduce", ->
			assert.deepEqual $([1,1,1]).weave([2,2,2]).fold( (a,b) -> a+b ), [3,3,3]
		it "returns half the items", ->
			assert.deepEqual $([1,2,3,4,5,6]).fold( (a,b) -> a+b ).length, 3

	describe ".flatten()", ->
		it "combines subsets", ->
			assert.deepEqual $([[1,2],[3,4]]).flatten(), [1,2,3,4]
		it "allows duplicates (unlike union)", ->
			assert.deepEqual $([[1,2],[1,2]]).flatten(), [1,2,1,2]

	describe ".call()", ->
		it "calls every function in the set", ->
			assert.deepEqual $([((x) -> x*2), ((x) -> x*x)]).call(4), [8, 16]
		it "skips non-functions", ->
			assert.deepEqual $([((x) -> x*2), NaN, ((x) -> x*x)]).call(4), [8, 16]

	describe ".apply()", ->
		it "calls every function in the set, with a specific context", ->
			assert.deepEqual($([((x) -> @+x), ((x) -> @*x)]).apply(4,[2]), [6, 8])

	describe ".keysOf()", ->
		it "is like Object.keys", ->
			assert.deepEqual $.keysOf(a:1), ['a']
		it "returns a bling", ->
			assert $.is 'bling', $.keysOf(a:1)
		it "includes any enumerable property", ->
			a = a: 1
			$.defineProperty a, "b", get: -> 2
			assert.deepEqual $.keysOf(a), ["a", "b"]

	describe ".valuesOf()", ->
		it "returns a bling", ->
			assert $.is 'bling', $.valuesOf(a:1)
		it "returns the set of values", ->
			assert.deepEqual $.valuesOf(a:1), [1]
		it "includes any enumerable properties", ->
			a = a: 1
			$.defineProperty a, "b", get: -> 2
			assert.deepEqual $.valuesOf(a), [1, 2]

	describe "EventEmitter", ->
		it "works", ->
			a = $.EventEmitter a:1
			v = false
			a.on "event", -> v = true
			a.emit "event"
			assert v
		it "works on new blings automatically", ->
			b = $()
			v = false
			b.on "event", -> v = true
			b.emit "event"
			assert v
		it "provides (almost) the same API as node's EventEmitter", ->
			b = $()
			["addListener", "emit", "listeners", "on", "removeAllListeners", "removeListener", "setMaxListeners"].forEach (k) ->
				assert $.is 'function', b[k]
		it "can bless an object in-place", ->
			a = a:1
			b = $.EventEmitter(a)
			assert $.is 'function', a.emit
			assert $.is 'function', b.emit
		it "does not leak listeners", ->
			a = $.EventEmitter a:1
			a.on "smoke", -> "fire"
			a.on "smoke", -> "flee"
			assert.equal a.listeners("smoke").length, 2
			a.listeners("smoke").push("water")
			assert.equal a.listeners("smoke").length, 2
		describe "class extends support", ->
			class Foo extends $.EventEmitter
				constructor: ->
					super @
					@x = 1
				method: ->
			f = new Foo()
			it "gives new instances the EE interface", ->
				assert.equal $.type(f.on), "function"
			it "does not clobber instance methods", ->
				assert.equal $.type(f.method), "function"
			it "does not clobber instance properties", ->
				assert.equal $.type(f.x), "number"
			it "works", ->
				flag = false
				f.on 'event', -> flag = true
				f.emit 'event'
				assert.equal flag, true
			describe "inheritance chain", ->
				class A extends $.EventEmitter
					A: ->
				class B extends A
					B: ->
				class C extends B
					constructor: ->
						super(@)
				a = new A()
				b = new B()
				c = new C()
				it "goes through one level", ->
					assert.equal $.type(a.on), "function"
				it "goes through two levels", ->
					assert.equal $.type(b.on), "function"
				it "goes through three levels", ->
					assert.equal $.type(c.on), "function"


	describe ".date", ->
		it "adds the 'date' type", ->
			assert $.is 'date', new Date(0)
		describe 'converts', ->
			it "date to string", ->
				assert.equal ($.as "string", new Date 1,2,3,4,5,6), "1901-03-03 09:05:06"
			it "string to date", ->
				assert.equal ($.as "date", "1901-03-03 09:05:06").toString(), new Date(1,2,3,4,5,6).toString()
			it "date to number", ->
				assert.equal ($.as "number", new Date 1,2,3,4,5,6), -2172149694
			it "number to date", ->
				assert.equal ($.as "date", -2172149694).toString(), (new Date 1,2,3,4,5,6).toString()
		describe ".stamp()", ->
			describe "converts date objects to numbers (with units)", ->
				it "ms", -> assert $.date.stamp(new Date(1000000), "ms") is 1000000
				it "seconds", -> assert $.date.stamp(new Date(1000000), "s") is 1000
		describe ".unstamp()", ->
			it "converts a number to a real date", ->
				assert $.is 'date', $.date.unstamp 0
			it "is the reverse of stamp", ->
				d1 = new Date(1000000)
				d2 = $.date.unstamp $.date.stamp d1
				assert d1.toString() is d2.toString()
			it "supports chaining as .unstamp()", ->
				assert $.is 'date', $([1000000]).unstamp().first()
		describe ".convert()", ->
			assert $.date.convert(1000000, "ms", "s") is 1000
		describe ".midnight()", ->
			it "returns a stamp", ->
				assert $.is 'number', $.date.midnight new Date 0
			it "shifts a date to midnight of that day", ->
				assert.notEqual -1, $.date.unstamp($.date.midnight new Date 1000000000).toUTCString().indexOf("00:00:00 GMT")
			it "supports chaining", ->
				assert.equal $($.date.range 1000, 1000000, 3)
					.midnight()
					.dateFormat("HHMMSS")
					.ints().sum(), 0
		describe ".format()", ->
			d1 = new Date(1000000000)
			describe "supports fields", ->
				it "yyyy", -> assert.equal $.date.format(d1, "yyyy"), "1970"
				it "mm", -> assert.equal $.date.format(d1, "mm"), "01"
				it "dd", -> assert.equal $.date.format(d1, "dd"), "12"
				it "HH", -> assert.equal $.date.format(d1, "HH"), "13"
				it "MM", -> assert.equal $.date.format(d1, "MM"), "46"
				it "SS", -> assert.equal $.date.format(d1, "SS"), "40"
			it "supports spacing and punctuation", ->
				assert.equal $.date.format(d1, "yyyy-mm-dd HH:MM:SS"), "1970-01-12 13:46:40"
			it "supports chaining as .dateFormat()", ->
				assert.equal $($.date.range 1000, 1000000, 3)
					.dateFormat("dd")
					.ints().sum(), 35
		describe ".parse()", ->
			it "supports the same formats as .format()", ->
				assert $.date.parse("1970-01-12 13:46:40", "yyyy-mm-dd HH:MM:SS", "ms") is 1000000000
			it "supports chaining as .dateParse()", ->
				assert $(["1970-01-12 13:46:40"]).dateParse("yyyy-mm-dd HH:MM:SS", "ms").first() is 1000000000
		describe ".range()", ->
			it "generates a range of date stamps", ->
				assert.equal $($.date.range(1000, 1000000, 3))
					.unstamp()
					.select("getUTCDate").call()

	describe ".TNET", ->
		describe ".parse()", ->
			it "parses TNET format strings into objects", ->
		describe ".stringify()", ->
			it "creates TNET strings from objects", ->

	describe ".StateMachine", ->
		it "allows subclassing to define machines", ->
			class T extends $.StateMachine
			t = new T
			assert $.is 'function', t.run
		describe ".run()", ->
			it "reads input and rules from @STATE_TABLE", ->
				class Capper extends $.StateMachine
					@STATE_TABLE = [
						{
							enter: ->
								@output = "<<"
								@GO 1
						}
						{
							def: (c) -> @output += c.toUpperCase()
							eof: @GO 2
						}
						{
							enter: -> @output += ">>"
						}
					]
					constructor: ->
						super(Capper.STATE_TABLE)

				assert.equal new Capper().run("hello").output, "<<HELLO>>"

	describe ".synth()", ->
		it "creates DOM nodes", ->
			assert $.is 'node', $.synth('div').first()
		it "uses CSS-like selectors", ->
		describe "supports CSS selectors:", ->
			it "class", -> assert.equal $.synth('div.cls').first().className, "cls"
			it "attributes", -> assert.equal $.synth('div[foo=bar]').first().attributes.foo, "bar"
			it "attributes (multiple)", -> assert.deepEqual $.synth('div[a=b][c=d]').first().attributes, {a:'b',c:'d'}
			it "text (single quotes)", -> assert.equal $.synth("div 'text'").first().toString(), "<div>text</div>"
			it "text (double quotes)", -> assert.equal $.synth('div "text"').first().toString(), "<div>text</div>"
			it "entity escaped", -> assert.equal $.synth('div "text&amp;stuff"').first().toString(), "<div>text&amp;stuff</div>"
			it "entity un-escaped", -> assert.equal $.synth('div "text&stuff"').first().toString(), "<div>text&stuff</div>"

	describe ".delay(ms, f)", ->
		it "runs f after a delay of ms", (done) ->
			t = $.now
			$.delay 100, ->
				delta = Math.abs(($.now - t) - 100)
				assert delta < 25
				done()

	describe ".config(name, def)", ->
		it "gets config from the environment", ->
			try
				process.env.UNIT_TEST_MAGIC = "magic"
				assert.equal $.config.get("UNIT_TEST_MAGIC"), "magic"
			finally
				delete process.env.UNIT_TEST_MAGIC
		it "supports a default value", ->
			assert.equal $.config.get("NOT_FOUND", "default"), "default"
		it "can be called directly", ->
			assert.equal $.config("NOT_FOUND", "default"), "default"

	describe ".index(keyMaker)", ->
		keyMaker = (obj) -> obj.a
		it "creates a private index", ->
			$([{a:1,b:2}, {a:2,b:3}]).index keyMaker
		it "cannot query until index has been built", ->
			assert.equal $([1,2,3]).query(a:1), null
		it "can .query() after indexing", ->
			a = $([{a:1,b:'b'},{a:2},{a:3}]).index keyMaker
			assert.equal a.query(a:1).b, 'b'
		it "can use compound keys", ->
			compoundKeyMaker = (obj) -> obj.a + "-" + obj.b
			a = $([{a:1,b:'b'},{a:2,b:1},{a:3,b:2,c:'c'}]).index compoundKeyMaker
			assert.equal a.query(a:3,b:2).c, 'c'
		describe "using more than one key maker", ->
			keyMakerOne = (obj) -> obj.a
			keyMakerTwo = (obj) -> obj.b
			keyMakerThree = (obj) -> obj.a + '-' + obj.b
			a = $([{a:1,b:'b'},{a:2,b:1},{a:3,b:2,c:'c'}])
			it "wont hurt if you re-index by the same keyMaker", ->
				a.index keyMakerOne
				a.index keyMakerOne
				assert.equal a.query(a:3).b, 2
			it "will allow querying against a second keyMaker", ->
				a.index keyMakerTwo
				assert.equal a.query(a:3).b, 2
				assert.equal a.query(b:2).a, 3
			it "will allow querying against N keyMakers", ->
				a.index keyMakerOne
				a.index keyMakerTwo
				a.index keyMakerThree
				assert.equal a.query(a:3).b, 2
				assert.equal a.query(b:'b').a, 1
				assert.equal a.query({a:3,b:2}).c, 'c'
	
	describe ".groupBy(key)", ->
		objs = $([
			{name: "a", k: 1, val: 1},
			{name: "a", k: 1, val: 2},
			{name: "a", k: 2, val: 3},
			{name: "b", k: 1, val: 4},
			{name: "c", k: 1, val: 5},
			{ val: 6 }

		])
		it "groups objects by the key", ->
			assert.deepEqual objs.groupBy('name'), [
				[ {name: "a", k:1, val: 1},
					{name: "a", k:1, val: 2},
					{name: "a", k:2, val: 3} ],
				[ {name: "b", k:1, val: 4} ],
				[ {name: "c", k:1, val: 5} ],
				[ { val: 6 } ]
			]
		it "can group by multiple keys", ->
			assert.deepEqual objs.groupBy(['name','k']), [
				[ {name: "a", k:1, val: 1},
					{name: "a", k:1, val: 2}
				],
				[ {name: "b", k:1, val: 4} ],
				[ {name: "c", k:1, val: 5} ],
				[ { val: 6 } ]
			]

		it "is mappable", ->
			assert.deepEqual objs.groupBy('name').map(-> @select('val').sum()),
				[ 6, 4, 5, 6 ]

		it "is mappable to a new object", ->
			assert.deepEqual objs.groupBy(['name','k']).map(->
				name: @select('name').first()
				sum: @select('val').sum()
				k: @select('k').first()
			),
				[ { name: "a", sum: 3, k:1 },
					{ name: "a", sum: 3, k:2 },
				  { name: "b", sum: 4, k:1 },
					{ name: "c", sum: 5, k:1 }
					{ name: undefined, sum: 6, k:undefined }
				]
	
	describe "$.sortedIndex()", ->
		it "returns the index to insert at", ->
			assert.equal $.sortedIndex([1,2,4], 3), 2
		it "will insert at end", ->
			assert.equal $.sortedIndex([1,2,3], 4), 3
		it "will insert at beginning", ->
			assert.equal $.sortedIndex([2,3,4], 1), 0
		it "can use a field for comparison", ->
			assert.equal $.sortedIndex([{a:1},{a:2},{a:4}], {a:3}, 'a'), 2
		it "can use a comparison function", ->
			assert.equal $.sortedIndex([1,2,4], 3, null, (x)->Math.pow(x,2)), 2

	describe ".sortBy(field,cmp)", ->
		it "can sort", ->
			assert.deepEqual $(3,1,2).sortBy(), [1,2,3]
		it "can sort by a field", ->
			assert.deepEqual $( {a:2}, {a:1}, {a:3} ).sortBy('a').select('a'), [1,2,3]
		it "does NOT sort in-place", ->
			a = $(2,3,1)
			b = a.sortBy()
			assert.deepEqual b, [1,2,3]
			assert a isnt b


describe "DOM", ->
	it "parse", ->
		d = $.HTML.parse "<div><a></a><b></b><c></c></div>"
		assert.equal $.type(d), "node"
		assert.equal d.nodeName, "DIV"
	it "stringify", -> assert.equal $.HTML.stringify($.HTML.parse(h = "<div><a/><b/><c/></div>")), h
	it "select_childNodes", -> assert.equal( $("<div><a></a><b></b><c></c></div>").select("childNodes").flatten().map($.type).toRepr(), "$(['node', 'node', 'node'])" )
	it "child", -> i = 0; d = $("<div><a></a><b></b><c></c></div>"); assert.equal( d.select('childNodes').flatten().map( () -> d.child(i++) ).toRepr(), "$([$([<a/>]), $([<b/>]), $([<c/>])])")
	it "child2", -> assert.equal($("tr").child(0).select('nodeName').toRepr(), "$(['TD', 'TD', 'TD', 'TD'])")
	it "textData", ->
		d = $("<div>&nbsp;</div>")
		assert.equal d.toRepr(), "$([<div>&nbsp;</div>])"
		t = d.child 0
		assert.equal t.toRepr(), "$([&nbsp;])"
		t.zap 'data', '<p>'
		assert.equal d.select('innerHTML').first(), '&lt;p&gt;'
	it "escape", -> assert.equal $.HTML.escape("<p>"), "&lt;p&gt;"
	it "dashName1", -> assert.equal $.dashize("fooBar"), "foo-bar"
	it "dashName2", -> assert.equal $.dashize("FooBar"), "-foo-bar"
	it "html1", -> assert.equal $("tr").html().first(), "<td>1,1</td><td>1,2</td>"
	it "html2", -> assert.equal $("div").html("<span>C</span>").html().first(), "<span>C</span>"
	it "append", ->
		try
			assert.equal($("tr td.d").append("<span>Hi</span>").html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	it "appendTo1", -> assert.equal($("<span>Hi</span>").toRepr(), "$([<span>Hi</span>])")
	it "appendTo2", ->
		try
			assert.equal($("<span>Hi</span>").appendTo("tr td.d").toRepr(), "$([<span>Hi</span>])")
		finally
			$("tr td.d span").remove()
	it "appendTo3", ->
		try
			assert.equal($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').toRepr(), '$([<td class="d">3,2<span>Hi</span></td>])')
		finally
			$("tr td.d span").remove()
	it "appendTo4", ->
		try
			assert.equal($("<span>Hi</span>").appendTo("tr td.d").select('parentNode').html().first(), "3,2<span>Hi</span>")
		finally
			$("tr td.d span").remove()
	it "prepend", ->
		try
			assert.equal($("tr td.d").prepend("<span>Hi</span>").html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	it "prependTo", ->
		try
			assert.equal($("<span>Hi</span>").prependTo("tr td.d").select('parentNode').html().first(), "<span>Hi</span>3,2")
		finally
			$("tr td.d span").remove()
	it "before", -> assert.equal($("<a><b></b></a>").find("b").before("<c></c>").select('parentNode').toRepr(), "$([<a><c/><b/></a>])")
	it "after1", -> assert.equal($("<a><b></b></a>").find("b").after("<c></c>").select('parentNode').toRepr(), "$([<a><b/><c/></a>])")
	it "after2", -> assert.equal($("<b></b>").after("<c></c>").select('parentNode').toRepr(), "$([<b/><c/>])")
	it "wrap", -> assert.equal($("<b></b>").wrap("<a></a>").select('parentNode').toRepr(), "$([<a><b/></a>])")
	it "unwrap", -> assert.equal($("<a><b/></a>").find("b").unwrap().first().parentNode, null)
	it "replace", -> assert.equal($("<a><b/><c/><b/></a>").find("b").replace("<p/>").eq(0).select('parentNode').toRepr(), "$([<a><p/><c/><p/></a>])")
	it "removeClass", -> assert.equal($("<a class='test'></a>").removeClass('test').toRepr(), "$([<a/>])")
	it "removeClass2", -> assert.equal($("<a></a>").removeClass('test').toRepr(), "$([<a/>])")
	it "addClass", -> assert.equal($("<a></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	it "addClass2", -> assert.equal($("<a class='test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	it "addClass3", -> assert.equal($("<a class='test test'></a>").addClass("test").toRepr(), '$([<a class="test"/>])')
	it "toggleClass", -> assert.equal($("<a class='on'></a>").toggleClass("on").toRepr(), "$([<a/>])")
	it "toggleClass2", -> assert.equal($("<a class='off'></a>").toggleClass("on").toRepr(), '$([<a class="off on"/>])')
	it "toggleClass3", -> assert.equal($("<a class=''></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	it "toggleClass4", -> assert.equal($("<a></a>").toggleClass("on").toRepr(), '$([<a class="on"/>])')
	it "hasClass", -> assert.equal($("<a class='foo'></a>").hasClass("foo").first(), true)
	it "hasClass2", -> assert.equal($("<a class='bar'></a>").hasClass("foo").first(), false)
	it "text1", -> assert.equal($("<a>Hello<b>World</b></a>").select('innerText').toRepr(), "$(['HelloWorld'])")
	it "text3", -> assert.equal($("<a>Hello<b>World</b></a>").text().toRepr(), "$(['HelloWorld'])")
	it "text2", -> assert.equal($("<a>Hello<b>World</b></a>").text("Goodbye").toRepr(), "$([<a>Goodbye</a>])")
	it "value1", -> assert.equal($("<input type='text' value='foo'/>").val().toRepr(), "$(['foo'])")
	it "value2", -> assert.equal($("<input />").val().toRepr(), "$([''])")
	it "value3", -> assert.equal($("<input type='checkbox' checked />").val().toRepr(), "$(['on'])")
	it "parents", -> assert.equal($("td.d").parents().first().select('nodeName').toRepr(), "$(['TR', 'TABLE', 'BODY', 'HTML'])")
	it "remove", ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
		b = a.find(".x")
			.assert.equal(2, -> @length)
			.assert.equal("$(['B', 'C'])", -> @select('nodeName').toRepr())
			.remove()
			.assert.equal("$([null, null])", -> @select('parentNode').toRepr() )
		assert.equal a.toRepr(), '$([<a><d/></a>])'
	it "find", ->
		a = $("<a><b class='x'/><c class='x'/><d/></a>")
			.find(".x")
			.assert.equal(2, -> @length)
			.assert.equal("$(['B', 'C'])", -> @select('nodeName').toRepr())
	it "clone", ->
		c = $("div.c").clone()[0]
		d = $("div.c")[0]
		c.a = "magic"
		assert.equal( typeof d.a, "undefined")
		assert.equal( typeof c.a, "string")
	it "toFragment", ->
		assert.equal($("td").clone().toFragment().childNodes.length, 8)



class Size
	init: ->
		proxy @, @pos = $(0,0,0), 'x', 'y', 'z'
		proxy @, @vol = $(0,0,0), 'w', 'h', 'd'
	size: (@w,@h=@w,@d=0) -> @
	position: (@x,@y,@z=0) -> @
	preDraw: (ctx) ->
		if @x isnt 0 or @y isnt 0
			ctx.translate @x, @y
class Velocity
	init: ->
		$.log "Velocity::init()"
		proxy @, @vel = $(0,0,0), 'vx', 'vy', 'vz'
	velocity: (@vx,@vy,@vz=0) -> @
	tick: (dt) ->
		if not @vel
			$.log "Object has a velocity tick, but wasn't inited with @vel"
			$.log @tick.funcs()
			$.log @init
		v = VEC_SCALE(@vel, dt)
		VEC_ADDV_INPLACE(@pos, v)
class Acceleration
	init: -> proxy @, @acc = $(0,0,0), 'ax', 'ay', 'az'
	accel: (@ax,@ay,@az=0) -> @
	tick: (dt) ->
		a = VEC_SCALE(@acc, dt)
		VEC_ADDV_INPLACE(@vel, a)
class Speed
	init: ->
		if not @speed
			$.log "Speed:init() called, but the object has no @speed()"
			$.log @init.funcs()
			$.log $.keysOf(@)
		@speed 0
	speed: (@spd) -> @
	tick: (dt) ->
		m = VEC_MAG(@vel)
		if m isnt 0
			m = @spd / m
			VEC_SCALE_INPLACE(@vel, m)
class Color
	init: -> @fillStyle = @strokeStyle = null
	fill: (@fillStyle) -> @
	stroke: (@strokeStyle) -> @
	preDraw: (ctx) ->
		ctx.fillStyle = @fillStyle
		ctx.strokeStyle = @strokeStyle
	draw: (ctx) ->
		ctx.fill() if @fillStyle
		ctx.stroke() if @strokeStyle
class Scale
	preDraw: (ctx) -> ctx.scale @scaler... if @scaler
	scale: (@scaler...) -> @
class Rotation
	init: -> @rot = 0
	rotation: (deg) ->
		@rot = $.deg2rad deg
		@
	preDraw: (ctx) -> ctx.rotate @rot if @rot
class Quality
	init: ->
		@quality = 1.0
		@decayPerMs = 0
	decay: (@decayPerMs) -> @
	tick: (dt) -> @quality = Math.max(0, @quality - @decayPerMs * dt )


class Player extends GameObject
	constructor: (@name) ->
		super @
		@money = new LinearValue 0
		@money.value = Rules.startingGold
		@towers = []
		@inHand = null
	tick: (dt) ->
		tower.tick(ctx) for tower in towers
	draw: (ctx) ->
	adjustIncome: (amt) ->
		@money.rate += amt / 1000
	adjustBalance: (amt) ->
		@money.value -= amt
	purchaseTower: (towerCode) ->
		if towerCode of Towers
			tower = Towers[towerCode]
			if @money.value > tower.cost
				@inHand = tower
		null
	placeInHand: (map, pos...) ->
		if @inHand
			map.placeItem @inHand, pos...
		null
	cancelPurchase: ->
		if @inHand
			@adjustBalance +@inHand.cost
		@inHand = null

class Shape extends Modular
	@mixin Size
	@mixin Scale
	@mixin Color
	@mixin Indexed
	@mixin Rotation
	@mixin Highlight
	@mixin Destroyable

class window.Circle extends Modular
	init: -> @rad = 10
	radius: (@rad) -> @
	draw: (ctx) ->
		ctx.circlePath 0,0,@rad
	@mixin Shape

class window.Triangle extends Modular
	draw: (ctx) ->
		ctx.beginPath()
		ctx.moveTo 0,0
		ctx.lineTo @w/2,@h
		ctx.lineTo -@w/2,@h
		ctx.lineTo 0,0
		ctx.closePath()
	@mixin Shape

proxy = (t, array, names...) ->
	for i in [0...names.length] by 1 then do (i) ->
		name = names[i]
		$.defineProperty t, name,
			get: -> array[i]
			set: (v) -> array[i] = v
	t

if not window?
	global.window = global


class window.Sprite extends Modular
	image: (url, onload=->) ->
		@img = new Image()
		@img.src = url
		@img.onload = onload
		@
	draw: (ctx) ->
		ctx.drawImage @img, 0, 0, @w, @h
	@mixin Drawable

class window.TileLayer extends Sprite
	init: -> @tileSize 100
	tileSize: (@tileWidth, @tileHeight=@tileWidth) -> @
	drawTile: (ctx, x, y) ->
		x *= @tileWidth
		y *= @tileHeight
		ctx.drawImage @img,x,y,@tileWidth,@tileHeight
	draw: (ctx, game) ->
		{width, height} = game.canvas
		for x in [0...width / @tileWidth] by 1
			for y in [0...height / @tileHeight] by 1
				@drawTile ctx, x, y

window.Textures = [
	"ground-snow1-0.jpg",
	"ground-snow1-0_footprints.jpg",
]
assert = require 'assert'
require 'bling'
$.extend global, require '../modular'

Array::clear or= -> @splice 0, @length

describe "Aspects", ->
	it "chains two methods into one", ->
		output = []
		f = -> output.push "f"
		g = -> output.push "g"
		m = Aspects(f, g)
		m()
		assert.deepEqual output, ["f", "g"]
	it "chains any number of methods at once", ->
		output = []
		f = -> output.push "f"
		g = -> output.push "g"
		h = -> output.push "h"
		m = Aspects(f, g, h)
		m()
		assert.deepEqual output, ["f", "g", 'h']
	it "flattens/unrolls nested chains", ->
		output = []
		f = -> output.push "f"
		g = -> output.push "g"
		h = -> output.push "h"
		i = -> output.push "i"
		m = Aspects(f, Aspects(g, Aspects(h, i)))
		m()
		assert.deepEqual output, ["f", "g", "h", "i"]
	it "does not leak state across nested chains", ->
		output = []
		f = -> output.push "f"
		g = -> output.push "g"
		h = -> output.push "h"
		fg = Aspects(f, g)
		fgh = Aspects(fg, h)
		fg()
		assert.deepEqual output, ["f","g"]
		output = []
		fgh()
		assert.deepEqual output, ["f","g","h"]
	it "can abort a chain", ->
		output = []
		f = -> output.push "f"
		g = -> new Aspects.Op("abort")
		h = -> output.push "h"
		do Aspects(f, g, h)
		assert.deepEqual output, ["f"]
	it "can alter the arguments for rest of the chain", ->
		outputA = []
		outputB = []
		f = (output) -> output.push 'f'
		g = (output) -> new Aspects.Op('arguments', [outputB])
		h = (output) -> output.push 'h'
		Aspects(f,g,h)(outputA)
		assert.deepEqual outputA, ['f']
		assert.deepEqual outputB, ['h']
	describe "inheriting aspects", ->
		output = []
		class A
			constructor: -> @a = 1
			fA: -> output.push 'a'; @
			fC: -> output.push 'c'; @
		class B
			constructor: -> @b = 2
			fB: -> output.push 'b'; @
			fC: -> output.push 'd'; @
		class C extends Aspects(A,B)

		w = new C()
		it "chains the constructor", ->
			assert "chain" of C
			assert C.chain.contains A
		it "runs all constructors when creating new instances", ->
			assert.equal w.a, 1
			assert.equal w.b, 2
		it "preserves functions from the prototype", ->
			output.clear()
			w.fA().fB()
			assert.deepEqual output, ['a','b']
		it "chains functions that collide", ->
			output.clear()
			assert "chain" of w.fC
			w.fC()
			assert.deepEqual output, ['c','d']
		it "can nest and mix multiple classes and chains", ->
			output.clear()
			D = Aspects A,B, Aspects A,B, Aspects A,B
			new D()
			assert.deepEqual output, ['a','a','a','b','b','b','c','d','c','d','c','d']
		it "can re-extend", ->
			output.clear()
			class D extends C
				fD: -> output.push 'd'; @
			new D().fA().fB().fC().fD()
			assert.deepEqual output, ['a','b','c','d','d']
		it "can re-mix and extend", ->
			output.clear()
			class D
				fD: -> output.push 'd'; @
			class E
				fC: -> output.push 'e'; @
				fE: -> output.push 'e'; @
			e = new (Aspects C,D,E)
			e.fA().fB().fC().fD().fE()
			assert.deepEqual output, ['a','b','c','d','e','d','e']
			assert.equal e.a, 1
			assert.equal e.b, 2



Towers =
	basic:
		name: "Basic Tower"
		cost: 100
		dps: 1.0
		range: 10

class Tower extends Sprite
	constructor: (@kind) ->
		super @
		$.extend @, Towers[@kind]


Towers =
	basic:
		name: "Basic Tower"
		cost: 100
		dps: 1.0
		range: 10

class Tower extends Sprite
	constructor: (@kind) ->
		super @
		$.extend @, Towers[@kind]

	constructor: (func) ->
		baseValue = baseTime = 0
		$.defineProperty @, 'value',
			get: -> func baseValue, $.now - baseTime
			set: (v) ->
				baseTime = $.now
				baseValue = v
		@value = 0
		@valueAt = (t) -> func baseValue, $.date.stamp(t) - baseTime
class LinearValue extends TimeValue
	constructor: (@rate) ->
		super (x, dt) => x + (dt*@rate)

class SmoothValue
	constructor: (smoothOver=10) ->
		data = $()
		sum = 0
		$.defineProperty @, 'value',
			get: ->
				sum/data.length
			set: (v) ->
				if not isFinite(v) then return
				if data.length >= smoothOver
					sum -= data.shift()
				sum += data.push(v).last()
The purpose of this code will be to expand on the ideas in nand.coffee - which evolves networks of NAND gates to solve truth tables.

The bootstrapper will also start with knowledge of NAND, but each potential truth table gets its own symbol, and can be used to create higher-dimension symbols.

So, there are 16 possible truth tables that map 2 bits to 1 bit, like XOR, AND, OR, etc.

There are 2^256 truth tables for every possible reductions of a single byte [8->1], or 256^256 [8->8] tables that mutate a byte.

Once functions get into the non-trivial size, even the size of an integer adder [16->8], the space of truth tables is immense.











nand = (a, b) -> if (a&b) then 0 else 1

exec = (s, context = {}) ->
	partial = (s) ->
		c = s[0]
		spare = s.substring(1)
		v = switch c
			when '0' then 0
			when '1' then 1
			when '.'
				tmp = partial(spare)
				left = tmp[0]
				spare = tmp[1]
				tmp = partial(spare)
				right = tmp[0]
				spare = tmp[1]
				nand(left, right)
			else context[c]
		return [v, spare]
	return partial(s)

test = (s, e, context = {}) ->
	v = exec(s, context)

test ".00", [1, ""]
test ".01", [1, ""]
test ".10", [1, ""]
test ".11", [0, ""]
test ".1.01", [0, ""]
test ".01.01", [1, ".01"]
test "..01.01", [0, ""]
test ".ab", [0, ""], { 'a': 1, 'b': 1 }
test ".ab", [1, ""], { 'a': 0, 'b': 1 }
test ".ab", [1, ""], { 'a': 1, 'b': 0 }
test ".ab", [1, ""], { 'a': 0, 'b': 0 }
test ".a.ab", [0, ""], { 'a': 1, 'b': 0 }
test "..a.ab.b.ab", [0, ""], { a: 0, b: 0 }
test "..a.ab.b.ab", [1, ""], { a: 0, b: 1 }
test "..a.ab.b.ab", [1, ""], { a: 1, b: 0 }
test "..a.ab.b.ab", [0, ""], { a: 1, b: 1 }

Random = (() ->
	a = 48721
	m = 2147483647
	q = m / a
	r = m % a
	n = 1.0 / m
	seed = new Date().getTime()
	_next = () ->
		seed = a * (seed % q) - r * (seed / q)
		if seed > 0
			seed = seed + m
		seed + n
	_int = (min, max) -> parseInt(_next() + min, 10) % max
	return {
		seed: (v) ->
			if v?
				seed = v
			seed
		next: _next
		int: _int
		choose: (choices) -> choices[Math.abs(_int(0,choices.length))]
		coin: (balance=.5) -> Random.next() <= balance
	}
)()

choices = '.ab.01'

make_candidate = () -> "." + (Random.choose(choices) for _ in [0..Random.int(1,1024)]).join("")

calc_error = (pattern, truth_table) ->
	e = r = 0
	for row in truth_table
		lr = eval(pattern, { a: row[0], b: row[1] })
		junk = lr[1]
		if lr[0] != row[2]
			e += 1
	code = pattern.substring(0,pattern.length - junk.length)
	err = e + (junk.length/pattern.length)
	return { code: code, err: err }

mutate = (pattern, mutation_rate = 0.05) ->
	for i in [0...pattern.length] by 1
		if Random.coin(mutation_rate)
			Random.choose([
					pattern = pattern.substring(0,i) + pattern.substring(i+1)
					pattern = pattern.substring(0,i) + Random.choose(choices) + pattern.substring(i)
					pattern = pattern.substring(0,i) + Random.choose(choices) + pattern.substring(i+1)
			])()
	return pattern

mate_a = (p, q) ->

mate_b = (p, q) ->


fill_pool = (pool, size) ->
	before = pool.length
	while pool.length < size
		pool.push(make_candidate())
	after = pool.length
	return after-before

trim_pool = (pool, table, size) ->
	errors = []
	for candidate in pool
		errors.push calc_error(candidate, table)
	errors.sort (a,b) ->
			return -1
		if a.err > b.err
			return 1
		if a.length < b.length
			return -1
		return 0
	pool = []
	for err in errors[...size]
		pool.push err.code
	return errors[0]

mutate_pool = (pool, table, mutation_rate = 0.15) ->
	survivors = 0
	for i in [0...pool.length]
		p = pool[i]
		p_err = calc_error(p, table).err
		q = mutate(p, mutation_rate)
		q_err = calc_error(q, table).err
		if q_err < p_err
			survivors += 1
			pool[i] = q
	return survivors

learn = (table, max_pool_size = 500, min_pool_size = 100, mutation_rate = 0.15, max_rounds_with_no_survivors = 10) ->
	pool = []
	fill_pool(pool, max_pool_size)
	best = trim_pool(pool, table, min_pool_size)
	attempts = 0
	while best.err > 0
		attempts += 1
		newborns = fill_pool(pool, max_pool_size)
		survivors = mutate_pool(pool, table)
		best = trim_pool(pool, table, min_pool_size)
		if survivors is 0
			max_rounds_with_no_survivors -= 1
			if max_rounds_with_no_survivors <= 0
				break
	best

xor_table = [
	[0, 0, 0],
	[0, 1, 1],
	[1, 0, 1],
	[1, 1, 0]
]

or_table = [
	[0, 0, 0],
	[0, 1, 1],
	[1, 0, 1],
	[1, 1, 1],
]

and_table = [
	[0, 0, 0],
	[0, 1, 0],
	[1, 0, 0],
	[1, 1, 1]
]


winner = learn(xor_table, 500, 100)




class Op:
	constructor: (code, name) ->
		@code = code
		@name = name
	eval: () ->
		throw "Not Implemented."

class GtOp extends Op:
	constructor: ->
		@super '>', 'gt'
	eval: (a, b) ->
		va = a.value if a.constructor.name is 'Register' else a
		vb = b.value if b.constructor.name is 'Register' else b
		return va > vb

class EqOp extends Op:
	constructor: ->
		@super '=', 'eq'
	eval: (


registers @1
numbers \d+\.*\d*
strings "..."



ops = {
	'>': [ '>', 'gt', (a, b) -> ]
	'=': [ '=', 'eq', (a, b) -> ]
	'?': [ '?', 'if', (a, b) -> ]
	'&': [ '&', 'and', (a, b) -> ]
	'|': [ '|', 'or', (a, b) -> ]
	'!': [ '!', 'not', (a) -> ]
	'^': [ '^', 'xor', (a, b) -> ]
	'+': [ '+', 'add', (a, b) -> ]
	'-': [ '-', 'sub', (a, b) -> ]
	'*': [ '*', 'mul', (a, b) -> ]
	'/': [ '/', 'div', (a, b) -> ]
	'%': [ '%', 'mod', (a, b) -> ]
	'.': [ '.', 'cat', (a, b) -> ]
	'->': [ '->', 'mov', (to, from) -> ]
}



